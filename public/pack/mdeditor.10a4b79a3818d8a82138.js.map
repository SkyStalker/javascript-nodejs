{"version":3,"sources":["webpack:///mdeditor.10a4b79a3818d8a82138.js","webpack:///./modules/mdeditor/client/index.js","webpack:///./~/jade/lib/runtime.js?12d0*******","webpack:///./client/clientRender.js?5dc5*******","webpack:///./modules/bem-jade.js?9eb7*******","webpack:///./client/image.js?8da9*******","webpack:///./client/config.js?7c1e","webpack:///./modules/i18n/index.js?917f","webpack:///./~/babelfish/index.js?4989","webpack:///./~/babelfish/lib/babelfish.js?2a74","webpack:///./~/babelfish/lib/parser.js?7712","webpack:///./~/plurals-cldr/index.js?edd1","webpack:///./modules/mdeditor/client/mdeditor.js","webpack:///./~/codemirror/lib/codemirror.js","webpack:///./~/codemirror/mode/gfm/gfm.js","webpack:///./~/codemirror/mode/markdown/markdown.js","webpack:///./~/codemirror/mode/xml/xml.js","webpack:///./~/codemirror/mode/meta.js","webpack:///./~/codemirror/addon/mode/overlay.js","webpack:///./modules/mdeditor/templates/editor.jade","webpack:///./modules/mdeditor/locales ^\\.\\/.*\\.yml$","webpack:///./modules/mdeditor/locales/en.yml","webpack:///./modules/mdeditor/locales/ru.yml"],"names":["mdeditor","webpackJsonp_name_",0,"module","exports","__webpack_require__","init","editorElems","document","querySelectorAll","i","length","editorElem","MdEditor","elem",116,158,"nulls","val","joinClasses","Array","isArray","map","Object","keys","filter","key","join","jade_encode_char","c","jade_encode_html_rules","jade_escape","html","result","String","replace","jade_match_html","merge","a","b","arguments","attrs","ac","bc","concat","cls","classes","escaped","buf","push","escape","text","style","attr","terse","indexOf","JSON","stringify","toISOString","obj","&","<",">","\"","rethrow","err","filename","lineno","str","Error","window","message","readFileSync","ex","context","lines","split","start","Math","max","end","min","slice","line","curr","path","DebugItem","this",161,"addStandardHelpers","locals","bem","thumb","template","create",162,"jade","settings","bem_tag","block","attributes","bem_chain","tag","newTag","alt","title","type","href","prefix","element","modifier","isElement","bem_classes","bem_block","match","RegExp","e","current_block","klass","sort","pop",163,"url","width","height","pixelRatio","devicePixelRatio","lastIndexOf",252,"lang",326,"t","args","LANG","i18n","apply","BabelFish","docs","requirePhrase","packageName","doc","addPhrase",327,328,"_class","prototype","toString","call","isString","isNumber","isNaN","isFinite","isBoolean","isFunction","isObject","forEach","iterator","nativeForEach","l","hasOwnProperty","format","f","len","formatRegExp","x","flatten","params","sub_val","sub_key","makePhraseKey","locale","phrase","keySeparator","searchPhraseKey","self","storage","_storage","_defaultLocale","fb_cache","_fallbacks_cache","fb_key","fb","_fallbacks","pluralizer","forms","idx","plural","defaultLocale","GENERIC_LOCALE","_plurals_cache","compile","nodes","strict_exec","forms_exec","plurals_cache","CAN_HAVE_DIRECTIVES_RE","test","parser","parse","node","anchor","strict","k","parsed","hasPhrase","unescaped","Function","translation","flattenLevel","fl","Infinity","floor","TypeError","raw","setFallback","fallbacks","def","translate","data","compiled","count","value","noFallback","getLocale","unique","out","fallback","locales","load","phrases","rule",329,"peg$subclass","child","parent","ctor","constructor","SyntaxError","expected","found","offset","column","name","input","substring","peg$reportedPos","peg$currPos","peg$computePosDetails","pos","advance","details","startPos","endPos","p","ch","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$maxFailExpected","peg$buildException","cleanupExpected","description","splice","buildMessage","stringEscape","s","hex","charCodeAt","toUpperCase","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","s1","peg$parseliteral","peg$FAILED","peg$parseplural","peg$parsevariable","s2","s3","s4","substr","peg$c2","peg$silentFails","peg$c3","peg$parseplural_forms","peg$c4","peg$c5","peg$parseplural_anchor","peg$c6","peg$c7","peg$c1","peg$parseplural_part","peg$c8","peg$c9","peg$c10","peg$c11","s5","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$parseplural_char","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$parseidentifier","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$parseidentifier_part","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$parseliteral_char","peg$c43","peg$c44","peg$c45","peg$c46","regularForms","undefined","strictForms","peg$result","options","peg$startRuleFunctions","peg$startRuleFunction","part","more","form","char","lc","literal_chars","startRule",330,"normalize","loc","toLowerCase","cFn","sval","v","n","o_forms","o","o_indexOf","oFn","ordinal","unpack","FORMS","add","B","y","IN","set","n100","i10","i100","i1000","n10","n1000000","f10","f100",358,359,"_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","clientRender","delegate","buttonSet","render","actionName","delegateTarget","getAtribute","preventDefault","replaceSelection","codemirror","redo","undo","selection","getSelection","link","cursorPos","getCursor","setCursor","before","after","moveCursorCharsCount","defaultText","textArea","makeButtonsFromActions","actions","buttons","action","allButtons","Bold","Italic","Code","Undo","Redo","FencedCode","Link","Ul","Ol","Heading","Image","insertAdjacentHTML","nextElementSibling","templateArea","querySelector","classList","remove","delegateMixin",360,"mod","CodeMirror","place","copyObj","defaults","setGuttersForLineNumbers","Doc","mode","lineSeparator","inputStyles","inputStyle","display","Display","wrapper","updateGutters","themeChanged","lineWrapping","className","autofocus","mobile","focus","initScrollbars","state","keyMaps","overlays","modeGen","overwrite","delayingBlurEvent","focused","suppressEdits","pasteIncoming","cutIncoming","selectingText","draggingText","highlight","Delayed","keySeq","specialChars","cm","ie","ie_version","setTimeout","reset","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","forceUpdate","attachDoc","hasFocus","bind","onFocus","onBlur","opt","optionHandlers","Init","maybeUpdateLineNumberWidth","finishInit","initHooks","endOperation","webkit","getComputedStyle","lineDiv","textRendering","d","scrollbarFiller","elt","setAttribute","gutterFiller","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","zIndex","paddingRight","gecko","draggable","appendChild","viewFrom","viewTo","first","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","loadMode","getMode","modeOption","resetModeState","iter","stateAfter","styles","frontier","startWorker","regChange","wrappingChanged","addClass","minWidth","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","textHeight","wrapping","perLine","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","ceil","est","estHeight","updateLineHeight","theme","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","updateGutterSpace","offsetWidth","marginLeft","lineLength","merged","cur","collapsedSpanAtStart","find","from","to","collapsedSpanAtEnd","getLine","lineNumbers","measureForScrollbars","gutterW","docH","round","paddingVert","clientHeight","viewHeight","scrollWidth","viewWidth","barLeft","fixedGutter","docHeight","scrollHeight","scrollGap","gutterWidth","NativeScrollbars","scroll","vert","horiz","on","scrollTop","scrollLeft","checkedZeroWidth","minHeight","NullScrollbars","scrollbars","clear","scrollbarModel","scrollbarStyle","insertBefore","axis","setScrollLeft","setScrollTop","startWidth","startHeight","updateScrollbarsInner","updateHeightsInViewport","sizes","update","right","paddingBottom","bottom","coverGutterNextToScrollbar","visibleLines","viewport","top","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","lastLine","firstChild","comp","compensateForHScroll","left","hidden","gutter","align","alignable","j","last","lineNumberFor","size","innerW","padding","lineNumberFormatter","firstLineNumber","getBoundingClientRect","DisplayUpdate","force","visible","editorIsHidden","wrapperHeight","wrapperWidth","oldDisplayWidth","displayWidth","dims","getDimensions","events","maybeClipScrollbars","marginBottom","borderRightWidth","updateDisplayIfNeeded","resetView","countDirtyView","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","activeElt","patchDisplay","offsetHeight","postUpdateDisplay","displayHeight","barMeasure","updateSelection","setDocumentHeight","signal","updateDisplaySimple","finish","total","prevBottom","offsetTop","bot","box","diff","updateWidgetHeight","rest","parentNode","gutterLeft","clientLeft","nextSibling","offsetLeft","fixedPos","gutterTotalWidth","updateNumbersFrom","rm","next","mac","currentWheelTarget","removeChild","container","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","createTextNode","buildLineElement","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","bgClass","background","wrap","getLineContent","ext","built","buildLineContent","pre","textClass","wrapClass","gutterBackground","markers","gutterMarkers","gutterWrap","setUneditable","id","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","positionLineWidget","above","signalLater","noHScroll","coverGutter","paddingLeft","position","copyPos","Pos","maxPos","cmp","minPos","ensureFocus","applyTextInput","inserted","deleted","sel","origin","paste","textLines","splitLines","multiPaste","ranges","lastCopied","range","empty","lst","updateInput","changeEvent","makeChange","triggerElectric","ensureCursorVisible","typing","handlePaste","pasted","clipboardData","getData","isReadOnly","disableInput","runInOp","electricChars","smartIndent","head","getModeAt","indented","indentLine","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","TextareaInput","prevInput","pollingFast","polling","inaccurateSelection","hasSelection","composing","hiddenTextarea","te","div","ios","border","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","gracePeriod","posToDOM","findViewForLine","info","mapFromLineView","order","getOrder","side","partPos","getBidiPartAt","nodeAndOffsetInLineMap","collapse","badPos","bad","domToPos","lineNode","childNodes","clipPos","locateNodeInLineView","textNode","topNode","maps","curNode","lineNo","contains","nodeType","nodeValue","dist","textContent","previousSibling","domTextBetween","fromLine","toLine","recognizeMarker","marker","walk","cmText","getAttribute","markerID","findMarks","getBetween","lineSep","nodeName","closing","Selection","primIndex","Range","normalizeSelection","prim","prev","inv","simpleSelection","clipLine","clipToLen","linelen","isLine","clipPosArray","array","extendRange","other","extend","posBefore","extendSelection","setSelection","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","done","history","setSelectionNoUndo","addSelectionToHistory","NaN","hasHandler","bias","setSelectionInner","skipAtomicInSelection","equals","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","old","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","dir","markedSpans","sp","m","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","near","movePos","far","cantEdit","showSelection","prepareSelection","curFragment","cursors","createDocumentFragment","selFragment","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","output","cursorCoords","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","fragment","rightSide","drawForLine","fromArg","toArg","coords","charCoords","lineObj","lineLen","iterateBidiSections","rightPos","leftPos","tmp","leftSide","paddingH","sFrom","sTo","singleVLine","visualLine","leftEnd","rightStart","restartBlink","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","time","startState","highlightWorker","Date","workTime","copyState","getStateBefore","changedLines","oldStyles","tooLong","maxHighlightLength","highlighted","highlightLine","oldCls","styleClasses","newCls","ischange","processLine","workDelay","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","search","countColumn","tabSize","save","removeChildrenAndAdd","currentStyle","parseInt","ensureLineHeights","rect","curWidth","heights","rects","getClientRects","abs","cache","caches","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewIndex","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","mStart","mEnd","insertLeft","coverStart","coverEnd","isExtendingChar","nullRect","maybeUpdateRectForZooming","rSpan","rbot","mid","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageXOffset","documentElement","body","pageScrollY","pageYOffset","intoCoordSystem","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","get","getBidi","level","bidiLeft","bidiRight","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","step","middle","middleX","measureText","viewChanged","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","preparedSelection","forceScroll","scrollPosIntoView","margin","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","operation","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","index","cutTop","cutBot","arr","oldN","newN","dirty","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","dx","dy","onMouseDown","signalDOMEvent","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","word","findWordAt","captureRightClick","onContextMenu","clearTimeout","now","moved","pageX","pageY","onScrollWheel","dragFunctions","enter","e_stop","over","onDragOver","onDragStart","drop","onDrop","leave","clearDragCursor","inp","getField","onKeyUp","onKeyDown","onKeyPress","dragDropChanged","wasOn","funcs","toggle","off","onResize","setSize","e_target","liberal","forRect","space","clientX","clientY","colDiff","supportsTouch","shiftKey","e_button","leftButtonDown","lastMiddleDown","delayBlurEvent","lastDoubleClick","lastClick","contained","metaKey","ctrlKey","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","startTime","dragEnd","e2","addNew","extendTo","lastPos","startCol","posCol","findColumn","startSel","ourIndex","scrollIntoView","oldRange","ourRange","sel_mouse","curCount","counter","editorSize","move","up","lastSelOrigin","altKey","gutterEvent","prevent","mX","mY","lineBox","e_defaultPrevented","g","lastDrop","files","dataTransfer","FileReader","File","read","loadFile","file","allowDropFileTypes","reader","onload","content","change","changeEnd","readAsText","selected","listSelections","replaceRange","setData","setDragImage","safari","img","src","presto","_top","frag","dragCursor","isScroller","delta","wheelEventDelta","canScrollX","canScrollY","outer","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","commands","ensurePolled","prevShift","Pass","lookupKeyForEditor","handle","lookupKey","extraKeys","keyMap","dispatchKey","seq","isModifierKey","stopSeq","handleKeyBinding","keyName","motion","handleCharBinding","keyCode","returnValue","code","handled","lastStoppedKey","hasCopyEvent","showCrossHair","charCode","which","fromCharCode","readOnly","receivedFocus","contextMenuInGutter","adjustForChange","computeSelAfterChange","offsetPos","nw","computeReplacedSel","hint","oldPrev","newPrev","filterChange","canceled","cancel","ignoreReadOnly","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","event","hist","source","undone","dest","lastOrigin","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","historyChangeFromChange","mergeOldSpans","shiftDoc","distance","spans","removed","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","full","isWholeLineUpdate","changesHandler","changeHandler","doScroll","innerHeight","phantom","scrollNode","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","cursorScrollMargin","sPos","scrollTo","how","aggressive","indent","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","spaceStr","changeLine","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","unit","visually","findNextLine","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","option","deflt","notOnInit","normalizeKeyName","ctrl","cmd","parts","getKeyMap","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clearHistory","nextMarkerId","startStyle","endStyle","css","cloneNode","linked","isParent","SharedTextMarker","findSharedMarkers","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","span","removeMarkedSpan","r","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","mk","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","prop","callBlankLine","blankLine","inner","readToken","stream","token","takeToken","asArray","getObj","copy","string","current","tokens","StringStream","eol","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","addModeClass","mName","st","overlay","at","i_end","opaque","getLineStyles","updateFrontier","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","col","splitSpaces","getOption","addToken","buildToken","hasBadBidiRects","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","zeroWidthElement","lastChild","defaultSpecialCharPlaceholder","displayText","special","mustWrap","lastIndex","exec","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","buildCollapsedSpan","ignoreWidget","needsContentAttribute","createElement","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","endStyles","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","insert","added","LeafChunk","BranchChunk","children","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","sz","getLines","h","lh","bidiOrdering","History","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","somethingSelected","existing","removeClearedSpans","copyHistoryArray","newGroup","instantiateSel","deepCopy","newChanges","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","defaultPrevented","srcElement","button","getHandlers","emitter","_handlers","noHandlers","bnd","list","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","spaceStrs","nothing","createObj","base","inst","isWordCharBasic","isEmpty","extendingChars","cssText","activeElement","root","classTest","as","forEachCodeMirror","getElementsByClassName","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","zwspSupported","badBidiRects","r0","r1","badZoomedRects","normal","fromRange","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","userAgent","navigator","platform","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","mac_geMountainLion","windows","presto_version","flipCtrlCmd","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","w","pointerEvents","bar","delay","maybeDisable","elementFromPoint","native","null","cmpPos","prepareCopyCut","getSelections","selectInput","lineWiseCopyCut","setSelections","textarea","poll","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","blur","resetPosition","slowPoll","pollInterval","missed","execCommand","same","prepareSelectAllHack","selectionStart","extval","selectionEnd","rehide","oldCSS","selectAll","detectingSelectAll","resetSelectionOnContextMenu","oldScrollY","scrollY","mouseup","readOnlyChanged","onCopyCut","clearData","kludge","hadFocus","startData","ours","applyComposition","forceCompositionEnd","pollContent","showPrimarySelection","showMultipleSelections","curAnchor","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","rangeCount","getRangeAt","rng","addRange","removeAllRanges","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","pollSelection","fromIndex","fromNode","toIndex","toNode","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","contenteditable","here","there","wheelDeltaX","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","helpers","help","helperType","_global","pred","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","lineInfo","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","check","toggleOverwrite","getScrollInfo","interpret","refresh","oldHeight","swapDoc","getInputField","getWrapperElement","getScrollerElement","getGutterElement","setValue","newBreaks","detach","attach","integer","disabled","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","skipToEnd","extendMode","properties","defineExtension","func","defineDocExtension","defineOption","defineInitHook","registerHelper","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","normalizeKeyMap","keymap","keyname","keyNames","noShift","altGraphKey","fromTextArea","getValue","tabindex","placeholder","leaveSubmitMethodAlone","realSubmit","submit","wrappedSubmit","getTextArea","toTextArea","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipTo","backUp","pattern","consume","caseInsensitive","cased","hideFirstChars","withOp","dHeight","oldH","removeInner","insertInner","iterN","spilled","newleaf","maybeSpill","me","sibling","myIndex","used","nextDocId","cleanGeneration","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","indexFromPos","copyHistory","linkedDoc","unlinkDoc","splitIds","iterLinkedDocs","getEditor","splitLinesAuto","eachLine","dontDelegate","method","e_stopPropagation","stopPropagation","cancelBubble","addEventListener","attachEvent","removeEventListener","detachEvent","handlers","ms","startIndex","startValue","nextTab","goal","select","_e","nonASCIISingleCaseWordChar","createRange","endNode","setEnd","setStart","createTextRange","moveToElementText","moveEnd","moveStart","host","nl","rt","ownerDocument","parentElement","compareEndPoints","oncopy",3,8,9,13,16,17,18,19,20,27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,106,107,109,110,111,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","types","nstart","unshift","version",361,"urlRE","config","modeConfig","codeDepth","gfmOverlay","codeBlock","ateSpace","combineTokens","difference","gitHubSpice","markdownConfig","underscoresBreakWords","taskLists","fencedCodeBlocks","strikethrough","overlayMode",362,"cmCfg","modeCfg","findModeByName","mimes","switchInline","inline","switchBlock","lineIsEmpty","linkTitle","em","strong","quote","indentedCode","htmlFound","htmlBlock","inlineNormal","blockNormal","trailingSpace","trailingSpaceNewLine","prevLine","thisLine","prevLineIsList","prevLineIsIndentedCode","indentationDiff","listDepth","tokenTypes","atxHeaderRE","header","highlightFormatting","formatting","getType","setextHeaderRE","footnoteLink","hrRE","hr","ulRE","olRE","listType","taskListRE","taskList","fencedCodeRE","fencedChars","localMode","localState","local","htmlMode","htmlState","tagStart","tokenize","isInText","md_inside","leavingLocal","returnType","maxBlockquoteDepth","taskOpen","taskClosed","linkHref","linkText","listMod","list2","list3","list1","handleText","textRE","formattingEscape","matchCh","regex","previousFormatting","image","linkInline","linkEmail","atts","ignoreUnderscore","prevPos","prevCh","getLinkHrefInside","endChar","returnState","inlineRE","footnoteLinkInside","footnoteUrl","savedInlineRE","tokenTypeOverrides","tokenType","allowAtxHeaderWithoutSpace","forceBlankLine","adjustedIndentation","fold",363,"htmlConfig","autoSelfClosers","area","br","command","embed","frame","keygen","meta","param","track","wbr","menuitem","implicitlyClosed","dd","li","optgroup","rp","tbody","td","tfoot","tr","contextGrabbers","dt","address","article","aside","blockquote","dl","fieldset","footer","h1","h2","h3","h4","h5","h6","hgroup","menu","nav","ol","section","table","ul","thead","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","editorConf","config_","inText","chain","inBlock","doctype","inTag","baseState","tagName","inAttribute","stringStartCol","closure","isInAttribute","terminator","depth","Context","startOfLine","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","setStyle","attrState","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","baseIndent","textAfter","fullLine","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","grabbers","blockCommentStart","blockCommentEnd","configuration","skipAttribute",364,"modeInfo","alias","findModeByMIME","findModeByExtension","findModeByFileName","dot",365,"combine","basePos","baseCur","overlayPos","overlayCur","streamSeen",366,"jade_interp","jade_mixins","locals_for_with","noBlockClass","$$obj","$index","$$l","class","data-action",367,"webpackContext","req","webpackContextResolve","./en.yml","./ru.yml","resolve",368,"heading","bold","italic","code_multiline","ol_item","ul_item",369],"mappings":"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","file":"mdeditor.10a4b79a3818d8a82138.js","sourcesContent":["var mdeditor =\nwebpackJsonp_name_([29],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(358);\n\tvar MdEditor = __webpack_require__(359);\n\t\n\tfunction init() {\n\t  var editorElems = document.querySelectorAll('.mdeditor');\n\t\n\t  for (var i = 0; i < editorElems.length; i++) {\n\t    var editorElem = editorElems[i];\n\t    new MdEditor({\n\t      elem: editorElem\n\t    });\n\t  }\n\t}\n\t\n\t// must be on document ready\n\tinit();\n\n/***/ },\n\n/***/ 116:\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n\n/***/ 158:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Merge two attribute objects giving precedence\n\t * to values in object `b`. Classes are special-cased\n\t * allowing for arrays and merging/joining appropriately\n\t * resulting in a string.\n\t *\n\t * @param {Object} a\n\t * @param {Object} b\n\t * @return {Object} a\n\t * @api private\n\t */\n\t\n\texports.merge = function merge(a, b) {\n\t  if (arguments.length === 1) {\n\t    var attrs = a[0];\n\t    for (var i = 1; i < a.length; i++) {\n\t      attrs = merge(attrs, a[i]);\n\t    }\n\t    return attrs;\n\t  }\n\t  var ac = a['class'];\n\t  var bc = b['class'];\n\t\n\t  if (ac || bc) {\n\t    ac = ac || [];\n\t    bc = bc || [];\n\t    if (!Array.isArray(ac)) ac = [ac];\n\t    if (!Array.isArray(bc)) bc = [bc];\n\t    a['class'] = ac.concat(bc).filter(nulls);\n\t  }\n\t\n\t  for (var key in b) {\n\t    if (key != 'class') {\n\t      a[key] = b[key];\n\t    }\n\t  }\n\t\n\t  return a;\n\t};\n\t\n\t/**\n\t * Filter null `val`s.\n\t *\n\t * @param {*} val\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction nulls(val) {\n\t  return val != null && val !== '';\n\t}\n\t\n\t/**\n\t * join array as classes.\n\t *\n\t * @param {*} val\n\t * @return {String}\n\t */\n\texports.joinClasses = joinClasses;\n\tfunction joinClasses(val) {\n\t  return (Array.isArray(val) ? val.map(joinClasses) : val && typeof val === 'object' ? Object.keys(val).filter(function (key) {\n\t    return val[key];\n\t  }) : [val]).filter(nulls).join(' ');\n\t}\n\t\n\t/**\n\t * Render the given classes.\n\t *\n\t * @param {Array} classes\n\t * @param {Array.<Boolean>} escaped\n\t * @return {String}\n\t */\n\texports.cls = function cls(classes, escaped) {\n\t  var buf = [];\n\t  for (var i = 0; i < classes.length; i++) {\n\t    if (escaped && escaped[i]) {\n\t      buf.push(exports.escape(joinClasses([classes[i]])));\n\t    } else {\n\t      buf.push(joinClasses(classes[i]));\n\t    }\n\t  }\n\t  var text = joinClasses(buf);\n\t  if (text.length) {\n\t    return ' class=\"' + text + '\"';\n\t  } else {\n\t    return '';\n\t  }\n\t};\n\t\n\texports.style = function (val) {\n\t  if (val && typeof val === 'object') {\n\t    return Object.keys(val).map(function (style) {\n\t      return style + ':' + val[style];\n\t    }).join(';');\n\t  } else {\n\t    return val;\n\t  }\n\t};\n\t/**\n\t * Render the given attribute.\n\t *\n\t * @param {String} key\n\t * @param {String} val\n\t * @param {Boolean} escaped\n\t * @param {Boolean} terse\n\t * @return {String}\n\t */\n\texports.attr = function attr(key, val, escaped, terse) {\n\t  if (key === 'style') {\n\t    val = exports.style(val);\n\t  }\n\t  if ('boolean' == typeof val || null == val) {\n\t    if (val) {\n\t      return ' ' + (terse ? key : key + '=\"' + key + '\"');\n\t    } else {\n\t      return '';\n\t    }\n\t  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n\t    if (JSON.stringify(val).indexOf('&') !== -1) {\n\t      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' + 'will be escaped to `&amp;`');\n\t    };\n\t    if (val && typeof val.toISOString === 'function') {\n\t      console.warn('Jade will eliminate the double quotes around dates in ' + 'ISO form after 2.0.0');\n\t    }\n\t    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\n\t  } else if (escaped) {\n\t    if (val && typeof val.toISOString === 'function') {\n\t      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n\t    }\n\t    return ' ' + key + '=\"' + exports.escape(val) + '\"';\n\t  } else {\n\t    if (val && typeof val.toISOString === 'function') {\n\t      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n\t    }\n\t    return ' ' + key + '=\"' + val + '\"';\n\t  }\n\t};\n\t\n\t/**\n\t * Render the given attributes object.\n\t *\n\t * @param {Object} obj\n\t * @param {Object} escaped\n\t * @return {String}\n\t */\n\texports.attrs = function attrs(obj, terse) {\n\t  var buf = [];\n\t\n\t  var keys = Object.keys(obj);\n\t\n\t  if (keys.length) {\n\t    for (var i = 0; i < keys.length; ++i) {\n\t      var key = keys[i],\n\t          val = obj[key];\n\t\n\t      if ('class' == key) {\n\t        if (val = joinClasses(val)) {\n\t          buf.push(' ' + key + '=\"' + val + '\"');\n\t        }\n\t      } else {\n\t        buf.push(exports.attr(key, val, false, terse));\n\t      }\n\t    }\n\t  }\n\t\n\t  return buf.join('');\n\t};\n\t\n\t/**\n\t * Escape the given string of `html`.\n\t *\n\t * @param {String} html\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tvar jade_encode_html_rules = {\n\t  '&': '&amp;',\n\t  '<': '&lt;',\n\t  '>': '&gt;',\n\t  '\"': '&quot;'\n\t};\n\tvar jade_match_html = /[&<>\"]/g;\n\t\n\tfunction jade_encode_char(c) {\n\t  return jade_encode_html_rules[c] || c;\n\t}\n\t\n\texports.escape = jade_escape;\n\tfunction jade_escape(html) {\n\t  var result = String(html).replace(jade_match_html, jade_encode_char);\n\t  if (result === '' + html) return html;else return result;\n\t};\n\t\n\t/**\n\t * Re-throw the given `err` in context to the\n\t * the jade in `filename` at the given `lineno`.\n\t *\n\t * @param {Error} err\n\t * @param {String} filename\n\t * @param {String} lineno\n\t * @api private\n\t */\n\t\n\texports.rethrow = function rethrow(err, filename, lineno, str) {\n\t  if (!(err instanceof Error)) throw err;\n\t  if ((typeof window != 'undefined' || !filename) && !str) {\n\t    err.message += ' on line ' + lineno;\n\t    throw err;\n\t  }\n\t  try {\n\t    str = str || __webpack_require__(116).readFileSync(filename, 'utf8');\n\t  } catch (ex) {\n\t    rethrow(err, null, lineno);\n\t  }\n\t  var context = 3,\n\t      lines = str.split('\\n'),\n\t      start = Math.max(lineno - context, 0),\n\t      end = Math.min(lines.length, lineno + context);\n\t\n\t  // Error context\n\t  var context = lines.slice(start, end).map(function (line, i) {\n\t    var curr = i + start + 1;\n\t    return (curr == lineno ? '  > ' : '    ') + curr + '| ' + line;\n\t  }).join('\\n');\n\t\n\t  // Alter exception message\n\t  err.path = filename;\n\t  err.message = (filename || 'Jade') + ':' + lineno + '\\n' + context + '\\n\\n' + err.message;\n\t  throw err;\n\t};\n\t\n\texports.DebugItem = function DebugItem(lineno, filename) {\n\t  this.lineno = lineno;\n\t  this.filename = filename;\n\t};\n\n/***/ },\n\n/***/ 161:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar bem = __webpack_require__(162)();\n\tvar thumb = __webpack_require__(163).thumb;\n\t\n\tmodule.exports = function (template, locals) {\n\t  locals = locals ? Object.create(locals) : {};\n\t  addStandardHelpers(locals);\n\t\n\t  return template(locals);\n\t};\n\t\n\tfunction addStandardHelpers(locals) {\n\t  locals.bem = bem;\n\t\n\t  locals.thumb = thumb;\n\t}\n\n/***/ },\n\n/***/ 162:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Adapted from bemto.jade, copyright(c) 2012 Roman Komarov <kizu@kizu.ru>\n\t\n\t/* jshint -W106 */\n\t\n\t'use strict';\n\t\n\tvar jade = __webpack_require__(158);\n\t\n\tmodule.exports = function (settings) {\n\t  settings = settings || {};\n\t\n\t  settings.prefix = settings.prefix || '';\n\t  settings.element = settings.element || '__';\n\t  settings.modifier = settings.modifier || '_';\n\t\n\t  return function (buf, bem_chain, tag, isElement) {\n\t    //console.log(\"-->\", arguments);\n\t    var block = this.block;\n\t    var attributes = this.attributes || {};\n\t\n\t    if (!attributes['class'] && tag && !isElement) {\n\t      throw new Error(\"Block without class: \" + tag);\n\t    }\n\t\n\t    // Rewriting the class for elements and modifiers\n\t    if (attributes['class']) {\n\t      var bem_classes = attributes['class'];\n\t\n\t      if (bem_classes instanceof Array) {\n\t        bem_classes = bem_classes.join(' ');\n\t      }\n\t      bem_classes = bem_classes.split(' ');\n\t\n\t      var bem_block;\n\t      try {\n\t        bem_block = bem_classes[0].match(new RegExp('^(((?!' + settings.element + '|' + settings.modifier + ').)+)'))[1];\n\t      } catch (e) {\n\t        throw new Error(\"Incorrect bem class: \" + bem_classes[0]);\n\t      }\n\t\n\t      if (!isElement) {\n\t        bem_chain[bem_chain.length] = bem_block;\n\t      } else {\n\t        bem_classes[0] = bem_chain[bem_chain.length - 1] + settings.element + bem_classes[0];\n\t      }\n\t\n\t      var current_block = (isElement ? bem_chain[bem_chain.length - 1] + settings.element : '') + bem_block;\n\t\n\t      // Adding the block if there is only modifier and/or element\n\t      if (bem_classes.indexOf(current_block) === -1) {\n\t        bem_classes[bem_classes.length] = current_block;\n\t      }\n\t\n\t      for (var i = 0; i < bem_classes.length; i++) {\n\t        var klass = bem_classes[i];\n\t\n\t        if (klass.match(new RegExp('^(?!' + settings.element + ')' + settings.modifier))) {\n\t          // Expanding the modifiers\n\t          bem_classes[i] = current_block + klass;\n\t        } else if (klass.match(new RegExp('^' + settings.element))) {\n\t          //- Expanding the mixed in elements\n\t          if (bem_chain[bem_chain.length - 2]) {\n\t            bem_classes[i] = bem_chain[bem_chain.length - 2] + klass;\n\t          } else {\n\t            bem_classes[i] = bem_chain[bem_chain.length - 1] + klass;\n\t          }\n\t        }\n\t\n\t        // Adding prefixes\n\t        if (bem_classes[i].match(new RegExp('^' + current_block + '($|(?=' + settings.element + '|' + settings.modifier + '))'))) {\n\t          bem_classes[i] = settings.prefix + bem_classes[i];\n\t        }\n\t      }\n\t\n\t      // Write modified classes to attributes in the correct order\n\t      attributes['class'] = bem_classes.sort().join(' ');\n\t    }\n\t\n\t    bem_tag(buf, block, attributes, bem_chain, tag);\n\t\n\t    // Closing actions (remove the current block from the chain)\n\t    if (!isElement) {\n\t      bem_chain.pop();\n\t    }\n\t  };\n\t\n\t  // used for tweaking what tag we are throwing and do we need to wrap anything here\n\t  function bem_tag(buf, block, attributes, bem_chain, tag) {\n\t    // rewriting tag name on different contexts\n\t    var newTag = tag || 'div';\n\t\n\t    switch (newTag) {\n\t      case 'img':\n\t        // If there is no title we don't need it to show even if there is some alt\n\t        if (attributes.alt && !attributes.title) {\n\t          attributes.title = '';\n\t        }\n\t        // If we have title, we must have it in alt if it's not set\n\t        if (attributes.title && !attributes.alt) {\n\t          attributes.alt = attributes.title;\n\t        }\n\t        if (!attributes.alt) {\n\t          attributes.alt = '';\n\t        }\n\t        break;\n\t      case 'input':\n\t        if (!attributes.type) {\n\t          attributes.type = \"text\";\n\t        }\n\t        break;\n\t      case 'html':\n\t        buf.push('<!DOCTYPE HTML>');\n\t        break;\n\t      case 'a':\n\t        if (!attributes.href) {\n\t          attributes.href = '#';\n\t        }\n\t    }\n\t\n\t    buf.push('<' + newTag + jade.attrs(jade.merge([attributes]), true) + \">\");\n\t\n\t    if (block) block();\n\t\n\t    if (['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'].indexOf(newTag) == -1) {\n\t      buf.push('</' + newTag + '>');\n\t    }\n\t  }\n\t};\n\n/***/ },\n\n/***/ 163:\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.thumb = function (url, width, height) {\n\t  // sometimes this may be called without url\n\t  if (!url) return url;\n\t\n\t  var pixelRatio = window.devicePixelRatio;\n\t\n\t  // return pixelRatio times larger image for retina\n\t  width *= pixelRatio;\n\t  height *= pixelRatio;\n\t\n\t  var modifier = width <= 160 && height <= 160 ? 't' : width <= 320 && height <= 320 ? 'm' : width <= 640 && height <= 640 ? 'i' : width <= 1024 && height <= 1024 ? 'h' : '';\n\t\n\t  return url.slice(0, url.lastIndexOf('.')) + modifier + url.slice(url.lastIndexOf('.'));\n\t};\n\n/***/ },\n\n/***/ 252:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = {\n\t  lang: (\"ru\")\n\t};\n\n/***/ },\n\n/***/ 326:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar BabelFish = __webpack_require__(327);\n\t\n\tvar i18n = new BabelFish('en');\n\t\n\tvar LANG = __webpack_require__(252).lang;\n\t\n\tfunction t() {\n\t  var args = [LANG];\n\t  for (var i = 0; i < arguments.length; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  return i18n.t.apply(i18n, args);\n\t}\n\t\n\tvar docs = {};\n\t\n\tt.i18n = i18n;\n\t\n\tt.requirePhrase = function (packageName, doc) {\n\t  // if same phrase with same doc was processed - don't redo it\n\t  if (docs[packageName] && docs[packageName].indexOf(doc) != -1) return;\n\t\n\t  if (!docs[packageName]) docs[packageName] = [];\n\t  docs[packageName].push(doc);\n\t\n\t  i18n.addPhrase(LANG, packageName, doc);\n\t};\n\t\n\tmodule.exports = t;\n\n/***/ },\n\n/***/ 327:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(328);\n\n/***/ },\n\n/***/ 328:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  class BabelFish\n\t *\n\t *  Internalization and localization library that makes i18n and l10n fun again.\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  var BabelFish = require('babelfish'),\n\t *      i18n = new BabelFish();\n\t *  ```\n\t *\n\t *  or\n\t *\n\t *  ```javascript\n\t *  var babelfish = require('babelfish'),\n\t *      i18n = babelfish();\n\t *  ```\n\t **/\n\t\n\t'use strict';\n\t\n\tvar parser = __webpack_require__(329);\n\tvar plural = __webpack_require__(330);\n\t\n\tfunction _class(obj) {\n\t  return Object.prototype.toString.call(obj);\n\t}\n\t\n\tfunction isString(obj) {\n\t  return _class(obj) === '[object String]';\n\t}\n\tfunction isNumber(obj) {\n\t  return !isNaN(obj) && isFinite(obj);\n\t}\n\tfunction isBoolean(obj) {\n\t  return obj === true || obj === false;\n\t}\n\tfunction isFunction(obj) {\n\t  return _class(obj) === '[object Function]';\n\t}\n\tfunction isObject(obj) {\n\t  return _class(obj) === '[object Object]';\n\t}\n\t\n\t/*istanbul ignore next*/\n\tvar isArray = Array.isArray || function _isArray(obj) {\n\t  return _class(obj) === '[object Array]';\n\t};\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t// The following two utilities (forEach and extend) are modified from Underscore\n\t//\n\t// http://underscorejs.org\n\t//\n\t// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n\t//\n\t// Underscore may be freely distributed under the MIT license\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar nativeForEach = Array.prototype.forEach;\n\t\n\t// The cornerstone, an `each` implementation, aka `forEach`.\n\t// Handles objects with the built-in `forEach`, arrays, and raw objects.\n\t// Delegates to **ECMAScript 5**'s native `forEach` if available.\n\t/*istanbul ignore next*/\n\tfunction forEach(obj, iterator, context) {\n\t  if (obj === null) {\n\t    return;\n\t  }\n\t  if (nativeForEach && obj.forEach === nativeForEach) {\n\t    obj.forEach(iterator, context);\n\t  } else if (obj.length === +obj.length) {\n\t    for (var i = 0, l = obj.length; i < l; i += 1) {\n\t      iterator.call(context, obj[i], i, obj);\n\t    }\n\t  } else {\n\t    for (var key in obj) {\n\t      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t        iterator.call(context, obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar formatRegExp = /%[sdj%]/g;\n\t\n\t/*istanbul ignore next*/\n\tfunction format(f) {\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function (x) {\n\t    if (x === '%%') {\n\t      return '%';\n\t    }\n\t    if (i >= len) {\n\t      return x;\n\t    }\n\t    switch (x) {\n\t      case '%s':\n\t        return String(args[i++]);\n\t      case '%d':\n\t        return Number(args[i++]);\n\t      case '%j':\n\t        return JSON.stringify(args[i++]);\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  return str;\n\t}\n\t\n\t// helpers\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t// Last resort locale, that exists for sure\n\tvar GENERIC_LOCALE = 'en';\n\t\n\t// flatten(obj) -> Object\n\t//\n\t// Flattens object into one-level dictionary.\n\t//\n\t// ##### Example\n\t//\n\t//     var obj = {\n\t//       abc: { def: 'foo' },\n\t//       hij: 'bar'\n\t//     };\n\t//\n\t//     flatten(obj);\n\t//     // -> { 'abc.def': 'foo', 'hij': 'bar' };\n\t//\n\tfunction flatten(obj) {\n\t  var params = {};\n\t\n\t  forEach(obj || {}, function (val, key) {\n\t    if (val && typeof val === 'object') {\n\t      forEach(flatten(val), function (sub_val, sub_key) {\n\t        params[key + '.' + sub_key] = sub_val;\n\t      });\n\t      return;\n\t    }\n\t\n\t    params[key] = val;\n\t  });\n\t\n\t  return params;\n\t}\n\t\n\tvar keySeparator = '#@$';\n\t\n\tfunction makePhraseKey(locale, phrase) {\n\t  return locale + keySeparator + phrase;\n\t}\n\t\n\tfunction searchPhraseKey(self, locale, phrase) {\n\t  var key = makePhraseKey(locale, phrase);\n\t  var storage = self._storage;\n\t\n\t  // direct search first\n\t  if (storage.hasOwnProperty(key)) {\n\t    return key;\n\t  }\n\t\n\t  // don't try follbacks for default locale\n\t  if (locale === self._defaultLocale) {\n\t    return null;\n\t  }\n\t\n\t  // search via fallback map cache\n\t  var fb_cache = self._fallbacks_cache;\n\t  if (fb_cache.hasOwnProperty(key)) {\n\t    return fb_cache[key];\n\t  }\n\t\n\t  // scan fallbacks & cache result\n\t  var fb = self._fallbacks[locale] || [self._defaultLocale];\n\t  var fb_key;\n\t\n\t  for (var i = 0, l = fb.length; i < l; i++) {\n\t    fb_key = makePhraseKey(fb[i], phrase);\n\t    if (storage.hasOwnProperty(fb_key)) {\n\t      // found - update cache and return result\n\t      fb_cache[key] = fb_key;\n\t      return fb_cache[key];\n\t    }\n\t  }\n\t\n\t  // mark fb_cache entry empty for fast lookup on next request\n\t  fb_cache[key] = null;\n\t  return null;\n\t}\n\t\n\tfunction pluralizer(lang, val, forms) {\n\t  var idx = plural.indexOf(lang, val);\n\t\n\t  if (idx === -1) {\n\t    return format('[pluralizer for \"%s\" locale not found]', lang);\n\t  }\n\t\n\t  if (typeof forms[idx] === 'undefined') {\n\t    return format('[plural form %d (\"%s\") not found in translation]', idx, plural.forms(lang)[idx]);\n\t  }\n\t\n\t  return forms[idx];\n\t}\n\t\n\t// public api (module)\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t/**\n\t *  new BabelFish([defaultLocale = 'en'])\n\t *\n\t *  Initiates new instance of BabelFish.\n\t *\n\t *  __Note!__ you can omit `new` for convenience, direct call will return\n\t * new instance too.\n\t **/\n\tfunction BabelFish(defaultLocale) {\n\t  if (!(this instanceof BabelFish)) {\n\t    return new BabelFish(defaultLocale);\n\t  }\n\t\n\t  this._defaultLocale = defaultLocale ? String(defaultLocale) : GENERIC_LOCALE;\n\t\n\t  // hash of locale => [ fallback1, fallback2, ... ] pairs\n\t  this._fallbacks = {};\n\t\n\t  // fallback cache for each phrase\n\t  //\n\t  // {\n\t  //   locale_key: fallback_key\n\t  // }\n\t  //\n\t  // fallback_key can be null if search failed\n\t  //\n\t  this._fallbacks_cache = {};\n\t\n\t  // storage of compiled translations\n\t  //\n\t  // {\n\t  //   locale + @#$ + phrase_key: {\n\t  //     locale:      locale name - can be different for fallbacks\n\t  //     translation: original translation phrase or data variable/object\n\t  //     raw:         true/false - does translation contain plain data or\n\t  //                  string to compile\n\t  //     compiled:    copiled translation fn or plain string\n\t  //   }\n\t  //   ...\n\t  // }\n\t  //\n\t  this._storage = {};\n\t\n\t  // cache for complex plural parts (with params)\n\t  //\n\t  // {\n\t  //   language: new BabelFish(language)\n\t  // }\n\t  //\n\t  this._plurals_cache = {};\n\t}\n\t\n\t// public api (instance)\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t/**\n\t *  BabelFish#addPhrase(locale, phrase, translation [, flattenLevel]) -> BabelFish\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String|Null): Phrase ID, e.g. `apps.forum`\n\t *  - translation (String|Object|Array|Number|Boolean): Translation or an object\n\t *    with nested phrases, or a pure object.\n\t *  - flattenLevel (Number|Boolean): Optional, 0..infinity. `Infinity` by default.\n\t *    Define \"flatten\" deepness for loaded object.  You can also use\n\t *    `true` as `0` or `false` as `Infinity`.\n\t *\n\t *\n\t *  ##### Flatten & using JS objects\n\t *\n\t *  By default all nested properties are normalized to strings like \"foo.bar.baz\",\n\t *  and if value is string, it will be compiled with babelfish notation.\n\t *  If deepness is above `flattenLevel` OR value is not object and not string,\n\t *  it will be used \"as is\". Note, only JSON stringifiable data should be used.\n\t *\n\t *  In short: you can safely pass `Array`, `Number` or `Boolean`. For objects you\n\t *  should define flatten level or disable it compleetely, to work with pure data.\n\t *\n\t *  Pure objects can be useful to prepare bulk data for external libraries, like\n\t *  calendars, time/date generators and so on.\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  i18n.addPhrase('ru-RU',\n\t *    'apps.forums.replies_count',\n\t *    '#{count} %{||}:count  ');\n\t *\n\t *  // equals to:\n\t *  i18n.addPhrase('ru-RU',\n\t *    'apps.forums',\n\t *    { replies_count: '#{count} %{||}:count  ' });\n\t *  ```\n\t **/\n\tBabelFish.prototype.addPhrase = function _addPhrase(locale, phrase, translation, flattenLevel) {\n\t  var self = this,\n\t      fl;\n\t\n\t  // Calculate flatten level. Infinity by default\n\t  if (isBoolean(flattenLevel)) {\n\t    fl = flattenLevel ? Infinity : 0;\n\t  } else if (isNumber(flattenLevel)) {\n\t    fl = Math.floor(flattenLevel);\n\t    if (fl < 0) {\n\t      throw new TypeError('Invalid flatten level (should be >= 0).');\n\t    }\n\t  } else {\n\t    fl = Infinity;\n\t  }\n\t\n\t  if (isObject(translation) && fl > 0) {\n\t    // recursive object walk, until flattenLevel allows\n\t    forEach(translation, function (val, key) {\n\t      self.addPhrase(locale, (phrase ? phrase + '.' : '') + key, val, fl - 1);\n\t    });\n\t    return this;\n\t  }\n\t\n\t  if (isString(translation)) {\n\t    this._storage[makePhraseKey(locale, phrase)] = {\n\t      translation: translation,\n\t      locale: locale,\n\t      raw: false\n\t    };\n\t  } else if (isArray(translation) || isNumber(translation) || isBoolean(translation) || fl === 0 && isObject(translation)) {\n\t    // Pure objects are stored without compilation\n\t    // Limit allowed types.\n\t    this._storage[makePhraseKey(locale, phrase)] = {\n\t      translation: translation,\n\t      locale: locale,\n\t      raw: true\n\t    };\n\t  } else {\n\t    // `Regex`, `Date`, `Uint8Array` and others types will\n\t    //  fuckup `stringify()`. Don't allow here.\n\t    // `undefined` also means wrong param in real life.\n\t    // `null` can be allowed when examples from real life available.\n\t    throw new TypeError('Invalid translation - [String|Object|Array|Number|Boolean] expected.');\n\t  }\n\t\n\t  self._fallbacks_cache = {};\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t *  BabelFish#setFallback(locale, fallbacks) -> BabelFish\n\t *  - locale (String): Target locale\n\t *  - fallbacks (Array): List of fallback locales\n\t *\n\t *  Set fallbacks for given locale.\n\t *\n\t *  When `locale` has no translation for the phrase, `fallbacks[0]` will be\n\t *  tried, if translation still not found, then `fallbacks[1]` will be tried\n\t *  and so on. If none of fallbacks have translation,\n\t *  default locale will be tried as last resort.\n\t *\n\t *  ##### Errors\n\t *\n\t *  - throws `Error`, when `locale` equals default locale\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  i18n.setFallback('ua-UK', ['ua', 'ru']);\n\t *  ```\n\t **/\n\tBabelFish.prototype.setFallback = function _setFallback(locale, fallbacks) {\n\t  var def = this._defaultLocale;\n\t\n\t  if (def === locale) {\n\t    throw new Error(\"Default locale can't have fallbacks\");\n\t  }\n\t\n\t  var fb = isArray(fallbacks) ? fallbacks.slice() : [fallbacks];\n\t  if (fb[fb.length - 1] !== def) {\n\t    fb.push(def);\n\t  }\n\t\n\t  this._fallbacks[locale] = fb;\n\t  this._fallbacks_cache = {};\n\t\n\t  return this;\n\t};\n\t\n\tvar CAN_HAVE_DIRECTIVES_RE = /#\\{|\\(\\(|\\\\\\\\/;\n\t\n\t// Compiles given string into function. Used to compile phrases,\n\t// which contains `plurals`, `variables`, etc.\n\tfunction compile(self, str, locale) {\n\t  var nodes, buf, key, strict_exec, forms_exec, plurals_cache;\n\t\n\t  // Quick check to avoid parse in most cases :)\n\t  if (!CAN_HAVE_DIRECTIVES_RE.test(str)) {\n\t    return str;\n\t  }\n\t\n\t  nodes = parser.parse(str);\n\t\n\t  if (nodes.length === 1 && nodes[0].type === 'literal') {\n\t    return nodes[0].text;\n\t  }\n\t\n\t  // init cache instance for plural parts, if not exists yet.\n\t  if (!self._plurals_cache[locale]) {\n\t    self._plurals_cache[locale] = new BabelFish(locale);\n\t  }\n\t  plurals_cache = self._plurals_cache[locale];\n\t\n\t  buf = [];\n\t  buf.push(['var str = \"\", strict, strict_exec, forms, forms_exec, plrl, cache, loc, loc_plzr, anchor;']);\n\t  buf.push('params = flatten(params);');\n\t\n\t  forEach(nodes, function (node) {\n\t    if (node.type === 'literal') {\n\t      buf.push(format('str += %j;', node.text));\n\t      return;\n\t    }\n\t\n\t    if (node.type === 'variable') {\n\t      key = node.anchor;\n\t      buf.push(format('str += (\"undefined\" === typeof (params[%j])) ? \"[missed variable: %s]\" : params[%j];', key, key, key));\n\t      return;\n\t    }\n\t\n\t    // should never happen\n\t    /*istanbul ignore next*/\n\t    if (node.type !== 'plural') {\n\t      throw new Error('Unknown node type');\n\t    }\n\t\n\t    //\n\t    // Compile plural\n\t    //\n\t\n\t    key = node.anchor;\n\t    // check if plural parts are plain strings or executable,\n\t    // and add executable to \"cache\" instance of babelfish\n\t    // plural part text will be used as translation key\n\t    strict_exec = {};\n\t    forEach(node.strict, function (text, k) {\n\t      var parsed = parser.parse(text);\n\t      if (parsed.length === 1 && parsed[0].type === 'literal') {\n\t        strict_exec[k] = false;\n\t        // patch with unescaped value for direct extract\n\t        node.strict[k] = parsed[0].text;\n\t        return;\n\t      }\n\t\n\t      strict_exec[k] = true;\n\t      if (!plurals_cache.hasPhrase(locale, text, true)) {\n\t        plurals_cache.addPhrase(locale, text, text);\n\t      }\n\t    });\n\t\n\t    forms_exec = {};\n\t    forEach(node.forms, function (text, idx) {\n\t      var parsed = parser.parse(text),\n\t          unescaped;\n\t      if (parsed.length === 1 && parsed[0].type === 'literal') {\n\t        // patch with unescaped value for direct extract\n\t        unescaped = parsed[0].text;\n\t        node.forms[idx] = unescaped;\n\t        forms_exec[unescaped] = false;\n\t        return;\n\t      }\n\t\n\t      forms_exec[text] = true;\n\t      if (!plurals_cache.hasPhrase(locale, text, true)) {\n\t        plurals_cache.addPhrase(locale, text, text);\n\t      }\n\t    });\n\t    /*eslint-disable space-in-parens*/\n\t    buf.push(format('loc = %j;', locale));\n\t    buf.push(format('loc_plzr = %j;', locale.split(/[-_]/)[0]));\n\t    buf.push(format('anchor = params[%j];', key));\n\t    buf.push(format('cache = this._plurals_cache[loc];'));\n\t    buf.push(format('strict = %j;', node.strict));\n\t    buf.push(format('strict_exec = %j;', strict_exec));\n\t    buf.push(format('forms = %j;', node.forms));\n\t    buf.push(format('forms_exec = %j;', forms_exec));\n\t    buf.push('if (+(anchor) != anchor) {');\n\t    buf.push(format('  str += \"[invalid plurals amount: %s(\" + anchor + \")]\";', key));\n\t    buf.push('} else {');\n\t    buf.push('  if (strict[anchor] !== undefined) {');\n\t    buf.push('    plrl = strict[anchor];');\n\t    buf.push('    str += strict_exec[anchor] ? cache.t(loc, plrl, params) : plrl;');\n\t    buf.push('  } else {');\n\t    buf.push('    plrl = pluralizer(loc_plzr, +anchor, forms);');\n\t    buf.push('    str += forms_exec[plrl] ? cache.t(loc, plrl, params) : plrl;');\n\t    buf.push('  }');\n\t    buf.push('}');\n\t    return;\n\t  });\n\t\n\t  buf.push('return str;');\n\t\n\t  /*eslint-disable no-new-func*/\n\t  return new Function('params', 'flatten', 'pluralizer', buf.join('\\n'));\n\t}\n\t\n\t/**\n\t *  BabelFish#translate(locale, phrase[, params]) -> String\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n\t *  - params (Object|Number|String): Params for translation. `Number` & `String`\n\t *    will be  coerced to `{ count: X, value: X }`\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  i18n.addPhrase('ru-RU',\n\t *     'apps.forums.replies_count',\n\t *     '#{count} ((||))  ');\n\t *\n\t *  // ...\n\t *\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 1 });\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', 1});\n\t *  // -> '1 '\n\t *\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 2 });\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', 2);\n\t *  // -> '2 a'\n\t *  ```\n\t **/\n\tBabelFish.prototype.translate = function _translate(locale, phrase, params) {\n\t  var key = searchPhraseKey(this, locale, phrase);\n\t  var data;\n\t\n\t  if (!key) {\n\t    return locale + ': No translation for [' + phrase + ']';\n\t  }\n\t\n\t  data = this._storage[key];\n\t\n\t  // simple string or other pure object\n\t  if (data.raw) {\n\t    return data.translation;\n\t  }\n\t\n\t  // compile data if not done yet\n\t  if (!data.hasOwnProperty('compiled')) {\n\t    // We should use locale from phrase, because of possible fallback,\n\t    // to keep plural locales in sync.\n\t    data.compiled = compile(this, data.translation, data.locale);\n\t  }\n\t\n\t  // return simple string immediately\n\t  if (!isFunction(data.compiled)) {\n\t    return data.compiled;\n\t  }\n\t\n\t  //\n\t  // Generate \"complex\" phrase\n\t  //\n\t\n\t  // Sugar: coerce numbers & strings to { count: X, value: X }\n\t  if (isNumber(params) || isString(params)) {\n\t    params = { count: params, value: params };\n\t  }\n\t\n\t  return data.compiled.call(this, params, flatten, pluralizer);\n\t};\n\t\n\t/**\n\t *  BabelFish#hasPhrase(locale, phrase) -> Boolean\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n\t *  - noFallback (Boolean): Disable search in fallbacks\n\t *\n\t *  Returns whenever or not there's a translation of a `phrase`.\n\t **/\n\tBabelFish.prototype.hasPhrase = function _hasPhrase(locale, phrase, noFallback) {\n\t  return noFallback ? this._storage.hasOwnProperty(makePhraseKey(locale, phrase)) : searchPhraseKey(this, locale, phrase) ? true : false;\n\t};\n\t\n\t/**\n\t *  BabelFish#getLocale(locale, phrase) -> String|null\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n\t *  - noFallback (Boolean): Disable search in fallbacks\n\t *\n\t *  Similar to [[BabelFish#hasPhrase]], but returns real locale of requested\n\t *  phrase, or `null` if nothing found. Can be useful for dynamic dependencies\n\t *  init. For example, when you fetch i10n config as single object and create\n\t *  phrases from it's content.\n\t **/\n\tBabelFish.prototype.getLocale = function _getLocale(locale, phrase, noFallback) {\n\t  if (noFallback) {\n\t    return this._storage.hasOwnProperty(makePhraseKey(locale, phrase)) ? locale : null;\n\t  }\n\t\n\t  var key = searchPhraseKey(this, locale, phrase);\n\t\n\t  return key ? key.split(keySeparator, 2)[0] : null;\n\t};\n\t\n\t/** alias of: BabelFish#translate\n\t *  BabelFish#t(locale, phrase[, params]) -> String\n\t **/\n\tBabelFish.prototype.t = BabelFish.prototype.translate;\n\t\n\t/**\n\t *  BabelFish#stringify(locale) -> String\n\t *  - locale (String): Locale of translation\n\t *\n\t *  Returns serialized locale data, uncluding fallbacks.\n\t *  It can be loaded back via `load()` method.\n\t **/\n\tBabelFish.prototype.stringify = function _stringify(locale) {\n\t  var self = this;\n\t\n\t  // Collect unique keys\n\t  var unique = {};\n\t\n\t  forEach(this._storage, function (val, key) {\n\t    unique[key.split(keySeparator)[1]] = true;\n\t  });\n\t\n\t  // Collect phrases (with fallbacks)\n\t  var result = {};\n\t\n\t  forEach(unique, function (val, key) {\n\t    var k = searchPhraseKey(self, locale, key);\n\t    // if key was just a garbage from another\n\t    // and doesn't fit into fallback chain for current locale - skip it\n\t    if (!k) {\n\t      return;\n\t    }\n\t    // create namespace if not exists\n\t    var l = self._storage[k].locale;\n\t    if (!result[l]) {\n\t      result[l] = {};\n\t    }\n\t    result[l][key] = self._storage[k].translation;\n\t  });\n\t\n\t  var out = {\n\t    fallback: {},\n\t    locales: result\n\t  };\n\t\n\t  // Get fallback rule. Cut auto-added fallback to default locale\n\t  var fallback = (self._fallbacks[locale] || []).slice(0, -1);\n\t  if (fallback.length) {\n\t    out.fallback[locale] = fallback;\n\t  }\n\t\n\t  return JSON.stringify(out);\n\t};\n\t\n\t/**\n\t *  BabelFish#load(data) -> BabelFish\n\t *  - data (Object|String): data from `stringify()` method, as object or string.\n\t *\n\t *  Batch load phrases data, prepared with `stringify()` method.\n\t *  Useful at browser side.\n\t **/\n\tBabelFish.prototype.load = function _load(data) {\n\t  var self = this;\n\t\n\t  if (isString(data)) {\n\t    data = JSON.parse(data);\n\t  }\n\t\n\t  forEach(data.locales, function (phrases, locale) {\n\t    forEach(phrases, function (translation, key) {\n\t      self.addPhrase(locale, key, translation, 0);\n\t    });\n\t  });\n\t\n\t  forEach(data.fallback, function (rule, locale) {\n\t    self.setFallback(locale, rule);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t// export module\n\tmodule.exports = BabelFish;\n\n/***/ },\n\n/***/ 329:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = (function () {\n\t  /*\n\t   * Generated by PEG.js 0.8.0.\n\t   *\n\t   * http://pegjs.majda.cz/\n\t   */\n\t\n\t  function peg$subclass(child, parent) {\n\t    function ctor() {\n\t      this.constructor = child;\n\t    }\n\t    ctor.prototype = parent.prototype;\n\t    child.prototype = new ctor();\n\t  }\n\t\n\t  function SyntaxError(message, expected, found, offset, line, column) {\n\t    this.message = message;\n\t    this.expected = expected;\n\t    this.found = found;\n\t    this.offset = offset;\n\t    this.line = line;\n\t    this.column = column;\n\t\n\t    this.name = \"SyntaxError\";\n\t  }\n\t\n\t  peg$subclass(SyntaxError, Error);\n\t\n\t  function parse(input) {\n\t    var options = arguments.length > 1 ? arguments[1] : {},\n\t        peg$FAILED = {},\n\t        peg$startRuleFunctions = { start: peg$parsestart },\n\t        peg$startRuleFunction = peg$parsestart,\n\t        peg$c0 = [],\n\t        peg$c1 = peg$FAILED,\n\t        peg$c2 = \"((\",\n\t        peg$c3 = { type: \"literal\", value: \"((\", description: \"\\\"((\\\"\" },\n\t        peg$c4 = \"))\",\n\t        peg$c5 = { type: \"literal\", value: \"))\", description: \"\\\"))\\\"\" },\n\t        peg$c6 = null,\n\t        peg$c7 = function peg$c7(forms, anchor) {\n\t      return {\n\t        type: 'plural',\n\t        forms: regularForms(forms),\n\t        strict: strictForms(forms),\n\t        anchor: anchor || 'count'\n\t      };\n\t    },\n\t        peg$c8 = \"|\",\n\t        peg$c9 = { type: \"literal\", value: \"|\", description: \"\\\"|\\\"\" },\n\t        peg$c10 = function peg$c10(part, more) {\n\t      return [part].concat(more);\n\t    },\n\t        peg$c11 = function peg$c11(part) {\n\t      return [part];\n\t    },\n\t        peg$c12 = \"=\",\n\t        peg$c13 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n\t        peg$c14 = /^[0-9]/,\n\t        peg$c15 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n\t        peg$c16 = \" \",\n\t        peg$c17 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n\t        peg$c18 = function peg$c18(strict, form) {\n\t      return {\n\t        strict: strict.join(''),\n\t        text: form.join('')\n\t      };\n\t    },\n\t        peg$c19 = function peg$c19() {\n\t      return {\n\t        text: text()\n\t      };\n\t    },\n\t        peg$c20 = \"\\\\\",\n\t        peg$c21 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n\t        peg$c22 = /^[\\\\|)(]/,\n\t        peg$c23 = { type: \"class\", value: \"[\\\\\\\\|)(]\", description: \"[\\\\\\\\|)(]\" },\n\t        peg$c24 = function peg$c24(char) {\n\t      return char;\n\t    },\n\t        peg$c25 = void 0,\n\t        peg$c26 = { type: \"any\", description: \"any character\" },\n\t        peg$c27 = function peg$c27() {\n\t      return text();\n\t    },\n\t        peg$c28 = \":\",\n\t        peg$c29 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n\t        peg$c30 = function peg$c30(name) {\n\t      return name;\n\t    },\n\t        peg$c31 = \"#{\",\n\t        peg$c32 = { type: \"literal\", value: \"#{\", description: \"\\\"#{\\\"\" },\n\t        peg$c33 = \"}\",\n\t        peg$c34 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n\t        peg$c35 = function peg$c35(anchor) {\n\t      return {\n\t        type: 'variable',\n\t        anchor: anchor\n\t      };\n\t    },\n\t        peg$c36 = \".\",\n\t        peg$c37 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n\t        peg$c38 = function peg$c38() {\n\t      return text();\n\t    },\n\t        peg$c39 = /^[a-zA-Z_$]/,\n\t        peg$c40 = { type: \"class\", value: \"[a-zA-Z_$]\", description: \"[a-zA-Z_$]\" },\n\t        peg$c41 = /^[a-zA-Z0-9_$]/,\n\t        peg$c42 = { type: \"class\", value: \"[a-zA-Z0-9_$]\", description: \"[a-zA-Z0-9_$]\" },\n\t        peg$c43 = function peg$c43(lc) {\n\t      return lc;\n\t    },\n\t        peg$c44 = function peg$c44(literal_chars) {\n\t      return {\n\t        type: 'literal',\n\t        text: literal_chars.join('')\n\t      };\n\t    },\n\t        peg$c45 = /^[\\\\#()|]/,\n\t        peg$c46 = { type: \"class\", value: \"[\\\\\\\\#()|]\", description: \"[\\\\\\\\#()|]\" },\n\t        peg$currPos = 0,\n\t        peg$reportedPos = 0,\n\t        peg$cachedPos = 0,\n\t        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n\t        peg$maxFailPos = 0,\n\t        peg$maxFailExpected = [],\n\t        peg$silentFails = 0,\n\t        peg$result;\n\t\n\t    if (\"startRule\" in options) {\n\t      if (!(options.startRule in peg$startRuleFunctions)) {\n\t        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n\t      }\n\t\n\t      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n\t    }\n\t\n\t    function text() {\n\t      return input.substring(peg$reportedPos, peg$currPos);\n\t    }\n\t\n\t    function offset() {\n\t      return peg$reportedPos;\n\t    }\n\t\n\t    function line() {\n\t      return peg$computePosDetails(peg$reportedPos).line;\n\t    }\n\t\n\t    function column() {\n\t      return peg$computePosDetails(peg$reportedPos).column;\n\t    }\n\t\n\t    function expected(description) {\n\t      throw peg$buildException(null, [{ type: \"other\", description: description }], peg$reportedPos);\n\t    }\n\t\n\t    function error(message) {\n\t      throw peg$buildException(message, null, peg$reportedPos);\n\t    }\n\t\n\t    function peg$computePosDetails(pos) {\n\t      function advance(details, startPos, endPos) {\n\t        var p, ch;\n\t\n\t        for (p = startPos; p < endPos; p++) {\n\t          ch = input.charAt(p);\n\t          if (ch === \"\\n\") {\n\t            if (!details.seenCR) {\n\t              details.line++;\n\t            }\n\t            details.column = 1;\n\t            details.seenCR = false;\n\t          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n\t            details.line++;\n\t            details.column = 1;\n\t            details.seenCR = true;\n\t          } else {\n\t            details.column++;\n\t            details.seenCR = false;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (peg$cachedPos !== pos) {\n\t        if (peg$cachedPos > pos) {\n\t          peg$cachedPos = 0;\n\t          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n\t        }\n\t        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n\t        peg$cachedPos = pos;\n\t      }\n\t\n\t      return peg$cachedPosDetails;\n\t    }\n\t\n\t    function peg$fail(expected) {\n\t      if (peg$currPos < peg$maxFailPos) {\n\t        return;\n\t      }\n\t\n\t      if (peg$currPos > peg$maxFailPos) {\n\t        peg$maxFailPos = peg$currPos;\n\t        peg$maxFailExpected = [];\n\t      }\n\t\n\t      peg$maxFailExpected.push(expected);\n\t    }\n\t\n\t    function peg$buildException(message, expected, pos) {\n\t      function cleanupExpected(expected) {\n\t        var i = 1;\n\t\n\t        expected.sort(function (a, b) {\n\t          if (a.description < b.description) {\n\t            return -1;\n\t          } else if (a.description > b.description) {\n\t            return 1;\n\t          } else {\n\t            return 0;\n\t          }\n\t        });\n\t\n\t        while (i < expected.length) {\n\t          if (expected[i - 1] === expected[i]) {\n\t            expected.splice(i, 1);\n\t          } else {\n\t            i++;\n\t          }\n\t        }\n\t      }\n\t\n\t      function buildMessage(expected, found) {\n\t        function stringEscape(s) {\n\t          function hex(ch) {\n\t            return ch.charCodeAt(0).toString(16).toUpperCase();\n\t          }\n\t\n\t          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch) {\n\t            return '\\\\x0' + hex(ch);\n\t          }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch) {\n\t            return '\\\\x' + hex(ch);\n\t          }).replace(/[\\u0180-\\u0FFF]/g, function (ch) {\n\t            return \"\\\\u0\" + hex(ch);\n\t          }).replace(/[\\u1080-\\uFFFF]/g, function (ch) {\n\t            return \"\\\\u\" + hex(ch);\n\t          });\n\t        }\n\t\n\t        var expectedDescs = new Array(expected.length),\n\t            expectedDesc,\n\t            foundDesc,\n\t            i;\n\t\n\t        for (i = 0; i < expected.length; i++) {\n\t          expectedDescs[i] = expected[i].description;\n\t        }\n\t\n\t        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(\", \") + \" or \" + expectedDescs[expected.length - 1] : expectedDescs[0];\n\t\n\t        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\t\n\t        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n\t      }\n\t\n\t      var posDetails = peg$computePosDetails(pos),\n\t          found = pos < input.length ? input.charAt(pos) : null;\n\t\n\t      if (expected !== null) {\n\t        cleanupExpected(expected);\n\t      }\n\t\n\t      return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);\n\t    }\n\t\n\t    function peg$parsestart() {\n\t      var s0, s1;\n\t\n\t      s0 = [];\n\t      s1 = peg$parseliteral();\n\t      if (s1 === peg$FAILED) {\n\t        s1 = peg$parseplural();\n\t        if (s1 === peg$FAILED) {\n\t          s1 = peg$parsevariable();\n\t        }\n\t      }\n\t      while (s1 !== peg$FAILED) {\n\t        s0.push(s1);\n\t        s1 = peg$parseliteral();\n\t        if (s1 === peg$FAILED) {\n\t          s1 = peg$parseplural();\n\t          if (s1 === peg$FAILED) {\n\t            s1 = peg$parsevariable();\n\t          }\n\t        }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural() {\n\t      var s0, s1, s2, s3, s4;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.substr(peg$currPos, 2) === peg$c2) {\n\t        s1 = peg$c2;\n\t        peg$currPos += 2;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c3);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = peg$parseplural_forms();\n\t        if (s2 !== peg$FAILED) {\n\t          if (input.substr(peg$currPos, 2) === peg$c4) {\n\t            s3 = peg$c4;\n\t            peg$currPos += 2;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c5);\n\t            }\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            s4 = peg$parseplural_anchor();\n\t            if (s4 === peg$FAILED) {\n\t              s4 = peg$c6;\n\t            }\n\t            if (s4 !== peg$FAILED) {\n\t              peg$reportedPos = s0;\n\t              s1 = peg$c7(s2, s4);\n\t              s0 = s1;\n\t            } else {\n\t              peg$currPos = s0;\n\t              s0 = peg$c1;\n\t            }\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_forms() {\n\t      var s0, s1, s2, s3;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = peg$parseplural_part();\n\t      if (s1 !== peg$FAILED) {\n\t        if (input.charCodeAt(peg$currPos) === 124) {\n\t          s2 = peg$c8;\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c9);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          s3 = peg$parseplural_forms();\n\t          if (s3 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c10(s1, s3);\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$currPos;\n\t        s1 = peg$parseplural_part();\n\t        if (s1 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c11(s1);\n\t        }\n\t        s0 = s1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_part() {\n\t      var s0, s1, s2, s3, s4, s5;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 61) {\n\t        s1 = peg$c12;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c13);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = [];\n\t        if (peg$c14.test(input.charAt(peg$currPos))) {\n\t          s3 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s3 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c15);\n\t          }\n\t        }\n\t        if (s3 !== peg$FAILED) {\n\t          while (s3 !== peg$FAILED) {\n\t            s2.push(s3);\n\t            if (peg$c14.test(input.charAt(peg$currPos))) {\n\t              s3 = input.charAt(peg$currPos);\n\t              peg$currPos++;\n\t            } else {\n\t              s3 = peg$FAILED;\n\t              if (peg$silentFails === 0) {\n\t                peg$fail(peg$c15);\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          s2 = peg$c1;\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          if (input.charCodeAt(peg$currPos) === 32) {\n\t            s3 = peg$c16;\n\t            peg$currPos++;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c17);\n\t            }\n\t          }\n\t          if (s3 === peg$FAILED) {\n\t            s3 = peg$c6;\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            s4 = [];\n\t            s5 = peg$parseplural_char();\n\t            if (s5 !== peg$FAILED) {\n\t              while (s5 !== peg$FAILED) {\n\t                s4.push(s5);\n\t                s5 = peg$parseplural_char();\n\t              }\n\t            } else {\n\t              s4 = peg$c1;\n\t            }\n\t            if (s4 !== peg$FAILED) {\n\t              peg$reportedPos = s0;\n\t              s1 = peg$c18(s2, s4);\n\t              s0 = s1;\n\t            } else {\n\t              peg$currPos = s0;\n\t              s0 = peg$c1;\n\t            }\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$currPos;\n\t        s1 = [];\n\t        s2 = peg$parseplural_char();\n\t        if (s2 !== peg$FAILED) {\n\t          while (s2 !== peg$FAILED) {\n\t            s1.push(s2);\n\t            s2 = peg$parseplural_char();\n\t          }\n\t        } else {\n\t          s1 = peg$c1;\n\t        }\n\t        if (s1 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c19();\n\t        }\n\t        s0 = s1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_char() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 92) {\n\t        s1 = peg$c20;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c21);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        if (peg$c22.test(input.charAt(peg$currPos))) {\n\t          s2 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c23);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c24(s2);\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$currPos;\n\t        s1 = peg$currPos;\n\t        peg$silentFails++;\n\t        if (input.charCodeAt(peg$currPos) === 124) {\n\t          s2 = peg$c8;\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c9);\n\t          }\n\t        }\n\t        if (s2 === peg$FAILED) {\n\t          if (input.substr(peg$currPos, 2) === peg$c4) {\n\t            s2 = peg$c4;\n\t            peg$currPos += 2;\n\t          } else {\n\t            s2 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c5);\n\t            }\n\t          }\n\t        }\n\t        peg$silentFails--;\n\t        if (s2 === peg$FAILED) {\n\t          s1 = peg$c25;\n\t        } else {\n\t          peg$currPos = s1;\n\t          s1 = peg$c1;\n\t        }\n\t        if (s1 !== peg$FAILED) {\n\t          if (input.length > peg$currPos) {\n\t            s2 = input.charAt(peg$currPos);\n\t            peg$currPos++;\n\t          } else {\n\t            s2 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c26);\n\t            }\n\t          }\n\t          if (s2 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c27();\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_anchor() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 58) {\n\t        s1 = peg$c28;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c29);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = peg$parseidentifier();\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c30(s2);\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parsevariable() {\n\t      var s0, s1, s2, s3;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.substr(peg$currPos, 2) === peg$c31) {\n\t        s1 = peg$c31;\n\t        peg$currPos += 2;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c32);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = peg$parseidentifier();\n\t        if (s2 !== peg$FAILED) {\n\t          if (input.charCodeAt(peg$currPos) === 125) {\n\t            s3 = peg$c33;\n\t            peg$currPos++;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c34);\n\t            }\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c35(s2);\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseidentifier() {\n\t      var s0, s1, s2, s3, s4;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = peg$parseidentifier_part();\n\t      if (s1 !== peg$FAILED) {\n\t        if (input.charCodeAt(peg$currPos) === 46) {\n\t          s2 = peg$c36;\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c37);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          s3 = [];\n\t          s4 = peg$parseidentifier();\n\t          if (s4 !== peg$FAILED) {\n\t            while (s4 !== peg$FAILED) {\n\t              s3.push(s4);\n\t              s4 = peg$parseidentifier();\n\t            }\n\t          } else {\n\t            s3 = peg$c1;\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c38();\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$parseidentifier_part();\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseidentifier_part() {\n\t      var s0, s1, s2, s3;\n\t\n\t      s0 = peg$currPos;\n\t      if (peg$c39.test(input.charAt(peg$currPos))) {\n\t        s1 = input.charAt(peg$currPos);\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c40);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = [];\n\t        if (peg$c41.test(input.charAt(peg$currPos))) {\n\t          s3 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s3 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c42);\n\t          }\n\t        }\n\t        while (s3 !== peg$FAILED) {\n\t          s2.push(s3);\n\t          if (peg$c41.test(input.charAt(peg$currPos))) {\n\t            s3 = input.charAt(peg$currPos);\n\t            peg$currPos++;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c42);\n\t            }\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c27();\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseliteral() {\n\t      var s0, s1, s2, s3, s4;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = [];\n\t      s2 = peg$currPos;\n\t      s3 = peg$currPos;\n\t      peg$silentFails++;\n\t      s4 = peg$parseplural();\n\t      if (s4 === peg$FAILED) {\n\t        s4 = peg$parsevariable();\n\t      }\n\t      peg$silentFails--;\n\t      if (s4 === peg$FAILED) {\n\t        s3 = peg$c25;\n\t      } else {\n\t        peg$currPos = s3;\n\t        s3 = peg$c1;\n\t      }\n\t      if (s3 !== peg$FAILED) {\n\t        s4 = peg$parseliteral_char();\n\t        if (s4 !== peg$FAILED) {\n\t          peg$reportedPos = s2;\n\t          s3 = peg$c43(s4);\n\t          s2 = s3;\n\t        } else {\n\t          peg$currPos = s2;\n\t          s2 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s2;\n\t        s2 = peg$c1;\n\t      }\n\t      if (s2 !== peg$FAILED) {\n\t        while (s2 !== peg$FAILED) {\n\t          s1.push(s2);\n\t          s2 = peg$currPos;\n\t          s3 = peg$currPos;\n\t          peg$silentFails++;\n\t          s4 = peg$parseplural();\n\t          if (s4 === peg$FAILED) {\n\t            s4 = peg$parsevariable();\n\t          }\n\t          peg$silentFails--;\n\t          if (s4 === peg$FAILED) {\n\t            s3 = peg$c25;\n\t          } else {\n\t            peg$currPos = s3;\n\t            s3 = peg$c1;\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            s4 = peg$parseliteral_char();\n\t            if (s4 !== peg$FAILED) {\n\t              peg$reportedPos = s2;\n\t              s3 = peg$c43(s4);\n\t              s2 = s3;\n\t            } else {\n\t              peg$currPos = s2;\n\t              s2 = peg$c1;\n\t            }\n\t          } else {\n\t            peg$currPos = s2;\n\t            s2 = peg$c1;\n\t          }\n\t        }\n\t      } else {\n\t        s1 = peg$c1;\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        peg$reportedPos = s0;\n\t        s1 = peg$c44(s1);\n\t      }\n\t      s0 = s1;\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseliteral_char() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 92) {\n\t        s1 = peg$c20;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c21);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        if (peg$c45.test(input.charAt(peg$currPos))) {\n\t          s2 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c46);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c24(s2);\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        if (input.length > peg$currPos) {\n\t          s0 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s0 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c26);\n\t          }\n\t        }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function regularForms(forms) {\n\t      var result = [];\n\t      for (var i = 0; i < forms.length; i++) {\n\t        if (forms[i].strict === undefined) {\n\t          result.push(forms[i].text);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t    function strictForms(forms) {\n\t      var result = {};\n\t      for (var i = 0; i < forms.length; i++) {\n\t        if (forms[i].strict !== undefined) {\n\t          result[forms[i].strict] = forms[i].text;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    peg$result = peg$startRuleFunction();\n\t\n\t    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n\t      return peg$result;\n\t    } else {\n\t      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n\t        peg$fail({ type: \"end\", description: \"end of input\" });\n\t      }\n\t\n\t      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n\t    }\n\t  }\n\t\n\t  return {\n\t    SyntaxError: SyntaxError,\n\t    parse: parse\n\t  };\n\t})();\n\n/***/ },\n\n/***/ 330:\n/***/ function(module, exports) {\n\n\t/*\n\t * Plural functions support (cardinal & ordinal forms)\n\t *\n\t * Autogenerated from CLDR:\n\t *\n\t *   Version:   28\n\t *   $Revision: 12002 $\n\t */\n\t\n\t'use strict';\n\t\n\t// pluralizers cache\n\tvar s = {};\n\t\n\tfunction normalize(loc) {\n\t  var l;\n\t  if (s[loc]) {\n\t    return loc;\n\t  }\n\t  l = loc.toLowerCase().replace('_', '-');\n\t  if (s[l]) {\n\t    return l;\n\t  }\n\t  l = l.split('-')[0];\n\t  if (s[l]) {\n\t    return l;\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction forms(loc) {\n\t  var l = normalize(loc);\n\t  return s[l] ? s[l].c : null;\n\t}\n\t\n\tfunction indexOf(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!l) {\n\t    return -1;\n\t  }\n\t\n\t  if (!s[l].cFn) {\n\t    return 0;\n\t  }\n\t\n\t  var sval = String(value),\n\t      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n\t      v = f.length,\n\t      n = +value,\n\t      i = +sval.split('.')[0],\n\t      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\t\n\t  return s[l].cFn(n, i, v, +f, t);\n\t}\n\t\n\tfunction plural(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!l) {\n\t    return null;\n\t  }\n\t  return s[l].c[indexOf(l, value)];\n\t}\n\t\n\tfunction o_forms(loc) {\n\t  var l = normalize(loc);\n\t  return s[l] ? s[l].o : null;\n\t}\n\t\n\tfunction o_indexOf(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!l) {\n\t    return -1;\n\t  }\n\t\n\t  if (!s[l].oFn) {\n\t    return 0;\n\t  }\n\t\n\t  var sval = String(value),\n\t      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n\t      v = f.length,\n\t      n = +value,\n\t      i = +sval.split('.')[0],\n\t      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\t\n\t  return s[l].oFn(n, i, v, +f, t);\n\t}\n\t\n\tfunction ordinal(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!s[l]) {\n\t    return null;\n\t  }\n\t  return s[l].o[o_indexOf(l, value)];\n\t}\n\t\n\tmodule.exports = plural;\n\tmodule.exports.indexOf = indexOf;\n\tmodule.exports.forms = forms;\n\tmodule.exports.ordinal = ordinal;\n\tmodule.exports.ordinal.indexOf = o_indexOf;\n\tmodule.exports.ordinal.forms = o_forms;\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar FORMS = ['zero', 'one', 'two', 'few', 'many', 'other'];\n\t\n\tfunction unpack(i) {\n\t  return FORMS[i];\n\t}\n\t\n\t// adds given `rule` pluralizer for given `locales` into `storage`\n\tfunction add(locales, rule) {\n\t  var i;\n\t\n\t  rule.c = rule.c ? rule.c.map(unpack) : ['other'];\n\t  rule.o = rule.o ? rule.o.map(unpack) : ['other'];\n\t\n\t  for (i = 0; i < locales.length; i++) {\n\t    s[locales[i]] = rule;\n\t  }\n\t}\n\t\n\tfunction B(x, y, val) {\n\t  return x <= val && val <= y && val % 1 === 0;\n\t}\n\tfunction IN(set, val) {\n\t  return set.indexOf(val) >= 0;\n\t}\n\t\n\tadd(['af', 'asa', 'bem', 'bez', 'bg', 'brx', 'ce', 'cgg', 'chr', 'ckb', 'dv', 'ee', 'el', 'eo', 'es', 'eu', 'fo', 'fur', 'gsw', 'ha', 'haw', 'jgo', 'jmc', 'kaj', 'kcg', 'kkj', 'kl', 'ks', 'ksb', 'ku', 'ky', 'lb', 'lg', 'mas', 'mgo', 'ml', 'mn', 'nah', 'nb', 'nd', 'nn', 'nnh', 'no', 'nr', 'ny', 'nyn', 'om', 'or', 'os', 'pap', 'ps', 'rm', 'rof', 'rwk', 'saq', 'sdh', 'seh', 'sn', 'so', 'ss', 'ssy', 'st', 'syr', 'ta', 'te', 'teo', 'tig', 'tk', 'tn', 'tr', 'ts', 'ug', 'uz', 've', 'vo', 'vun', 'wae', 'xh', 'xog'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ak', 'bh', 'guw', 'ln', 'mg', 'nso', 'pa', 'ti', 'wa'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return B(0, 1, n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['am', 'fa', 'kn', 'zu'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ar'], {\n\t  c: [0, 1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n100 = n % 100;\n\t    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : B(3, 10, n100) ? 3 : B(11, 99, n100) ? 4 : 5;\n\t  }\n\t});\n\t\n\tadd(['as', 'bn'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 4, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([1, 5, 7, 8, 9, 10], n) ? 0 : IN([2, 3], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['ast', 'de', 'et', 'fi', 'fy', 'gl', 'ji', 'nl', 'sw', 'ur', 'yi'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['az'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 3, 4, 5],\n\t  oFn: function oFn(n, i) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100,\n\t        i1000 = i % 1000;\n\t    return IN([1, 2, 5, 7, 8], i10) || IN([20, 50, 70, 80], i100) ? 0 : IN([3, 4], i10) || IN([100, 200, 300, 400, 500, 600, 700, 800, 900], i1000) ? 1 : i === 0 || i10 === 6 || IN([40, 60, 90], i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['be'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 1 && n100 !== 11 ? 0 : B(2, 4, n10) && !B(12, 14, n100) ? 1 : n10 === 0 || B(5, 9, n10) || B(11, 14, n100) ? 2 : 3;\n\t  },\n\t  o: [3, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return IN([2, 3], n10) && !IN([12, 13], n100) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['bm', 'bo', 'dz', 'id', 'ig', 'ii', 'in', 'ja', 'jbo', 'jv', 'jw', 'kde', 'kea', 'km', 'ko', 'lkt', 'my', 'nqo', 'root', 'sah', 'ses', 'sg', 'th', 'to', 'wo', 'yo', 'zh'], {});\n\t\n\tadd(['br'], {\n\t  c: [1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100,\n\t        n1000000 = n % 1000000;\n\t    return n10 === 1 && !IN([11, 71, 91], n100) ? 0 : n10 === 2 && !IN([12, 72, 92], n100) ? 1 : (B(3, 4, n10) || n10 === 9) && !B(10, 19, n100) && !B(70, 79, n100) && !B(90, 99, n100) ? 2 : n !== 0 && n1000000 === 0 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['bs', 'hr', 'sh', 'sr'], {\n\t  c: [1, 3, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100,\n\t        f10 = f % 10,\n\t        f100 = f % 100;\n\t    return v === 0 && i10 === 1 && i100 !== 11 || f10 === 1 && f100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) || B(2, 4, f10) && !B(12, 14, f100) ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['ca'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([1, 3], n) ? 0 : n === 2 ? 1 : n === 4 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['cs', 'sk'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : B(2, 4, i) && v === 0 ? 1 : v !== 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['cy'], {\n\t  c: [0, 1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n === 3 ? 3 : n === 6 ? 4 : 5;\n\t  },\n\t  o: [0, 1, 2, 3, 4, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([0, 7, 8, 9], n) ? 0 : n === 1 ? 1 : n === 2 ? 2 : IN([3, 4], n) ? 3 : IN([5, 6], n) ? 4 : 5;\n\t  }\n\t});\n\t\n\tadd(['da'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f, t) {\n\t    return n === 1 || t !== 0 && IN([0, 1], i) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['dsb', 'hsb'], {\n\t  c: [1, 2, 3, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i100 = i % 100,\n\t        f100 = f % 100;\n\t    return v === 0 && i100 === 1 || f100 === 1 ? 0 : v === 0 && i100 === 2 || f100 === 2 ? 1 : v === 0 && B(3, 4, i100) || B(3, 4, f100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['en'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 1 && n100 !== 11 ? 0 : n10 === 2 && n100 !== 12 ? 1 : n10 === 3 && n100 !== 13 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['ff', 'kab'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return IN([0, 1], i) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['fil', 'tl'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i10 = i % 10,\n\t        f10 = f % 10;\n\t    return v === 0 && IN([1, 2, 3], i) || v === 0 && !IN([4, 6, 9], i10) || v !== 0 && !IN([4, 6, 9], f10) ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['fr', 'hy'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return IN([0, 1], i) ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ga'], {\n\t  c: [1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : n === 2 ? 1 : B(3, 6, n) ? 2 : B(7, 10, n) ? 3 : 4;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['gd'], {\n\t  c: [1, 2, 3, 5],\n\t  cFn: function cFn(n) {\n\t    return IN([1, 11], n) ? 0 : IN([2, 12], n) ? 1 : B(3, 10, n) || B(13, 19, n) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['gu', 'hi'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 4, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : IN([2, 3], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['gv'], {\n\t  c: [1, 2, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return v === 0 && i10 === 1 ? 0 : v === 0 && i10 === 2 ? 1 : v === 0 && IN([0, 20, 40, 60, 80], i100) ? 2 : v !== 0 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['he', 'iw'], {\n\t  c: [1, 2, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var n10 = n % 10;\n\t    return i === 1 && v === 0 ? 0 : i === 2 && v === 0 ? 1 : v === 0 && !B(0, 10, n) && n10 === 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['hu'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([1, 5], n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['is'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f, t) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return t === 0 && i10 === 1 && i100 !== 11 || t !== 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['it'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [4, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([11, 8, 80, 800], n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['iu', 'kw', 'naq', 'se', 'sma', 'smi', 'smj', 'smn', 'sms'], {\n\t  c: [1, 2, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : n === 2 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['ka'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 4, 5],\n\t  oFn: function oFn(n, i) {\n\t    var i100 = i % 100;\n\t    return i === 1 ? 0 : i === 0 || B(2, 20, i100) || i100 === 40 || i100 === 60 || i100 === 80 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['kk'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [4, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10;\n\t    return n10 === 6 || n10 === 9 || n10 === 0 && n !== 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ksh'], {\n\t  c: [0, 1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 0 ? 0 : n === 1 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['lag'], {\n\t  c: [0, 1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return n === 0 ? 0 : IN([0, 1], i) && n !== 0 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['lo', 'ms', 'vi'], {\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['lt'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 1 && !B(11, 19, n100) ? 0 : B(2, 9, n10) && !B(11, 19, n100) ? 1 : f !== 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['lv', 'prg'], {\n\t  c: [0, 1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100,\n\t        f100 = f % 100,\n\t        f10 = f % 10;\n\t    return n10 === 0 || B(11, 19, n100) || v === 2 && B(11, 19, f100) ? 0 : n10 === 1 && n100 !== 11 || v === 2 && f10 === 1 && f100 !== 11 || v !== 2 && f10 === 1 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['mk'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i10 = i % 10,\n\t        f10 = f % 10;\n\t    return v === 0 && i10 === 1 || f10 === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 4, 5],\n\t  oFn: function oFn(n, i) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return i10 === 1 && i100 !== 11 ? 0 : i10 === 2 && i100 !== 12 ? 1 : IN([7, 8], i10) && !IN([17, 18], i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['mo', 'ro'], {\n\t  c: [1, 3, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var n100 = n % 100;\n\t    return i === 1 && v === 0 ? 0 : v !== 0 || n === 0 || n !== 1 && B(1, 19, n100) ? 1 : 2;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['mr'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : IN([2, 3], n) ? 1 : n === 4 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['mt'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n100 = n % 100;\n\t    return n === 1 ? 0 : n === 0 || B(2, 10, n100) ? 1 : B(11, 19, n100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['ne'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return B(1, 4, n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['pl'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return i === 1 && v === 0 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i !== 1 && B(0, 1, i10) || v === 0 && B(5, 9, i10) || v === 0 && B(12, 14, i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['pt'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return B(0, 2, n) && n !== 2 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['pt-pt'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return n === 1 && v === 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ru'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['shi'], {\n\t  c: [1, 3, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : B(2, 10, n) ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['si'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    return IN([0, 1], n) || i === 0 && f === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['sl'], {\n\t  c: [1, 2, 3, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i100 = i % 100;\n\t    return v === 0 && i100 === 1 ? 0 : v === 0 && i100 === 2 ? 1 : v === 0 && B(3, 4, i100) || v !== 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['sq'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 4, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n === 1 ? 0 : n10 === 4 && n100 !== 14 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['sv'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return IN([1, 2], n10) && !IN([11, 12], n100) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['tzm'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return B(0, 1, n) || B(11, 99, n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['uk'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n\t  },\n\t  o: [3, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 3 && n100 !== 13 ? 0 : 1;\n\t  }\n\t});\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\n/***/ },\n\n/***/ 358:\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n\n/***/ 359:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar CodeMirror = __webpack_require__(360);\n\t__webpack_require__(361);\n\t\n\tvar template = __webpack_require__(366);\n\t\n\tvar clientRender = __webpack_require__(161);\n\t\n\tvar delegate = __webpack_require__(148);\n\t\n\tvar t = __webpack_require__(326);\n\t\n\tvar LANG = __webpack_require__(252).lang;\n\t\n\tt.requirePhrase('mdedit', __webpack_require__(367)(\"./\" + LANG + '.yml'));\n\t\n\tvar MdEditor = (function () {\n\t  _createClass(MdEditor, [{\n\t    key: 'actionBold',\n\t    value: function actionBold() {\n\t      this.replaceSelection(\"**\", \"**\", 2, t(\"bold\"));\n\t    }\n\t  }, {\n\t    key: 'actionItalic',\n\t    value: function actionItalic() {\n\t      this.replaceSelection(\"*\", \"*\", 1, t(\"italic\"));\n\t    }\n\t  }, {\n\t    key: 'actionCode',\n\t    value: function actionCode() {\n\t      this.replaceSelection(\"`\", \"`\", 0, t(\"code\"));\n\t    }\n\t  }, {\n\t    key: 'actionRedo',\n\t    value: function actionRedo() {\n\t      this.codemirror.redo();\n\t    }\n\t  }, {\n\t    key: 'actionUndo',\n\t    value: function actionUndo() {\n\t      this.codemirror.undo();\n\t    }\n\t  }, {\n\t    key: 'actionFencedCode',\n\t    value: function actionFencedCode() {\n\t      this.replaceSelection(\"\\n```js\\n\", \"\\n```\\n\", 0, t(\"code_multiline\"));\n\t    }\n\t  }, {\n\t    key: 'actionLink',\n\t    value: function actionLink() {\n\t\n\t      var selection = this.codemirror.getSelection();\n\t      var text = '';\n\t      var link = 'http://';\n\t\n\t      if (selection.match(/^https?:\\/\\//)) {\n\t        link = selection;\n\t      } else {\n\t        text = selection;\n\t      }\n\t\n\t      if (link) {\n\t        text = 'link text';\n\t      }\n\t      this.codemirror.replaceSelection('[' + text + '](' + link + ')');\n\t      var cursorPos = this.codemirror.getCursor();\n\t      this.codemirror.setCursor(cursorPos.line, cursorPos.ch - (3 + link.length));\n\t    }\n\t  }, {\n\t    key: 'actionOl',\n\t    value: function actionOl() {\n\t      this.replaceSelection(\"1. \", \"\\n\", 0, t('ol_item'));\n\t    }\n\t  }, {\n\t    key: 'actionUl',\n\t    value: function actionUl() {\n\t      this.replaceSelection(\"- \", \"\\n\", 0, t('ul_item'));\n\t    }\n\t  }, {\n\t    key: 'actionHeading',\n\t    value: function actionHeading() {\n\t      this.replaceSelection(\"# \", \"\\n\", 0, t(\"heading\"));\n\t    }\n\t  }, {\n\t    key: 'actionImage',\n\t    value: function actionImage() {\n\t      var selection = this.codemirror.getSelection();\n\t      var text = t(\"alt\");\n\t\n\t      if (!selection) {\n\t        selection = \"http://my.jpg\";\n\t      }\n\t      this.codemirror.replaceSelection('![' + text + '](' + selection + ')');\n\t      var cursorPos = this.codemirror.getCursor();\n\t      this.codemirror.setCursor(cursorPos.line, cursorPos.ch - (1 + selection.length));\n\t    }\n\t  }, {\n\t    key: 'replaceSelection',\n\t    value: function replaceSelection(before, after, moveCursorCharsCount, defaultText) {\n\t\n\t      var selection = this.codemirror.getSelection();\n\t      if (!selection) selection = defaultText;\n\t      this.codemirror.replaceSelection(before + selection + after);\n\t\n\t      var cursorPos = this.codemirror.getCursor();\n\t      this.codemirror.setCursor(cursorPos.line, cursorPos.ch - moveCursorCharsCount);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render(textArea) {\n\t      var allButtons = {\n\t        Bold: 'bold [Ctrl-B]',\n\t        Italic: 'italic [Ctrl-I]',\n\t        Code: 'inline code',\n\t        Undo: 'undo [Ctrl-Z]',\n\t        Redo: 'redo [Ctrl-Y]',\n\t        FencedCode: 'multiline code',\n\t        Link: 'link',\n\t        Ul: 'itemized list',\n\t        Ol: 'ordered list',\n\t        Heading: 'heading',\n\t        Image: 'insert image'\n\t      };\n\t\n\t      function makeButtonsFromActions(actions) {\n\t        var buttons = [];\n\t        for (var i = 0; i < actions.length; i++) {\n\t          buttons.push({ action: actions[i], title: allButtons[actions[i]] });\n\t        }\n\t        return buttons;\n\t      }\n\t\n\t      var buttons;\n\t      switch (this.options.buttonSet) {\n\t        default:\n\t          buttons = makeButtonsFromActions('Bold Italic Code Undo Redo FencedCode Link Ul Ol Heading Image'.split(' '));\n\t      }\n\t\n\t      textArea.insertAdjacentHTML(\"afterEnd\", clientRender(template, {\n\t        buttons: buttons\n\t      }));\n\t\n\t      this.elem = textArea.nextElementSibling;\n\t\n\t      var templateArea = this.elem.querySelector('textarea');\n\t      templateArea.replace(textArea);\n\t\n\t      textArea.classList.remove('mdeditor');\n\t      // move all classes from template textarea to the existing one\n\t      for (var i = 0; i < templateArea.classList.length; i++) {\n\t        var cls = templateArea.classList[i];\n\t        textArea.classList.add(cls);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  function MdEditor(options) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, MdEditor);\n\t\n\t    this.options = Object.create(options);\n\t    if (!options.buttonSet) this.options.buttonSet = 'standard';\n\t\n\t    this.render(options.elem);\n\t    this.value = this.elem.value;\n\t\n\t    this.delegate('[data-action]', function (e) {\n\t      var actionName = 'action' + this.delegateTarget.getAtribute('data-action');\n\t      if (!this[actionName]) return;\n\t\n\t      e.preventDefault();\n\t      this[actionName]();\n\t    });\n\t\n\t    return;\n\t\n\t    this.codemirror = CodeMirror.fromTextArea(this.elem.querySelector('textarea'), {\n\t      tabSize: 2,\n\t      //lineNumbers: false,\n\t      mode: 'gfm'\n\t    });\n\t\n\t    this.codemirror.setOption(\"extraKeys\", {\n\t      'Ctrl-B': function CtrlB() {\n\t        return _this.actionBold();\n\t      },\n\t      'Ctrl-I': function CtrlI() {\n\t        return _this.actionItalic();\n\t      }\n\t    });\n\t\n\t    /*\n\t     editor.on(\"change\", function(cm, change) {\n\t     document.getElementById(\"qa-preview\").innerHTML = cm.getValue();\n\t     });\n\t     */\n\t  }\n\t\n\t  return MdEditor;\n\t})();\n\t\n\tdelegate.delegateMixin(MdEditor.prototype);\n\t\n\tmodule.exports = MdEditor;\n\n/***/ },\n\n/***/ 360:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// This is CodeMirror (http://codemirror.net), a code editor\n\t// implemented in JavaScript on top of the browser's DOM.\n\t//\n\t// You can find some technical background for some of the code below\n\t// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    module.exports = mod();\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    return define([], mod);\n\t  else // Plain browser env\n\t    (this || window).CodeMirror = mod();\n\t})(function() {\n\t  \"use strict\";\n\t\n\t  // BROWSER SNIFFING\n\t\n\t  // Kludges for bugs and behavior differences that can't be feature\n\t  // detected are enabled based on userAgent etc sniffing.\n\t  var userAgent = navigator.userAgent;\n\t  var platform = navigator.platform;\n\t\n\t  var gecko = /gecko\\/\\d/i.test(userAgent);\n\t  var ie_upto10 = /MSIE \\d/.test(userAgent);\n\t  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n\t  var ie = ie_upto10 || ie_11up;\n\t  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n\t  var webkit = /WebKit\\//.test(userAgent);\n\t  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n\t  var chrome = /Chrome\\//.test(userAgent);\n\t  var presto = /Opera\\//.test(userAgent);\n\t  var safari = /Apple Computer/.test(navigator.vendor);\n\t  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n\t  var phantom = /PhantomJS/.test(userAgent);\n\t\n\t  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n\t  // This is woefully incomplete. Suggestions for alternative methods welcome.\n\t  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n\t  var mac = ios || /Mac/.test(platform);\n\t  var windows = /win/i.test(platform);\n\t\n\t  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\t  if (presto_version) presto_version = Number(presto_version[1]);\n\t  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n\t  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\t  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n\t  var captureRightClick = gecko || (ie && ie_version >= 9);\n\t\n\t  // Optimize some code when these features are not used.\n\t  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\t\n\t  // EDITOR CONSTRUCTOR\n\t\n\t  // A CodeMirror instance represents an editor. This is the object\n\t  // that user code is usually dealing with.\n\t\n\t  function CodeMirror(place, options) {\n\t    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\t\n\t    this.options = options = options ? copyObj(options) : {};\n\t    // Determine effective options based on given values and defaults.\n\t    copyObj(defaults, options, false);\n\t    setGuttersForLineNumbers(options);\n\t\n\t    var doc = options.value;\n\t    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n\t    this.doc = doc;\n\t\n\t    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n\t    var display = this.display = new Display(place, doc, input);\n\t    display.wrapper.CodeMirror = this;\n\t    updateGutters(this);\n\t    themeChanged(this);\n\t    if (options.lineWrapping)\n\t      this.display.wrapper.className += \" CodeMirror-wrap\";\n\t    if (options.autofocus && !mobile) display.input.focus();\n\t    initScrollbars(this);\n\t\n\t    this.state = {\n\t      keyMaps: [],  // stores maps added by addKeyMap\n\t      overlays: [], // highlighting overlays, as added by addOverlay\n\t      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n\t      overwrite: false,\n\t      delayingBlurEvent: false,\n\t      focused: false,\n\t      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n\t      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n\t      selectingText: false,\n\t      draggingText: false,\n\t      highlight: new Delayed(), // stores highlight worker timeout\n\t      keySeq: null,  // Unfinished key sequence\n\t      specialChars: null\n\t    };\n\t\n\t    var cm = this;\n\t\n\t    // Override magic textarea content restore that IE sometimes does\n\t    // on our hidden textarea on reload\n\t    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\t\n\t    registerEventHandlers(this);\n\t    ensureGlobalHandlers();\n\t\n\t    startOperation(this);\n\t    this.curOp.forceUpdate = true;\n\t    attachDoc(this, doc);\n\t\n\t    if ((options.autofocus && !mobile) || cm.hasFocus())\n\t      setTimeout(bind(onFocus, this), 20);\n\t    else\n\t      onBlur(this);\n\t\n\t    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n\t      optionHandlers[opt](this, options[opt], Init);\n\t    maybeUpdateLineNumberWidth(this);\n\t    if (options.finishInit) options.finishInit(this);\n\t    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n\t    endOperation(this);\n\t    // Suppress optimizelegibility in Webkit, since it breaks text\n\t    // measuring on line wrapping boundaries.\n\t    if (webkit && options.lineWrapping &&\n\t        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n\t      display.lineDiv.style.textRendering = \"auto\";\n\t  }\n\t\n\t  // DISPLAY CONSTRUCTOR\n\t\n\t  // The display handles the DOM integration, both for input reading\n\t  // and content drawing. It holds references to DOM nodes and\n\t  // display-related state.\n\t\n\t  function Display(place, doc, input) {\n\t    var d = this;\n\t    this.input = input;\n\t\n\t    // Covers bottom-right square when both scrollbars are present.\n\t    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n\t    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n\t    // and h scrollbar is present.\n\t    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n\t    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Will contain the actual code, positioned to cover the viewport.\n\t    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n\t    // Elements are added to these to represent selection and cursors.\n\t    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n\t    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n\t    // A visibility: hidden element used to find the size of things.\n\t    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // When lines outside of the viewport are measured, they are drawn in this.\n\t    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\t    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n\t                      null, \"position: relative; outline: none\");\n\t    // Moved around its parent to cover visible view.\n\t    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n\t    // Set to the height of the document, allowing scrolling.\n\t    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n\t    d.sizerWidth = null;\n\t    // Behavior of elts with overflow: auto and padding is\n\t    // inconsistent across browsers. This is used to ensure the\n\t    // scrollable area is big enough.\n\t    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n\t    // Will contain the gutters, if any.\n\t    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n\t    d.lineGutter = null;\n\t    // Actual scrollable element.\n\t    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n\t    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n\t    // The element in which the editor lives.\n\t    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\t\n\t    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\t    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n\t    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\t\n\t    if (place) {\n\t      if (place.appendChild) place.appendChild(d.wrapper);\n\t      else place(d.wrapper);\n\t    }\n\t\n\t    // Current rendered range (may be bigger than the view window).\n\t    d.viewFrom = d.viewTo = doc.first;\n\t    d.reportedViewFrom = d.reportedViewTo = doc.first;\n\t    // Information about the rendered lines.\n\t    d.view = [];\n\t    d.renderedView = null;\n\t    // Holds info about a single rendered line when it was rendered\n\t    // for measurement, while not in view.\n\t    d.externalMeasured = null;\n\t    // Empty space (in pixels) above the view\n\t    d.viewOffset = 0;\n\t    d.lastWrapHeight = d.lastWrapWidth = 0;\n\t    d.updateLineNumbers = null;\n\t\n\t    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n\t    d.scrollbarsClipped = false;\n\t\n\t    // Used to only resize the line number gutter when necessary (when\n\t    // the amount of lines crosses a boundary that makes its width change)\n\t    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n\t    // Set to true when a non-horizontal-scrolling line widget is\n\t    // added. As an optimization, line widget aligning is skipped when\n\t    // this is false.\n\t    d.alignWidgets = false;\n\t\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t\n\t    // Tracks the maximum line length so that the horizontal scrollbar\n\t    // can be kept static when scrolling.\n\t    d.maxLine = null;\n\t    d.maxLineLength = 0;\n\t    d.maxLineChanged = false;\n\t\n\t    // Used for measuring wheel scrolling granularity\n\t    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\t\n\t    // True when shift is held down.\n\t    d.shift = false;\n\t\n\t    // Used to track whether anything happened since the context menu\n\t    // was opened.\n\t    d.selForContextMenu = null;\n\t\n\t    d.activeTouch = null;\n\t\n\t    input.init(d);\n\t  }\n\t\n\t  // STATE UPDATES\n\t\n\t  // Used to get the editor into a consistent state again when options change.\n\t\n\t  function loadMode(cm) {\n\t    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n\t    resetModeState(cm);\n\t  }\n\t\n\t  function resetModeState(cm) {\n\t    cm.doc.iter(function(line) {\n\t      if (line.stateAfter) line.stateAfter = null;\n\t      if (line.styles) line.styles = null;\n\t    });\n\t    cm.doc.frontier = cm.doc.first;\n\t    startWorker(cm, 100);\n\t    cm.state.modeGen++;\n\t    if (cm.curOp) regChange(cm);\n\t  }\n\t\n\t  function wrappingChanged(cm) {\n\t    if (cm.options.lineWrapping) {\n\t      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      cm.display.sizer.style.minWidth = \"\";\n\t      cm.display.sizerWidth = null;\n\t    } else {\n\t      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      findMaxLine(cm);\n\t    }\n\t    estimateLineHeights(cm);\n\t    regChange(cm);\n\t    clearCaches(cm);\n\t    setTimeout(function(){updateScrollbars(cm);}, 100);\n\t  }\n\t\n\t  // Returns a function that estimates the height of a line, to use as\n\t  // first approximation until the line becomes visible (and is thus\n\t  // properly measurable).\n\t  function estimateHeight(cm) {\n\t    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n\t    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n\t    return function(line) {\n\t      if (lineIsHidden(cm.doc, line)) return 0;\n\t\n\t      var widgetsHeight = 0;\n\t      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n\t        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n\t      }\n\t\n\t      if (wrapping)\n\t        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n\t      else\n\t        return widgetsHeight + th;\n\t    };\n\t  }\n\t\n\t  function estimateLineHeights(cm) {\n\t    var doc = cm.doc, est = estimateHeight(cm);\n\t    doc.iter(function(line) {\n\t      var estHeight = est(line);\n\t      if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t    });\n\t  }\n\t\n\t  function themeChanged(cm) {\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n\t      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n\t    clearCaches(cm);\n\t  }\n\t\n\t  function guttersChanged(cm) {\n\t    updateGutters(cm);\n\t    regChange(cm);\n\t    setTimeout(function(){alignHorizontally(cm);}, 20);\n\t  }\n\t\n\t  // Rebuild the gutter elements, ensure the margin to the left of the\n\t  // code matches their width.\n\t  function updateGutters(cm) {\n\t    var gutters = cm.display.gutters, specs = cm.options.gutters;\n\t    removeChildren(gutters);\n\t    for (var i = 0; i < specs.length; ++i) {\n\t      var gutterClass = specs[i];\n\t      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\t      if (gutterClass == \"CodeMirror-linenumbers\") {\n\t        cm.display.lineGutter = gElt;\n\t        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n\t      }\n\t    }\n\t    gutters.style.display = i ? \"\" : \"none\";\n\t    updateGutterSpace(cm);\n\t  }\n\t\n\t  function updateGutterSpace(cm) {\n\t    var width = cm.display.gutters.offsetWidth;\n\t    cm.display.sizer.style.marginLeft = width + \"px\";\n\t  }\n\t\n\t  // Compute the character length of a line, taking into account\n\t  // collapsed ranges (see markText) that might hide parts, and join\n\t  // other lines onto it.\n\t  function lineLength(line) {\n\t    if (line.height == 0) return 0;\n\t    var len = line.text.length, merged, cur = line;\n\t    while (merged = collapsedSpanAtStart(cur)) {\n\t      var found = merged.find(0, true);\n\t      cur = found.from.line;\n\t      len += found.from.ch - found.to.ch;\n\t    }\n\t    cur = line;\n\t    while (merged = collapsedSpanAtEnd(cur)) {\n\t      var found = merged.find(0, true);\n\t      len -= cur.text.length - found.from.ch;\n\t      cur = found.to.line;\n\t      len += cur.text.length - found.to.ch;\n\t    }\n\t    return len;\n\t  }\n\t\n\t  // Find the longest line in the document.\n\t  function findMaxLine(cm) {\n\t    var d = cm.display, doc = cm.doc;\n\t    d.maxLine = getLine(doc, doc.first);\n\t    d.maxLineLength = lineLength(d.maxLine);\n\t    d.maxLineChanged = true;\n\t    doc.iter(function(line) {\n\t      var len = lineLength(line);\n\t      if (len > d.maxLineLength) {\n\t        d.maxLineLength = len;\n\t        d.maxLine = line;\n\t      }\n\t    });\n\t  }\n\t\n\t  // Make sure the gutters options contains the element\n\t  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\t  function setGuttersForLineNumbers(options) {\n\t    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n\t    if (found == -1 && options.lineNumbers) {\n\t      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n\t    } else if (found > -1 && !options.lineNumbers) {\n\t      options.gutters = options.gutters.slice(0);\n\t      options.gutters.splice(found, 1);\n\t    }\n\t  }\n\t\n\t  // SCROLLBARS\n\t\n\t  // Prepare DOM reads needed to update the scrollbars. Done in one\n\t  // shot to minimize update/measure roundtrips.\n\t  function measureForScrollbars(cm) {\n\t    var d = cm.display, gutterW = d.gutters.offsetWidth;\n\t    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n\t    return {\n\t      clientHeight: d.scroller.clientHeight,\n\t      viewHeight: d.wrapper.clientHeight,\n\t      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n\t      viewWidth: d.wrapper.clientWidth,\n\t      barLeft: cm.options.fixedGutter ? gutterW : 0,\n\t      docHeight: docH,\n\t      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n\t      nativeBarWidth: d.nativeBarWidth,\n\t      gutterWidth: gutterW\n\t    };\n\t  }\n\t\n\t  function NativeScrollbars(place, scroll, cm) {\n\t    this.cm = cm;\n\t    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n\t    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n\t    place(vert); place(horiz);\n\t\n\t    on(vert, \"scroll\", function() {\n\t      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n\t    });\n\t    on(horiz, \"scroll\", function() {\n\t      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n\t    });\n\t\n\t    this.checkedZeroWidth = false;\n\t    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\t    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n\t  }\n\t\n\t  NativeScrollbars.prototype = copyObj({\n\t    update: function(measure) {\n\t      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n\t      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n\t      var sWidth = measure.nativeBarWidth;\n\t\n\t      if (needsV) {\n\t        this.vert.style.display = \"block\";\n\t        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n\t        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n\t        // A bug in IE8 can cause this value to be negative, so guard it.\n\t        this.vert.firstChild.style.height =\n\t          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n\t      } else {\n\t        this.vert.style.display = \"\";\n\t        this.vert.firstChild.style.height = \"0\";\n\t      }\n\t\n\t      if (needsH) {\n\t        this.horiz.style.display = \"block\";\n\t        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n\t        this.horiz.style.left = measure.barLeft + \"px\";\n\t        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n\t        this.horiz.firstChild.style.width =\n\t          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n\t      } else {\n\t        this.horiz.style.display = \"\";\n\t        this.horiz.firstChild.style.width = \"0\";\n\t      }\n\t\n\t      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n\t        if (sWidth == 0) this.zeroWidthHack();\n\t        this.checkedZeroWidth = true;\n\t      }\n\t\n\t      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n\t    },\n\t    setScrollLeft: function(pos) {\n\t      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n\t      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n\t    },\n\t    setScrollTop: function(pos) {\n\t      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n\t      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n\t    },\n\t    zeroWidthHack: function() {\n\t      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n\t      this.horiz.style.height = this.vert.style.width = w;\n\t      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n\t      this.disableHoriz = new Delayed;\n\t      this.disableVert = new Delayed;\n\t    },\n\t    enableZeroWidthBar: function(bar, delay) {\n\t      bar.style.pointerEvents = \"auto\";\n\t      function maybeDisable() {\n\t        // To find out whether the scrollbar is still visible, we\n\t        // check whether the element under the pixel in the bottom\n\t        // left corner of the scrollbar box is the scrollbar box\n\t        // itself (when the bar is still visible) or its filler child\n\t        // (when the bar is hidden). If it is still visible, we keep\n\t        // it enabled, if it's hidden, we disable pointer events.\n\t        var box = bar.getBoundingClientRect();\n\t        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n\t        if (elt != bar) bar.style.pointerEvents = \"none\";\n\t        else delay.set(1000, maybeDisable);\n\t      }\n\t      delay.set(1000, maybeDisable);\n\t    },\n\t    clear: function() {\n\t      var parent = this.horiz.parentNode;\n\t      parent.removeChild(this.horiz);\n\t      parent.removeChild(this.vert);\n\t    }\n\t  }, NativeScrollbars.prototype);\n\t\n\t  function NullScrollbars() {}\n\t\n\t  NullScrollbars.prototype = copyObj({\n\t    update: function() { return {bottom: 0, right: 0}; },\n\t    setScrollLeft: function() {},\n\t    setScrollTop: function() {},\n\t    clear: function() {}\n\t  }, NullScrollbars.prototype);\n\t\n\t  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\t\n\t  function initScrollbars(cm) {\n\t    if (cm.display.scrollbars) {\n\t      cm.display.scrollbars.clear();\n\t      if (cm.display.scrollbars.addClass)\n\t        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t    }\n\t\n\t    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n\t      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n\t      // Prevent clicks in the scrollbars from killing focus\n\t      on(node, \"mousedown\", function() {\n\t        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n\t      });\n\t      node.setAttribute(\"cm-not-content\", \"true\");\n\t    }, function(pos, axis) {\n\t      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n\t      else setScrollTop(cm, pos);\n\t    }, cm);\n\t    if (cm.display.scrollbars.addClass)\n\t      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t  }\n\t\n\t  function updateScrollbars(cm, measure) {\n\t    if (!measure) measure = measureForScrollbars(cm);\n\t    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n\t    updateScrollbarsInner(cm, measure);\n\t    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n\t      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n\t        updateHeightsInViewport(cm);\n\t      updateScrollbarsInner(cm, measureForScrollbars(cm));\n\t      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n\t    }\n\t  }\n\t\n\t  // Re-synchronize the fake scrollbars with the actual size of the\n\t  // content.\n\t  function updateScrollbarsInner(cm, measure) {\n\t    var d = cm.display;\n\t    var sizes = d.scrollbars.update(measure);\n\t\n\t    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n\t    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\t\n\t    if (sizes.right && sizes.bottom) {\n\t      d.scrollbarFiller.style.display = \"block\";\n\t      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n\t      d.scrollbarFiller.style.width = sizes.right + \"px\";\n\t    } else d.scrollbarFiller.style.display = \"\";\n\t    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n\t      d.gutterFiller.style.display = \"block\";\n\t      d.gutterFiller.style.height = sizes.bottom + \"px\";\n\t      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n\t    } else d.gutterFiller.style.display = \"\";\n\t  }\n\t\n\t  // Compute the lines that are visible in a given viewport (defaults\n\t  // the the current scroll position). viewport may contain top,\n\t  // height, and ensure (see op.scrollToPos) properties.\n\t  function visibleLines(display, doc, viewport) {\n\t    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n\t    top = Math.floor(top - paddingTop(display));\n\t    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\t\n\t    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n\t    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n\t    // forces those lines into the viewport (if possible).\n\t    if (viewport && viewport.ensure) {\n\t      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n\t      if (ensureFrom < from) {\n\t        from = ensureFrom;\n\t        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n\t      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n\t        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n\t        to = ensureTo;\n\t      }\n\t    }\n\t    return {from: from, to: Math.max(to, from + 1)};\n\t  }\n\t\n\t  // LINE NUMBERS\n\t\n\t  // Re-align line numbers and gutter marks to compensate for\n\t  // horizontal scrolling.\n\t  function alignHorizontally(cm) {\n\t    var display = cm.display, view = display.view;\n\t    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n\t    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n\t    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n\t    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n\t      if (cm.options.fixedGutter && view[i].gutter)\n\t        view[i].gutter.style.left = left;\n\t      var align = view[i].alignable;\n\t      if (align) for (var j = 0; j < align.length; j++)\n\t        align[j].style.left = left;\n\t    }\n\t    if (cm.options.fixedGutter)\n\t      display.gutters.style.left = (comp + gutterW) + \"px\";\n\t  }\n\t\n\t  // Used to ensure that the line number gutter is still the right\n\t  // size for the current document size. Returns true when an update\n\t  // is needed.\n\t  function maybeUpdateLineNumberWidth(cm) {\n\t    if (!cm.options.lineNumbers) return false;\n\t    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n\t    if (last.length != display.lineNumChars) {\n\t      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n\t                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n\t      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n\t      display.lineGutter.style.width = \"\";\n\t      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n\t      display.lineNumWidth = display.lineNumInnerWidth + padding;\n\t      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n\t      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n\t      updateGutterSpace(cm);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function lineNumberFor(options, i) {\n\t    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n\t  }\n\t\n\t  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n\t  // but using getBoundingClientRect to get a sub-pixel-accurate\n\t  // result.\n\t  function compensateForHScroll(display) {\n\t    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n\t  }\n\t\n\t  // DISPLAY DRAWING\n\t\n\t  function DisplayUpdate(cm, viewport, force) {\n\t    var display = cm.display;\n\t\n\t    this.viewport = viewport;\n\t    // Store some values that we'll need later (but don't want to force a relayout for)\n\t    this.visible = visibleLines(display, cm.doc, viewport);\n\t    this.editorIsHidden = !display.wrapper.offsetWidth;\n\t    this.wrapperHeight = display.wrapper.clientHeight;\n\t    this.wrapperWidth = display.wrapper.clientWidth;\n\t    this.oldDisplayWidth = displayWidth(cm);\n\t    this.force = force;\n\t    this.dims = getDimensions(cm);\n\t    this.events = [];\n\t  }\n\t\n\t  DisplayUpdate.prototype.signal = function(emitter, type) {\n\t    if (hasHandler(emitter, type))\n\t      this.events.push(arguments);\n\t  };\n\t  DisplayUpdate.prototype.finish = function() {\n\t    for (var i = 0; i < this.events.length; i++)\n\t      signal.apply(null, this.events[i]);\n\t  };\n\t\n\t  function maybeClipScrollbars(cm) {\n\t    var display = cm.display;\n\t    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n\t      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n\t      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n\t      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n\t      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n\t      display.scrollbarsClipped = true;\n\t    }\n\t  }\n\t\n\t  // Does the actual updating of the line display. Bails out\n\t  // (returning false) when there is nothing to be done and forced is\n\t  // false.\n\t  function updateDisplayIfNeeded(cm, update) {\n\t    var display = cm.display, doc = cm.doc;\n\t\n\t    if (update.editorIsHidden) {\n\t      resetView(cm);\n\t      return false;\n\t    }\n\t\n\t    // Bail out if the visible area is already rendered and nothing changed.\n\t    if (!update.force &&\n\t        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n\t        display.renderedView == display.view && countDirtyView(cm) == 0)\n\t      return false;\n\t\n\t    if (maybeUpdateLineNumberWidth(cm)) {\n\t      resetView(cm);\n\t      update.dims = getDimensions(cm);\n\t    }\n\t\n\t    // Compute a suitable new viewport (from & to)\n\t    var end = doc.first + doc.size;\n\t    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n\t    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\t    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n\t    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n\t    if (sawCollapsedSpans) {\n\t      from = visualLineNo(cm.doc, from);\n\t      to = visualLineEndNo(cm.doc, to);\n\t    }\n\t\n\t    var different = from != display.viewFrom || to != display.viewTo ||\n\t      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n\t    adjustView(cm, from, to);\n\t\n\t    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n\t    // Position the mover div to align with the current scroll position\n\t    cm.display.mover.style.top = display.viewOffset + \"px\";\n\t\n\t    var toUpdate = countDirtyView(cm);\n\t    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n\t      return false;\n\t\n\t    // For big changes, we hide the enclosing element during the\n\t    // update, since that speeds up the operations on most browsers.\n\t    var focused = activeElt();\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n\t    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n\t    display.renderedView = display.view;\n\t    // There might have been a widget with a focused element that got\n\t    // hidden or updated, if so re-focus it.\n\t    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\t\n\t    // Prevent selection and cursors from interfering with the scroll\n\t    // width and height.\n\t    removeChildren(display.cursorDiv);\n\t    removeChildren(display.selectionDiv);\n\t    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\t\n\t    if (different) {\n\t      display.lastWrapHeight = update.wrapperHeight;\n\t      display.lastWrapWidth = update.wrapperWidth;\n\t      startWorker(cm, 400);\n\t    }\n\t\n\t    display.updateLineNumbers = null;\n\t\n\t    return true;\n\t  }\n\t\n\t  function postUpdateDisplay(cm, update) {\n\t    var viewport = update.viewport;\n\t    for (var first = true;; first = false) {\n\t      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n\t        // Clip forced viewport to actual scrollable area.\n\t        if (viewport && viewport.top != null)\n\t          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n\t        // Updated line heights might result in the drawn area not\n\t        // actually covering the viewport. Keep looping until it does.\n\t        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\t        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n\t          break;\n\t      }\n\t      if (!updateDisplayIfNeeded(cm, update)) break;\n\t      updateHeightsInViewport(cm);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t    }\n\t\n\t    update.signal(cm, \"update\", cm);\n\t    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n\t      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n\t      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n\t    }\n\t  }\n\t\n\t  function updateDisplaySimple(cm, viewport) {\n\t    var update = new DisplayUpdate(cm, viewport);\n\t    if (updateDisplayIfNeeded(cm, update)) {\n\t      updateHeightsInViewport(cm);\n\t      postUpdateDisplay(cm, update);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t      update.finish();\n\t    }\n\t  }\n\t\n\t  function setDocumentHeight(cm, measure) {\n\t    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n\t    var total = measure.docHeight + cm.display.barHeight;\n\t    cm.display.heightForcer.style.top = total + \"px\";\n\t    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n\t  }\n\t\n\t  // Read the actual heights of the rendered lines, and update their\n\t  // stored heights to match.\n\t  function updateHeightsInViewport(cm) {\n\t    var display = cm.display;\n\t    var prevBottom = display.lineDiv.offsetTop;\n\t    for (var i = 0; i < display.view.length; i++) {\n\t      var cur = display.view[i], height;\n\t      if (cur.hidden) continue;\n\t      if (ie && ie_version < 8) {\n\t        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n\t        height = bot - prevBottom;\n\t        prevBottom = bot;\n\t      } else {\n\t        var box = cur.node.getBoundingClientRect();\n\t        height = box.bottom - box.top;\n\t      }\n\t      var diff = cur.line.height - height;\n\t      if (height < 2) height = textHeight(display);\n\t      if (diff > .001 || diff < -.001) {\n\t        updateLineHeight(cur.line, height);\n\t        updateWidgetHeight(cur.line);\n\t        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n\t          updateWidgetHeight(cur.rest[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Read and store the height of line widgets associated with the\n\t  // given line.\n\t  function updateWidgetHeight(line) {\n\t    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n\t      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n\t  }\n\t\n\t  // Do a bulk-read of the DOM positions and sizes needed to draw the\n\t  // view, so that we don't interleave reading and writing to the DOM.\n\t  function getDimensions(cm) {\n\t    var d = cm.display, left = {}, width = {};\n\t    var gutterLeft = d.gutters.clientLeft;\n\t    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n\t      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n\t      width[cm.options.gutters[i]] = n.clientWidth;\n\t    }\n\t    return {fixedPos: compensateForHScroll(d),\n\t            gutterTotalWidth: d.gutters.offsetWidth,\n\t            gutterLeft: left,\n\t            gutterWidth: width,\n\t            wrapperWidth: d.wrapper.clientWidth};\n\t  }\n\t\n\t  // Sync the actual display DOM structure with display.view, removing\n\t  // nodes for lines that are no longer in view, and creating the ones\n\t  // that are not there yet, and updating the ones that are out of\n\t  // date.\n\t  function patchDisplay(cm, updateNumbersFrom, dims) {\n\t    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n\t    var container = display.lineDiv, cur = container.firstChild;\n\t\n\t    function rm(node) {\n\t      var next = node.nextSibling;\n\t      // Works around a throw-scroll bug in OS X Webkit\n\t      if (webkit && mac && cm.display.currentWheelTarget == node)\n\t        node.style.display = \"none\";\n\t      else\n\t        node.parentNode.removeChild(node);\n\t      return next;\n\t    }\n\t\n\t    var view = display.view, lineN = display.viewFrom;\n\t    // Loop over the elements in the view, syncing cur (the DOM nodes\n\t    // in display.lineDiv) with the view as we go.\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (lineView.hidden) {\n\t      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n\t        var node = buildLineElement(cm, lineView, lineN, dims);\n\t        container.insertBefore(node, cur);\n\t      } else { // Already drawn\n\t        while (cur != lineView.node) cur = rm(cur);\n\t        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n\t          updateNumbersFrom <= lineN && lineView.lineNumber;\n\t        if (lineView.changes) {\n\t          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n\t          updateLineForChanges(cm, lineView, lineN, dims);\n\t        }\n\t        if (updateNumber) {\n\t          removeChildren(lineView.lineNumber);\n\t          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n\t        }\n\t        cur = lineView.node.nextSibling;\n\t      }\n\t      lineN += lineView.size;\n\t    }\n\t    while (cur) cur = rm(cur);\n\t  }\n\t\n\t  // When an aspect of a line changes, a string is added to\n\t  // lineView.changes. This updates the relevant part of the line's\n\t  // DOM structure.\n\t  function updateLineForChanges(cm, lineView, lineN, dims) {\n\t    for (var j = 0; j < lineView.changes.length; j++) {\n\t      var type = lineView.changes[j];\n\t      if (type == \"text\") updateLineText(cm, lineView);\n\t      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n\t      else if (type == \"class\") updateLineClasses(lineView);\n\t      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n\t    }\n\t    lineView.changes = null;\n\t  }\n\t\n\t  // Lines with gutter elements, widgets or a background class need to\n\t  // be wrapped, and have the extra elements added to the wrapper div\n\t  function ensureLineWrapped(lineView) {\n\t    if (lineView.node == lineView.text) {\n\t      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\t      if (lineView.text.parentNode)\n\t        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n\t      lineView.node.appendChild(lineView.text);\n\t      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n\t    }\n\t    return lineView.node;\n\t  }\n\t\n\t  function updateLineBackground(lineView) {\n\t    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\t    if (cls) cls += \" CodeMirror-linebackground\";\n\t    if (lineView.background) {\n\t      if (cls) lineView.background.className = cls;\n\t      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n\t    } else if (cls) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n\t    }\n\t  }\n\t\n\t  // Wrapper around buildLineContent which will reuse the structure\n\t  // in display.externalMeasured when possible.\n\t  function getLineContent(cm, lineView) {\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && ext.line == lineView.line) {\n\t      cm.display.externalMeasured = null;\n\t      lineView.measure = ext.measure;\n\t      return ext.built;\n\t    }\n\t    return buildLineContent(cm, lineView);\n\t  }\n\t\n\t  // Redraw the line's text. Interacts with the background and text\n\t  // classes because the mode may output tokens that influence these\n\t  // classes.\n\t  function updateLineText(cm, lineView) {\n\t    var cls = lineView.text.className;\n\t    var built = getLineContent(cm, lineView);\n\t    if (lineView.text == lineView.node) lineView.node = built.pre;\n\t    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n\t    lineView.text = built.pre;\n\t    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n\t      lineView.bgClass = built.bgClass;\n\t      lineView.textClass = built.textClass;\n\t      updateLineClasses(lineView);\n\t    } else if (cls) {\n\t      lineView.text.className = cls;\n\t    }\n\t  }\n\t\n\t  function updateLineClasses(lineView) {\n\t    updateLineBackground(lineView);\n\t    if (lineView.line.wrapClass)\n\t      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n\t    else if (lineView.node != lineView.text)\n\t      lineView.node.className = \"\";\n\t    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n\t    lineView.text.className = textClass || \"\";\n\t  }\n\t\n\t  function updateLineGutter(cm, lineView, lineN, dims) {\n\t    if (lineView.gutter) {\n\t      lineView.node.removeChild(lineView.gutter);\n\t      lineView.gutter = null;\n\t    }\n\t    if (lineView.gutterBackground) {\n\t      lineView.node.removeChild(lineView.gutterBackground);\n\t      lineView.gutterBackground = null;\n\t    }\n\t    if (lineView.line.gutterClass) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n\t                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n\t                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n\t      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n\t    }\n\t    var markers = lineView.line.gutterMarkers;\n\t    if (cm.options.lineNumbers || markers) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n\t                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n\t      cm.display.input.setUneditable(gutterWrap);\n\t      wrap.insertBefore(gutterWrap, lineView.text);\n\t      if (lineView.line.gutterClass)\n\t        gutterWrap.className += \" \" + lineView.line.gutterClass;\n\t      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n\t        lineView.lineNumber = gutterWrap.appendChild(\n\t          elt(\"div\", lineNumberFor(cm.options, lineN),\n\t              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n\t              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n\t              + cm.display.lineNumInnerWidth + \"px\"));\n\t      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n\t        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n\t        if (found)\n\t          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n\t                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateLineWidgets(cm, lineView, dims) {\n\t    if (lineView.alignable) lineView.alignable = null;\n\t    for (var node = lineView.node.firstChild, next; node; node = next) {\n\t      var next = node.nextSibling;\n\t      if (node.className == \"CodeMirror-linewidget\")\n\t        lineView.node.removeChild(node);\n\t    }\n\t    insertLineWidgets(cm, lineView, dims);\n\t  }\n\t\n\t  // Build a line's DOM representation from scratch\n\t  function buildLineElement(cm, lineView, lineN, dims) {\n\t    var built = getLineContent(cm, lineView);\n\t    lineView.text = lineView.node = built.pre;\n\t    if (built.bgClass) lineView.bgClass = built.bgClass;\n\t    if (built.textClass) lineView.textClass = built.textClass;\n\t\n\t    updateLineClasses(lineView);\n\t    updateLineGutter(cm, lineView, lineN, dims);\n\t    insertLineWidgets(cm, lineView, dims);\n\t    return lineView.node;\n\t  }\n\t\n\t  // A lineView may contain multiple logical lines (when merged by\n\t  // collapsed spans). The widgets for all of them need to be drawn.\n\t  function insertLineWidgets(cm, lineView, dims) {\n\t    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\t    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n\t  }\n\t\n\t  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n\t    if (!line.widgets) return;\n\t    var wrap = ensureLineWrapped(lineView);\n\t    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n\t      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\t      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      positionLineWidget(widget, node, lineView, dims);\n\t      cm.display.input.setUneditable(node);\n\t      if (allowAbove && widget.above)\n\t        wrap.insertBefore(node, lineView.gutter || lineView.text);\n\t      else\n\t        wrap.appendChild(node);\n\t      signalLater(widget, \"redraw\");\n\t    }\n\t  }\n\t\n\t  function positionLineWidget(widget, node, lineView, dims) {\n\t    if (widget.noHScroll) {\n\t      (lineView.alignable || (lineView.alignable = [])).push(node);\n\t      var width = dims.wrapperWidth;\n\t      node.style.left = dims.fixedPos + \"px\";\n\t      if (!widget.coverGutter) {\n\t        width -= dims.gutterTotalWidth;\n\t        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n\t      }\n\t      node.style.width = width + \"px\";\n\t    }\n\t    if (widget.coverGutter) {\n\t      node.style.zIndex = 5;\n\t      node.style.position = \"relative\";\n\t      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n\t    }\n\t  }\n\t\n\t  // POSITION OBJECT\n\t\n\t  // A Pos instance represents a position within the text.\n\t  var Pos = CodeMirror.Pos = function(line, ch) {\n\t    if (!(this instanceof Pos)) return new Pos(line, ch);\n\t    this.line = line; this.ch = ch;\n\t  };\n\t\n\t  // Compare two positions, return 0 if they are the same, a negative\n\t  // number when a is less, and a positive number otherwise.\n\t  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\t\n\t  function copyPos(x) {return Pos(x.line, x.ch);}\n\t  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n\t  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\t\n\t  // INPUT HANDLING\n\t\n\t  function ensureFocus(cm) {\n\t    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n\t  }\n\t\n\t  // This will be set to an array of strings when copying, so that,\n\t  // when pasting, we know what kind of selections the copied text\n\t  // was made out of.\n\t  var lastCopied = null;\n\t\n\t  function applyTextInput(cm, inserted, deleted, sel, origin) {\n\t    var doc = cm.doc;\n\t    cm.display.shift = false;\n\t    if (!sel) sel = doc.sel;\n\t\n\t    var paste = cm.state.pasteIncoming || origin == \"paste\";\n\t    var textLines = doc.splitLines(inserted), multiPaste = null;\n\t    // When pasing N lines into N selections, insert one line per selection\n\t    if (paste && sel.ranges.length > 1) {\n\t      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n\t        if (sel.ranges.length % lastCopied.length == 0) {\n\t          multiPaste = [];\n\t          for (var i = 0; i < lastCopied.length; i++)\n\t            multiPaste.push(doc.splitLines(lastCopied[i]));\n\t        }\n\t      } else if (textLines.length == sel.ranges.length) {\n\t        multiPaste = map(textLines, function(l) { return [l]; });\n\t      }\n\t    }\n\t\n\t    // Normal behavior is to insert the new text into every selection\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      var from = range.from(), to = range.to();\n\t      if (range.empty()) {\n\t        if (deleted && deleted > 0) // Handle deletion\n\t          from = Pos(from.line, from.ch - deleted);\n\t        else if (cm.state.overwrite && !paste) // Handle overwrite\n\t          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n\t      }\n\t      var updateInput = cm.curOp.updateInput;\n\t      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n\t                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n\t      makeChange(cm.doc, changeEvent);\n\t      signalLater(cm, \"inputRead\", cm, changeEvent);\n\t    }\n\t    if (inserted && !paste)\n\t      triggerElectric(cm, inserted);\n\t\n\t    ensureCursorVisible(cm);\n\t    cm.curOp.updateInput = updateInput;\n\t    cm.curOp.typing = true;\n\t    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n\t  }\n\t\n\t  function handlePaste(e, cm) {\n\t    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n\t    if (pasted) {\n\t      e.preventDefault();\n\t      if (!cm.isReadOnly() && !cm.options.disableInput)\n\t        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n\t      return true;\n\t    }\n\t  }\n\t\n\t  function triggerElectric(cm, inserted) {\n\t    // When an 'electric' character is inserted, immediately trigger a reindent\n\t    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n\t    var sel = cm.doc.sel;\n\t\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n\t      var mode = cm.getModeAt(range.head);\n\t      var indented = false;\n\t      if (mode.electricChars) {\n\t        for (var j = 0; j < mode.electricChars.length; j++)\n\t          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n\t            indented = indentLine(cm, range.head.line, \"smart\");\n\t            break;\n\t          }\n\t      } else if (mode.electricInput) {\n\t        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n\t          indented = indentLine(cm, range.head.line, \"smart\");\n\t      }\n\t      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n\t    }\n\t  }\n\t\n\t  function copyableRanges(cm) {\n\t    var text = [], ranges = [];\n\t    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n\t      var line = cm.doc.sel.ranges[i].head.line;\n\t      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n\t      ranges.push(lineRange);\n\t      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n\t    }\n\t    return {text: text, ranges: ranges};\n\t  }\n\t\n\t  function disableBrowserMagic(field) {\n\t    field.setAttribute(\"autocorrect\", \"off\");\n\t    field.setAttribute(\"autocapitalize\", \"off\");\n\t    field.setAttribute(\"spellcheck\", \"false\");\n\t  }\n\t\n\t  // TEXTAREA INPUT STYLE\n\t\n\t  function TextareaInput(cm) {\n\t    this.cm = cm;\n\t    // See input.poll and input.reset\n\t    this.prevInput = \"\";\n\t\n\t    // Flag that indicates whether we expect input to appear real soon\n\t    // now (after some event like 'keypress' or 'input') and are\n\t    // polling intensively.\n\t    this.pollingFast = false;\n\t    // Self-resetting timeout for the poller\n\t    this.polling = new Delayed();\n\t    // Tracks when input.reset has punted to just putting a short\n\t    // string into the textarea instead of the full selection.\n\t    this.inaccurateSelection = false;\n\t    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\t    this.hasSelection = false;\n\t    this.composing = null;\n\t  };\n\t\n\t  function hiddenTextarea() {\n\t    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n\t    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n\t    // The textarea is kept positioned near the cursor to prevent the\n\t    // fact that it'll be scrolled into view on input from scrolling\n\t    // our fake cursor out of view. On webkit, when wrap=off, paste is\n\t    // very slow. So make the area wide instead.\n\t    if (webkit) te.style.width = \"1000px\";\n\t    else te.setAttribute(\"wrap\", \"off\");\n\t    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\t    if (ios) te.style.border = \"1px solid black\";\n\t    disableBrowserMagic(te);\n\t    return div;\n\t  }\n\t\n\t  TextareaInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = this.cm;\n\t\n\t      // Wraps and hides input textarea\n\t      var div = this.wrapper = hiddenTextarea();\n\t      // The semihidden textarea that is focused when the editor is\n\t      // focused, and receives input.\n\t      var te = this.textarea = div.firstChild;\n\t      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\t\n\t      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\t      if (ios) te.style.width = \"0px\";\n\t\n\t      on(te, \"input\", function() {\n\t        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n\t        input.poll();\n\t      });\n\t\n\t      on(te, \"paste\", function(e) {\n\t        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\t\n\t        cm.state.pasteIncoming = true;\n\t        input.fastPoll();\n\t      });\n\t\n\t      function prepareCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (input.inaccurateSelection) {\n\t            input.prevInput = \"\";\n\t            input.inaccurateSelection = false;\n\t            te.value = lastCopied.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n\t          } else {\n\t            input.prevInput = \"\";\n\t            te.value = ranges.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        }\n\t        if (e.type == \"cut\") cm.state.cutIncoming = true;\n\t      }\n\t      on(te, \"cut\", prepareCopyCut);\n\t      on(te, \"copy\", prepareCopyCut);\n\t\n\t      on(display.scroller, \"paste\", function(e) {\n\t        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n\t        cm.state.pasteIncoming = true;\n\t        input.focus();\n\t      });\n\t\n\t      // Prevent normal selection in the editor (we handle our own)\n\t      on(display.lineSpace, \"selectstart\", function(e) {\n\t        if (!eventInWidget(display, e)) e_preventDefault(e);\n\t      });\n\t\n\t      on(te, \"compositionstart\", function() {\n\t        var start = cm.getCursor(\"from\");\n\t        if (input.composing) input.composing.range.clear()\n\t        input.composing = {\n\t          start: start,\n\t          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n\t        };\n\t      });\n\t      on(te, \"compositionend\", function() {\n\t        if (input.composing) {\n\t          input.poll();\n\t          input.composing.range.clear();\n\t          input.composing = null;\n\t        }\n\t      });\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      // Redraw the selection and/or cursor\n\t      var cm = this.cm, display = cm.display, doc = cm.doc;\n\t      var result = prepareSelection(cm);\n\t\n\t      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\t      if (cm.options.moveInputWithCursor) {\n\t        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n\t        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n\t        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n\t                                            headPos.top + lineOff.top - wrapOff.top));\n\t        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n\t                                             headPos.left + lineOff.left - wrapOff.left));\n\t      }\n\t\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(drawn) {\n\t      var cm = this.cm, display = cm.display;\n\t      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n\t      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\t      if (drawn.teTop != null) {\n\t        this.wrapper.style.top = drawn.teTop + \"px\";\n\t        this.wrapper.style.left = drawn.teLeft + \"px\";\n\t      }\n\t    },\n\t\n\t    // Reset the input to correspond to the selection (or to be empty,\n\t    // when not typing and nothing is selected)\n\t    reset: function(typing) {\n\t      if (this.contextMenuPending) return;\n\t      var minimal, selected, cm = this.cm, doc = cm.doc;\n\t      if (cm.somethingSelected()) {\n\t        this.prevInput = \"\";\n\t        var range = doc.sel.primary();\n\t        minimal = hasCopyEvent &&\n\t          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n\t        var content = minimal ? \"-\" : selected || cm.getSelection();\n\t        this.textarea.value = content;\n\t        if (cm.state.focused) selectInput(this.textarea);\n\t        if (ie && ie_version >= 9) this.hasSelection = content;\n\t      } else if (!typing) {\n\t        this.prevInput = this.textarea.value = \"\";\n\t        if (ie && ie_version >= 9) this.hasSelection = null;\n\t      }\n\t      this.inaccurateSelection = minimal;\n\t    },\n\t\n\t    getField: function() { return this.textarea; },\n\t\n\t    supportsTouch: function() { return false; },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n\t        try { this.textarea.focus(); }\n\t        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\t      }\n\t    },\n\t\n\t    blur: function() { this.textarea.blur(); },\n\t\n\t    resetPosition: function() {\n\t      this.wrapper.style.top = this.wrapper.style.left = 0;\n\t    },\n\t\n\t    receivedFocus: function() { this.slowPoll(); },\n\t\n\t    // Poll for input changes, using the normal rate of polling. This\n\t    // runs as long as the editor is focused.\n\t    slowPoll: function() {\n\t      var input = this;\n\t      if (input.pollingFast) return;\n\t      input.polling.set(this.cm.options.pollInterval, function() {\n\t        input.poll();\n\t        if (input.cm.state.focused) input.slowPoll();\n\t      });\n\t    },\n\t\n\t    // When an event has just come in that is likely to add or change\n\t    // something in the input textarea, we poll faster, to ensure that\n\t    // the change appears on the screen quickly.\n\t    fastPoll: function() {\n\t      var missed = false, input = this;\n\t      input.pollingFast = true;\n\t      function p() {\n\t        var changed = input.poll();\n\t        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n\t        else {input.pollingFast = false; input.slowPoll();}\n\t      }\n\t      input.polling.set(20, p);\n\t    },\n\t\n\t    // Read input from the textarea, and update the document to match.\n\t    // When something is selected, it is present in the textarea, and\n\t    // selected (unless it is huge, in which case a placeholder is\n\t    // used). When nothing is selected, the cursor sits after previously\n\t    // seen text (can be empty), which is stored in prevInput (we must\n\t    // not reset the textarea when typing, because that breaks IME).\n\t    poll: function() {\n\t      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n\t      // Since this is called a *lot*, try to bail out as cheaply as\n\t      // possible when it is clear that nothing happened. hasSelection\n\t      // will be the case when there is a lot of text in the textarea,\n\t      // in which case reading its value would be expensive.\n\t      if (this.contextMenuPending || !cm.state.focused ||\n\t          (hasSelection(input) && !prevInput && !this.composing) ||\n\t          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n\t        return false;\n\t\n\t      var text = input.value;\n\t      // If nothing changed, bail.\n\t      if (text == prevInput && !cm.somethingSelected()) return false;\n\t      // Work around nonsensical selection resetting in IE9/10, and\n\t      // inexplicable appearance of private area unicode characters on\n\t      // some key combos in Mac (#2689).\n\t      if (ie && ie_version >= 9 && this.hasSelection === text ||\n\t          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n\t        cm.display.input.reset();\n\t        return false;\n\t      }\n\t\n\t      if (cm.doc.sel == cm.display.selForContextMenu) {\n\t        var first = text.charCodeAt(0);\n\t        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n\t        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n\t      }\n\t      // Find the part of the input that is actually new\n\t      var same = 0, l = Math.min(prevInput.length, text.length);\n\t      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\t\n\t      var self = this;\n\t      runInOp(cm, function() {\n\t        applyTextInput(cm, text.slice(same), prevInput.length - same,\n\t                       null, self.composing ? \"*compose\" : null);\n\t\n\t        // Don't leave long text in the textarea, since it makes further polling slow\n\t        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n\t        else self.prevInput = text;\n\t\n\t        if (self.composing) {\n\t          self.composing.range.clear();\n\t          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n\t                                             {className: \"CodeMirror-composing\"});\n\t        }\n\t      });\n\t      return true;\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      if (this.pollingFast && this.poll()) this.pollingFast = false;\n\t    },\n\t\n\t    onKeyPress: function() {\n\t      if (ie && ie_version >= 9) this.hasSelection = null;\n\t      this.fastPoll();\n\t    },\n\t\n\t    onContextMenu: function(e) {\n\t      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n\t      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n\t      if (!pos || presto) return; // Opera is difficult.\n\t\n\t      // Reset the current text selection only if the click is done outside of the selection\n\t      // and 'resetSelectionOnContextMenu' option is true.\n\t      var reset = cm.options.resetSelectionOnContextMenu;\n\t      if (reset && cm.doc.sel.contains(pos) == -1)\n\t        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\t\n\t      var oldCSS = te.style.cssText;\n\t      input.wrapper.style.position = \"absolute\";\n\t      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n\t        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n\t        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n\t        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n\t      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n\t      display.input.focus();\n\t      if (webkit) window.scrollTo(null, oldScrollY);\n\t      display.input.reset();\n\t      // Adds \"Select all\" to context menu in FF\n\t      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n\t      input.contextMenuPending = true;\n\t      display.selForContextMenu = cm.doc.sel;\n\t      clearTimeout(display.detectingSelectAll);\n\t\n\t      // Select-all will be greyed out if there's nothing to select, so\n\t      // this adds a zero-width space so that we can later check whether\n\t      // it got selected.\n\t      function prepareSelectAllHack() {\n\t        if (te.selectionStart != null) {\n\t          var selected = cm.somethingSelected();\n\t          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n\t          te.value = \"\\u21da\"; // Used to catch context-menu undo\n\t          te.value = extval;\n\t          input.prevInput = selected ? \"\" : \"\\u200b\";\n\t          te.selectionStart = 1; te.selectionEnd = extval.length;\n\t          // Re-set this, in case some other handler touched the\n\t          // selection in the meantime.\n\t          display.selForContextMenu = cm.doc.sel;\n\t        }\n\t      }\n\t      function rehide() {\n\t        input.contextMenuPending = false;\n\t        input.wrapper.style.position = \"relative\";\n\t        te.style.cssText = oldCSS;\n\t        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\t\n\t        // Try to detect the user choosing select-all\n\t        if (te.selectionStart != null) {\n\t          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n\t          var i = 0, poll = function() {\n\t            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n\t                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n\t              operation(cm, commands.selectAll)(cm);\n\t            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n\t            else display.input.reset();\n\t          };\n\t          display.detectingSelectAll = setTimeout(poll, 200);\n\t        }\n\t      }\n\t\n\t      if (ie && ie_version >= 9) prepareSelectAllHack();\n\t      if (captureRightClick) {\n\t        e_stop(e);\n\t        var mouseup = function() {\n\t          off(window, \"mouseup\", mouseup);\n\t          setTimeout(rehide, 20);\n\t        };\n\t        on(window, \"mouseup\", mouseup);\n\t      } else {\n\t        setTimeout(rehide, 50);\n\t      }\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      if (!val) this.reset();\n\t    },\n\t\n\t    setUneditable: nothing,\n\t\n\t    needsContentAttribute: false\n\t  }, TextareaInput.prototype);\n\t\n\t  // CONTENTEDITABLE INPUT STYLE\n\t\n\t  function ContentEditableInput(cm) {\n\t    this.cm = cm;\n\t    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n\t    this.polling = new Delayed();\n\t    this.gracePeriod = false;\n\t  }\n\t\n\t  ContentEditableInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = input.cm;\n\t      var div = input.div = display.lineDiv;\n\t      disableBrowserMagic(div);\n\t\n\t      on(div, \"paste\", function(e) {\n\t        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);\n\t      })\n\t\n\t      on(div, \"compositionstart\", function(e) {\n\t        var data = e.data;\n\t        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n\t        if (!data) return;\n\t        var prim = cm.doc.sel.primary();\n\t        var line = cm.getLine(prim.head.line);\n\t        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n\t        if (found > -1 && found <= prim.head.ch)\n\t          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n\t                                                Pos(prim.head.line, found + data.length));\n\t      });\n\t      on(div, \"compositionupdate\", function(e) {\n\t        input.composing.data = e.data;\n\t      });\n\t      on(div, \"compositionend\", function(e) {\n\t        var ours = input.composing;\n\t        if (!ours) return;\n\t        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n\t          ours.data = e.data;\n\t        // Need a small delay to prevent other code (input event,\n\t        // selection polling) from doing damage when fired right after\n\t        // compositionend.\n\t        setTimeout(function() {\n\t          if (!ours.handled)\n\t            input.applyComposition(ours);\n\t          if (input.composing == ours)\n\t            input.composing = null;\n\t        }, 50);\n\t      });\n\t\n\t      on(div, \"touchstart\", function() {\n\t        input.forceCompositionEnd();\n\t      });\n\t\n\t      on(div, \"input\", function() {\n\t        if (input.composing) return;\n\t        if (cm.isReadOnly() || !input.pollContent())\n\t          runInOp(input.cm, function() {regChange(cm);});\n\t      });\n\t\n\t      function onCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.operation(function() {\n\t              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n\t              cm.replaceSelection(\"\", null, \"cut\");\n\t            });\n\t          }\n\t        }\n\t        // iOS exposes the clipboard API, but seems to discard content inserted into it\n\t        if (e.clipboardData && !ios) {\n\t          e.preventDefault();\n\t          e.clipboardData.clearData();\n\t          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n\t        } else {\n\t          // Old-fashioned briefly-focus-a-textarea hack\n\t          var kludge = hiddenTextarea(), te = kludge.firstChild;\n\t          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n\t          te.value = lastCopied.join(\"\\n\");\n\t          var hadFocus = document.activeElement;\n\t          selectInput(te);\n\t          setTimeout(function() {\n\t            cm.display.lineSpace.removeChild(kludge);\n\t            hadFocus.focus();\n\t          }, 50);\n\t        }\n\t      }\n\t      on(div, \"copy\", onCopyCut);\n\t      on(div, \"cut\", onCopyCut);\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      var result = prepareSelection(this.cm, false);\n\t      result.focus = this.cm.state.focused;\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(info) {\n\t      if (!info || !this.cm.display.view.length) return;\n\t      if (info.focus) this.showPrimarySelection();\n\t      this.showMultipleSelections(info);\n\t    },\n\t\n\t    showPrimarySelection: function() {\n\t      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n\t      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n\t      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n\t      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n\t          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n\t          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n\t        return;\n\t\n\t      var start = posToDOM(this.cm, prim.from());\n\t      var end = posToDOM(this.cm, prim.to());\n\t      if (!start && !end) return;\n\t\n\t      var view = this.cm.display.view;\n\t      var old = sel.rangeCount && sel.getRangeAt(0);\n\t      if (!start) {\n\t        start = {node: view[0].measure.map[2], offset: 0};\n\t      } else if (!end) { // FIXME dangerously hacky\n\t        var measure = view[view.length - 1].measure;\n\t        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n\t        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n\t      }\n\t\n\t      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n\t      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\t      if (rng) {\n\t        if (!gecko && this.cm.state.focused) {\n\t          sel.collapse(start.node, start.offset);\n\t          if (!rng.collapsed) sel.addRange(rng);\n\t        } else {\n\t          sel.removeAllRanges();\n\t          sel.addRange(rng);\n\t        }\n\t        if (old && sel.anchorNode == null) sel.addRange(old);\n\t        else if (gecko) this.startGracePeriod();\n\t      }\n\t      this.rememberSelection();\n\t    },\n\t\n\t    startGracePeriod: function() {\n\t      var input = this;\n\t      clearTimeout(this.gracePeriod);\n\t      this.gracePeriod = setTimeout(function() {\n\t        input.gracePeriod = false;\n\t        if (input.selectionChanged())\n\t          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n\t      }, 20);\n\t    },\n\t\n\t    showMultipleSelections: function(info) {\n\t      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n\t      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n\t    },\n\t\n\t    rememberSelection: function() {\n\t      var sel = window.getSelection();\n\t      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n\t      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n\t    },\n\t\n\t    selectionInEditor: function() {\n\t      var sel = window.getSelection();\n\t      if (!sel.rangeCount) return false;\n\t      var node = sel.getRangeAt(0).commonAncestorContainer;\n\t      return contains(this.div, node);\n\t    },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n\t    },\n\t    blur: function() { this.div.blur(); },\n\t    getField: function() { return this.div; },\n\t\n\t    supportsTouch: function() { return true; },\n\t\n\t    receivedFocus: function() {\n\t      var input = this;\n\t      if (this.selectionInEditor())\n\t        this.pollSelection();\n\t      else\n\t        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\t\n\t      function poll() {\n\t        if (input.cm.state.focused) {\n\t          input.pollSelection();\n\t          input.polling.set(input.cm.options.pollInterval, poll);\n\t        }\n\t      }\n\t      this.polling.set(this.cm.options.pollInterval, poll);\n\t    },\n\t\n\t    selectionChanged: function() {\n\t      var sel = window.getSelection();\n\t      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n\t        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n\t    },\n\t\n\t    pollSelection: function() {\n\t      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n\t        var sel = window.getSelection(), cm = this.cm;\n\t        this.rememberSelection();\n\t        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n\t        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\t        if (anchor && head) runInOp(cm, function() {\n\t          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\t          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n\t        });\n\t      }\n\t    },\n\t\n\t    pollContent: function() {\n\t      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n\t      var from = sel.from(), to = sel.to();\n\t      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\t\n\t      var fromIndex;\n\t      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n\t        var fromLine = lineNo(display.view[0].line);\n\t        var fromNode = display.view[0].node;\n\t      } else {\n\t        var fromLine = lineNo(display.view[fromIndex].line);\n\t        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n\t      }\n\t      var toIndex = findViewIndex(cm, to.line);\n\t      if (toIndex == display.view.length - 1) {\n\t        var toLine = display.viewTo - 1;\n\t        var toNode = display.lineDiv.lastChild;\n\t      } else {\n\t        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n\t        var toNode = display.view[toIndex + 1].node.previousSibling;\n\t      }\n\t\n\t      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n\t      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\t      while (newText.length > 1 && oldText.length > 1) {\n\t        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n\t        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n\t        else break;\n\t      }\n\t\n\t      var cutFront = 0, cutEnd = 0;\n\t      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n\t      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n\t        ++cutFront;\n\t      var newBot = lst(newText), oldBot = lst(oldText);\n\t      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n\t                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\t      while (cutEnd < maxCutEnd &&\n\t             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n\t        ++cutEnd;\n\t\n\t      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n\t      newText[0] = newText[0].slice(cutFront);\n\t\n\t      var chFrom = Pos(fromLine, cutFront);\n\t      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\t      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n\t        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\t        return true;\n\t      }\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    reset: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    forceCompositionEnd: function() {\n\t      if (!this.composing || this.composing.handled) return;\n\t      this.applyComposition(this.composing);\n\t      this.composing.handled = true;\n\t      this.div.blur();\n\t      this.div.focus();\n\t    },\n\t    applyComposition: function(composing) {\n\t      if (this.cm.isReadOnly())\n\t        operation(this.cm, regChange)(this.cm)\n\t      else if (composing.data && composing.data != composing.startData)\n\t        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n\t    },\n\t\n\t    setUneditable: function(node) {\n\t      node.contentEditable = \"false\"\n\t    },\n\t\n\t    onKeyPress: function(e) {\n\t      e.preventDefault();\n\t      if (!this.cm.isReadOnly())\n\t        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      this.div.contentEditable = String(val != \"nocursor\")\n\t    },\n\t\n\t    onContextMenu: nothing,\n\t    resetPosition: nothing,\n\t\n\t    needsContentAttribute: true\n\t  }, ContentEditableInput.prototype);\n\t\n\t  function posToDOM(cm, pos) {\n\t    var view = findViewForLine(cm, pos.line);\n\t    if (!view || view.hidden) return null;\n\t    var line = getLine(cm.doc, pos.line);\n\t    var info = mapFromLineView(view, line, pos.line);\n\t\n\t    var order = getOrder(line), side = \"left\";\n\t    if (order) {\n\t      var partPos = getBidiPartAt(order, pos.ch);\n\t      side = partPos % 2 ? \"right\" : \"left\";\n\t    }\n\t    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n\t    result.offset = result.collapse == \"right\" ? result.end : result.start;\n\t    return result;\n\t  }\n\t\n\t  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\t\n\t  function domToPos(cm, node, offset) {\n\t    var lineNode;\n\t    if (node == cm.display.lineDiv) {\n\t      lineNode = cm.display.lineDiv.childNodes[offset];\n\t      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n\t      node = null; offset = 0;\n\t    } else {\n\t      for (lineNode = node;; lineNode = lineNode.parentNode) {\n\t        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n\t        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n\t      }\n\t    }\n\t    for (var i = 0; i < cm.display.view.length; i++) {\n\t      var lineView = cm.display.view[i];\n\t      if (lineView.node == lineNode)\n\t        return locateNodeInLineView(lineView, node, offset);\n\t    }\n\t  }\n\t\n\t  function locateNodeInLineView(lineView, node, offset) {\n\t    var wrapper = lineView.text.firstChild, bad = false;\n\t    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n\t    if (node == wrapper) {\n\t      bad = true;\n\t      node = wrapper.childNodes[offset];\n\t      offset = 0;\n\t      if (!node) {\n\t        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n\t        return badPos(Pos(lineNo(line), line.text.length), bad);\n\t      }\n\t    }\n\t\n\t    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n\t    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n\t      textNode = node.firstChild;\n\t      if (offset) offset = textNode.nodeValue.length;\n\t    }\n\t    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n\t    var measure = lineView.measure, maps = measure.maps;\n\t\n\t    function find(textNode, topNode, offset) {\n\t      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n\t        var map = i < 0 ? measure.map : maps[i];\n\t        for (var j = 0; j < map.length; j += 3) {\n\t          var curNode = map[j + 2];\n\t          if (curNode == textNode || curNode == topNode) {\n\t            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n\t            var ch = map[j] + offset;\n\t            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n\t            return Pos(line, ch);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    var found = find(textNode, topNode, offset);\n\t    if (found) return badPos(found, bad);\n\t\n\t    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\t    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n\t      found = find(after, after.firstChild, 0);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch - dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n\t      found = find(before, before.firstChild, -1);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch + dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t  }\n\t\n\t  function domTextBetween(cm, from, to, fromLine, toLine) {\n\t    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n\t    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n\t    function walk(node) {\n\t      if (node.nodeType == 1) {\n\t        var cmText = node.getAttribute(\"cm-text\");\n\t        if (cmText != null) {\n\t          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n\t          text += cmText;\n\t          return;\n\t        }\n\t        var markerID = node.getAttribute(\"cm-marker\"), range;\n\t        if (markerID) {\n\t          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\t          if (found.length && (range = found[0].find()))\n\t            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n\t          return;\n\t        }\n\t        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n\t        for (var i = 0; i < node.childNodes.length; i++)\n\t          walk(node.childNodes[i]);\n\t        if (/^(pre|div|p)$/i.test(node.nodeName))\n\t          closing = true;\n\t      } else if (node.nodeType == 3) {\n\t        var val = node.nodeValue;\n\t        if (!val) return;\n\t        if (closing) {\n\t          text += lineSep;\n\t          closing = false;\n\t        }\n\t        text += val;\n\t      }\n\t    }\n\t    for (;;) {\n\t      walk(from);\n\t      if (from == to) break;\n\t      from = from.nextSibling;\n\t    }\n\t    return text;\n\t  }\n\t\n\t  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\t\n\t  // SELECTION / CURSOR\n\t\n\t  // Selection objects are immutable. A new one is created every time\n\t  // the selection changes. A selection is one or more non-overlapping\n\t  // (and non-touching) ranges, sorted, and an integer that indicates\n\t  // which one is the primary selection (the one that's scrolled into\n\t  // view, that getCursor returns, etc).\n\t  function Selection(ranges, primIndex) {\n\t    this.ranges = ranges;\n\t    this.primIndex = primIndex;\n\t  }\n\t\n\t  Selection.prototype = {\n\t    primary: function() { return this.ranges[this.primIndex]; },\n\t    equals: function(other) {\n\t      if (other == this) return true;\n\t      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var here = this.ranges[i], there = other.ranges[i];\n\t        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n\t      }\n\t      return true;\n\t    },\n\t    deepCopy: function() {\n\t      for (var out = [], i = 0; i < this.ranges.length; i++)\n\t        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n\t      return new Selection(out, this.primIndex);\n\t    },\n\t    somethingSelected: function() {\n\t      for (var i = 0; i < this.ranges.length; i++)\n\t        if (!this.ranges[i].empty()) return true;\n\t      return false;\n\t    },\n\t    contains: function(pos, end) {\n\t      if (!end) end = pos;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var range = this.ranges[i];\n\t        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n\t          return i;\n\t      }\n\t      return -1;\n\t    }\n\t  };\n\t\n\t  function Range(anchor, head) {\n\t    this.anchor = anchor; this.head = head;\n\t  }\n\t\n\t  Range.prototype = {\n\t    from: function() { return minPos(this.anchor, this.head); },\n\t    to: function() { return maxPos(this.anchor, this.head); },\n\t    empty: function() {\n\t      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n\t    }\n\t  };\n\t\n\t  // Take an unsorted, potentially overlapping set of ranges, and\n\t  // build a selection out of it. 'Consumes' ranges array (modifying\n\t  // it).\n\t  function normalizeSelection(ranges, primIndex) {\n\t    var prim = ranges[primIndex];\n\t    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n\t    primIndex = indexOf(ranges, prim);\n\t    for (var i = 1; i < ranges.length; i++) {\n\t      var cur = ranges[i], prev = ranges[i - 1];\n\t      if (cmp(prev.to(), cur.from()) >= 0) {\n\t        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n\t        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\t        if (i <= primIndex) --primIndex;\n\t        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n\t      }\n\t    }\n\t    return new Selection(ranges, primIndex);\n\t  }\n\t\n\t  function simpleSelection(anchor, head) {\n\t    return new Selection([new Range(anchor, head || anchor)], 0);\n\t  }\n\t\n\t  // Most of the external API clips given positions to make sure they\n\t  // actually exist within the document.\n\t  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n\t  function clipPos(doc, pos) {\n\t    if (pos.line < doc.first) return Pos(doc.first, 0);\n\t    var last = doc.first + doc.size - 1;\n\t    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n\t    return clipToLen(pos, getLine(doc, pos.line).text.length);\n\t  }\n\t  function clipToLen(pos, linelen) {\n\t    var ch = pos.ch;\n\t    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n\t    else if (ch < 0) return Pos(pos.line, 0);\n\t    else return pos;\n\t  }\n\t  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\t  function clipPosArray(doc, array) {\n\t    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n\t    return out;\n\t  }\n\t\n\t  // SELECTION UPDATES\n\t\n\t  // The 'scroll' parameter given to many of these indicated whether\n\t  // the new cursor position should be scrolled into view after\n\t  // modifying the selection.\n\t\n\t  // If shift is held or the extend flag is set, extends a range to\n\t  // include a given position (and optionally a second position).\n\t  // Otherwise, simply returns the range between the given positions.\n\t  // Used for cursor motion and such.\n\t  function extendRange(doc, range, head, other) {\n\t    if (doc.cm && doc.cm.display.shift || doc.extend) {\n\t      var anchor = range.anchor;\n\t      if (other) {\n\t        var posBefore = cmp(head, anchor) < 0;\n\t        if (posBefore != (cmp(other, anchor) < 0)) {\n\t          anchor = head;\n\t          head = other;\n\t        } else if (posBefore != (cmp(head, other) < 0)) {\n\t          head = other;\n\t        }\n\t      }\n\t      return new Range(anchor, head);\n\t    } else {\n\t      return new Range(other || head, head);\n\t    }\n\t  }\n\t\n\t  // Extend the primary selection range, discard the rest.\n\t  function extendSelection(doc, head, other, options) {\n\t    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n\t  }\n\t\n\t  // Extend all selections (pos is an array of selections with length\n\t  // equal the number of selections)\n\t  function extendSelections(doc, heads, options) {\n\t    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n\t      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n\t    var newSel = normalizeSelection(out, doc.sel.primIndex);\n\t    setSelection(doc, newSel, options);\n\t  }\n\t\n\t  // Updates a single range in the selection.\n\t  function replaceOneSelection(doc, i, range, options) {\n\t    var ranges = doc.sel.ranges.slice(0);\n\t    ranges[i] = range;\n\t    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n\t  }\n\t\n\t  // Reset the selection to a single range.\n\t  function setSimpleSelection(doc, anchor, head, options) {\n\t    setSelection(doc, simpleSelection(anchor, head), options);\n\t  }\n\t\n\t  // Give beforeSelectionChange handlers a change to influence a\n\t  // selection update.\n\t  function filterSelectionChange(doc, sel, options) {\n\t    var obj = {\n\t      ranges: sel.ranges,\n\t      update: function(ranges) {\n\t        this.ranges = [];\n\t        for (var i = 0; i < ranges.length; i++)\n\t          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n\t                                     clipPos(doc, ranges[i].head));\n\t      },\n\t      origin: options && options.origin\n\t    };\n\t    signal(doc, \"beforeSelectionChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n\t    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n\t    else return sel;\n\t  }\n\t\n\t  function setSelectionReplaceHistory(doc, sel, options) {\n\t    var done = doc.history.done, last = lst(done);\n\t    if (last && last.ranges) {\n\t      done[done.length - 1] = sel;\n\t      setSelectionNoUndo(doc, sel, options);\n\t    } else {\n\t      setSelection(doc, sel, options);\n\t    }\n\t  }\n\t\n\t  // Set a new selection.\n\t  function setSelection(doc, sel, options) {\n\t    setSelectionNoUndo(doc, sel, options);\n\t    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n\t  }\n\t\n\t  function setSelectionNoUndo(doc, sel, options) {\n\t    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n\t      sel = filterSelectionChange(doc, sel, options);\n\t\n\t    var bias = options && options.bias ||\n\t      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\t\n\t    if (!(options && options.scroll === false) && doc.cm)\n\t      ensureCursorVisible(doc.cm);\n\t  }\n\t\n\t  function setSelectionInner(doc, sel) {\n\t    if (sel.equals(doc.sel)) return;\n\t\n\t    doc.sel = sel;\n\t\n\t    if (doc.cm) {\n\t      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n\t      signalCursorActivity(doc.cm);\n\t    }\n\t    signalLater(doc, \"cursorActivity\", doc);\n\t  }\n\t\n\t  // Verify that the selection does not partially select any atomic\n\t  // marked ranges.\n\t  function reCheckSelection(doc) {\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n\t  }\n\t\n\t  // Return a selection that does not partially select any atomic\n\t  // ranges.\n\t  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n\t    var out;\n\t    for (var i = 0; i < sel.ranges.length; i++) {\n\t      var range = sel.ranges[i];\n\t      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n\t      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n\t      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n\t      if (out || newAnchor != range.anchor || newHead != range.head) {\n\t        if (!out) out = sel.ranges.slice(0, i);\n\t        out[i] = new Range(newAnchor, newHead);\n\t      }\n\t    }\n\t    return out ? normalizeSelection(out, sel.primIndex) : sel;\n\t  }\n\t\n\t  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n\t    var line = getLine(doc, pos.line);\n\t    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t      var sp = line.markedSpans[i], m = sp.marker;\n\t      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n\t          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n\t        if (mayClear) {\n\t          signal(m, \"beforeCursorEnter\");\n\t          if (m.explicitlyCleared) {\n\t            if (!line.markedSpans) break;\n\t            else {--i; continue;}\n\t          }\n\t        }\n\t        if (!m.atomic) continue;\n\t\n\t        if (oldPos) {\n\t          var near = m.find(dir < 0 ? 1 : -1), diff;\n\t          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) near = movePos(doc, near, -dir, line);\n\t          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n\t            return skipAtomicInner(doc, near, pos, dir, mayClear);\n\t        }\n\t\n\t        var far = m.find(dir < 0 ? -1 : 1);\n\t        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) far = movePos(doc, far, dir, line);\n\t        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n\t      }\n\t    }\n\t    return pos;\n\t  }\n\t\n\t  // Ensure a given position is not inside an atomic range.\n\t  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n\t    var dir = bias || 1;\n\t    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n\t        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n\t    if (!found) {\n\t      doc.cantEdit = true;\n\t      return Pos(doc.first, 0);\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function movePos(doc, pos, dir, line) {\n\t    if (dir < 0 && pos.ch == 0) {\n\t      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n\t      else return null;\n\t    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n\t      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n\t      else return null;\n\t    } else {\n\t      return new Pos(pos.line, pos.ch + dir);\n\t    }\n\t  }\n\t\n\t  // SELECTION DRAWING\n\t\n\t  function updateSelection(cm) {\n\t    cm.display.input.showSelection(cm.display.input.prepareSelection());\n\t  }\n\t\n\t  function prepareSelection(cm, primary) {\n\t    var doc = cm.doc, result = {};\n\t    var curFragment = result.cursors = document.createDocumentFragment();\n\t    var selFragment = result.selection = document.createDocumentFragment();\n\t\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      if (primary === false && i == doc.sel.primIndex) continue;\n\t      var range = doc.sel.ranges[i];\n\t      var collapsed = range.empty();\n\t      if (collapsed || cm.options.showCursorWhenSelecting)\n\t        drawSelectionCursor(cm, range.head, curFragment);\n\t      if (!collapsed)\n\t        drawSelectionRange(cm, range, selFragment);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Draws a cursor for the given range\n\t  function drawSelectionCursor(cm, head, output) {\n\t    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\t\n\t    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n\t    cursor.style.left = pos.left + \"px\";\n\t    cursor.style.top = pos.top + \"px\";\n\t    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\t\n\t    if (pos.other) {\n\t      // Secondary cursor, shown when on a 'jump' in bi-directional text\n\t      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n\t      otherCursor.style.display = \"\";\n\t      otherCursor.style.left = pos.other.left + \"px\";\n\t      otherCursor.style.top = pos.other.top + \"px\";\n\t      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n\t    }\n\t  }\n\t\n\t  // Draws the given range as a highlighted selection\n\t  function drawSelectionRange(cm, range, output) {\n\t    var display = cm.display, doc = cm.doc;\n\t    var fragment = document.createDocumentFragment();\n\t    var padding = paddingH(cm.display), leftSide = padding.left;\n\t    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\t\n\t    function add(left, top, width, bottom) {\n\t      if (top < 0) top = 0;\n\t      top = Math.round(top);\n\t      bottom = Math.round(bottom);\n\t      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n\t                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n\t                               \"px; height: \" + (bottom - top) + \"px\"));\n\t    }\n\t\n\t    function drawForLine(line, fromArg, toArg) {\n\t      var lineObj = getLine(doc, line);\n\t      var lineLen = lineObj.text.length;\n\t      var start, end;\n\t      function coords(ch, bias) {\n\t        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n\t      }\n\t\n\t      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n\t        var leftPos = coords(from, \"left\"), rightPos, left, right;\n\t        if (from == to) {\n\t          rightPos = leftPos;\n\t          left = right = leftPos.left;\n\t        } else {\n\t          rightPos = coords(to - 1, \"right\");\n\t          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n\t          left = leftPos.left;\n\t          right = rightPos.right;\n\t        }\n\t        if (fromArg == null && from == 0) left = leftSide;\n\t        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n\t          add(left, leftPos.top, null, leftPos.bottom);\n\t          left = leftSide;\n\t          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n\t        }\n\t        if (toArg == null && to == lineLen) right = rightSide;\n\t        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n\t          start = leftPos;\n\t        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n\t          end = rightPos;\n\t        if (left < leftSide + 1) left = leftSide;\n\t        add(left, rightPos.top, right - left, rightPos.bottom);\n\t      });\n\t      return {start: start, end: end};\n\t    }\n\t\n\t    var sFrom = range.from(), sTo = range.to();\n\t    if (sFrom.line == sTo.line) {\n\t      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n\t    } else {\n\t      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n\t      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n\t      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n\t      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\t      if (singleVLine) {\n\t        if (leftEnd.top < rightStart.top - 2) {\n\t          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n\t          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n\t        } else {\n\t          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n\t        }\n\t      }\n\t      if (leftEnd.bottom < rightStart.top)\n\t        add(leftSide, leftEnd.bottom, null, rightStart.top);\n\t    }\n\t\n\t    output.appendChild(fragment);\n\t  }\n\t\n\t  // Cursor-blinking\n\t  function restartBlink(cm) {\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display;\n\t    clearInterval(display.blinker);\n\t    var on = true;\n\t    display.cursorDiv.style.visibility = \"\";\n\t    if (cm.options.cursorBlinkRate > 0)\n\t      display.blinker = setInterval(function() {\n\t        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n\t      }, cm.options.cursorBlinkRate);\n\t    else if (cm.options.cursorBlinkRate < 0)\n\t      display.cursorDiv.style.visibility = \"hidden\";\n\t  }\n\t\n\t  // HIGHLIGHT WORKER\n\t\n\t  function startWorker(cm, time) {\n\t    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n\t      cm.state.highlight.set(time, bind(highlightWorker, cm));\n\t  }\n\t\n\t  function highlightWorker(cm) {\n\t    var doc = cm.doc;\n\t    if (doc.frontier < doc.first) doc.frontier = doc.first;\n\t    if (doc.frontier >= cm.display.viewTo) return;\n\t    var end = +new Date + cm.options.workTime;\n\t    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n\t    var changedLines = [];\n\t\n\t    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n\t      if (doc.frontier >= cm.display.viewFrom) { // Visible\n\t        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n\t        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n\t        line.styles = highlighted.styles;\n\t        var oldCls = line.styleClasses, newCls = highlighted.classes;\n\t        if (newCls) line.styleClasses = newCls;\n\t        else if (oldCls) line.styleClasses = null;\n\t        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n\t          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\t        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n\t        if (ischange) changedLines.push(doc.frontier);\n\t        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n\t      } else {\n\t        if (line.text.length <= cm.options.maxHighlightLength)\n\t          processLine(cm, line.text, state);\n\t        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n\t      }\n\t      ++doc.frontier;\n\t      if (+new Date > end) {\n\t        startWorker(cm, cm.options.workDelay);\n\t        return true;\n\t      }\n\t    });\n\t    if (changedLines.length) runInOp(cm, function() {\n\t      for (var i = 0; i < changedLines.length; i++)\n\t        regLineChange(cm, changedLines[i], \"text\");\n\t    });\n\t  }\n\t\n\t  // Finds the line to start with when starting a parse. Tries to\n\t  // find a line with a stateAfter, so that it can start with a\n\t  // valid state. If that fails, it returns the line with the\n\t  // smallest indentation, which tends to need the least context to\n\t  // parse correctly.\n\t  function findStartLine(cm, n, precise) {\n\t    var minindent, minline, doc = cm.doc;\n\t    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\t    for (var search = n; search > lim; --search) {\n\t      if (search <= doc.first) return doc.first;\n\t      var line = getLine(doc, search - 1);\n\t      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n\t      var indented = countColumn(line.text, null, cm.options.tabSize);\n\t      if (minline == null || minindent > indented) {\n\t        minline = search - 1;\n\t        minindent = indented;\n\t      }\n\t    }\n\t    return minline;\n\t  }\n\t\n\t  function getStateBefore(cm, n, precise) {\n\t    var doc = cm.doc, display = cm.display;\n\t    if (!doc.mode.startState) return true;\n\t    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n\t    if (!state) state = startState(doc.mode);\n\t    else state = copyState(doc.mode, state);\n\t    doc.iter(pos, n, function(line) {\n\t      processLine(cm, line.text, state);\n\t      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n\t      line.stateAfter = save ? copyState(doc.mode, state) : null;\n\t      ++pos;\n\t    });\n\t    if (precise) doc.frontier = pos;\n\t    return state;\n\t  }\n\t\n\t  // POSITION MEASUREMENT\n\t\n\t  function paddingTop(display) {return display.lineSpace.offsetTop;}\n\t  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n\t  function paddingH(display) {\n\t    if (display.cachedPaddingH) return display.cachedPaddingH;\n\t    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n\t    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n\t    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n\t    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n\t    return data;\n\t  }\n\t\n\t  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n\t  function displayWidth(cm) {\n\t    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n\t  }\n\t  function displayHeight(cm) {\n\t    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n\t  }\n\t\n\t  // Ensure the lineView.wrapping.heights array is populated. This is\n\t  // an array of bottom offsets for the lines that make up a drawn\n\t  // line. When lineWrapping is on, there might be more than one\n\t  // height.\n\t  function ensureLineHeights(cm, lineView, rect) {\n\t    var wrapping = cm.options.lineWrapping;\n\t    var curWidth = wrapping && displayWidth(cm);\n\t    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n\t      var heights = lineView.measure.heights = [];\n\t      if (wrapping) {\n\t        lineView.measure.width = curWidth;\n\t        var rects = lineView.text.firstChild.getClientRects();\n\t        for (var i = 0; i < rects.length - 1; i++) {\n\t          var cur = rects[i], next = rects[i + 1];\n\t          if (Math.abs(cur.bottom - next.bottom) > 2)\n\t            heights.push((cur.bottom + next.top) / 2 - rect.top);\n\t        }\n\t      }\n\t      heights.push(rect.bottom - rect.top);\n\t    }\n\t  }\n\t\n\t  // Find a line map (mapping character offsets to text nodes) and a\n\t  // measurement cache for the given line number. (A line view might\n\t  // contain multiple lines when collapsed ranges are present.)\n\t  function mapFromLineView(lineView, line, lineN) {\n\t    if (lineView.line == line)\n\t      return {map: lineView.measure.map, cache: lineView.measure.cache};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineView.rest[i] == line)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineNo(lineView.rest[i]) > lineN)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n\t  }\n\t\n\t  // Render a line into the hidden node display.externalMeasured. Used\n\t  // when measurement is needed for a line that's not in the viewport.\n\t  function updateExternalMeasurement(cm, line) {\n\t    line = visualLine(line);\n\t    var lineN = lineNo(line);\n\t    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n\t    view.lineN = lineN;\n\t    var built = view.built = buildLineContent(cm, view);\n\t    view.text = built.pre;\n\t    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n\t    return view;\n\t  }\n\t\n\t  // Get a {top, bottom, left, right} box (in line-local coordinates)\n\t  // for a given character.\n\t  function measureChar(cm, line, ch, bias) {\n\t    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n\t  }\n\t\n\t  // Find a line view that corresponds to the given line number.\n\t  function findViewForLine(cm, lineN) {\n\t    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n\t      return cm.display.view[findViewIndex(cm, lineN)];\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n\t      return ext;\n\t  }\n\t\n\t  // Measurement can be split in two steps, the set-up work that\n\t  // applies to the whole line, and the measurement of the actual\n\t  // character. Functions like coordsChar, that need to do a lot of\n\t  // measurements in a row, can thus ensure that the set-up work is\n\t  // only done once.\n\t  function prepareMeasureForLine(cm, line) {\n\t    var lineN = lineNo(line);\n\t    var view = findViewForLine(cm, lineN);\n\t    if (view && !view.text) {\n\t      view = null;\n\t    } else if (view && view.changes) {\n\t      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n\t      cm.curOp.forceUpdate = true;\n\t    }\n\t    if (!view)\n\t      view = updateExternalMeasurement(cm, line);\n\t\n\t    var info = mapFromLineView(view, line, lineN);\n\t    return {\n\t      line: line, view: view, rect: null,\n\t      map: info.map, cache: info.cache, before: info.before,\n\t      hasHeights: false\n\t    };\n\t  }\n\t\n\t  // Given a prepared measurement object, measures the position of an\n\t  // actual character (or fetches it from the cache).\n\t  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n\t    if (prepared.before) ch = -1;\n\t    var key = ch + (bias || \"\"), found;\n\t    if (prepared.cache.hasOwnProperty(key)) {\n\t      found = prepared.cache[key];\n\t    } else {\n\t      if (!prepared.rect)\n\t        prepared.rect = prepared.view.text.getBoundingClientRect();\n\t      if (!prepared.hasHeights) {\n\t        ensureLineHeights(cm, prepared.view, prepared.rect);\n\t        prepared.hasHeights = true;\n\t      }\n\t      found = measureCharInner(cm, prepared, ch, bias);\n\t      if (!found.bogus) prepared.cache[key] = found;\n\t    }\n\t    return {left: found.left, right: found.right,\n\t            top: varHeight ? found.rtop : found.top,\n\t            bottom: varHeight ? found.rbottom : found.bottom};\n\t  }\n\t\n\t  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\t\n\t  function nodeAndOffsetInLineMap(map, ch, bias) {\n\t    var node, start, end, collapse;\n\t    // First, search the line map for the text node corresponding to,\n\t    // or closest to, the target character.\n\t    for (var i = 0; i < map.length; i += 3) {\n\t      var mStart = map[i], mEnd = map[i + 1];\n\t      if (ch < mStart) {\n\t        start = 0; end = 1;\n\t        collapse = \"left\";\n\t      } else if (ch < mEnd) {\n\t        start = ch - mStart;\n\t        end = start + 1;\n\t      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n\t        end = mEnd - mStart;\n\t        start = end - 1;\n\t        if (ch >= mEnd) collapse = \"right\";\n\t      }\n\t      if (start != null) {\n\t        node = map[i + 2];\n\t        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n\t          collapse = bias;\n\t        if (bias == \"left\" && start == 0)\n\t          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n\t            node = map[(i -= 3) + 2];\n\t            collapse = \"left\";\n\t          }\n\t        if (bias == \"right\" && start == mEnd - mStart)\n\t          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n\t            node = map[(i += 3) + 2];\n\t            collapse = \"right\";\n\t          }\n\t        break;\n\t      }\n\t    }\n\t    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n\t  }\n\t\n\t  function measureCharInner(cm, prepared, ch, bias) {\n\t    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n\t    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\t\n\t    var rect;\n\t    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n\t      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n\t        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n\t        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n\t        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n\t          rect = node.parentNode.getBoundingClientRect();\n\t        } else if (ie && cm.options.lineWrapping) {\n\t          var rects = range(node, start, end).getClientRects();\n\t          if (rects.length)\n\t            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t          else\n\t            rect = nullRect;\n\t        } else {\n\t          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n\t        }\n\t        if (rect.left || rect.right || start == 0) break;\n\t        end = start;\n\t        start = start - 1;\n\t        collapse = \"right\";\n\t      }\n\t      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n\t    } else { // If it is a widget, simply get the box for the whole widget.\n\t      if (start > 0) collapse = bias = \"right\";\n\t      var rects;\n\t      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n\t        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t      else\n\t        rect = node.getBoundingClientRect();\n\t    }\n\t    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n\t      var rSpan = node.parentNode.getClientRects()[0];\n\t      if (rSpan)\n\t        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n\t      else\n\t        rect = nullRect;\n\t    }\n\t\n\t    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n\t    var mid = (rtop + rbot) / 2;\n\t    var heights = prepared.view.measure.heights;\n\t    for (var i = 0; i < heights.length - 1; i++)\n\t      if (mid < heights[i]) break;\n\t    var top = i ? heights[i - 1] : 0, bot = heights[i];\n\t    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n\t                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n\t                  top: top, bottom: bot};\n\t    if (!rect.left && !rect.right) result.bogus = true;\n\t    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Work around problem with bounding client rects on ranges being\n\t  // returned incorrectly when zoomed on IE10 and below.\n\t  function maybeUpdateRectForZooming(measure, rect) {\n\t    if (!window.screen || screen.logicalXDPI == null ||\n\t        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n\t      return rect;\n\t    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n\t    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n\t    return {left: rect.left * scaleX, right: rect.right * scaleX,\n\t            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n\t  }\n\t\n\t  function clearLineMeasurementCacheFor(lineView) {\n\t    if (lineView.measure) {\n\t      lineView.measure.cache = {};\n\t      lineView.measure.heights = null;\n\t      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t        lineView.measure.caches[i] = {};\n\t    }\n\t  }\n\t\n\t  function clearLineMeasurementCache(cm) {\n\t    cm.display.externalMeasure = null;\n\t    removeChildren(cm.display.lineMeasure);\n\t    for (var i = 0; i < cm.display.view.length; i++)\n\t      clearLineMeasurementCacheFor(cm.display.view[i]);\n\t  }\n\t\n\t  function clearCaches(cm) {\n\t    clearLineMeasurementCache(cm);\n\t    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\t    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n\t    cm.display.lineNumChars = null;\n\t  }\n\t\n\t  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n\t  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\t\n\t  // Converts a {top, bottom, left, right} box from line-local\n\t  // coordinates into another coordinate system. Context may be one of\n\t  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n\t  // or \"page\".\n\t  function intoCoordSystem(cm, lineObj, rect, context) {\n\t    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n\t      var size = widgetHeight(lineObj.widgets[i]);\n\t      rect.top += size; rect.bottom += size;\n\t    }\n\t    if (context == \"line\") return rect;\n\t    if (!context) context = \"local\";\n\t    var yOff = heightAtLine(lineObj);\n\t    if (context == \"local\") yOff += paddingTop(cm.display);\n\t    else yOff -= cm.display.viewOffset;\n\t    if (context == \"page\" || context == \"window\") {\n\t      var lOff = cm.display.lineSpace.getBoundingClientRect();\n\t      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n\t      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n\t      rect.left += xOff; rect.right += xOff;\n\t    }\n\t    rect.top += yOff; rect.bottom += yOff;\n\t    return rect;\n\t  }\n\t\n\t  // Coverts a box from \"div\" coords to another coordinate system.\n\t  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n\t  function fromCoordSystem(cm, coords, context) {\n\t    if (context == \"div\") return coords;\n\t    var left = coords.left, top = coords.top;\n\t    // First move into \"page\" coordinate system\n\t    if (context == \"page\") {\n\t      left -= pageScrollX();\n\t      top -= pageScrollY();\n\t    } else if (context == \"local\" || !context) {\n\t      var localBox = cm.display.sizer.getBoundingClientRect();\n\t      left += localBox.left;\n\t      top += localBox.top;\n\t    }\n\t\n\t    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n\t    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n\t  }\n\t\n\t  function charCoords(cm, pos, context, lineObj, bias) {\n\t    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n\t    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n\t  }\n\t\n\t  // Returns a box for a given cursor position, which may have an\n\t  // 'other' property containing the position of the secondary cursor\n\t  // on a bidi boundary.\n\t  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n\t    lineObj = lineObj || getLine(cm.doc, pos.line);\n\t    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t    function get(ch, right) {\n\t      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\t      if (right) m.left = m.right; else m.right = m.left;\n\t      return intoCoordSystem(cm, lineObj, m, context);\n\t    }\n\t    function getBidi(ch, partPos) {\n\t      var part = order[partPos], right = part.level % 2;\n\t      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n\t        part = order[--partPos];\n\t        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n\t        right = true;\n\t      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n\t        part = order[++partPos];\n\t        ch = bidiLeft(part) - part.level % 2;\n\t        right = false;\n\t      }\n\t      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n\t      return get(ch, right);\n\t    }\n\t    var order = getOrder(lineObj), ch = pos.ch;\n\t    if (!order) return get(ch);\n\t    var partPos = getBidiPartAt(order, ch);\n\t    var val = getBidi(ch, partPos);\n\t    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n\t    return val;\n\t  }\n\t\n\t  // Used to cheaply estimate the coordinates for a position. Used for\n\t  // intermediate scroll updates.\n\t  function estimateCoords(cm, pos) {\n\t    var left = 0, pos = clipPos(cm.doc, pos);\n\t    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n\t    var lineObj = getLine(cm.doc, pos.line);\n\t    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n\t    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n\t  }\n\t\n\t  // Positions returned by coordsChar contain some extra information.\n\t  // xRel is the relative x position of the input coordinates compared\n\t  // to the found position (so xRel > 0 means the coordinates are to\n\t  // the right of the character position, for example). When outside\n\t  // is true, that means the coordinates lie outside the line's\n\t  // vertical range.\n\t  function PosWithInfo(line, ch, outside, xRel) {\n\t    var pos = Pos(line, ch);\n\t    pos.xRel = xRel;\n\t    if (outside) pos.outside = true;\n\t    return pos;\n\t  }\n\t\n\t  // Compute the character position closest to the given coordinates.\n\t  // Input must be lineSpace-local (\"div\" coordinate system).\n\t  function coordsChar(cm, x, y) {\n\t    var doc = cm.doc;\n\t    y += cm.display.viewOffset;\n\t    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\t    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n\t    if (lineN > last)\n\t      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n\t    if (x < 0) x = 0;\n\t\n\t    var lineObj = getLine(doc, lineN);\n\t    for (;;) {\n\t      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n\t      var merged = collapsedSpanAtEnd(lineObj);\n\t      var mergedPos = merged && merged.find(0, true);\n\t      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n\t        lineN = lineNo(lineObj = mergedPos.to.line);\n\t      else\n\t        return found;\n\t    }\n\t  }\n\t\n\t  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n\t    var innerOff = y - heightAtLine(lineObj);\n\t    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n\t    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t\n\t    function getX(ch) {\n\t      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n\t      wrongLine = true;\n\t      if (innerOff > sp.bottom) return sp.left - adjust;\n\t      else if (innerOff < sp.top) return sp.left + adjust;\n\t      else wrongLine = false;\n\t      return sp.left;\n\t    }\n\t\n\t    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n\t    var from = lineLeft(lineObj), to = lineRight(lineObj);\n\t    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\t\n\t    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n\t    // Do a binary search between these bounds.\n\t    for (;;) {\n\t      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n\t        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n\t        var xDiff = x - (ch == from ? fromX : toX);\n\t        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n\t        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n\t                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n\t        return pos;\n\t      }\n\t      var step = Math.ceil(dist / 2), middle = from + step;\n\t      if (bidi) {\n\t        middle = from;\n\t        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n\t      }\n\t      var middleX = getX(middle);\n\t      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n\t      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n\t    }\n\t  }\n\t\n\t  var measureText;\n\t  // Compute the default text height.\n\t  function textHeight(display) {\n\t    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\t    if (measureText == null) {\n\t      measureText = elt(\"pre\");\n\t      // Measure a bunch of lines, for browsers that compute\n\t      // fractional heights.\n\t      for (var i = 0; i < 49; ++i) {\n\t        measureText.appendChild(document.createTextNode(\"x\"));\n\t        measureText.appendChild(elt(\"br\"));\n\t      }\n\t      measureText.appendChild(document.createTextNode(\"x\"));\n\t    }\n\t    removeChildrenAndAdd(display.measure, measureText);\n\t    var height = measureText.offsetHeight / 50;\n\t    if (height > 3) display.cachedTextHeight = height;\n\t    removeChildren(display.measure);\n\t    return height || 1;\n\t  }\n\t\n\t  // Compute the default character width.\n\t  function charWidth(display) {\n\t    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n\t    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n\t    var pre = elt(\"pre\", [anchor]);\n\t    removeChildrenAndAdd(display.measure, pre);\n\t    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n\t    if (width > 2) display.cachedCharWidth = width;\n\t    return width || 10;\n\t  }\n\t\n\t  // OPERATIONS\n\t\n\t  // Operations are used to wrap a series of changes to the editor\n\t  // state in such a way that each change won't have to update the\n\t  // cursor and display (which would be awkward, slow, and\n\t  // error-prone). Instead, display updates are batched and then all\n\t  // combined and executed at once.\n\t\n\t  var operationGroup = null;\n\t\n\t  var nextOpId = 0;\n\t  // Start a new operation.\n\t  function startOperation(cm) {\n\t    cm.curOp = {\n\t      cm: cm,\n\t      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n\t      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n\t      forceUpdate: false,      // Used to force a redraw\n\t      updateInput: null,       // Whether to reset the input textarea\n\t      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n\t      changeObjs: null,        // Accumulated changes, for firing change events\n\t      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n\t      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n\t      selectionChanged: false, // Whether the selection needs to be redrawn\n\t      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n\t      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n\t      scrollToPos: null,       // Used to scroll to a specific position\n\t      focus: false,\n\t      id: ++nextOpId           // Unique ID\n\t    };\n\t    if (operationGroup) {\n\t      operationGroup.ops.push(cm.curOp);\n\t    } else {\n\t      cm.curOp.ownsGroup = operationGroup = {\n\t        ops: [cm.curOp],\n\t        delayedCallbacks: []\n\t      };\n\t    }\n\t  }\n\t\n\t  function fireCallbacksForOps(group) {\n\t    // Calls delayed callbacks and cursorActivity handlers until no\n\t    // new ones appear\n\t    var callbacks = group.delayedCallbacks, i = 0;\n\t    do {\n\t      for (; i < callbacks.length; i++)\n\t        callbacks[i].call(null);\n\t      for (var j = 0; j < group.ops.length; j++) {\n\t        var op = group.ops[j];\n\t        if (op.cursorActivityHandlers)\n\t          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n\t            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n\t      }\n\t    } while (i < callbacks.length);\n\t  }\n\t\n\t  // Finish an operation, updating the display and signalling delayed events\n\t  function endOperation(cm) {\n\t    var op = cm.curOp, group = op.ownsGroup;\n\t    if (!group) return;\n\t\n\t    try { fireCallbacksForOps(group); }\n\t    finally {\n\t      operationGroup = null;\n\t      for (var i = 0; i < group.ops.length; i++)\n\t        group.ops[i].cm.curOp = null;\n\t      endOperations(group);\n\t    }\n\t  }\n\t\n\t  // The DOM updates done when an operation finishes are batched so\n\t  // that the minimum number of relayouts are required.\n\t  function endOperations(group) {\n\t    var ops = group.ops;\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_finish(ops[i]);\n\t  }\n\t\n\t  function endOperation_R1(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    maybeClipScrollbars(cm);\n\t    if (op.updateMaxLine) findMaxLine(cm);\n\t\n\t    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n\t      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n\t                         op.scrollToPos.to.line >= display.viewTo) ||\n\t      display.maxLineChanged && cm.options.lineWrapping;\n\t    op.update = op.mustUpdate &&\n\t      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n\t  }\n\t\n\t  function endOperation_W1(op) {\n\t    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n\t  }\n\t\n\t  function endOperation_R2(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\t\n\t    op.barMeasure = measureForScrollbars(cm);\n\t\n\t    // If the max line changed since it was last measured, measure it,\n\t    // and ensure the document's width matches it.\n\t    // updateDisplay_W2 will use these properties to do the actual resizing\n\t    if (display.maxLineChanged && !cm.options.lineWrapping) {\n\t      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n\t      cm.display.sizerWidth = op.adjustWidthTo;\n\t      op.barMeasure.scrollWidth =\n\t        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n\t      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n\t    }\n\t\n\t    if (op.updatedDisplay || op.selectionChanged)\n\t      op.preparedSelection = display.input.prepareSelection();\n\t  }\n\t\n\t  function endOperation_W2(op) {\n\t    var cm = op.cm;\n\t\n\t    if (op.adjustWidthTo != null) {\n\t      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\t      if (op.maxScrollLeft < cm.doc.scrollLeft)\n\t        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n\t      cm.display.maxLineChanged = false;\n\t    }\n\t\n\t    if (op.preparedSelection)\n\t      cm.display.input.showSelection(op.preparedSelection);\n\t    if (op.updatedDisplay)\n\t      setDocumentHeight(cm, op.barMeasure);\n\t    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n\t      updateScrollbars(cm, op.barMeasure);\n\t\n\t    if (op.selectionChanged) restartBlink(cm);\n\t\n\t    if (cm.state.focused && op.updateInput)\n\t      cm.display.input.reset(op.typing);\n\t    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))\n\t      ensureFocus(op.cm);\n\t  }\n\t\n\t  function endOperation_finish(op) {\n\t    var cm = op.cm, display = cm.display, doc = cm.doc;\n\t\n\t    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\t\n\t    // Abort mouse wheel delta measurement, when scrolling explicitly\n\t    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n\t      display.wheelStartX = display.wheelStartY = null;\n\t\n\t    // Propagate the scroll position to the actual DOM scroller\n\t    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n\t      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n\t      display.scrollbars.setScrollTop(doc.scrollTop);\n\t      display.scroller.scrollTop = doc.scrollTop;\n\t    }\n\t    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n\t      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n\t      display.scrollbars.setScrollLeft(doc.scrollLeft);\n\t      display.scroller.scrollLeft = doc.scrollLeft;\n\t      alignHorizontally(cm);\n\t    }\n\t    // If we need to scroll a specific position into view, do so.\n\t    if (op.scrollToPos) {\n\t      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n\t                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n\t      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n\t    }\n\t\n\t    // Fire events for markers that are hidden/unidden by editing or\n\t    // undoing\n\t    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n\t    if (hidden) for (var i = 0; i < hidden.length; ++i)\n\t      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n\t    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n\t      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\t\n\t    if (display.wrapper.offsetHeight)\n\t      doc.scrollTop = cm.display.scroller.scrollTop;\n\t\n\t    // Fire change events, and delayed event handlers\n\t    if (op.changeObjs)\n\t      signal(cm, \"changes\", cm, op.changeObjs);\n\t    if (op.update)\n\t      op.update.finish();\n\t  }\n\t\n\t  // Run the given function in an operation\n\t  function runInOp(cm, f) {\n\t    if (cm.curOp) return f();\n\t    startOperation(cm);\n\t    try { return f(); }\n\t    finally { endOperation(cm); }\n\t  }\n\t  // Wraps a function in an operation. Returns the wrapped function.\n\t  function operation(cm, f) {\n\t    return function() {\n\t      if (cm.curOp) return f.apply(cm, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(cm, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t  // Used to add methods to editor and doc instances, wrapping them in\n\t  // operations.\n\t  function methodOp(f) {\n\t    return function() {\n\t      if (this.curOp) return f.apply(this, arguments);\n\t      startOperation(this);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(this); }\n\t    };\n\t  }\n\t  function docMethodOp(f) {\n\t    return function() {\n\t      var cm = this.cm;\n\t      if (!cm || cm.curOp) return f.apply(this, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t\n\t  // VIEW TRACKING\n\t\n\t  // These objects are used to represent the visible (currently drawn)\n\t  // part of the document. A LineView may correspond to multiple\n\t  // logical lines, if those are connected by collapsed ranges.\n\t  function LineView(doc, line, lineN) {\n\t    // The starting line\n\t    this.line = line;\n\t    // Continuing lines, if any\n\t    this.rest = visualLineContinued(line);\n\t    // Number of logical lines in this visual line\n\t    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n\t    this.node = this.text = null;\n\t    this.hidden = lineIsHidden(doc, line);\n\t  }\n\t\n\t  // Create a range of LineView objects for the given lines.\n\t  function buildViewArray(cm, from, to) {\n\t    var array = [], nextPos;\n\t    for (var pos = from; pos < to; pos = nextPos) {\n\t      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n\t      nextPos = pos + view.size;\n\t      array.push(view);\n\t    }\n\t    return array;\n\t  }\n\t\n\t  // Updates the display.view data structure for a given change to the\n\t  // document. From and to are in pre-change coordinates. Lendiff is\n\t  // the amount of lines added or subtracted by the change. This is\n\t  // used for changes that span multiple lines, or change the way\n\t  // lines are divided into visual lines. regLineChange (below)\n\t  // registers single-line changes.\n\t  function regChange(cm, from, to, lendiff) {\n\t    if (from == null) from = cm.doc.first;\n\t    if (to == null) to = cm.doc.first + cm.doc.size;\n\t    if (!lendiff) lendiff = 0;\n\t\n\t    var display = cm.display;\n\t    if (lendiff && to < display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n\t      display.updateLineNumbers = from;\n\t\n\t    cm.curOp.viewChanged = true;\n\t\n\t    if (from >= display.viewTo) { // Change after\n\t      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n\t        resetView(cm);\n\t    } else if (to <= display.viewFrom) { // Change before\n\t      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n\t        resetView(cm);\n\t      } else {\n\t        display.viewFrom += lendiff;\n\t        display.viewTo += lendiff;\n\t      }\n\t    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n\t      resetView(cm);\n\t    } else if (from <= display.viewFrom) { // Top overlap\n\t      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cut) {\n\t        display.view = display.view.slice(cut.index);\n\t        display.viewFrom = cut.lineN;\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else if (to >= display.viewTo) { // Bottom overlap\n\t      var cut = viewCuttingPoint(cm, from, from, -1);\n\t      if (cut) {\n\t        display.view = display.view.slice(0, cut.index);\n\t        display.viewTo = cut.lineN;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else { // Gap in the middle\n\t      var cutTop = viewCuttingPoint(cm, from, from, -1);\n\t      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cutTop && cutBot) {\n\t        display.view = display.view.slice(0, cutTop.index)\n\t          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n\t          .concat(display.view.slice(cutBot.index));\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    }\n\t\n\t    var ext = display.externalMeasured;\n\t    if (ext) {\n\t      if (to < ext.lineN)\n\t        ext.lineN += lendiff;\n\t      else if (from < ext.lineN + ext.size)\n\t        display.externalMeasured = null;\n\t    }\n\t  }\n\t\n\t  // Register a change to a single line. Type must be one of \"text\",\n\t  // \"gutter\", \"class\", \"widget\"\n\t  function regLineChange(cm, line, type) {\n\t    cm.curOp.viewChanged = true;\n\t    var display = cm.display, ext = cm.display.externalMeasured;\n\t    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n\t      display.externalMeasured = null;\n\t\n\t    if (line < display.viewFrom || line >= display.viewTo) return;\n\t    var lineView = display.view[findViewIndex(cm, line)];\n\t    if (lineView.node == null) return;\n\t    var arr = lineView.changes || (lineView.changes = []);\n\t    if (indexOf(arr, type) == -1) arr.push(type);\n\t  }\n\t\n\t  // Clear the view.\n\t  function resetView(cm) {\n\t    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n\t    cm.display.view = [];\n\t    cm.display.viewOffset = 0;\n\t  }\n\t\n\t  // Find the view element corresponding to a given line. Return null\n\t  // when the line isn't visible.\n\t  function findViewIndex(cm, n) {\n\t    if (n >= cm.display.viewTo) return null;\n\t    n -= cm.display.viewFrom;\n\t    if (n < 0) return null;\n\t    var view = cm.display.view;\n\t    for (var i = 0; i < view.length; i++) {\n\t      n -= view[i].size;\n\t      if (n < 0) return i;\n\t    }\n\t  }\n\t\n\t  function viewCuttingPoint(cm, oldN, newN, dir) {\n\t    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n\t    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n\t      return {index: index, lineN: newN};\n\t    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n\t      n += view[i].size;\n\t    if (n != oldN) {\n\t      if (dir > 0) {\n\t        if (index == view.length - 1) return null;\n\t        diff = (n + view[index].size) - oldN;\n\t        index++;\n\t      } else {\n\t        diff = n - oldN;\n\t      }\n\t      oldN += diff; newN += diff;\n\t    }\n\t    while (visualLineNo(cm.doc, newN) != newN) {\n\t      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n\t      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n\t      index += dir;\n\t    }\n\t    return {index: index, lineN: newN};\n\t  }\n\t\n\t  // Force the view to cover a given range, adding empty view element\n\t  // or clipping off existing ones as needed.\n\t  function adjustView(cm, from, to) {\n\t    var display = cm.display, view = display.view;\n\t    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n\t      display.view = buildViewArray(cm, from, to);\n\t      display.viewFrom = from;\n\t    } else {\n\t      if (display.viewFrom > from)\n\t        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n\t      else if (display.viewFrom < from)\n\t        display.view = display.view.slice(findViewIndex(cm, from));\n\t      display.viewFrom = from;\n\t      if (display.viewTo < to)\n\t        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n\t      else if (display.viewTo > to)\n\t        display.view = display.view.slice(0, findViewIndex(cm, to));\n\t    }\n\t    display.viewTo = to;\n\t  }\n\t\n\t  // Count the number of lines in the view whose DOM representation is\n\t  // out of date (or nonexistent).\n\t  function countDirtyView(cm) {\n\t    var view = cm.display.view, dirty = 0;\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n\t    }\n\t    return dirty;\n\t  }\n\t\n\t  // EVENT HANDLERS\n\t\n\t  // Attach the necessary event handlers when initializing the editor\n\t  function registerEventHandlers(cm) {\n\t    var d = cm.display;\n\t    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\t    // Older IE's will not fire a second mousedown for a double click\n\t    if (ie && ie_version < 11)\n\t      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n\t        if (signalDOMEvent(cm, e)) return;\n\t        var pos = posFromMouse(cm, e);\n\t        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n\t        e_preventDefault(e);\n\t        var word = cm.findWordAt(pos);\n\t        extendSelection(cm.doc, word.anchor, word.head);\n\t      }));\n\t    else\n\t      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n\t    // Some browsers fire contextmenu *after* opening the menu, at\n\t    // which point we can't mess with it anymore. Context menu is\n\t    // handled in onMouseDown for these browsers.\n\t    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\t\n\t    // Used to suppress mouse event handling when a touch happens\n\t    var touchFinished, prevTouch = {end: 0};\n\t    function finishTouch() {\n\t      if (d.activeTouch) {\n\t        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n\t        prevTouch = d.activeTouch;\n\t        prevTouch.end = +new Date;\n\t      }\n\t    };\n\t    function isMouseLikeTouchEvent(e) {\n\t      if (e.touches.length != 1) return false;\n\t      var touch = e.touches[0];\n\t      return touch.radiusX <= 1 && touch.radiusY <= 1;\n\t    }\n\t    function farAway(touch, other) {\n\t      if (other.left == null) return true;\n\t      var dx = other.left - touch.left, dy = other.top - touch.top;\n\t      return dx * dx + dy * dy > 20 * 20;\n\t    }\n\t    on(d.scroller, \"touchstart\", function(e) {\n\t      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n\t        clearTimeout(touchFinished);\n\t        var now = +new Date;\n\t        d.activeTouch = {start: now, moved: false,\n\t                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n\t        if (e.touches.length == 1) {\n\t          d.activeTouch.left = e.touches[0].pageX;\n\t          d.activeTouch.top = e.touches[0].pageY;\n\t        }\n\t      }\n\t    });\n\t    on(d.scroller, \"touchmove\", function() {\n\t      if (d.activeTouch) d.activeTouch.moved = true;\n\t    });\n\t    on(d.scroller, \"touchend\", function(e) {\n\t      var touch = d.activeTouch;\n\t      if (touch && !eventInWidget(d, e) && touch.left != null &&\n\t          !touch.moved && new Date - touch.start < 300) {\n\t        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n\t        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n\t          range = new Range(pos, pos);\n\t        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n\t          range = cm.findWordAt(pos);\n\t        else // Triple tap\n\t          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n\t        cm.setSelection(range.anchor, range.head);\n\t        cm.focus();\n\t        e_preventDefault(e);\n\t      }\n\t      finishTouch();\n\t    });\n\t    on(d.scroller, \"touchcancel\", finishTouch);\n\t\n\t    // Sync scrolling between fake scrollbars and real scrollable\n\t    // area, ensure viewport is updated when scrolling.\n\t    on(d.scroller, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) {\n\t        setScrollTop(cm, d.scroller.scrollTop);\n\t        setScrollLeft(cm, d.scroller.scrollLeft, true);\n\t        signal(cm, \"scroll\", cm);\n\t      }\n\t    });\n\t\n\t    // Listen to wheel events in order to try and update the viewport on time.\n\t    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n\t    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\t\n\t    // Prevent wrapper from ever scrolling\n\t    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\t\n\t    d.dragFunctions = {\n\t      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n\t      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n\t      start: function(e){onDragStart(cm, e);},\n\t      drop: operation(cm, onDrop),\n\t      leave: function() {clearDragCursor(cm);}\n\t    };\n\t\n\t    var inp = d.input.getField();\n\t    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n\t    on(inp, \"keydown\", operation(cm, onKeyDown));\n\t    on(inp, \"keypress\", operation(cm, onKeyPress));\n\t    on(inp, \"focus\", bind(onFocus, cm));\n\t    on(inp, \"blur\", bind(onBlur, cm));\n\t  }\n\t\n\t  function dragDropChanged(cm, value, old) {\n\t    var wasOn = old && old != CodeMirror.Init;\n\t    if (!value != !wasOn) {\n\t      var funcs = cm.display.dragFunctions;\n\t      var toggle = value ? on : off;\n\t      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n\t      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n\t      toggle(cm.display.scroller, \"dragover\", funcs.over);\n\t      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n\t      toggle(cm.display.scroller, \"drop\", funcs.drop);\n\t    }\n\t  }\n\t\n\t  // Called when the window resizes\n\t  function onResize(cm) {\n\t    var d = cm.display;\n\t    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n\t      return;\n\t    // Might be a text scaling operation, clear size caches.\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t    d.scrollbarsClipped = false;\n\t    cm.setSize();\n\t  }\n\t\n\t  // MOUSE EVENTS\n\t\n\t  // Return true when the given mouse event happened in a widget\n\t  function eventInWidget(display, e) {\n\t    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n\t      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n\t          (n.parentNode == display.sizer && n != display.mover))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // Given a mouse event, find the corresponding position. If liberal\n\t  // is false, it checks whether a gutter or scrollbar was clicked,\n\t  // and returns null if it was. forRect is used by rectangular\n\t  // selections, and tries to estimate a character position even for\n\t  // coordinates beyond the right of the text.\n\t  function posFromMouse(cm, e, liberal, forRect) {\n\t    var display = cm.display;\n\t    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\t\n\t    var x, y, space = display.lineSpace.getBoundingClientRect();\n\t    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\t    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n\t    catch (e) { return null; }\n\t    var coords = coordsChar(cm, x, y), line;\n\t    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n\t      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n\t      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // A mouse down can be a single click, double click, triple click,\n\t  // start of selection drag, start of text drag, new cursor\n\t  // (ctrl-click), rectangle drag (alt-drag), or xwin\n\t  // middle-click-paste. Or it might be a click on something we should\n\t  // not interfere with, such as a scrollbar or widget.\n\t  function onMouseDown(e) {\n\t    var cm = this, display = cm.display;\n\t    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n\t    display.shift = e.shiftKey;\n\t\n\t    if (eventInWidget(display, e)) {\n\t      if (!webkit) {\n\t        // Briefly turn off draggability, to allow widgets to do\n\t        // normal dragging things.\n\t        display.scroller.draggable = false;\n\t        setTimeout(function(){display.scroller.draggable = true;}, 100);\n\t      }\n\t      return;\n\t    }\n\t    if (clickInGutter(cm, e)) return;\n\t    var start = posFromMouse(cm, e);\n\t    window.focus();\n\t\n\t    switch (e_button(e)) {\n\t    case 1:\n\t      // #3261: make sure, that we're not starting a second selection\n\t      if (cm.state.selectingText)\n\t        cm.state.selectingText(e);\n\t      else if (start)\n\t        leftButtonDown(cm, e, start);\n\t      else if (e_target(e) == display.scroller)\n\t        e_preventDefault(e);\n\t      break;\n\t    case 2:\n\t      if (webkit) cm.state.lastMiddleDown = +new Date;\n\t      if (start) extendSelection(cm.doc, start);\n\t      setTimeout(function() {display.input.focus();}, 20);\n\t      e_preventDefault(e);\n\t      break;\n\t    case 3:\n\t      if (captureRightClick) onContextMenu(cm, e);\n\t      else delayBlurEvent(cm);\n\t      break;\n\t    }\n\t  }\n\t\n\t  var lastClick, lastDoubleClick;\n\t  function leftButtonDown(cm, e, start) {\n\t    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n\t    else cm.curOp.focus = activeElt();\n\t\n\t    var now = +new Date, type;\n\t    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n\t      type = \"triple\";\n\t    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n\t      type = \"double\";\n\t      lastDoubleClick = {time: now, pos: start};\n\t    } else {\n\t      type = \"single\";\n\t      lastClick = {time: now, pos: start};\n\t    }\n\t\n\t    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n\t    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n\t        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n\t        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n\t        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n\t      leftButtonStartDrag(cm, e, start, modifier);\n\t    else\n\t      leftButtonSelect(cm, e, start, type, modifier);\n\t  }\n\t\n\t  // Start a text drag. When it ends, see if any dragging actually\n\t  // happen, and treat as a click if it didn't.\n\t  function leftButtonStartDrag(cm, e, start, modifier) {\n\t    var display = cm.display, startTime = +new Date;\n\t    var dragEnd = operation(cm, function(e2) {\n\t      if (webkit) display.scroller.draggable = false;\n\t      cm.state.draggingText = false;\n\t      off(document, \"mouseup\", dragEnd);\n\t      off(display.scroller, \"drop\", dragEnd);\n\t      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n\t        e_preventDefault(e2);\n\t        if (!modifier && +new Date - 200 < startTime)\n\t          extendSelection(cm.doc, start);\n\t        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\t        if (webkit || ie && ie_version == 9)\n\t          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n\t        else\n\t          display.input.focus();\n\t      }\n\t    });\n\t    // Let the drag handler handle this.\n\t    if (webkit) display.scroller.draggable = true;\n\t    cm.state.draggingText = dragEnd;\n\t    // IE's approach to draggable\n\t    if (display.scroller.dragDrop) display.scroller.dragDrop();\n\t    on(document, \"mouseup\", dragEnd);\n\t    on(display.scroller, \"drop\", dragEnd);\n\t  }\n\t\n\t  // Normal selection, as opposed to text dragging.\n\t  function leftButtonSelect(cm, e, start, type, addNew) {\n\t    var display = cm.display, doc = cm.doc;\n\t    e_preventDefault(e);\n\t\n\t    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n\t    if (addNew && !e.shiftKey) {\n\t      ourIndex = doc.sel.contains(start);\n\t      if (ourIndex > -1)\n\t        ourRange = ranges[ourIndex];\n\t      else\n\t        ourRange = new Range(start, start);\n\t    } else {\n\t      ourRange = doc.sel.primary();\n\t      ourIndex = doc.sel.primIndex;\n\t    }\n\t\n\t    if (e.altKey) {\n\t      type = \"rect\";\n\t      if (!addNew) ourRange = new Range(start, start);\n\t      start = posFromMouse(cm, e, true, true);\n\t      ourIndex = -1;\n\t    } else if (type == \"double\") {\n\t      var word = cm.findWordAt(start);\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n\t      else\n\t        ourRange = word;\n\t    } else if (type == \"triple\") {\n\t      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n\t      else\n\t        ourRange = line;\n\t    } else {\n\t      ourRange = extendRange(doc, ourRange, start);\n\t    }\n\t\n\t    if (!addNew) {\n\t      ourIndex = 0;\n\t      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n\t      startSel = doc.sel;\n\t    } else if (ourIndex == -1) {\n\t      ourIndex = ranges.length;\n\t      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n\t      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t      startSel = doc.sel;\n\t    } else {\n\t      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n\t    }\n\t\n\t    var lastPos = start;\n\t    function extendTo(pos) {\n\t      if (cmp(lastPos, pos) == 0) return;\n\t      lastPos = pos;\n\t\n\t      if (type == \"rect\") {\n\t        var ranges = [], tabSize = cm.options.tabSize;\n\t        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n\t        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n\t        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n\t        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n\t             line <= end; line++) {\n\t          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n\t          if (left == right)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n\t          else if (text.length > leftPos)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n\t        }\n\t        if (!ranges.length) ranges.push(new Range(start, start));\n\t        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n\t                     {origin: \"*mouse\", scroll: false});\n\t        cm.scrollIntoView(pos);\n\t      } else {\n\t        var oldRange = ourRange;\n\t        var anchor = oldRange.anchor, head = pos;\n\t        if (type != \"single\") {\n\t          if (type == \"double\")\n\t            var range = cm.findWordAt(pos);\n\t          else\n\t            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n\t          if (cmp(range.anchor, anchor) > 0) {\n\t            head = range.head;\n\t            anchor = minPos(oldRange.from(), range.anchor);\n\t          } else {\n\t            head = range.anchor;\n\t            anchor = maxPos(oldRange.to(), range.head);\n\t          }\n\t        }\n\t        var ranges = startSel.ranges.slice(0);\n\t        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n\t        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n\t      }\n\t    }\n\t\n\t    var editorSize = display.wrapper.getBoundingClientRect();\n\t    // Used to ensure timeout re-tries don't fire when another extend\n\t    // happened in the meantime (clearTimeout isn't reliable -- at\n\t    // least on Chrome, the timeouts still happen even when cleared,\n\t    // if the clear happens after their scheduled firing time).\n\t    var counter = 0;\n\t\n\t    function extend(e) {\n\t      var curCount = ++counter;\n\t      var cur = posFromMouse(cm, e, true, type == \"rect\");\n\t      if (!cur) return;\n\t      if (cmp(cur, lastPos) != 0) {\n\t        cm.curOp.focus = activeElt();\n\t        extendTo(cur);\n\t        var visible = visibleLines(display, doc);\n\t        if (cur.line >= visible.to || cur.line < visible.from)\n\t          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n\t      } else {\n\t        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\t        if (outside) setTimeout(operation(cm, function() {\n\t          if (counter != curCount) return;\n\t          display.scroller.scrollTop += outside;\n\t          extend(e);\n\t        }), 50);\n\t      }\n\t    }\n\t\n\t    function done(e) {\n\t      cm.state.selectingText = false;\n\t      counter = Infinity;\n\t      e_preventDefault(e);\n\t      display.input.focus();\n\t      off(document, \"mousemove\", move);\n\t      off(document, \"mouseup\", up);\n\t      doc.history.lastSelOrigin = null;\n\t    }\n\t\n\t    var move = operation(cm, function(e) {\n\t      if (!e_button(e)) done(e);\n\t      else extend(e);\n\t    });\n\t    var up = operation(cm, done);\n\t    cm.state.selectingText = up;\n\t    on(document, \"mousemove\", move);\n\t    on(document, \"mouseup\", up);\n\t  }\n\t\n\t  // Determines whether an event happened in the gutter, and fires the\n\t  // handlers for the corresponding event.\n\t  function gutterEvent(cm, e, type, prevent) {\n\t    try { var mX = e.clientX, mY = e.clientY; }\n\t    catch(e) { return false; }\n\t    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n\t    if (prevent) e_preventDefault(e);\n\t\n\t    var display = cm.display;\n\t    var lineBox = display.lineDiv.getBoundingClientRect();\n\t\n\t    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n\t    mY -= lineBox.top - display.viewOffset;\n\t\n\t    for (var i = 0; i < cm.options.gutters.length; ++i) {\n\t      var g = display.gutters.childNodes[i];\n\t      if (g && g.getBoundingClientRect().right >= mX) {\n\t        var line = lineAtHeight(cm.doc, mY);\n\t        var gutter = cm.options.gutters[i];\n\t        signal(cm, type, cm, line, gutter, e);\n\t        return e_defaultPrevented(e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function clickInGutter(cm, e) {\n\t    return gutterEvent(cm, e, \"gutterClick\", true);\n\t  }\n\t\n\t  // Kludge to work around strange IE behavior where it'll sometimes\n\t  // re-fire a series of drag-related events right after the drop (#1551)\n\t  var lastDrop = 0;\n\t\n\t  function onDrop(e) {\n\t    var cm = this;\n\t    clearDragCursor(cm);\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n\t      return;\n\t    e_preventDefault(e);\n\t    if (ie) lastDrop = +new Date;\n\t    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n\t    if (!pos || cm.isReadOnly()) return;\n\t    // Might be a file drop, in which case we simply extract the text\n\t    // and insert it.\n\t    if (files && files.length && window.FileReader && window.File) {\n\t      var n = files.length, text = Array(n), read = 0;\n\t      var loadFile = function(file, i) {\n\t        if (cm.options.allowDropFileTypes &&\n\t            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n\t          return;\n\t\n\t        var reader = new FileReader;\n\t        reader.onload = operation(cm, function() {\n\t          var content = reader.result;\n\t          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n\t          text[i] = content;\n\t          if (++read == n) {\n\t            pos = clipPos(cm.doc, pos);\n\t            var change = {from: pos, to: pos,\n\t                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n\t                          origin: \"paste\"};\n\t            makeChange(cm.doc, change);\n\t            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n\t          }\n\t        });\n\t        reader.readAsText(file);\n\t      };\n\t      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n\t    } else { // Normal drop\n\t      // Don't do a replace if the drop happened inside of the selected text.\n\t      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n\t        cm.state.draggingText(e);\n\t        // Ensure the editor is re-focused\n\t        setTimeout(function() {cm.display.input.focus();}, 20);\n\t        return;\n\t      }\n\t      try {\n\t        var text = e.dataTransfer.getData(\"Text\");\n\t        if (text) {\n\t          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n\t            var selected = cm.listSelections();\n\t          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\t          if (selected) for (var i = 0; i < selected.length; ++i)\n\t            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n\t          cm.replaceSelection(text, \"around\", \"paste\");\n\t          cm.display.input.focus();\n\t        }\n\t      }\n\t      catch(e){}\n\t    }\n\t  }\n\t\n\t  function onDragStart(cm, e) {\n\t    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\t\n\t    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\t\n\t    // Use dummy image instead of default browsers image.\n\t    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\t    if (e.dataTransfer.setDragImage && !safari) {\n\t      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\t      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t      if (presto) {\n\t        img.width = img.height = 1;\n\t        cm.display.wrapper.appendChild(img);\n\t        // Force a relayout, or Opera won't use our image for some obscure reason\n\t        img._top = img.offsetTop;\n\t      }\n\t      e.dataTransfer.setDragImage(img, 0, 0);\n\t      if (presto) img.parentNode.removeChild(img);\n\t    }\n\t  }\n\t\n\t  function onDragOver(cm, e) {\n\t    var pos = posFromMouse(cm, e);\n\t    if (!pos) return;\n\t    var frag = document.createDocumentFragment();\n\t    drawSelectionCursor(cm, pos, frag);\n\t    if (!cm.display.dragCursor) {\n\t      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n\t      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n\t    }\n\t    removeChildrenAndAdd(cm.display.dragCursor, frag);\n\t  }\n\t\n\t  function clearDragCursor(cm) {\n\t    if (cm.display.dragCursor) {\n\t      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n\t      cm.display.dragCursor = null;\n\t    }\n\t  }\n\t\n\t  // SCROLL EVENTS\n\t\n\t  // Sync the scrollable area and scrollbars, ensure the viewport\n\t  // covers the visible area.\n\t  function setScrollTop(cm, val) {\n\t    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n\t    cm.doc.scrollTop = val;\n\t    if (!gecko) updateDisplaySimple(cm, {top: val});\n\t    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n\t    cm.display.scrollbars.setScrollTop(val);\n\t    if (gecko) updateDisplaySimple(cm);\n\t    startWorker(cm, 100);\n\t  }\n\t  // Sync scroller and scrollbar, ensure the gutter elements are\n\t  // aligned.\n\t  function setScrollLeft(cm, val, isScroller) {\n\t    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n\t    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\t    cm.doc.scrollLeft = val;\n\t    alignHorizontally(cm);\n\t    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n\t    cm.display.scrollbars.setScrollLeft(val);\n\t  }\n\t\n\t  // Since the delta values reported on mouse wheel events are\n\t  // unstandardized between browsers and even browser versions, and\n\t  // generally horribly unpredictable, this code starts by measuring\n\t  // the scroll effect that the first few mouse wheel events have,\n\t  // and, from that, detects the way it can convert deltas to pixel\n\t  // offsets afterwards.\n\t  //\n\t  // The reason we want to know the amount a wheel event will scroll\n\t  // is that it gives us a chance to update the display before the\n\t  // actual scrolling happens, reducing flickering.\n\t\n\t  var wheelSamples = 0, wheelPixelsPerUnit = null;\n\t  // Fill in a browser-detected starting value on browsers where we\n\t  // know one. These don't have to be accurate -- the result of them\n\t  // being wrong would just be a slight flicker on the first wheel\n\t  // scroll (if it is large enough).\n\t  if (ie) wheelPixelsPerUnit = -.53;\n\t  else if (gecko) wheelPixelsPerUnit = 15;\n\t  else if (chrome) wheelPixelsPerUnit = -.7;\n\t  else if (safari) wheelPixelsPerUnit = -1/3;\n\t\n\t  var wheelEventDelta = function(e) {\n\t    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n\t    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n\t    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n\t    else if (dy == null) dy = e.wheelDelta;\n\t    return {x: dx, y: dy};\n\t  };\n\t  CodeMirror.wheelEventPixels = function(e) {\n\t    var delta = wheelEventDelta(e);\n\t    delta.x *= wheelPixelsPerUnit;\n\t    delta.y *= wheelPixelsPerUnit;\n\t    return delta;\n\t  };\n\t\n\t  function onScrollWheel(cm, e) {\n\t    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\t\n\t    var display = cm.display, scroll = display.scroller;\n\t    // Quit if there's nothing to scroll here\n\t    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n\t    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\t    if (!(dx && canScrollX || dy && canScrollY)) return;\n\t\n\t    // Webkit browsers on OS X abort momentum scrolls when the target\n\t    // of the scroll event is removed from the scrollable element.\n\t    // This hack (see related code in patchDisplay) makes sure the\n\t    // element is kept around.\n\t    if (dy && mac && webkit) {\n\t      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n\t        for (var i = 0; i < view.length; i++) {\n\t          if (view[i].node == cur) {\n\t            cm.display.currentWheelTarget = cur;\n\t            break outer;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // On some browsers, horizontal scrolling will cause redraws to\n\t    // happen before the gutter has been realigned, causing it to\n\t    // wriggle around in a most unseemly way. When we have an\n\t    // estimated pixels/delta value, we just handle horizontal\n\t    // scrolling entirely here. It'll be slightly off from native, but\n\t    // better than glitching out.\n\t    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n\t      if (dy && canScrollY)\n\t        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n\t      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n\t      // Only prevent default scrolling if vertical scrolling is\n\t      // actually possible. Otherwise, it causes vertical scroll\n\t      // jitter on OSX trackpads when deltaX is small and deltaY\n\t      // is large (issue #3579)\n\t      if (!dy || (dy && canScrollY))\n\t        e_preventDefault(e);\n\t      display.wheelStartX = null; // Abort measurement, if in progress\n\t      return;\n\t    }\n\t\n\t    // 'Project' the visible viewport to cover the area that is being\n\t    // scrolled into view (if we know enough to estimate it).\n\t    if (dy && wheelPixelsPerUnit != null) {\n\t      var pixels = dy * wheelPixelsPerUnit;\n\t      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n\t      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n\t      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n\t      updateDisplaySimple(cm, {top: top, bottom: bot});\n\t    }\n\t\n\t    if (wheelSamples < 20) {\n\t      if (display.wheelStartX == null) {\n\t        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n\t        display.wheelDX = dx; display.wheelDY = dy;\n\t        setTimeout(function() {\n\t          if (display.wheelStartX == null) return;\n\t          var movedX = scroll.scrollLeft - display.wheelStartX;\n\t          var movedY = scroll.scrollTop - display.wheelStartY;\n\t          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n\t            (movedX && display.wheelDX && movedX / display.wheelDX);\n\t          display.wheelStartX = display.wheelStartY = null;\n\t          if (!sample) return;\n\t          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n\t          ++wheelSamples;\n\t        }, 200);\n\t      } else {\n\t        display.wheelDX += dx; display.wheelDY += dy;\n\t      }\n\t    }\n\t  }\n\t\n\t  // KEY EVENTS\n\t\n\t  // Run a handler that was bound to a key.\n\t  function doHandleBinding(cm, bound, dropShift) {\n\t    if (typeof bound == \"string\") {\n\t      bound = commands[bound];\n\t      if (!bound) return false;\n\t    }\n\t    // Ensure previous input has been read, so that the handler sees a\n\t    // consistent view of the document\n\t    cm.display.input.ensurePolled();\n\t    var prevShift = cm.display.shift, done = false;\n\t    try {\n\t      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n\t      if (dropShift) cm.display.shift = false;\n\t      done = bound(cm) != Pass;\n\t    } finally {\n\t      cm.display.shift = prevShift;\n\t      cm.state.suppressEdits = false;\n\t    }\n\t    return done;\n\t  }\n\t\n\t  function lookupKeyForEditor(cm, name, handle) {\n\t    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n\t      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\t      if (result) return result;\n\t    }\n\t    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n\t      || lookupKey(name, cm.options.keyMap, handle, cm);\n\t  }\n\t\n\t  var stopSeq = new Delayed;\n\t  function dispatchKey(cm, name, e, handle) {\n\t    var seq = cm.state.keySeq;\n\t    if (seq) {\n\t      if (isModifierKey(name)) return \"handled\";\n\t      stopSeq.set(50, function() {\n\t        if (cm.state.keySeq == seq) {\n\t          cm.state.keySeq = null;\n\t          cm.display.input.reset();\n\t        }\n\t      });\n\t      name = seq + \" \" + name;\n\t    }\n\t    var result = lookupKeyForEditor(cm, name, handle);\n\t\n\t    if (result == \"multi\")\n\t      cm.state.keySeq = name;\n\t    if (result == \"handled\")\n\t      signalLater(cm, \"keyHandled\", cm, name, e);\n\t\n\t    if (result == \"handled\" || result == \"multi\") {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t    }\n\t\n\t    if (seq && !result && /\\'$/.test(name)) {\n\t      e_preventDefault(e);\n\t      return true;\n\t    }\n\t    return !!result;\n\t  }\n\t\n\t  // Handle a key from the keydown event.\n\t  function handleKeyBinding(cm, e) {\n\t    var name = keyName(e, true);\n\t    if (!name) return false;\n\t\n\t    if (e.shiftKey && !cm.state.keySeq) {\n\t      // First try to resolve full name (including 'Shift-'). Failing\n\t      // that, see if there is a cursor-motion command (starting with\n\t      // 'go') bound to the keyname without 'Shift-'.\n\t      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n\t          || dispatchKey(cm, name, e, function(b) {\n\t               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n\t                 return doHandleBinding(cm, b);\n\t             });\n\t    } else {\n\t      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n\t    }\n\t  }\n\t\n\t  // Handle a key from the keypress event\n\t  function handleCharBinding(cm, e, ch) {\n\t    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n\t                       function(b) { return doHandleBinding(cm, b, true); });\n\t  }\n\t\n\t  var lastStoppedKey = null;\n\t  function onKeyDown(e) {\n\t    var cm = this;\n\t    cm.curOp.focus = activeElt();\n\t    if (signalDOMEvent(cm, e)) return;\n\t    // IE does strange things with escape.\n\t    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n\t    var code = e.keyCode;\n\t    cm.display.shift = code == 16 || e.shiftKey;\n\t    var handled = handleKeyBinding(cm, e);\n\t    if (presto) {\n\t      lastStoppedKey = handled ? code : null;\n\t      // Opera has no cut event... we try to at least catch the key combo\n\t      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n\t        cm.replaceSelection(\"\", null, \"cut\");\n\t    }\n\t\n\t    // Turn mouse into crosshair when Alt is held on Mac.\n\t    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n\t      showCrossHair(cm);\n\t  }\n\t\n\t  function showCrossHair(cm) {\n\t    var lineDiv = cm.display.lineDiv;\n\t    addClass(lineDiv, \"CodeMirror-crosshair\");\n\t\n\t    function up(e) {\n\t      if (e.keyCode == 18 || !e.altKey) {\n\t        rmClass(lineDiv, \"CodeMirror-crosshair\");\n\t        off(document, \"keyup\", up);\n\t        off(document, \"mouseover\", up);\n\t      }\n\t    }\n\t    on(document, \"keyup\", up);\n\t    on(document, \"mouseover\", up);\n\t  }\n\t\n\t  function onKeyUp(e) {\n\t    if (e.keyCode == 16) this.doc.sel.shift = false;\n\t    signalDOMEvent(this, e);\n\t  }\n\t\n\t  function onKeyPress(e) {\n\t    var cm = this;\n\t    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n\t    var keyCode = e.keyCode, charCode = e.charCode;\n\t    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n\t    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n\t    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n\t    if (handleCharBinding(cm, e, ch)) return;\n\t    cm.display.input.onKeyPress(e);\n\t  }\n\t\n\t  // FOCUS/BLUR EVENTS\n\t\n\t  function delayBlurEvent(cm) {\n\t    cm.state.delayingBlurEvent = true;\n\t    setTimeout(function() {\n\t      if (cm.state.delayingBlurEvent) {\n\t        cm.state.delayingBlurEvent = false;\n\t        onBlur(cm);\n\t      }\n\t    }, 100);\n\t  }\n\t\n\t  function onFocus(cm) {\n\t    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\t\n\t    if (cm.options.readOnly == \"nocursor\") return;\n\t    if (!cm.state.focused) {\n\t      signal(cm, \"focus\", cm);\n\t      cm.state.focused = true;\n\t      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t      // This test prevents this from firing when a context\n\t      // menu is closed (since the input reset would kill the\n\t      // select-all detection hack)\n\t      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n\t        cm.display.input.reset();\n\t        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n\t      }\n\t      cm.display.input.receivedFocus();\n\t    }\n\t    restartBlink(cm);\n\t  }\n\t  function onBlur(cm) {\n\t    if (cm.state.delayingBlurEvent) return;\n\t\n\t    if (cm.state.focused) {\n\t      signal(cm, \"blur\", cm);\n\t      cm.state.focused = false;\n\t      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t    }\n\t    clearInterval(cm.display.blinker);\n\t    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n\t  }\n\t\n\t  // CONTEXT MENU HANDLING\n\t\n\t  // To make the context menu work, we need to briefly unhide the\n\t  // textarea (making it as unobtrusive as possible) to let the\n\t  // right-click take effect on it.\n\t  function onContextMenu(cm, e) {\n\t    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n\t    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n\t    cm.display.input.onContextMenu(e);\n\t  }\n\t\n\t  function contextMenuInGutter(cm, e) {\n\t    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n\t    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n\t  }\n\t\n\t  // UPDATING\n\t\n\t  // Compute the position of the end of a change (its 'to' property\n\t  // refers to the pre-change end).\n\t  var changeEnd = CodeMirror.changeEnd = function(change) {\n\t    if (!change.text) return change.to;\n\t    return Pos(change.from.line + change.text.length - 1,\n\t               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n\t  };\n\t\n\t  // Adjust a position to refer to the post-change position of the\n\t  // same text, or the end of the change if the change covers it.\n\t  function adjustForChange(pos, change) {\n\t    if (cmp(pos, change.from) < 0) return pos;\n\t    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\t\n\t    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n\t    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n\t    return Pos(line, ch);\n\t  }\n\t\n\t  function computeSelAfterChange(doc, change) {\n\t    var out = [];\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      var range = doc.sel.ranges[i];\n\t      out.push(new Range(adjustForChange(range.anchor, change),\n\t                         adjustForChange(range.head, change)));\n\t    }\n\t    return normalizeSelection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  function offsetPos(pos, old, nw) {\n\t    if (pos.line == old.line)\n\t      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n\t    else\n\t      return Pos(nw.line + (pos.line - old.line), pos.ch);\n\t  }\n\t\n\t  // Used by replaceSelections to allow moving the selection to the\n\t  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\t  function computeReplacedSel(doc, changes, hint) {\n\t    var out = [];\n\t    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n\t    for (var i = 0; i < changes.length; i++) {\n\t      var change = changes[i];\n\t      var from = offsetPos(change.from, oldPrev, newPrev);\n\t      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n\t      oldPrev = change.to;\n\t      newPrev = to;\n\t      if (hint == \"around\") {\n\t        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n\t        out[i] = new Range(inv ? to : from, inv ? from : to);\n\t      } else {\n\t        out[i] = new Range(from, from);\n\t      }\n\t    }\n\t    return new Selection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  // Allow \"beforeChange\" event handlers to influence a change\n\t  function filterChange(doc, change, update) {\n\t    var obj = {\n\t      canceled: false,\n\t      from: change.from,\n\t      to: change.to,\n\t      text: change.text,\n\t      origin: change.origin,\n\t      cancel: function() { this.canceled = true; }\n\t    };\n\t    if (update) obj.update = function(from, to, text, origin) {\n\t      if (from) this.from = clipPos(doc, from);\n\t      if (to) this.to = clipPos(doc, to);\n\t      if (text) this.text = text;\n\t      if (origin !== undefined) this.origin = origin;\n\t    };\n\t    signal(doc, \"beforeChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\t\n\t    if (obj.canceled) return null;\n\t    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n\t  }\n\t\n\t  // Apply a change to a document, and add it to the document's\n\t  // history, and propagating it to all linked documents.\n\t  function makeChange(doc, change, ignoreReadOnly) {\n\t    if (doc.cm) {\n\t      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n\t      if (doc.cm.state.suppressEdits) return;\n\t    }\n\t\n\t    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n\t      change = filterChange(doc, change, true);\n\t      if (!change) return;\n\t    }\n\t\n\t    // Possibly split or suppress the update based on the presence\n\t    // of read-only spans in its range.\n\t    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\t    if (split) {\n\t      for (var i = split.length - 1; i >= 0; --i)\n\t        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n\t    } else {\n\t      makeChangeInner(doc, change);\n\t    }\n\t  }\n\t\n\t  function makeChangeInner(doc, change) {\n\t    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n\t    var selAfter = computeSelAfterChange(doc, change);\n\t    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\t\n\t    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n\t    var rebased = [];\n\t\n\t    linkedDocs(doc, function(doc, sharedHist) {\n\t      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t        rebaseHist(doc.history, change);\n\t        rebased.push(doc.history);\n\t      }\n\t      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n\t    });\n\t  }\n\t\n\t  // Revert a change stored in a document's history.\n\t  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n\t    if (doc.cm && doc.cm.state.suppressEdits) return;\n\t\n\t    var hist = doc.history, event, selAfter = doc.sel;\n\t    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\t\n\t    // Verify that there is a useable event (so that ctrl-z won't\n\t    // needlessly clear selection events)\n\t    for (var i = 0; i < source.length; i++) {\n\t      event = source[i];\n\t      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n\t        break;\n\t    }\n\t    if (i == source.length) return;\n\t    hist.lastOrigin = hist.lastSelOrigin = null;\n\t\n\t    for (;;) {\n\t      event = source.pop();\n\t      if (event.ranges) {\n\t        pushSelectionToHistory(event, dest);\n\t        if (allowSelectionOnly && !event.equals(doc.sel)) {\n\t          setSelection(doc, event, {clearRedo: false});\n\t          return;\n\t        }\n\t        selAfter = event;\n\t      }\n\t      else break;\n\t    }\n\t\n\t    // Build up a reverse change object to add to the opposite history\n\t    // stack (redo when undoing, and vice versa).\n\t    var antiChanges = [];\n\t    pushSelectionToHistory(selAfter, dest);\n\t    dest.push({changes: antiChanges, generation: hist.generation});\n\t    hist.generation = event.generation || ++hist.maxGeneration;\n\t\n\t    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\t\n\t    for (var i = event.changes.length - 1; i >= 0; --i) {\n\t      var change = event.changes[i];\n\t      change.origin = type;\n\t      if (filter && !filterChange(doc, change, false)) {\n\t        source.length = 0;\n\t        return;\n\t      }\n\t\n\t      antiChanges.push(historyChangeFromChange(doc, change));\n\t\n\t      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n\t      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\t      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n\t      var rebased = [];\n\t\n\t      // Propagate to the linked documents\n\t      linkedDocs(doc, function(doc, sharedHist) {\n\t        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t          rebaseHist(doc.history, change);\n\t          rebased.push(doc.history);\n\t        }\n\t        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n\t      });\n\t    }\n\t  }\n\t\n\t  // Sub-views need their line numbers shifted when text is added\n\t  // above or below them in the parent document.\n\t  function shiftDoc(doc, distance) {\n\t    if (distance == 0) return;\n\t    doc.first += distance;\n\t    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n\t      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n\t                       Pos(range.head.line + distance, range.head.ch));\n\t    }), doc.sel.primIndex);\n\t    if (doc.cm) {\n\t      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\t      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n\t        regLineChange(doc.cm, l, \"gutter\");\n\t    }\n\t  }\n\t\n\t  // More lower-level change function, handling only a single document\n\t  // (not linked ones).\n\t  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n\t    if (doc.cm && !doc.cm.curOp)\n\t      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\t\n\t    if (change.to.line < doc.first) {\n\t      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n\t      return;\n\t    }\n\t    if (change.from.line > doc.lastLine()) return;\n\t\n\t    // Clip the change to the size of this doc\n\t    if (change.from.line < doc.first) {\n\t      var shift = change.text.length - 1 - (doc.first - change.from.line);\n\t      shiftDoc(doc, shift);\n\t      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n\t                text: [lst(change.text)], origin: change.origin};\n\t    }\n\t    var last = doc.lastLine();\n\t    if (change.to.line > last) {\n\t      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n\t                text: [change.text[0]], origin: change.origin};\n\t    }\n\t\n\t    change.removed = getBetween(doc, change.from, change.to);\n\t\n\t    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n\t    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n\t    else updateDoc(doc, change, spans);\n\t    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\t  }\n\t\n\t  // Handle the interaction of a change to a document with the editor\n\t  // that this document is part of.\n\t  function makeChangeSingleDocInEditor(cm, change, spans) {\n\t    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\t\n\t    var recomputeMaxLength = false, checkWidthStart = from.line;\n\t    if (!cm.options.lineWrapping) {\n\t      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n\t      doc.iter(checkWidthStart, to.line + 1, function(line) {\n\t        if (line == display.maxLine) {\n\t          recomputeMaxLength = true;\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t\n\t    if (doc.sel.contains(change.from, change.to) > -1)\n\t      signalCursorActivity(cm);\n\t\n\t    updateDoc(doc, change, spans, estimateHeight(cm));\n\t\n\t    if (!cm.options.lineWrapping) {\n\t      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n\t        var len = lineLength(line);\n\t        if (len > display.maxLineLength) {\n\t          display.maxLine = line;\n\t          display.maxLineLength = len;\n\t          display.maxLineChanged = true;\n\t          recomputeMaxLength = false;\n\t        }\n\t      });\n\t      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n\t    }\n\t\n\t    // Adjust frontier, schedule worker\n\t    doc.frontier = Math.min(doc.frontier, from.line);\n\t    startWorker(cm, 400);\n\t\n\t    var lendiff = change.text.length - (to.line - from.line) - 1;\n\t    // Remember that these lines changed, for updating the display\n\t    if (change.full)\n\t      regChange(cm);\n\t    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n\t      regLineChange(cm, from.line, \"text\");\n\t    else\n\t      regChange(cm, from.line, to.line + 1, lendiff);\n\t\n\t    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n\t    if (changeHandler || changesHandler) {\n\t      var obj = {\n\t        from: from, to: to,\n\t        text: change.text,\n\t        removed: change.removed,\n\t        origin: change.origin\n\t      };\n\t      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n\t      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n\t    }\n\t    cm.display.selForContextMenu = null;\n\t  }\n\t\n\t  function replaceRange(doc, code, from, to, origin) {\n\t    if (!to) to = from;\n\t    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n\t    if (typeof code == \"string\") code = doc.splitLines(code);\n\t    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n\t  }\n\t\n\t  // SCROLLING THINGS INTO VIEW\n\t\n\t  // If an editor sits on the top or bottom of the window, partially\n\t  // scrolled out of view, this ensures that the cursor is visible.\n\t  function maybeScrollWindow(cm, coords) {\n\t    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\t\n\t    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n\t    if (coords.top + box.top < 0) doScroll = true;\n\t    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\t    if (doScroll != null && !phantom) {\n\t      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n\t                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n\t                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n\t                           coords.left + \"px; width: 2px;\");\n\t      cm.display.lineSpace.appendChild(scrollNode);\n\t      scrollNode.scrollIntoView(doScroll);\n\t      cm.display.lineSpace.removeChild(scrollNode);\n\t    }\n\t  }\n\t\n\t  // Scroll a given position into view (immediately), verifying that\n\t  // it actually became visible (as line heights are accurately\n\t  // measured, the position of something may 'drift' during drawing).\n\t  function scrollPosIntoView(cm, pos, end, margin) {\n\t    if (margin == null) margin = 0;\n\t    for (var limit = 0; limit < 5; limit++) {\n\t      var changed = false, coords = cursorCoords(cm, pos);\n\t      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n\t      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n\t                                         Math.min(coords.top, endCoords.top) - margin,\n\t                                         Math.max(coords.left, endCoords.left),\n\t                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n\t      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n\t      if (scrollPos.scrollTop != null) {\n\t        setScrollTop(cm, scrollPos.scrollTop);\n\t        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n\t      }\n\t      if (scrollPos.scrollLeft != null) {\n\t        setScrollLeft(cm, scrollPos.scrollLeft);\n\t        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n\t      }\n\t      if (!changed) break;\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // Scroll a given set of coordinates into view (immediately).\n\t  function scrollIntoView(cm, x1, y1, x2, y2) {\n\t    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n\t    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n\t    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n\t  }\n\t\n\t  // Calculate a new scroll position needed to scroll the given\n\t  // rectangle into view. Returns an object with scrollTop and\n\t  // scrollLeft properties. When these are undefined, the\n\t  // vertical/horizontal position does not need to be adjusted.\n\t  function calculateScrollPos(cm, x1, y1, x2, y2) {\n\t    var display = cm.display, snapMargin = textHeight(cm.display);\n\t    if (y1 < 0) y1 = 0;\n\t    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n\t    var screen = displayHeight(cm), result = {};\n\t    if (y2 - y1 > screen) y2 = y1 + screen;\n\t    var docBottom = cm.doc.height + paddingVert(display);\n\t    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n\t    if (y1 < screentop) {\n\t      result.scrollTop = atTop ? 0 : y1;\n\t    } else if (y2 > screentop + screen) {\n\t      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n\t      if (newTop != screentop) result.scrollTop = newTop;\n\t    }\n\t\n\t    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n\t    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n\t    var tooWide = x2 - x1 > screenw;\n\t    if (tooWide) x2 = x1 + screenw;\n\t    if (x1 < 10)\n\t      result.scrollLeft = 0;\n\t    else if (x1 < screenleft)\n\t      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n\t    else if (x2 > screenw + screenleft - 3)\n\t      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\t    return result;\n\t  }\n\t\n\t  // Store a relative adjustment to the scroll position in the current\n\t  // operation (to be applied when the operation finishes).\n\t  function addToScrollPos(cm, left, top) {\n\t    if (left != null || top != null) resolveScrollToPos(cm);\n\t    if (left != null)\n\t      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n\t    if (top != null)\n\t      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n\t  }\n\t\n\t  // Make sure that at the end of the operation the current cursor is\n\t  // shown.\n\t  function ensureCursorVisible(cm) {\n\t    resolveScrollToPos(cm);\n\t    var cur = cm.getCursor(), from = cur, to = cur;\n\t    if (!cm.options.lineWrapping) {\n\t      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n\t      to = Pos(cur.line, cur.ch + 1);\n\t    }\n\t    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n\t  }\n\t\n\t  // When an operation has its scrollToPos property set, and another\n\t  // scroll action is applied before the end of the operation, this\n\t  // 'simulates' scrolling that position into view in a cheap way, so\n\t  // that the effect of intermediate scroll commands is not ignored.\n\t  function resolveScrollToPos(cm) {\n\t    var range = cm.curOp.scrollToPos;\n\t    if (range) {\n\t      cm.curOp.scrollToPos = null;\n\t      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n\t      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n\t                                    Math.min(from.top, to.top) - range.margin,\n\t                                    Math.max(from.right, to.right),\n\t                                    Math.max(from.bottom, to.bottom) + range.margin);\n\t      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t    }\n\t  }\n\t\n\t  // API UTILITIES\n\t\n\t  // Indent the given line. The how parameter can be \"smart\",\n\t  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n\t  // (typically set to true for forced single-line indents), empty\n\t  // lines are not indented, and places where the mode returns Pass\n\t  // are left alone.\n\t  function indentLine(cm, n, how, aggressive) {\n\t    var doc = cm.doc, state;\n\t    if (how == null) how = \"add\";\n\t    if (how == \"smart\") {\n\t      // Fall back to \"prev\" when the mode doesn't have an indentation\n\t      // method.\n\t      if (!doc.mode.indent) how = \"prev\";\n\t      else state = getStateBefore(cm, n);\n\t    }\n\t\n\t    var tabSize = cm.options.tabSize;\n\t    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n\t    if (!aggressive && !/\\S/.test(line.text)) {\n\t      indentation = 0;\n\t      how = \"not\";\n\t    } else if (how == \"smart\") {\n\t      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\t      if (indentation == Pass || indentation > 150) {\n\t        if (!aggressive) return;\n\t        how = \"prev\";\n\t      }\n\t    }\n\t    if (how == \"prev\") {\n\t      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n\t      else indentation = 0;\n\t    } else if (how == \"add\") {\n\t      indentation = curSpace + cm.options.indentUnit;\n\t    } else if (how == \"subtract\") {\n\t      indentation = curSpace - cm.options.indentUnit;\n\t    } else if (typeof how == \"number\") {\n\t      indentation = curSpace + how;\n\t    }\n\t    indentation = Math.max(0, indentation);\n\t\n\t    var indentString = \"\", pos = 0;\n\t    if (cm.options.indentWithTabs)\n\t      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n\t    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\t\n\t    if (indentString != curSpaceString) {\n\t      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\t      line.stateAfter = null;\n\t      return true;\n\t    } else {\n\t      // Ensure that, if the cursor was in the whitespace at the start\n\t      // of the line, it is moved to the end of that space.\n\t      for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t        var range = doc.sel.ranges[i];\n\t        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n\t          var pos = Pos(n, curSpaceString.length);\n\t          replaceOneSelection(doc, i, new Range(pos, pos));\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // Utility for applying a change to a line by handle or number,\n\t  // returning the number and optionally registering the line as\n\t  // changed.\n\t  function changeLine(doc, handle, changeType, op) {\n\t    var no = handle, line = handle;\n\t    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n\t    else no = lineNo(handle);\n\t    if (no == null) return null;\n\t    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n\t    return line;\n\t  }\n\t\n\t  // Helper for deleting text near the selection(s), used to implement\n\t  // backspace, delete, and similar functionality.\n\t  function deleteNearSelection(cm, compute) {\n\t    var ranges = cm.doc.sel.ranges, kill = [];\n\t    // Build up a set of ranges to kill first, merging overlapping\n\t    // ranges.\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var toKill = compute(ranges[i]);\n\t      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n\t        var replaced = kill.pop();\n\t        if (cmp(replaced.from, toKill.from) < 0) {\n\t          toKill.from = replaced.from;\n\t          break;\n\t        }\n\t      }\n\t      kill.push(toKill);\n\t    }\n\t    // Next, remove those actual ranges.\n\t    runInOp(cm, function() {\n\t      for (var i = kill.length - 1; i >= 0; i--)\n\t        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n\t      ensureCursorVisible(cm);\n\t    });\n\t  }\n\t\n\t  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n\t  // right), unit can be \"char\", \"column\" (like char, but doesn't\n\t  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n\t  // the start of next group of word or non-word-non-whitespace\n\t  // chars). The visually param controls whether, in right-to-left\n\t  // text, direction 1 means to move towards the next index in the\n\t  // string, or towards the character to the right of the current\n\t  // position. The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosH(doc, pos, dir, unit, visually) {\n\t    var line = pos.line, ch = pos.ch, origDir = dir;\n\t    var lineObj = getLine(doc, line);\n\t    function findNextLine() {\n\t      var l = line + dir;\n\t      if (l < doc.first || l >= doc.first + doc.size) return false\n\t      line = l;\n\t      return lineObj = getLine(doc, l);\n\t    }\n\t    function moveOnce(boundToLine) {\n\t      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\t      if (next == null) {\n\t        if (!boundToLine && findNextLine()) {\n\t          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n\t          else ch = dir < 0 ? lineObj.text.length : 0;\n\t        } else return false\n\t      } else ch = next;\n\t      return true;\n\t    }\n\t\n\t    if (unit == \"char\") {\n\t      moveOnce()\n\t    } else if (unit == \"column\") {\n\t      moveOnce(true)\n\t    } else if (unit == \"word\" || unit == \"group\") {\n\t      var sawType = null, group = unit == \"group\";\n\t      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\t      for (var first = true;; first = false) {\n\t        if (dir < 0 && !moveOnce(!first)) break;\n\t        var cur = lineObj.text.charAt(ch) || \"\\n\";\n\t        var type = isWordChar(cur, helper) ? \"w\"\n\t          : group && cur == \"\\n\" ? \"n\"\n\t          : !group || /\\s/.test(cur) ? null\n\t          : \"p\";\n\t        if (group && !first && !type) type = \"s\";\n\t        if (sawType && sawType != type) {\n\t          if (dir < 0) {dir = 1; moveOnce();}\n\t          break;\n\t        }\n\t\n\t        if (type) sawType = type;\n\t        if (dir > 0 && !moveOnce(!first)) break;\n\t      }\n\t    }\n\t    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n\t    if (!cmp(pos, result)) result.hitSide = true;\n\t    return result;\n\t  }\n\t\n\t  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n\t  // \"page\" or \"line\". The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosV(cm, pos, dir, unit) {\n\t    var doc = cm.doc, x = pos.left, y;\n\t    if (unit == \"page\") {\n\t      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n\t      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n\t    } else if (unit == \"line\") {\n\t      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n\t    }\n\t    for (;;) {\n\t      var target = coordsChar(cm, x, y);\n\t      if (!target.outside) break;\n\t      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n\t      y += dir * 5;\n\t    }\n\t    return target;\n\t  }\n\t\n\t  // EDITOR METHODS\n\t\n\t  // The publicly visible API. Note that methodOp(f) means\n\t  // 'wrap f in an operation, performed on its `this` parameter'.\n\t\n\t  // This is not the complete set of editor methods. Most of the\n\t  // methods defined on the Doc type are also injected into\n\t  // CodeMirror.prototype, for backwards compatibility and\n\t  // convenience.\n\t\n\t  CodeMirror.prototype = {\n\t    constructor: CodeMirror,\n\t    focus: function(){window.focus(); this.display.input.focus();},\n\t\n\t    setOption: function(option, value) {\n\t      var options = this.options, old = options[option];\n\t      if (options[option] == value && option != \"mode\") return;\n\t      options[option] = value;\n\t      if (optionHandlers.hasOwnProperty(option))\n\t        operation(this, optionHandlers[option])(this, value, old);\n\t    },\n\t\n\t    getOption: function(option) {return this.options[option];},\n\t    getDoc: function() {return this.doc;},\n\t\n\t    addKeyMap: function(map, bottom) {\n\t      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n\t    },\n\t    removeKeyMap: function(map) {\n\t      var maps = this.state.keyMaps;\n\t      for (var i = 0; i < maps.length; ++i)\n\t        if (maps[i] == map || maps[i].name == map) {\n\t          maps.splice(i, 1);\n\t          return true;\n\t        }\n\t    },\n\t\n\t    addOverlay: methodOp(function(spec, options) {\n\t      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\t      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n\t      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n\t      this.state.modeGen++;\n\t      regChange(this);\n\t    }),\n\t    removeOverlay: methodOp(function(spec) {\n\t      var overlays = this.state.overlays;\n\t      for (var i = 0; i < overlays.length; ++i) {\n\t        var cur = overlays[i].modeSpec;\n\t        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n\t          overlays.splice(i, 1);\n\t          this.state.modeGen++;\n\t          regChange(this);\n\t          return;\n\t        }\n\t      }\n\t    }),\n\t\n\t    indentLine: methodOp(function(n, dir, aggressive) {\n\t      if (typeof dir != \"string\" && typeof dir != \"number\") {\n\t        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n\t        else dir = dir ? \"add\" : \"subtract\";\n\t      }\n\t      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n\t    }),\n\t    indentSelection: methodOp(function(how) {\n\t      var ranges = this.doc.sel.ranges, end = -1;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (!range.empty()) {\n\t          var from = range.from(), to = range.to();\n\t          var start = Math.max(end, from.line);\n\t          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\t          for (var j = start; j < end; ++j)\n\t            indentLine(this, j, how);\n\t          var newRanges = this.doc.sel.ranges;\n\t          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n\t            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n\t        } else if (range.head.line > end) {\n\t          indentLine(this, range.head.line, how, true);\n\t          end = range.head.line;\n\t          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n\t        }\n\t      }\n\t    }),\n\t\n\t    // Fetch the parser token for a given character. Useful for hacks\n\t    // that want to inspect the mode state (say, for completion).\n\t    getTokenAt: function(pos, precise) {\n\t      return takeToken(this, pos, precise);\n\t    },\n\t\n\t    getLineTokens: function(line, precise) {\n\t      return takeToken(this, Pos(line), precise, true);\n\t    },\n\t\n\t    getTokenTypeAt: function(pos) {\n\t      pos = clipPos(this.doc, pos);\n\t      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n\t      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n\t      var type;\n\t      if (ch == 0) type = styles[2];\n\t      else for (;;) {\n\t        var mid = (before + after) >> 1;\n\t        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n\t        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n\t        else { type = styles[mid * 2 + 2]; break; }\n\t      }\n\t      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n\t      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n\t    },\n\t\n\t    getModeAt: function(pos) {\n\t      var mode = this.doc.mode;\n\t      if (!mode.innerMode) return mode;\n\t      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n\t    },\n\t\n\t    getHelper: function(pos, type) {\n\t      return this.getHelpers(pos, type)[0];\n\t    },\n\t\n\t    getHelpers: function(pos, type) {\n\t      var found = [];\n\t      if (!helpers.hasOwnProperty(type)) return found;\n\t      var help = helpers[type], mode = this.getModeAt(pos);\n\t      if (typeof mode[type] == \"string\") {\n\t        if (help[mode[type]]) found.push(help[mode[type]]);\n\t      } else if (mode[type]) {\n\t        for (var i = 0; i < mode[type].length; i++) {\n\t          var val = help[mode[type][i]];\n\t          if (val) found.push(val);\n\t        }\n\t      } else if (mode.helperType && help[mode.helperType]) {\n\t        found.push(help[mode.helperType]);\n\t      } else if (help[mode.name]) {\n\t        found.push(help[mode.name]);\n\t      }\n\t      for (var i = 0; i < help._global.length; i++) {\n\t        var cur = help._global[i];\n\t        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n\t          found.push(cur.val);\n\t      }\n\t      return found;\n\t    },\n\t\n\t    getStateAfter: function(line, precise) {\n\t      var doc = this.doc;\n\t      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n\t      return getStateBefore(this, line + 1, precise);\n\t    },\n\t\n\t    cursorCoords: function(start, mode) {\n\t      var pos, range = this.doc.sel.primary();\n\t      if (start == null) pos = range.head;\n\t      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n\t      else pos = start ? range.from() : range.to();\n\t      return cursorCoords(this, pos, mode || \"page\");\n\t    },\n\t\n\t    charCoords: function(pos, mode) {\n\t      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n\t    },\n\t\n\t    coordsChar: function(coords, mode) {\n\t      coords = fromCoordSystem(this, coords, mode || \"page\");\n\t      return coordsChar(this, coords.left, coords.top);\n\t    },\n\t\n\t    lineAtHeight: function(height, mode) {\n\t      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n\t      return lineAtHeight(this.doc, height + this.display.viewOffset);\n\t    },\n\t    heightAtLine: function(line, mode) {\n\t      var end = false, lineObj;\n\t      if (typeof line == \"number\") {\n\t        var last = this.doc.first + this.doc.size - 1;\n\t        if (line < this.doc.first) line = this.doc.first;\n\t        else if (line > last) { line = last; end = true; }\n\t        lineObj = getLine(this.doc, line);\n\t      } else {\n\t        lineObj = line;\n\t      }\n\t      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n\t        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n\t    },\n\t\n\t    defaultTextHeight: function() { return textHeight(this.display); },\n\t    defaultCharWidth: function() { return charWidth(this.display); },\n\t\n\t    setGutterMarker: methodOp(function(line, gutterID, value) {\n\t      return changeLine(this.doc, line, \"gutter\", function(line) {\n\t        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n\t        markers[gutterID] = value;\n\t        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    clearGutter: methodOp(function(gutterID) {\n\t      var cm = this, doc = cm.doc, i = doc.first;\n\t      doc.iter(function(line) {\n\t        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n\t          line.gutterMarkers[gutterID] = null;\n\t          regLineChange(cm, i, \"gutter\");\n\t          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n\t        }\n\t        ++i;\n\t      });\n\t    }),\n\t\n\t    lineInfo: function(line) {\n\t      if (typeof line == \"number\") {\n\t        if (!isLine(this.doc, line)) return null;\n\t        var n = line;\n\t        line = getLine(this.doc, line);\n\t        if (!line) return null;\n\t      } else {\n\t        var n = lineNo(line);\n\t        if (n == null) return null;\n\t      }\n\t      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n\t              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n\t              widgets: line.widgets};\n\t    },\n\t\n\t    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\t\n\t    addWidget: function(pos, node, scroll, vert, horiz) {\n\t      var display = this.display;\n\t      pos = cursorCoords(this, clipPos(this.doc, pos));\n\t      var top = pos.bottom, left = pos.left;\n\t      node.style.position = \"absolute\";\n\t      node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      this.display.input.setUneditable(node);\n\t      display.sizer.appendChild(node);\n\t      if (vert == \"over\") {\n\t        top = pos.top;\n\t      } else if (vert == \"above\" || vert == \"near\") {\n\t        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n\t        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n\t        // Default to positioning above (if specified and possible); otherwise default to positioning below\n\t        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n\t          top = pos.top - node.offsetHeight;\n\t        else if (pos.bottom + node.offsetHeight <= vspace)\n\t          top = pos.bottom;\n\t        if (left + node.offsetWidth > hspace)\n\t          left = hspace - node.offsetWidth;\n\t      }\n\t      node.style.top = top + \"px\";\n\t      node.style.left = node.style.right = \"\";\n\t      if (horiz == \"right\") {\n\t        left = display.sizer.clientWidth - node.offsetWidth;\n\t        node.style.right = \"0px\";\n\t      } else {\n\t        if (horiz == \"left\") left = 0;\n\t        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n\t        node.style.left = left + \"px\";\n\t      }\n\t      if (scroll)\n\t        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n\t    },\n\t\n\t    triggerOnKeyDown: methodOp(onKeyDown),\n\t    triggerOnKeyPress: methodOp(onKeyPress),\n\t    triggerOnKeyUp: onKeyUp,\n\t\n\t    execCommand: function(cmd) {\n\t      if (commands.hasOwnProperty(cmd))\n\t        return commands[cmd].call(null, this);\n\t    },\n\t\n\t    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\t\n\t    findPosH: function(from, amount, unit, visually) {\n\t      var dir = 1;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        cur = findPosH(this.doc, cur, dir, unit, visually);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveH: methodOp(function(dir, unit) {\n\t      var cm = this;\n\t      cm.extendSelectionsBy(function(range) {\n\t        if (cm.display.shift || cm.doc.extend || range.empty())\n\t          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n\t        else\n\t          return dir < 0 ? range.from() : range.to();\n\t      }, sel_move);\n\t    }),\n\t\n\t    deleteH: methodOp(function(dir, unit) {\n\t      var sel = this.doc.sel, doc = this.doc;\n\t      if (sel.somethingSelected())\n\t        doc.replaceSelection(\"\", null, \"+delete\");\n\t      else\n\t        deleteNearSelection(this, function(range) {\n\t          var other = findPosH(doc, range.head, dir, unit, false);\n\t          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n\t        });\n\t    }),\n\t\n\t    findPosV: function(from, amount, unit, goalColumn) {\n\t      var dir = 1, x = goalColumn;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        var coords = cursorCoords(this, cur, \"div\");\n\t        if (x == null) x = coords.left;\n\t        else coords.left = x;\n\t        cur = findPosV(this, coords, dir, unit);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveV: methodOp(function(dir, unit) {\n\t      var cm = this, doc = this.doc, goals = [];\n\t      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n\t      doc.extendSelectionsBy(function(range) {\n\t        if (collapse)\n\t          return dir < 0 ? range.from() : range.to();\n\t        var headPos = cursorCoords(cm, range.head, \"div\");\n\t        if (range.goalColumn != null) headPos.left = range.goalColumn;\n\t        goals.push(headPos.left);\n\t        var pos = findPosV(cm, headPos, dir, unit);\n\t        if (unit == \"page\" && range == doc.sel.primary())\n\t          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n\t        return pos;\n\t      }, sel_move);\n\t      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n\t        doc.sel.ranges[i].goalColumn = goals[i];\n\t    }),\n\t\n\t    // Find the word at the given position (as returned by coordsChar).\n\t    findWordAt: function(pos) {\n\t      var doc = this.doc, line = getLine(doc, pos.line).text;\n\t      var start = pos.ch, end = pos.ch;\n\t      if (line) {\n\t        var helper = this.getHelper(pos, \"wordChars\");\n\t        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n\t        var startChar = line.charAt(start);\n\t        var check = isWordChar(startChar, helper)\n\t          ? function(ch) { return isWordChar(ch, helper); }\n\t          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n\t          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n\t        while (start > 0 && check(line.charAt(start - 1))) --start;\n\t        while (end < line.length && check(line.charAt(end))) ++end;\n\t      }\n\t      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n\t    },\n\t\n\t    toggleOverwrite: function(value) {\n\t      if (value != null && value == this.state.overwrite) return;\n\t      if (this.state.overwrite = !this.state.overwrite)\n\t        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t      else\n\t        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t\n\t      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n\t    },\n\t    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\t    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\t\n\t    scrollTo: methodOp(function(x, y) {\n\t      if (x != null || y != null) resolveScrollToPos(this);\n\t      if (x != null) this.curOp.scrollLeft = x;\n\t      if (y != null) this.curOp.scrollTop = y;\n\t    }),\n\t    getScrollInfo: function() {\n\t      var scroller = this.display.scroller;\n\t      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n\t              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n\t              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n\t              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n\t    },\n\t\n\t    scrollIntoView: methodOp(function(range, margin) {\n\t      if (range == null) {\n\t        range = {from: this.doc.sel.primary().head, to: null};\n\t        if (margin == null) margin = this.options.cursorScrollMargin;\n\t      } else if (typeof range == \"number\") {\n\t        range = {from: Pos(range, 0), to: null};\n\t      } else if (range.from == null) {\n\t        range = {from: range, to: null};\n\t      }\n\t      if (!range.to) range.to = range.from;\n\t      range.margin = margin || 0;\n\t\n\t      if (range.from.line != null) {\n\t        resolveScrollToPos(this);\n\t        this.curOp.scrollToPos = range;\n\t      } else {\n\t        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n\t                                      Math.min(range.from.top, range.to.top) - range.margin,\n\t                                      Math.max(range.from.right, range.to.right),\n\t                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n\t        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t      }\n\t    }),\n\t\n\t    setSize: methodOp(function(width, height) {\n\t      var cm = this;\n\t      function interpret(val) {\n\t        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n\t      }\n\t      if (width != null) cm.display.wrapper.style.width = interpret(width);\n\t      if (height != null) cm.display.wrapper.style.height = interpret(height);\n\t      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n\t      var lineNo = cm.display.viewFrom;\n\t      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n\t        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n\t          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n\t        ++lineNo;\n\t      });\n\t      cm.curOp.forceUpdate = true;\n\t      signal(cm, \"refresh\", this);\n\t    }),\n\t\n\t    operation: function(f){return runInOp(this, f);},\n\t\n\t    refresh: methodOp(function() {\n\t      var oldHeight = this.display.cachedTextHeight;\n\t      regChange(this);\n\t      this.curOp.forceUpdate = true;\n\t      clearCaches(this);\n\t      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n\t      updateGutterSpace(this);\n\t      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n\t        estimateLineHeights(this);\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    swapDoc: methodOp(function(doc) {\n\t      var old = this.doc;\n\t      old.cm = null;\n\t      attachDoc(this, doc);\n\t      clearCaches(this);\n\t      this.display.input.reset();\n\t      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n\t      this.curOp.forceScroll = true;\n\t      signalLater(this, \"swapDoc\", this, old);\n\t      return old;\n\t    }),\n\t\n\t    getInputField: function(){return this.display.input.getField();},\n\t    getWrapperElement: function(){return this.display.wrapper;},\n\t    getScrollerElement: function(){return this.display.scroller;},\n\t    getGutterElement: function(){return this.display.gutters;}\n\t  };\n\t  eventMixin(CodeMirror);\n\t\n\t  // OPTION DEFAULTS\n\t\n\t  // The default configuration options.\n\t  var defaults = CodeMirror.defaults = {};\n\t  // Functions to run when options are changed.\n\t  var optionHandlers = CodeMirror.optionHandlers = {};\n\t\n\t  function option(name, deflt, handle, notOnInit) {\n\t    CodeMirror.defaults[name] = deflt;\n\t    if (handle) optionHandlers[name] =\n\t      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n\t  }\n\t\n\t  // Passed to option handlers when there is no old value.\n\t  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\t\n\t  // These two are, on init, called from the constructor because they\n\t  // have to be initialized before the editor can start at all.\n\t  option(\"value\", \"\", function(cm, val) {\n\t    cm.setValue(val);\n\t  }, true);\n\t  option(\"mode\", null, function(cm, val) {\n\t    cm.doc.modeOption = val;\n\t    loadMode(cm);\n\t  }, true);\n\t\n\t  option(\"indentUnit\", 2, loadMode, true);\n\t  option(\"indentWithTabs\", false);\n\t  option(\"smartIndent\", true);\n\t  option(\"tabSize\", 4, function(cm) {\n\t    resetModeState(cm);\n\t    clearCaches(cm);\n\t    regChange(cm);\n\t  }, true);\n\t  option(\"lineSeparator\", null, function(cm, val) {\n\t    cm.doc.lineSep = val;\n\t    if (!val) return;\n\t    var newBreaks = [], lineNo = cm.doc.first;\n\t    cm.doc.iter(function(line) {\n\t      for (var pos = 0;;) {\n\t        var found = line.text.indexOf(val, pos);\n\t        if (found == -1) break;\n\t        pos = found + val.length;\n\t        newBreaks.push(Pos(lineNo, found));\n\t      }\n\t      lineNo++;\n\t    });\n\t    for (var i = newBreaks.length - 1; i >= 0; i--)\n\t      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n\t  });\n\t  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n\t    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\t    if (old != CodeMirror.Init) cm.refresh();\n\t  });\n\t  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n\t  option(\"electricChars\", true);\n\t  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n\t    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n\t  }, true);\n\t  option(\"rtlMoveVisually\", !windows);\n\t  option(\"wholeLineUpdateBefore\", true);\n\t\n\t  option(\"theme\", \"default\", function(cm) {\n\t    themeChanged(cm);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"keyMap\", \"default\", function(cm, val, old) {\n\t    var next = getKeyMap(val);\n\t    var prev = old != CodeMirror.Init && getKeyMap(old);\n\t    if (prev && prev.detach) prev.detach(cm, next);\n\t    if (next.attach) next.attach(cm, prev || null);\n\t  });\n\t  option(\"extraKeys\", null);\n\t\n\t  option(\"lineWrapping\", false, wrappingChanged, true);\n\t  option(\"gutters\", [], function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"fixedGutter\", true, function(cm, val) {\n\t    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n\t  option(\"scrollbarStyle\", \"native\", function(cm) {\n\t    initScrollbars(cm);\n\t    updateScrollbars(cm);\n\t    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n\t    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n\t  }, true);\n\t  option(\"lineNumbers\", false, function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"firstLineNumber\", 1, guttersChanged, true);\n\t  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n\t  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\t\n\t  option(\"resetSelectionOnContextMenu\", true);\n\t  option(\"lineWiseCopyCut\", true);\n\t\n\t  option(\"readOnly\", false, function(cm, val) {\n\t    if (val == \"nocursor\") {\n\t      onBlur(cm);\n\t      cm.display.input.blur();\n\t      cm.display.disabled = true;\n\t    } else {\n\t      cm.display.disabled = false;\n\t    }\n\t    cm.display.input.readOnlyChanged(val)\n\t  });\n\t  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n\t  option(\"dragDrop\", true, dragDropChanged);\n\t  option(\"allowDropFileTypes\", null);\n\t\n\t  option(\"cursorBlinkRate\", 530);\n\t  option(\"cursorScrollMargin\", 0);\n\t  option(\"cursorHeight\", 1, updateSelection, true);\n\t  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n\t  option(\"workTime\", 100);\n\t  option(\"workDelay\", 100);\n\t  option(\"flattenSpans\", true, resetModeState, true);\n\t  option(\"addModeClass\", false, resetModeState, true);\n\t  option(\"pollInterval\", 100);\n\t  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n\t  option(\"historyEventDelay\", 1250);\n\t  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\t  option(\"maxHighlightLength\", 10000, resetModeState, true);\n\t  option(\"moveInputWithCursor\", true, function(cm, val) {\n\t    if (!val) cm.display.input.resetPosition();\n\t  });\n\t\n\t  option(\"tabindex\", null, function(cm, val) {\n\t    cm.display.input.getField().tabIndex = val || \"\";\n\t  });\n\t  option(\"autofocus\", null);\n\t\n\t  // MODE DEFINITION AND QUERYING\n\t\n\t  // Known modes, by name and by MIME\n\t  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\t\n\t  // Extra arguments are stored as the mode's dependencies, which is\n\t  // used by (legacy) mechanisms like loadmode.js to automatically\n\t  // load a mode. (Preferred mechanism is the require/define calls.)\n\t  CodeMirror.defineMode = function(name, mode) {\n\t    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\t    if (arguments.length > 2)\n\t      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n\t    modes[name] = mode;\n\t  };\n\t\n\t  CodeMirror.defineMIME = function(mime, spec) {\n\t    mimeModes[mime] = spec;\n\t  };\n\t\n\t  // Given a MIME type, a {name, ...options} config object, or a name\n\t  // string, return a mode config object.\n\t  CodeMirror.resolveMode = function(spec) {\n\t    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n\t      spec = mimeModes[spec];\n\t    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n\t      var found = mimeModes[spec.name];\n\t      if (typeof found == \"string\") found = {name: found};\n\t      spec = createObj(found, spec);\n\t      spec.name = found.name;\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/xml\");\n\t    }\n\t    if (typeof spec == \"string\") return {name: spec};\n\t    else return spec || {name: \"null\"};\n\t  };\n\t\n\t  // Given a mode spec (anything that resolveMode accepts), find and\n\t  // initialize an actual mode object.\n\t  CodeMirror.getMode = function(options, spec) {\n\t    var spec = CodeMirror.resolveMode(spec);\n\t    var mfactory = modes[spec.name];\n\t    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n\t    var modeObj = mfactory(options, spec);\n\t    if (modeExtensions.hasOwnProperty(spec.name)) {\n\t      var exts = modeExtensions[spec.name];\n\t      for (var prop in exts) {\n\t        if (!exts.hasOwnProperty(prop)) continue;\n\t        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n\t        modeObj[prop] = exts[prop];\n\t      }\n\t    }\n\t    modeObj.name = spec.name;\n\t    if (spec.helperType) modeObj.helperType = spec.helperType;\n\t    if (spec.modeProps) for (var prop in spec.modeProps)\n\t      modeObj[prop] = spec.modeProps[prop];\n\t\n\t    return modeObj;\n\t  };\n\t\n\t  // Minimal default mode.\n\t  CodeMirror.defineMode(\"null\", function() {\n\t    return {token: function(stream) {stream.skipToEnd();}};\n\t  });\n\t  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\t\n\t  // This can be used to attach properties to mode objects from\n\t  // outside the actual mode definition.\n\t  var modeExtensions = CodeMirror.modeExtensions = {};\n\t  CodeMirror.extendMode = function(mode, properties) {\n\t    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n\t    copyObj(properties, exts);\n\t  };\n\t\n\t  // EXTENSIONS\n\t\n\t  CodeMirror.defineExtension = function(name, func) {\n\t    CodeMirror.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineDocExtension = function(name, func) {\n\t    Doc.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineOption = option;\n\t\n\t  var initHooks = [];\n\t  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\t\n\t  var helpers = CodeMirror.helpers = {};\n\t  CodeMirror.registerHelper = function(type, name, value) {\n\t    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n\t    helpers[type][name] = value;\n\t  };\n\t  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n\t    CodeMirror.registerHelper(type, name, value);\n\t    helpers[type]._global.push({pred: predicate, val: value});\n\t  };\n\t\n\t  // MODE STATE HANDLING\n\t\n\t  // Utility functions for working with state. Exported because nested\n\t  // modes need to do this for their inner modes.\n\t\n\t  var copyState = CodeMirror.copyState = function(mode, state) {\n\t    if (state === true) return state;\n\t    if (mode.copyState) return mode.copyState(state);\n\t    var nstate = {};\n\t    for (var n in state) {\n\t      var val = state[n];\n\t      if (val instanceof Array) val = val.concat([]);\n\t      nstate[n] = val;\n\t    }\n\t    return nstate;\n\t  };\n\t\n\t  var startState = CodeMirror.startState = function(mode, a1, a2) {\n\t    return mode.startState ? mode.startState(a1, a2) : true;\n\t  };\n\t\n\t  // Given a mode and a state (for that mode), find the inner mode and\n\t  // state at the position that the state refers to.\n\t  CodeMirror.innerMode = function(mode, state) {\n\t    while (mode.innerMode) {\n\t      var info = mode.innerMode(state);\n\t      if (!info || info.mode == mode) break;\n\t      state = info.state;\n\t      mode = info.mode;\n\t    }\n\t    return info || {mode: mode, state: state};\n\t  };\n\t\n\t  // STANDARD COMMANDS\n\t\n\t  // Commands are parameter-less actions that can be performed on an\n\t  // editor, mostly used for keybindings.\n\t  var commands = CodeMirror.commands = {\n\t    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n\t    singleSelection: function(cm) {\n\t      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n\t    },\n\t    killLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        if (range.empty()) {\n\t          var len = getLine(cm.doc, range.head.line).text.length;\n\t          if (range.head.ch == len && range.head.line < cm.lastLine())\n\t            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n\t          else\n\t            return {from: range.head, to: Pos(range.head.line, len)};\n\t        } else {\n\t          return {from: range.from(), to: range.to()};\n\t        }\n\t      });\n\t    },\n\t    deleteLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0),\n\t                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n\t      });\n\t    },\n\t    delLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0), to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        return {from: leftPos, to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineRight: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t        return {from: range.from(), to: rightPos };\n\t      });\n\t    },\n\t    undo: function(cm) {cm.undo();},\n\t    redo: function(cm) {cm.redo();},\n\t    undoSelection: function(cm) {cm.undoSelection();},\n\t    redoSelection: function(cm) {cm.redoSelection();},\n\t    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n\t    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n\t    goLineStart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineStartSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        return lineStartSmart(cm, range.head);\n\t      }, {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineEnd: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: -1});\n\t    },\n\t    goLineRight: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeft: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: 0, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeftSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n\t        return pos;\n\t      }, sel_move);\n\t    },\n\t    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n\t    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n\t    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n\t    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n\t    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n\t    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n\t    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n\t    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n\t    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n\t    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n\t    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n\t    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n\t    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n\t    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n\t    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n\t    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n\t    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n\t    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n\t    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n\t    indentMore: function(cm) {cm.indentSelection(\"add\");},\n\t    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n\t    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n\t    insertSoftTab: function(cm) {\n\t      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var pos = ranges[i].from();\n\t        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n\t        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n\t      }\n\t      cm.replaceSelections(spaces);\n\t    },\n\t    defaultTab: function(cm) {\n\t      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n\t      else cm.execCommand(\"insertTab\");\n\t    },\n\t    transposeChars: function(cm) {\n\t      runInOp(cm, function() {\n\t        var ranges = cm.listSelections(), newSel = [];\n\t        for (var i = 0; i < ranges.length; i++) {\n\t          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n\t          if (line) {\n\t            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n\t            if (cur.ch > 0) {\n\t              cur = new Pos(cur.line, cur.ch + 1);\n\t              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n\t                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n\t            } else if (cur.line > cm.doc.first) {\n\t              var prev = getLine(cm.doc, cur.line - 1).text;\n\t              if (prev)\n\t                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n\t                                prev.charAt(prev.length - 1),\n\t                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n\t            }\n\t          }\n\t          newSel.push(new Range(cur, cur));\n\t        }\n\t        cm.setSelections(newSel);\n\t      });\n\t    },\n\t    newlineAndIndent: function(cm) {\n\t      runInOp(cm, function() {\n\t        var len = cm.listSelections().length;\n\t        for (var i = 0; i < len; i++) {\n\t          var range = cm.listSelections()[i];\n\t          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n\t          cm.indentLine(range.from().line + 1, null, true);\n\t        }\n\t        ensureCursorVisible(cm);\n\t      });\n\t    },\n\t    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n\t  };\n\t\n\t\n\t  // STANDARD KEYMAPS\n\t\n\t  var keyMap = CodeMirror.keyMap = {};\n\t\n\t  keyMap.basic = {\n\t    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n\t    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n\t    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n\t    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n\t    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n\t    \"Esc\": \"singleSelection\"\n\t  };\n\t  // Note that the save and find-related commands aren't defined by\n\t  // default. User code or addons can define them. Unknown commands\n\t  // are simply ignored.\n\t  keyMap.pcDefault = {\n\t    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n\t    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n\t    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n\t    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n\t    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n\t    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n\t    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n\t    fallthrough: \"basic\"\n\t  };\n\t  // Very basic readline/emacs-style bindings, which are standard on Mac.\n\t  keyMap.emacsy = {\n\t    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n\t    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n\t    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n\t    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n\t  };\n\t  keyMap.macDefault = {\n\t    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n\t    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n\t    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n\t    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n\t    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n\t    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n\t    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n\t    fallthrough: [\"basic\", \"emacsy\"]\n\t  };\n\t  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\t\n\t  // KEYMAP DISPATCH\n\t\n\t  function normalizeKeyName(name) {\n\t    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n\t    var alt, ctrl, shift, cmd;\n\t    for (var i = 0; i < parts.length - 1; i++) {\n\t      var mod = parts[i];\n\t      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n\t      else if (/^a(lt)?$/i.test(mod)) alt = true;\n\t      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n\t      else if (/^s(hift)$/i.test(mod)) shift = true;\n\t      else throw new Error(\"Unrecognized modifier name: \" + mod);\n\t    }\n\t    if (alt) name = \"Alt-\" + name;\n\t    if (ctrl) name = \"Ctrl-\" + name;\n\t    if (cmd) name = \"Cmd-\" + name;\n\t    if (shift) name = \"Shift-\" + name;\n\t    return name;\n\t  }\n\t\n\t  // This is a kludge to keep keymaps mostly working as raw objects\n\t  // (backwards compatibility) while at the same time support features\n\t  // like normalization and multi-stroke key bindings. It compiles a\n\t  // new normalized keymap, and then updates the old object to reflect\n\t  // this.\n\t  CodeMirror.normalizeKeyMap = function(keymap) {\n\t    var copy = {};\n\t    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n\t      var value = keymap[keyname];\n\t      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n\t      if (value == \"...\") { delete keymap[keyname]; continue; }\n\t\n\t      var keys = map(keyname.split(\" \"), normalizeKeyName);\n\t      for (var i = 0; i < keys.length; i++) {\n\t        var val, name;\n\t        if (i == keys.length - 1) {\n\t          name = keys.join(\" \");\n\t          val = value;\n\t        } else {\n\t          name = keys.slice(0, i + 1).join(\" \");\n\t          val = \"...\";\n\t        }\n\t        var prev = copy[name];\n\t        if (!prev) copy[name] = val;\n\t        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n\t      }\n\t      delete keymap[keyname];\n\t    }\n\t    for (var prop in copy) keymap[prop] = copy[prop];\n\t    return keymap;\n\t  };\n\t\n\t  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n\t    map = getKeyMap(map);\n\t    var found = map.call ? map.call(key, context) : map[key];\n\t    if (found === false) return \"nothing\";\n\t    if (found === \"...\") return \"multi\";\n\t    if (found != null && handle(found)) return \"handled\";\n\t\n\t    if (map.fallthrough) {\n\t      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n\t        return lookupKey(key, map.fallthrough, handle, context);\n\t      for (var i = 0; i < map.fallthrough.length; i++) {\n\t        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\t        if (result) return result;\n\t      }\n\t    }\n\t  };\n\t\n\t  // Modifier key presses don't count as 'real' key presses for the\n\t  // purpose of keymap fallthrough.\n\t  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n\t    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n\t    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n\t  };\n\t\n\t  // Look up the name of a key as indicated by an event object.\n\t  var keyName = CodeMirror.keyName = function(event, noShift) {\n\t    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n\t    var base = keyNames[event.keyCode], name = base;\n\t    if (name == null || event.altGraphKey) return false;\n\t    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n\t    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n\t    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n\t    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n\t    return name;\n\t  };\n\t\n\t  function getKeyMap(val) {\n\t    return typeof val == \"string\" ? keyMap[val] : val;\n\t  }\n\t\n\t  // FROMTEXTAREA\n\t\n\t  CodeMirror.fromTextArea = function(textarea, options) {\n\t    options = options ? copyObj(options) : {};\n\t    options.value = textarea.value;\n\t    if (!options.tabindex && textarea.tabIndex)\n\t      options.tabindex = textarea.tabIndex;\n\t    if (!options.placeholder && textarea.placeholder)\n\t      options.placeholder = textarea.placeholder;\n\t    // Set autofocus to true if this textarea is focused, or if it has\n\t    // autofocus and no other element is focused.\n\t    if (options.autofocus == null) {\n\t      var hasFocus = activeElt();\n\t      options.autofocus = hasFocus == textarea ||\n\t        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n\t    }\n\t\n\t    function save() {textarea.value = cm.getValue();}\n\t    if (textarea.form) {\n\t      on(textarea.form, \"submit\", save);\n\t      // Deplorable hack to make the submit method do the right thing.\n\t      if (!options.leaveSubmitMethodAlone) {\n\t        var form = textarea.form, realSubmit = form.submit;\n\t        try {\n\t          var wrappedSubmit = form.submit = function() {\n\t            save();\n\t            form.submit = realSubmit;\n\t            form.submit();\n\t            form.submit = wrappedSubmit;\n\t          };\n\t        } catch(e) {}\n\t      }\n\t    }\n\t\n\t    options.finishInit = function(cm) {\n\t      cm.save = save;\n\t      cm.getTextArea = function() { return textarea; };\n\t      cm.toTextArea = function() {\n\t        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\t        save();\n\t        textarea.parentNode.removeChild(cm.getWrapperElement());\n\t        textarea.style.display = \"\";\n\t        if (textarea.form) {\n\t          off(textarea.form, \"submit\", save);\n\t          if (typeof textarea.form.submit == \"function\")\n\t            textarea.form.submit = realSubmit;\n\t        }\n\t      };\n\t    };\n\t\n\t    textarea.style.display = \"none\";\n\t    var cm = CodeMirror(function(node) {\n\t      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n\t    }, options);\n\t    return cm;\n\t  };\n\t\n\t  // STRING STREAM\n\t\n\t  // Fed to the mode parsers, provides helper functions to make\n\t  // parsers more succinct.\n\t\n\t  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n\t    this.pos = this.start = 0;\n\t    this.string = string;\n\t    this.tabSize = tabSize || 8;\n\t    this.lastColumnPos = this.lastColumnValue = 0;\n\t    this.lineStart = 0;\n\t  };\n\t\n\t  StringStream.prototype = {\n\t    eol: function() {return this.pos >= this.string.length;},\n\t    sol: function() {return this.pos == this.lineStart;},\n\t    peek: function() {return this.string.charAt(this.pos) || undefined;},\n\t    next: function() {\n\t      if (this.pos < this.string.length)\n\t        return this.string.charAt(this.pos++);\n\t    },\n\t    eat: function(match) {\n\t      var ch = this.string.charAt(this.pos);\n\t      if (typeof match == \"string\") var ok = ch == match;\n\t      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\t      if (ok) {++this.pos; return ch;}\n\t    },\n\t    eatWhile: function(match) {\n\t      var start = this.pos;\n\t      while (this.eat(match)){}\n\t      return this.pos > start;\n\t    },\n\t    eatSpace: function() {\n\t      var start = this.pos;\n\t      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\t      return this.pos > start;\n\t    },\n\t    skipToEnd: function() {this.pos = this.string.length;},\n\t    skipTo: function(ch) {\n\t      var found = this.string.indexOf(ch, this.pos);\n\t      if (found > -1) {this.pos = found; return true;}\n\t    },\n\t    backUp: function(n) {this.pos -= n;},\n\t    column: function() {\n\t      if (this.lastColumnPos < this.start) {\n\t        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n\t        this.lastColumnPos = this.start;\n\t      }\n\t      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    indentation: function() {\n\t      return countColumn(this.string, null, this.tabSize) -\n\t        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    match: function(pattern, consume, caseInsensitive) {\n\t      if (typeof pattern == \"string\") {\n\t        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n\t        var substr = this.string.substr(this.pos, pattern.length);\n\t        if (cased(substr) == cased(pattern)) {\n\t          if (consume !== false) this.pos += pattern.length;\n\t          return true;\n\t        }\n\t      } else {\n\t        var match = this.string.slice(this.pos).match(pattern);\n\t        if (match && match.index > 0) return null;\n\t        if (match && consume !== false) this.pos += match[0].length;\n\t        return match;\n\t      }\n\t    },\n\t    current: function(){return this.string.slice(this.start, this.pos);},\n\t    hideFirstChars: function(n, inner) {\n\t      this.lineStart += n;\n\t      try { return inner(); }\n\t      finally { this.lineStart -= n; }\n\t    }\n\t  };\n\t\n\t  // TEXTMARKERS\n\t\n\t  // Created with markText and setBookmark methods. A TextMarker is a\n\t  // handle that can be used to clear or find a marked position in the\n\t  // document. Line objects hold arrays (markedSpans) containing\n\t  // {from, to, marker} object pointing to such marker objects, and\n\t  // indicating that such a marker is present on that line. Multiple\n\t  // lines may point to the same marker when it spans across lines.\n\t  // The spans will have null for their from/to properties when the\n\t  // marker continues beyond the start/end of the line. Markers have\n\t  // links back to the lines they currently touch.\n\t\n\t  var nextMarkerId = 0;\n\t\n\t  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n\t    this.lines = [];\n\t    this.type = type;\n\t    this.doc = doc;\n\t    this.id = ++nextMarkerId;\n\t  };\n\t  eventMixin(TextMarker);\n\t\n\t  // Clear the marker.\n\t  TextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    if (hasHandler(this, \"clear\")) {\n\t      var found = this.find();\n\t      if (found) signalLater(this, \"clear\", found.from, found.to);\n\t    }\n\t    var min = null, max = null;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n\t      else if (cm) {\n\t        if (span.to != null) max = lineNo(line);\n\t        if (span.from != null) min = lineNo(line);\n\t      }\n\t      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\t      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n\t        updateLineHeight(line, textHeight(cm.display));\n\t    }\n\t    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n\t      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n\t      if (len > cm.display.maxLineLength) {\n\t        cm.display.maxLine = visual;\n\t        cm.display.maxLineLength = len;\n\t        cm.display.maxLineChanged = true;\n\t      }\n\t    }\n\t\n\t    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n\t    this.lines.length = 0;\n\t    this.explicitlyCleared = true;\n\t    if (this.atomic && this.doc.cantEdit) {\n\t      this.doc.cantEdit = false;\n\t      if (cm) reCheckSelection(cm.doc);\n\t    }\n\t    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n\t    if (withOp) endOperation(cm);\n\t    if (this.parent) this.parent.clear();\n\t  };\n\t\n\t  // Find the position of the marker in the document. Returns a {from,\n\t  // to} object by default. Side can be passed to get a specific side\n\t  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n\t  // Pos objects returned contain a line object, rather than a line\n\t  // number (used to prevent looking up the same line twice).\n\t  TextMarker.prototype.find = function(side, lineObj) {\n\t    if (side == null && this.type == \"bookmark\") side = 1;\n\t    var from, to;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.from != null) {\n\t        from = Pos(lineObj ? line : lineNo(line), span.from);\n\t        if (side == -1) return from;\n\t      }\n\t      if (span.to != null) {\n\t        to = Pos(lineObj ? line : lineNo(line), span.to);\n\t        if (side == 1) return to;\n\t      }\n\t    }\n\t    return from && {from: from, to: to};\n\t  };\n\t\n\t  // Signals that the marker's widget changed, and surrounding layout\n\t  // should be recomputed.\n\t  TextMarker.prototype.changed = function() {\n\t    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n\t    if (!pos || !cm) return;\n\t    runInOp(cm, function() {\n\t      var line = pos.line, lineN = lineNo(pos.line);\n\t      var view = findViewForLine(cm, lineN);\n\t      if (view) {\n\t        clearLineMeasurementCacheFor(view);\n\t        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n\t      }\n\t      cm.curOp.updateMaxLine = true;\n\t      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n\t        var oldHeight = widget.height;\n\t        widget.height = null;\n\t        var dHeight = widgetHeight(widget) - oldHeight;\n\t        if (dHeight)\n\t          updateLineHeight(line, line.height + dHeight);\n\t      }\n\t    });\n\t  };\n\t\n\t  TextMarker.prototype.attachLine = function(line) {\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n\t        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n\t    }\n\t    this.lines.push(line);\n\t  };\n\t  TextMarker.prototype.detachLine = function(line) {\n\t    this.lines.splice(indexOf(this.lines, line), 1);\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n\t    }\n\t  };\n\t\n\t  // Collapsed markers have unique ids, in order to be able to order\n\t  // them, which is needed for uniquely determining an outer marker\n\t  // when they overlap (they may nest, but not partially overlap).\n\t  var nextMarkerId = 0;\n\t\n\t  // Create a marker, wire it up to the right lines, and\n\t  function markText(doc, from, to, options, type) {\n\t    // Shared markers (across linked documents) are handled separately\n\t    // (markTextShared will call out to this again, once per\n\t    // document).\n\t    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n\t    // Ensure we are in an operation.\n\t    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\t\n\t    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n\t    if (options) copyObj(options, marker, false);\n\t    // Don't connect empty markers unless clearWhenEmpty is false\n\t    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n\t      return marker;\n\t    if (marker.replacedWith) {\n\t      // Showing up as a widget implies collapsed (widget replaces text)\n\t      marker.collapsed = true;\n\t      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\t      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n\t      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n\t    }\n\t    if (marker.collapsed) {\n\t      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n\t          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n\t        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n\t      sawCollapsedSpans = true;\n\t    }\n\t\n\t    if (marker.addToHistory)\n\t      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\t\n\t    var curLine = from.line, cm = doc.cm, updateMaxLine;\n\t    doc.iter(curLine, to.line + 1, function(line) {\n\t      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n\t        updateMaxLine = true;\n\t      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n\t      addMarkedSpan(line, new MarkedSpan(marker,\n\t                                         curLine == from.line ? from.ch : null,\n\t                                         curLine == to.line ? to.ch : null));\n\t      ++curLine;\n\t    });\n\t    // lineIsHidden depends on the presence of the spans, so needs a second pass\n\t    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n\t      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n\t    });\n\t\n\t    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\t\n\t    if (marker.readOnly) {\n\t      sawReadOnlySpans = true;\n\t      if (doc.history.done.length || doc.history.undone.length)\n\t        doc.clearHistory();\n\t    }\n\t    if (marker.collapsed) {\n\t      marker.id = ++nextMarkerId;\n\t      marker.atomic = true;\n\t    }\n\t    if (cm) {\n\t      // Sync editor state\n\t      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n\t      if (marker.collapsed)\n\t        regChange(cm, from.line, to.line + 1);\n\t      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n\t        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n\t      if (marker.atomic) reCheckSelection(cm.doc);\n\t      signalLater(cm, \"markerAdded\", cm, marker);\n\t    }\n\t    return marker;\n\t  }\n\t\n\t  // SHARED TEXTMARKERS\n\t\n\t  // A shared marker spans multiple linked documents. It is\n\t  // implemented as a meta-marker-object controlling multiple normal\n\t  // markers.\n\t  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n\t    this.markers = markers;\n\t    this.primary = primary;\n\t    for (var i = 0; i < markers.length; ++i)\n\t      markers[i].parent = this;\n\t  };\n\t  eventMixin(SharedTextMarker);\n\t\n\t  SharedTextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    this.explicitlyCleared = true;\n\t    for (var i = 0; i < this.markers.length; ++i)\n\t      this.markers[i].clear();\n\t    signalLater(this, \"clear\");\n\t  };\n\t  SharedTextMarker.prototype.find = function(side, lineObj) {\n\t    return this.primary.find(side, lineObj);\n\t  };\n\t\n\t  function markTextShared(doc, from, to, options, type) {\n\t    options = copyObj(options);\n\t    options.shared = false;\n\t    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n\t    var widget = options.widgetNode;\n\t    linkedDocs(doc, function(doc) {\n\t      if (widget) options.widgetNode = widget.cloneNode(true);\n\t      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n\t      for (var i = 0; i < doc.linked.length; ++i)\n\t        if (doc.linked[i].isParent) return;\n\t      primary = lst(markers);\n\t    });\n\t    return new SharedTextMarker(markers, primary);\n\t  }\n\t\n\t  function findSharedMarkers(doc) {\n\t    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n\t                         function(m) { return m.parent; });\n\t  }\n\t\n\t  function copySharedMarkers(doc, markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], pos = marker.find();\n\t      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n\t      if (cmp(mFrom, mTo)) {\n\t        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\t        marker.markers.push(subMark);\n\t        subMark.parent = marker;\n\t      }\n\t    }\n\t  }\n\t\n\t  function detachSharedMarkers(markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], linked = [marker.primary.doc];;\n\t      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n\t      for (var j = 0; j < marker.markers.length; j++) {\n\t        var subMarker = marker.markers[j];\n\t        if (indexOf(linked, subMarker.doc) == -1) {\n\t          subMarker.parent = null;\n\t          marker.markers.splice(j--, 1);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // TEXTMARKER SPANS\n\t\n\t  function MarkedSpan(marker, from, to) {\n\t    this.marker = marker;\n\t    this.from = from; this.to = to;\n\t  }\n\t\n\t  // Search an array of spans for a span matching the given marker.\n\t  function getMarkedSpanFor(spans, marker) {\n\t    if (spans) for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.marker == marker) return span;\n\t    }\n\t  }\n\t  // Remove a span from an array, returning undefined if no spans are\n\t  // left (we don't store arrays for lines without spans).\n\t  function removeMarkedSpan(spans, span) {\n\t    for (var r, i = 0; i < spans.length; ++i)\n\t      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n\t    return r;\n\t  }\n\t  // Add a span to a line.\n\t  function addMarkedSpan(line, span) {\n\t    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\t    span.marker.attachLine(line);\n\t  }\n\t\n\t  // Used for the algorithm that adjusts markers for a change in the\n\t  // document. These functions cut an array of spans at a given\n\t  // character position, returning an array of remaining chunks (or\n\t  // undefined if nothing remains).\n\t  function markedSpansBefore(old, startCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\t      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n\t        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t  function markedSpansAfter(old, endCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\t      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n\t        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n\t                                              span.to == null ? null : span.to - endCh));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  // Given a change object, compute the new set of marker spans that\n\t  // cover the line in which the change took place. Removes spans\n\t  // entirely within the change, reconnects spans belonging to the\n\t  // same marker that appear on both sides of the change, and cuts off\n\t  // spans partially within the change. Returns an array of span\n\t  // arrays with one element for each line in (after) the change.\n\t  function stretchSpansOverChange(doc, change) {\n\t    if (change.full) return null;\n\t    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n\t    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\t    if (!oldFirst && !oldLast) return null;\n\t\n\t    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n\t    // Get the spans that 'stick out' on both sides\n\t    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n\t    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\t\n\t    // Next, merge those two ends\n\t    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n\t    if (first) {\n\t      // Fix up .to properties of first\n\t      for (var i = 0; i < first.length; ++i) {\n\t        var span = first[i];\n\t        if (span.to == null) {\n\t          var found = getMarkedSpanFor(last, span.marker);\n\t          if (!found) span.to = startCh;\n\t          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n\t        }\n\t      }\n\t    }\n\t    if (last) {\n\t      // Fix up .from in last (or move them into first in case of sameLine)\n\t      for (var i = 0; i < last.length; ++i) {\n\t        var span = last[i];\n\t        if (span.to != null) span.to += offset;\n\t        if (span.from == null) {\n\t          var found = getMarkedSpanFor(first, span.marker);\n\t          if (!found) {\n\t            span.from = offset;\n\t            if (sameLine) (first || (first = [])).push(span);\n\t          }\n\t        } else {\n\t          span.from += offset;\n\t          if (sameLine) (first || (first = [])).push(span);\n\t        }\n\t      }\n\t    }\n\t    // Make sure we didn't create any zero-length spans\n\t    if (first) first = clearEmptySpans(first);\n\t    if (last && last != first) last = clearEmptySpans(last);\n\t\n\t    var newMarkers = [first];\n\t    if (!sameLine) {\n\t      // Fill gap with whole-line-spans\n\t      var gap = change.text.length - 2, gapMarkers;\n\t      if (gap > 0 && first)\n\t        for (var i = 0; i < first.length; ++i)\n\t          if (first[i].to == null)\n\t            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n\t      for (var i = 0; i < gap; ++i)\n\t        newMarkers.push(gapMarkers);\n\t      newMarkers.push(last);\n\t    }\n\t    return newMarkers;\n\t  }\n\t\n\t  // Remove spans that are empty and don't have a clearWhenEmpty\n\t  // option of false.\n\t  function clearEmptySpans(spans) {\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n\t        spans.splice(i--, 1);\n\t    }\n\t    if (!spans.length) return null;\n\t    return spans;\n\t  }\n\t\n\t  // Used for un/re-doing changes from the history. Combines the\n\t  // result of computing the existing spans with the set of spans that\n\t  // existed in the history (so that deleting around a span and then\n\t  // undoing brings back the span).\n\t  function mergeOldSpans(doc, change) {\n\t    var old = getOldSpans(doc, change);\n\t    var stretched = stretchSpansOverChange(doc, change);\n\t    if (!old) return stretched;\n\t    if (!stretched) return old;\n\t\n\t    for (var i = 0; i < old.length; ++i) {\n\t      var oldCur = old[i], stretchCur = stretched[i];\n\t      if (oldCur && stretchCur) {\n\t        spans: for (var j = 0; j < stretchCur.length; ++j) {\n\t          var span = stretchCur[j];\n\t          for (var k = 0; k < oldCur.length; ++k)\n\t            if (oldCur[k].marker == span.marker) continue spans;\n\t          oldCur.push(span);\n\t        }\n\t      } else if (stretchCur) {\n\t        old[i] = stretchCur;\n\t      }\n\t    }\n\t    return old;\n\t  }\n\t\n\t  // Used to 'clip' out readOnly ranges when making a change.\n\t  function removeReadOnlyRanges(doc, from, to) {\n\t    var markers = null;\n\t    doc.iter(from.line, to.line + 1, function(line) {\n\t      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t        var mark = line.markedSpans[i].marker;\n\t        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n\t          (markers || (markers = [])).push(mark);\n\t      }\n\t    });\n\t    if (!markers) return null;\n\t    var parts = [{from: from, to: to}];\n\t    for (var i = 0; i < markers.length; ++i) {\n\t      var mk = markers[i], m = mk.find(0);\n\t      for (var j = 0; j < parts.length; ++j) {\n\t        var p = parts[j];\n\t        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n\t        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n\t        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n\t          newParts.push({from: p.from, to: m.from});\n\t        if (dto > 0 || !mk.inclusiveRight && !dto)\n\t          newParts.push({from: m.to, to: p.to});\n\t        parts.splice.apply(parts, newParts);\n\t        j += newParts.length - 1;\n\t      }\n\t    }\n\t    return parts;\n\t  }\n\t\n\t  // Connect or disconnect spans from a line.\n\t  function detachMarkedSpans(line) {\n\t    var spans = line.markedSpans;\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.detachLine(line);\n\t    line.markedSpans = null;\n\t  }\n\t  function attachMarkedSpans(line, spans) {\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.attachLine(line);\n\t    line.markedSpans = spans;\n\t  }\n\t\n\t  // Helpers used when computing which overlapping collapsed span\n\t  // counts as the larger one.\n\t  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n\t  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\t\n\t  // Returns a number indicating which of two overlapping collapsed\n\t  // spans is larger (and thus includes the other). Falls back to\n\t  // comparing ids when the spans cover exactly the same range.\n\t  function compareCollapsedMarkers(a, b) {\n\t    var lenDiff = a.lines.length - b.lines.length;\n\t    if (lenDiff != 0) return lenDiff;\n\t    var aPos = a.find(), bPos = b.find();\n\t    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\t    if (fromCmp) return -fromCmp;\n\t    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\t    if (toCmp) return toCmp;\n\t    return b.id - a.id;\n\t  }\n\t\n\t  // Find out whether a line ends or starts in a collapsed span. If\n\t  // so, return the marker for that span.\n\t  function collapsedSpanAtSide(line, start) {\n\t    var sps = sawCollapsedSpans && line.markedSpans, found;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n\t          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n\t        found = sp.marker;\n\t    }\n\t    return found;\n\t  }\n\t  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n\t  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\t\n\t  // Test whether there exists a collapsed span that partially\n\t  // overlaps (covers the start or end, but not both) of a new span.\n\t  // Such overlap is not allowed.\n\t  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n\t    var line = getLine(doc, lineNo);\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var i = 0; i < sps.length; ++i) {\n\t      var sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      var found = sp.marker.find(0);\n\t      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n\t      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\t      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n\t      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n\t          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // A visual line is a line as drawn on the screen. Folding, for\n\t  // example, can cause multiple logical lines to appear on the same\n\t  // visual line. This finds the start of the visual line that the\n\t  // given line is part of (usually that is the line itself).\n\t  function visualLine(line) {\n\t    var merged;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = merged.find(-1, true).line;\n\t    return line;\n\t  }\n\t\n\t  // Returns an array of logical lines that continue the visual line\n\t  // started by the argument, or undefined if there are no such lines.\n\t  function visualLineContinued(line) {\n\t    var merged, lines;\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      (lines || (lines = [])).push(line);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  // Get the line number of the start of the visual line that the\n\t  // given line number is part of.\n\t  function visualLineNo(doc, lineN) {\n\t    var line = getLine(doc, lineN), vis = visualLine(line);\n\t    if (line == vis) return lineN;\n\t    return lineNo(vis);\n\t  }\n\t  // Get the line number of the start of the next visual line after\n\t  // the given line.\n\t  function visualLineEndNo(doc, lineN) {\n\t    if (lineN > doc.lastLine()) return lineN;\n\t    var line = getLine(doc, lineN), merged;\n\t    if (!lineIsHidden(doc, line)) return lineN;\n\t    while (merged = collapsedSpanAtEnd(line))\n\t      line = merged.find(1, true).line;\n\t    return lineNo(line) + 1;\n\t  }\n\t\n\t  // Compute whether a line is hidden. Lines count as hidden when they\n\t  // are part of a visual line that starts with another line, or when\n\t  // they are entirely covered by collapsed, non-widget span.\n\t  function lineIsHidden(doc, line) {\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      if (sp.from == null) return true;\n\t      if (sp.marker.widgetNode) continue;\n\t      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n\t        return true;\n\t    }\n\t  }\n\t  function lineIsHiddenInner(doc, line, span) {\n\t    if (span.to == null) {\n\t      var end = span.marker.find(1, true);\n\t      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n\t    }\n\t    if (span.marker.inclusiveRight && span.to == line.text.length)\n\t      return true;\n\t    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n\t      sp = line.markedSpans[i];\n\t      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n\t          (sp.to == null || sp.to != span.from) &&\n\t          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n\t          lineIsHiddenInner(doc, line, sp)) return true;\n\t    }\n\t  }\n\t\n\t  // LINE WIDGETS\n\t\n\t  // Line widgets are block elements displayed above or below a line.\n\t\n\t  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n\t    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n\t      this[opt] = options[opt];\n\t    this.doc = doc;\n\t    this.node = node;\n\t  };\n\t  eventMixin(LineWidget);\n\t\n\t  function adjustScrollWhenAboveVisible(cm, line, diff) {\n\t    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n\t      addToScrollPos(cm, null, diff);\n\t  }\n\t\n\t  LineWidget.prototype.clear = function() {\n\t    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n\t    if (no == null || !ws) return;\n\t    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n\t    if (!ws.length) line.widgets = null;\n\t    var height = widgetHeight(this);\n\t    updateLineHeight(line, Math.max(0, line.height - height));\n\t    if (cm) runInOp(cm, function() {\n\t      adjustScrollWhenAboveVisible(cm, line, -height);\n\t      regLineChange(cm, no, \"widget\");\n\t    });\n\t  };\n\t  LineWidget.prototype.changed = function() {\n\t    var oldH = this.height, cm = this.doc.cm, line = this.line;\n\t    this.height = null;\n\t    var diff = widgetHeight(this) - oldH;\n\t    if (!diff) return;\n\t    updateLineHeight(line, line.height + diff);\n\t    if (cm) runInOp(cm, function() {\n\t      cm.curOp.forceUpdate = true;\n\t      adjustScrollWhenAboveVisible(cm, line, diff);\n\t    });\n\t  };\n\t\n\t  function widgetHeight(widget) {\n\t    if (widget.height != null) return widget.height;\n\t    var cm = widget.doc.cm;\n\t    if (!cm) return 0;\n\t    if (!contains(document.body, widget.node)) {\n\t      var parentStyle = \"position: relative;\";\n\t      if (widget.coverGutter)\n\t        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n\t      if (widget.noHScroll)\n\t        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n\t      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n\t    }\n\t    return widget.height = widget.node.parentNode.offsetHeight;\n\t  }\n\t\n\t  function addLineWidget(doc, handle, node, options) {\n\t    var widget = new LineWidget(doc, node, options);\n\t    var cm = doc.cm;\n\t    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n\t    changeLine(doc, handle, \"widget\", function(line) {\n\t      var widgets = line.widgets || (line.widgets = []);\n\t      if (widget.insertAt == null) widgets.push(widget);\n\t      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n\t      widget.line = line;\n\t      if (cm && !lineIsHidden(doc, line)) {\n\t        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n\t        updateLineHeight(line, line.height + widgetHeight(widget));\n\t        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n\t        cm.curOp.forceUpdate = true;\n\t      }\n\t      return true;\n\t    });\n\t    return widget;\n\t  }\n\t\n\t  // LINE DATA STRUCTURE\n\t\n\t  // Line objects. These hold state related to a line, including\n\t  // highlighting info (the styles array).\n\t  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n\t    this.text = text;\n\t    attachMarkedSpans(this, markedSpans);\n\t    this.height = estimateHeight ? estimateHeight(this) : 1;\n\t  };\n\t  eventMixin(Line);\n\t  Line.prototype.lineNo = function() { return lineNo(this); };\n\t\n\t  // Change the content (text, markers) of a line. Automatically\n\t  // invalidates cached information and tries to re-estimate the\n\t  // line's height.\n\t  function updateLine(line, text, markedSpans, estimateHeight) {\n\t    line.text = text;\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    if (line.styles) line.styles = null;\n\t    if (line.order != null) line.order = null;\n\t    detachMarkedSpans(line);\n\t    attachMarkedSpans(line, markedSpans);\n\t    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\t    if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t  }\n\t\n\t  // Detach a line from the document tree and its markers.\n\t  function cleanUpLine(line) {\n\t    line.parent = null;\n\t    detachMarkedSpans(line);\n\t  }\n\t\n\t  function extractLineClasses(type, output) {\n\t    if (type) for (;;) {\n\t      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\t      if (!lineClass) break;\n\t      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n\t      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\t      if (output[prop] == null)\n\t        output[prop] = lineClass[2];\n\t      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n\t        output[prop] += \" \" + lineClass[2];\n\t    }\n\t    return type;\n\t  }\n\t\n\t  function callBlankLine(mode, state) {\n\t    if (mode.blankLine) return mode.blankLine(state);\n\t    if (!mode.innerMode) return;\n\t    var inner = CodeMirror.innerMode(mode, state);\n\t    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n\t  }\n\t\n\t  function readToken(mode, stream, state, inner) {\n\t    for (var i = 0; i < 10; i++) {\n\t      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n\t      var style = mode.token(stream, state);\n\t      if (stream.pos > stream.start) return style;\n\t    }\n\t    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n\t  }\n\t\n\t  // Utility for getTokenAt and getLineTokens\n\t  function takeToken(cm, pos, precise, asArray) {\n\t    function getObj(copy) {\n\t      return {start: stream.start, end: stream.pos,\n\t              string: stream.current(),\n\t              type: style || null,\n\t              state: copy ? copyState(doc.mode, state) : state};\n\t    }\n\t\n\t    var doc = cm.doc, mode = doc.mode, style;\n\t    pos = clipPos(doc, pos);\n\t    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n\t    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n\t    if (asArray) tokens = [];\n\t    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n\t      stream.start = stream.pos;\n\t      style = readToken(mode, stream, state);\n\t      if (asArray) tokens.push(getObj(true));\n\t    }\n\t    return asArray ? tokens : getObj();\n\t  }\n\t\n\t  // Run the given mode's parser over a line, calling f for each token.\n\t  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n\t    var flattenSpans = mode.flattenSpans;\n\t    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n\t    var curStart = 0, curStyle = null;\n\t    var stream = new StringStream(text, cm.options.tabSize), style;\n\t    var inner = cm.options.addModeClass && [null];\n\t    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n\t    while (!stream.eol()) {\n\t      if (stream.pos > cm.options.maxHighlightLength) {\n\t        flattenSpans = false;\n\t        if (forceToEnd) processLine(cm, text, state, stream.pos);\n\t        stream.pos = text.length;\n\t        style = null;\n\t      } else {\n\t        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n\t      }\n\t      if (inner) {\n\t        var mName = inner[0].name;\n\t        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n\t      }\n\t      if (!flattenSpans || curStyle != style) {\n\t        while (curStart < stream.start) {\n\t          curStart = Math.min(stream.start, curStart + 50000);\n\t          f(curStart, curStyle);\n\t        }\n\t        curStyle = style;\n\t      }\n\t      stream.start = stream.pos;\n\t    }\n\t    while (curStart < stream.pos) {\n\t      // Webkit seems to refuse to render text nodes longer than 57444 characters\n\t      var pos = Math.min(stream.pos, curStart + 50000);\n\t      f(pos, curStyle);\n\t      curStart = pos;\n\t    }\n\t  }\n\t\n\t  // Compute a style array (an array starting with a mode generation\n\t  // -- for invalidation -- followed by pairs of end positions and\n\t  // style strings), which is used to highlight the tokens on the\n\t  // line.\n\t  function highlightLine(cm, line, state, forceToEnd) {\n\t    // A styles array always starts with a number identifying the\n\t    // mode/overlays that it is based on (for easy invalidation).\n\t    var st = [cm.state.modeGen], lineClasses = {};\n\t    // Compute the base array of styles\n\t    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n\t      st.push(end, style);\n\t    }, lineClasses, forceToEnd);\n\t\n\t    // Run overlays, adjust style array.\n\t    for (var o = 0; o < cm.state.overlays.length; ++o) {\n\t      var overlay = cm.state.overlays[o], i = 1, at = 0;\n\t      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n\t        var start = i;\n\t        // Ensure there's a token end at the current position, and that i points at it\n\t        while (at < end) {\n\t          var i_end = st[i];\n\t          if (i_end > end)\n\t            st.splice(i, 1, end, st[i+1], i_end);\n\t          i += 2;\n\t          at = Math.min(end, i_end);\n\t        }\n\t        if (!style) return;\n\t        if (overlay.opaque) {\n\t          st.splice(start, i - start, end, \"cm-overlay \" + style);\n\t          i = start + 2;\n\t        } else {\n\t          for (; start < i; start += 2) {\n\t            var cur = st[start+1];\n\t            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n\t          }\n\t        }\n\t      }, lineClasses);\n\t    }\n\t\n\t    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n\t  }\n\t\n\t  function getLineStyles(cm, line, updateFrontier) {\n\t    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n\t      var state = getStateBefore(cm, lineNo(line));\n\t      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n\t      line.stateAfter = state;\n\t      line.styles = result.styles;\n\t      if (result.classes) line.styleClasses = result.classes;\n\t      else if (line.styleClasses) line.styleClasses = null;\n\t      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n\t    }\n\t    return line.styles;\n\t  }\n\t\n\t  // Lightweight form of highlight -- proceed over this line and\n\t  // update state, but don't save a style array. Used for lines that\n\t  // aren't currently visible.\n\t  function processLine(cm, text, state, startAt) {\n\t    var mode = cm.doc.mode;\n\t    var stream = new StringStream(text, cm.options.tabSize);\n\t    stream.start = stream.pos = startAt || 0;\n\t    if (text == \"\") callBlankLine(mode, state);\n\t    while (!stream.eol()) {\n\t      readToken(mode, stream, state);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t\n\t  // Convert a style as returned by a mode (either null, or a string\n\t  // containing one or more styles) to a CSS style. This is cached,\n\t  // and also looks for line-wide styles.\n\t  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n\t  function interpretTokenStyle(style, options) {\n\t    if (!style || /^\\s*$/.test(style)) return null;\n\t    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n\t    return cache[style] ||\n\t      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n\t  }\n\t\n\t  // Render the DOM representation of the text of a line. Also builds\n\t  // up a 'line map', which points at the DOM nodes that represent\n\t  // specific stretches of text, and is used by the measuring code.\n\t  // The returned object contains the DOM node, this map, and\n\t  // information about line-wide styles that were set by the mode.\n\t  function buildLineContent(cm, lineView) {\n\t    // The padding-right forces the element to have a 'border', which\n\t    // is needed on Webkit to be able to get line-level bounding\n\t    // rectangles for it (in measureChar).\n\t    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n\t    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n\t                   col: 0, pos: 0, cm: cm,\n\t                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n\t    lineView.measure = {};\n\t\n\t    // Iterate over the logical lines that make up this visual line.\n\t    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n\t      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n\t      builder.pos = 0;\n\t      builder.addToken = buildToken;\n\t      // Optionally wire in some hacks into the token-rendering\n\t      // algorithm, to deal with browser quirks.\n\t      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n\t        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n\t      builder.map = [];\n\t      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n\t      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\t      if (line.styleClasses) {\n\t        if (line.styleClasses.bgClass)\n\t          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n\t        if (line.styleClasses.textClass)\n\t          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n\t      }\n\t\n\t      // Ensure at least a single node is present, for measuring.\n\t      if (builder.map.length == 0)\n\t        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\t\n\t      // Store the map and a cache object for the current logical line\n\t      if (i == 0) {\n\t        lineView.measure.map = builder.map;\n\t        lineView.measure.cache = {};\n\t      } else {\n\t        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n\t        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n\t      }\n\t    }\n\t\n\t    // See issue #2901\n\t    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n\t      builder.content.className = \"cm-tab-wrap-hack\";\n\t\n\t    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\t    if (builder.pre.className)\n\t      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\t\n\t    return builder;\n\t  }\n\t\n\t  function defaultSpecialCharPlaceholder(ch) {\n\t    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n\t    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n\t    token.setAttribute(\"aria-label\", token.title);\n\t    return token;\n\t  }\n\t\n\t  // Build up the DOM representation for a single token, and add it to\n\t  // the line map. Takes care to render special characters separately.\n\t  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n\t    if (!text) return;\n\t    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n\t    var special = builder.cm.state.specialChars, mustWrap = false;\n\t    if (!special.test(text)) {\n\t      builder.col += text.length;\n\t      var content = document.createTextNode(displayText);\n\t      builder.map.push(builder.pos, builder.pos + text.length, content);\n\t      if (ie && ie_version < 9) mustWrap = true;\n\t      builder.pos += text.length;\n\t    } else {\n\t      var content = document.createDocumentFragment(), pos = 0;\n\t      while (true) {\n\t        special.lastIndex = pos;\n\t        var m = special.exec(text);\n\t        var skipped = m ? m.index - pos : text.length - pos;\n\t        if (skipped) {\n\t          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.map.push(builder.pos, builder.pos + skipped, txt);\n\t          builder.col += skipped;\n\t          builder.pos += skipped;\n\t        }\n\t        if (!m) break;\n\t        pos += skipped + 1;\n\t        if (m[0] == \"\\t\") {\n\t          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n\t          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n\t          txt.setAttribute(\"role\", \"presentation\");\n\t          txt.setAttribute(\"cm-text\", \"\\t\");\n\t          builder.col += tabWidth;\n\t        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n\t          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          builder.col += 1;\n\t        } else {\n\t          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.col += 1;\n\t        }\n\t        builder.map.push(builder.pos, builder.pos + 1, txt);\n\t        builder.pos++;\n\t      }\n\t    }\n\t    if (style || startStyle || endStyle || mustWrap || css) {\n\t      var fullStyle = style || \"\";\n\t      if (startStyle) fullStyle += startStyle;\n\t      if (endStyle) fullStyle += endStyle;\n\t      var token = elt(\"span\", [content], fullStyle, css);\n\t      if (title) token.title = title;\n\t      return builder.content.appendChild(token);\n\t    }\n\t    builder.content.appendChild(content);\n\t  }\n\t\n\t  function splitSpaces(old) {\n\t    var out = \" \";\n\t    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n\t    out += \" \";\n\t    return out;\n\t  }\n\t\n\t  // Work around nonsense dimensions being reported for stretches of\n\t  // right-to-left text.\n\t  function buildTokenBadBidi(inner, order) {\n\t    return function(builder, text, style, startStyle, endStyle, title, css) {\n\t      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n\t      var start = builder.pos, end = start + text.length;\n\t      for (;;) {\n\t        // Find the part that overlaps with the start of this text\n\t        for (var i = 0; i < order.length; i++) {\n\t          var part = order[i];\n\t          if (part.to > start && part.from <= start) break;\n\t        }\n\t        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n\t        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n\t        startStyle = null;\n\t        text = text.slice(part.to - start);\n\t        start = part.to;\n\t      }\n\t    };\n\t  }\n\t\n\t  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n\t    var widget = !ignoreWidget && marker.widgetNode;\n\t    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n\t    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n\t      if (!widget)\n\t        widget = builder.content.appendChild(document.createElement(\"span\"));\n\t      widget.setAttribute(\"cm-marker\", marker.id);\n\t    }\n\t    if (widget) {\n\t      builder.cm.display.input.setUneditable(widget);\n\t      builder.content.appendChild(widget);\n\t    }\n\t    builder.pos += size;\n\t  }\n\t\n\t  // Outputs a number of spans to make up a line, taking highlighting\n\t  // and marked text into account.\n\t  function insertLineContent(line, builder, styles) {\n\t    var spans = line.markedSpans, allText = line.text, at = 0;\n\t    if (!spans) {\n\t      for (var i = 1; i < styles.length; i+=2)\n\t        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n\t      return;\n\t    }\n\t\n\t    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n\t    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n\t    for (;;) {\n\t      if (nextChange == pos) { // Update current marker set\n\t        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n\t        collapsed = null; nextChange = Infinity;\n\t        var foundBookmarks = [], endStyles\n\t        for (var j = 0; j < spans.length; ++j) {\n\t          var sp = spans[j], m = sp.marker;\n\t          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n\t            foundBookmarks.push(m);\n\t          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n\t            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n\t              nextChange = sp.to;\n\t              spanEndStyle = \"\";\n\t            }\n\t            if (m.className) spanStyle += \" \" + m.className;\n\t            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n\t            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n\t            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n\t            if (m.title && !title) title = m.title;\n\t            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n\t              collapsed = sp;\n\t          } else if (sp.from > pos && nextChange > sp.from) {\n\t            nextChange = sp.from;\n\t          }\n\t        }\n\t        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n\t          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\t\n\t        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n\t          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n\t        if (collapsed && (collapsed.from || 0) == pos) {\n\t          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n\t                             collapsed.marker, collapsed.from == null);\n\t          if (collapsed.to == null) return;\n\t          if (collapsed.to == pos) collapsed = false;\n\t        }\n\t      }\n\t      if (pos >= len) break;\n\t\n\t      var upto = Math.min(len, nextChange);\n\t      while (true) {\n\t        if (text) {\n\t          var end = pos + text.length;\n\t          if (!collapsed) {\n\t            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n\t            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n\t                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n\t          }\n\t          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n\t          pos = end;\n\t          spanStartStyle = \"\";\n\t        }\n\t        text = allText.slice(at, at = styles[i++]);\n\t        style = interpretTokenStyle(styles[i++], builder.cm.options);\n\t      }\n\t    }\n\t  }\n\t\n\t  // DOCUMENT DATA STRUCTURE\n\t\n\t  // By default, updates that start and end at the beginning of a line\n\t  // are treated specially, in order to make the association of line\n\t  // widgets and marker elements with the text behave more intuitive.\n\t  function isWholeLineUpdate(doc, change) {\n\t    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n\t      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n\t  }\n\t\n\t  // Perform a change on the document data structure.\n\t  function updateDoc(doc, change, markedSpans, estimateHeight) {\n\t    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\t    function update(line, text, spans) {\n\t      updateLine(line, text, spans, estimateHeight);\n\t      signalLater(line, \"change\", line, change);\n\t    }\n\t    function linesFor(start, end) {\n\t      for (var i = start, result = []; i < end; ++i)\n\t        result.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      return result;\n\t    }\n\t\n\t    var from = change.from, to = change.to, text = change.text;\n\t    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n\t    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\t\n\t    // Adjust the line structure\n\t    if (change.full) {\n\t      doc.insert(0, linesFor(0, text.length));\n\t      doc.remove(text.length, doc.size - text.length);\n\t    } else if (isWholeLineUpdate(doc, change)) {\n\t      // This is a whole-line replace. Treated specially to make\n\t      // sure line objects move the way they are supposed to.\n\t      var added = linesFor(0, text.length - 1);\n\t      update(lastLine, lastLine.text, lastSpans);\n\t      if (nlines) doc.remove(from.line, nlines);\n\t      if (added.length) doc.insert(from.line, added);\n\t    } else if (firstLine == lastLine) {\n\t      if (text.length == 1) {\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n\t      } else {\n\t        var added = linesFor(1, text.length - 1);\n\t        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t        doc.insert(from.line + 1, added);\n\t      }\n\t    } else if (text.length == 1) {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n\t      doc.remove(from.line + 1, nlines);\n\t    } else {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\t      var added = linesFor(1, text.length - 1);\n\t      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n\t      doc.insert(from.line + 1, added);\n\t    }\n\t\n\t    signalLater(doc, \"change\", doc, change);\n\t  }\n\t\n\t  // The document is represented as a BTree consisting of leaves, with\n\t  // chunk of lines in them, and branches, with up to ten leaves or\n\t  // other branch nodes below them. The top node is always a branch\n\t  // node, and is the document object itself (meaning it has\n\t  // additional methods and properties).\n\t  //\n\t  // All nodes have parent links. The tree is used both to go from\n\t  // line numbers to line objects, and to go from objects to numbers.\n\t  // It also indexes by height, and is used to convert between height\n\t  // and line object, and to find the total height of the document.\n\t  //\n\t  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\t\n\t  function LeafChunk(lines) {\n\t    this.lines = lines;\n\t    this.parent = null;\n\t    for (var i = 0, height = 0; i < lines.length; ++i) {\n\t      lines[i].parent = this;\n\t      height += lines[i].height;\n\t    }\n\t    this.height = height;\n\t  }\n\t\n\t  LeafChunk.prototype = {\n\t    chunkSize: function() { return this.lines.length; },\n\t    // Remove the n lines at offset 'at'.\n\t    removeInner: function(at, n) {\n\t      for (var i = at, e = at + n; i < e; ++i) {\n\t        var line = this.lines[i];\n\t        this.height -= line.height;\n\t        cleanUpLine(line);\n\t        signalLater(line, \"delete\");\n\t      }\n\t      this.lines.splice(at, n);\n\t    },\n\t    // Helper used to collapse a small branch into a single leaf.\n\t    collapse: function(lines) {\n\t      lines.push.apply(lines, this.lines);\n\t    },\n\t    // Insert the given array of lines at offset 'at', count them as\n\t    // having the given height.\n\t    insertInner: function(at, lines, height) {\n\t      this.height += height;\n\t      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\t      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n\t    },\n\t    // Used to iterate over a part of the tree.\n\t    iterN: function(at, n, op) {\n\t      for (var e = at + n; at < e; ++at)\n\t        if (op(this.lines[at])) return true;\n\t    }\n\t  };\n\t\n\t  function BranchChunk(children) {\n\t    this.children = children;\n\t    var size = 0, height = 0;\n\t    for (var i = 0; i < children.length; ++i) {\n\t      var ch = children[i];\n\t      size += ch.chunkSize(); height += ch.height;\n\t      ch.parent = this;\n\t    }\n\t    this.size = size;\n\t    this.height = height;\n\t    this.parent = null;\n\t  }\n\t\n\t  BranchChunk.prototype = {\n\t    chunkSize: function() { return this.size; },\n\t    removeInner: function(at, n) {\n\t      this.size -= n;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var rm = Math.min(n, sz - at), oldHeight = child.height;\n\t          child.removeInner(at, rm);\n\t          this.height -= oldHeight - child.height;\n\t          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n\t          if ((n -= rm) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t      // If the result is smaller than 25 lines, ensure that it is a\n\t      // single leaf node.\n\t      if (this.size - n < 25 &&\n\t          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n\t        var lines = [];\n\t        this.collapse(lines);\n\t        this.children = [new LeafChunk(lines)];\n\t        this.children[0].parent = this;\n\t      }\n\t    },\n\t    collapse: function(lines) {\n\t      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.size += lines.length;\n\t      this.height += height;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at <= sz) {\n\t          child.insertInner(at, lines, height);\n\t          if (child.lines && child.lines.length > 50) {\n\t            while (child.lines.length > 50) {\n\t              var spilled = child.lines.splice(child.lines.length - 25, 25);\n\t              var newleaf = new LeafChunk(spilled);\n\t              child.height -= newleaf.height;\n\t              this.children.splice(i + 1, 0, newleaf);\n\t              newleaf.parent = this;\n\t            }\n\t            this.maybeSpill();\n\t          }\n\t          break;\n\t        }\n\t        at -= sz;\n\t      }\n\t    },\n\t    // When a node has grown, check whether it should be split.\n\t    maybeSpill: function() {\n\t      if (this.children.length <= 10) return;\n\t      var me = this;\n\t      do {\n\t        var spilled = me.children.splice(me.children.length - 5, 5);\n\t        var sibling = new BranchChunk(spilled);\n\t        if (!me.parent) { // Become the parent node\n\t          var copy = new BranchChunk(me.children);\n\t          copy.parent = me;\n\t          me.children = [copy, sibling];\n\t          me = copy;\n\t        } else {\n\t          me.size -= sibling.size;\n\t          me.height -= sibling.height;\n\t          var myIndex = indexOf(me.parent.children, me);\n\t          me.parent.children.splice(myIndex + 1, 0, sibling);\n\t        }\n\t        sibling.parent = me.parent;\n\t      } while (me.children.length > 10);\n\t      me.parent.maybeSpill();\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var used = Math.min(n, sz - at);\n\t          if (child.iterN(at, used, op)) return true;\n\t          if ((n -= used) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t    }\n\t  };\n\t\n\t  var nextDocId = 0;\n\t  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n\t    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n\t    if (firstLine == null) firstLine = 0;\n\t\n\t    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n\t    this.first = firstLine;\n\t    this.scrollTop = this.scrollLeft = 0;\n\t    this.cantEdit = false;\n\t    this.cleanGeneration = 1;\n\t    this.frontier = firstLine;\n\t    var start = Pos(firstLine, 0);\n\t    this.sel = simpleSelection(start);\n\t    this.history = new History(null);\n\t    this.id = ++nextDocId;\n\t    this.modeOption = mode;\n\t    this.lineSep = lineSep;\n\t    this.extend = false;\n\t\n\t    if (typeof text == \"string\") text = this.splitLines(text);\n\t    updateDoc(this, {from: start, to: start, text: text});\n\t    setSelection(this, simpleSelection(start), sel_dontScroll);\n\t  };\n\t\n\t  Doc.prototype = createObj(BranchChunk.prototype, {\n\t    constructor: Doc,\n\t    // Iterate over the document. Supports two forms -- with only one\n\t    // argument, it calls that for each line in the document. With\n\t    // three, it iterates over the range given by the first two (with\n\t    // the second being non-inclusive).\n\t    iter: function(from, to, op) {\n\t      if (op) this.iterN(from - this.first, to - from, op);\n\t      else this.iterN(this.first, this.first + this.size, from);\n\t    },\n\t\n\t    // Non-public interface for adding and removing lines.\n\t    insert: function(at, lines) {\n\t      var height = 0;\n\t      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n\t      this.insertInner(at - this.first, lines, height);\n\t    },\n\t    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\t\n\t    // From here, the methods are part of the public interface. Most\n\t    // are also available from CodeMirror (editor) instances.\n\t\n\t    getValue: function(lineSep) {\n\t      var lines = getLines(this, this.first, this.first + this.size);\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    setValue: docMethodOp(function(code) {\n\t      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n\t      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n\t                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n\t      setSelection(this, simpleSelection(top));\n\t    }),\n\t    replaceRange: function(code, from, to, origin) {\n\t      from = clipPos(this, from);\n\t      to = to ? clipPos(this, to) : from;\n\t      replaceRange(this, code, from, to, origin);\n\t    },\n\t    getRange: function(from, to, lineSep) {\n\t      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t\n\t    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\t\n\t    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n\t    getLineNumber: function(line) {return lineNo(line);},\n\t\n\t    getLineHandleVisualStart: function(line) {\n\t      if (typeof line == \"number\") line = getLine(this, line);\n\t      return visualLine(line);\n\t    },\n\t\n\t    lineCount: function() {return this.size;},\n\t    firstLine: function() {return this.first;},\n\t    lastLine: function() {return this.first + this.size - 1;},\n\t\n\t    clipPos: function(pos) {return clipPos(this, pos);},\n\t\n\t    getCursor: function(start) {\n\t      var range = this.sel.primary(), pos;\n\t      if (start == null || start == \"head\") pos = range.head;\n\t      else if (start == \"anchor\") pos = range.anchor;\n\t      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n\t      else pos = range.from();\n\t      return pos;\n\t    },\n\t    listSelections: function() { return this.sel.ranges; },\n\t    somethingSelected: function() {return this.sel.somethingSelected();},\n\t\n\t    setCursor: docMethodOp(function(line, ch, options) {\n\t      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n\t    }),\n\t    setSelection: docMethodOp(function(anchor, head, options) {\n\t      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n\t    }),\n\t    extendSelection: docMethodOp(function(head, other, options) {\n\t      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n\t    }),\n\t    extendSelections: docMethodOp(function(heads, options) {\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    extendSelectionsBy: docMethodOp(function(f, options) {\n\t      var heads = map(this.sel.ranges, f);\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    setSelections: docMethodOp(function(ranges, primary, options) {\n\t      if (!ranges.length) return;\n\t      for (var i = 0, out = []; i < ranges.length; i++)\n\t        out[i] = new Range(clipPos(this, ranges[i].anchor),\n\t                           clipPos(this, ranges[i].head));\n\t      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n\t      setSelection(this, normalizeSelection(out, primary), options);\n\t    }),\n\t    addSelection: docMethodOp(function(anchor, head, options) {\n\t      var ranges = this.sel.ranges.slice(0);\n\t      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n\t      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n\t    }),\n\t\n\t    getSelection: function(lineSep) {\n\t      var ranges = this.sel.ranges, lines;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        lines = lines ? lines.concat(sel) : sel;\n\t      }\n\t      if (lineSep === false) return lines;\n\t      else return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    getSelections: function(lineSep) {\n\t      var parts = [], ranges = this.sel.ranges;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n\t        parts[i] = sel;\n\t      }\n\t      return parts;\n\t    },\n\t    replaceSelection: function(code, collapse, origin) {\n\t      var dup = [];\n\t      for (var i = 0; i < this.sel.ranges.length; i++)\n\t        dup[i] = code;\n\t      this.replaceSelections(dup, collapse, origin || \"+input\");\n\t    },\n\t    replaceSelections: docMethodOp(function(code, collapse, origin) {\n\t      var changes = [], sel = this.sel;\n\t      for (var i = 0; i < sel.ranges.length; i++) {\n\t        var range = sel.ranges[i];\n\t        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n\t      }\n\t      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\t      for (var i = changes.length - 1; i >= 0; i--)\n\t        makeChange(this, changes[i]);\n\t      if (newSel) setSelectionReplaceHistory(this, newSel);\n\t      else if (this.cm) ensureCursorVisible(this.cm);\n\t    }),\n\t    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n\t    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n\t    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n\t    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\t\n\t    setExtending: function(val) {this.extend = val;},\n\t    getExtending: function() {return this.extend;},\n\t\n\t    historySize: function() {\n\t      var hist = this.history, done = 0, undone = 0;\n\t      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n\t      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n\t      return {undo: done, redo: undone};\n\t    },\n\t    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\t\n\t    markClean: function() {\n\t      this.cleanGeneration = this.changeGeneration(true);\n\t    },\n\t    changeGeneration: function(forceSplit) {\n\t      if (forceSplit)\n\t        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n\t      return this.history.generation;\n\t    },\n\t    isClean: function (gen) {\n\t      return this.history.generation == (gen || this.cleanGeneration);\n\t    },\n\t\n\t    getHistory: function() {\n\t      return {done: copyHistoryArray(this.history.done),\n\t              undone: copyHistoryArray(this.history.undone)};\n\t    },\n\t    setHistory: function(histData) {\n\t      var hist = this.history = new History(this.history.maxGeneration);\n\t      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n\t      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n\t    },\n\t\n\t    addLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        if (!line[prop]) line[prop] = cls;\n\t        else if (classTest(cls).test(line[prop])) return false;\n\t        else line[prop] += \" \" + cls;\n\t        return true;\n\t      });\n\t    }),\n\t    removeLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        var cur = line[prop];\n\t        if (!cur) return false;\n\t        else if (cls == null) line[prop] = null;\n\t        else {\n\t          var found = cur.match(classTest(cls));\n\t          if (!found) return false;\n\t          var end = found.index + found[0].length;\n\t          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n\t        }\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    addLineWidget: docMethodOp(function(handle, node, options) {\n\t      return addLineWidget(this, handle, node, options);\n\t    }),\n\t    removeLineWidget: function(widget) { widget.clear(); },\n\t\n\t    markText: function(from, to, options) {\n\t      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n\t    },\n\t    setBookmark: function(pos, options) {\n\t      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n\t                      insertLeft: options && options.insertLeft,\n\t                      clearWhenEmpty: false, shared: options && options.shared,\n\t                      handleMouseEvents: options && options.handleMouseEvents};\n\t      pos = clipPos(this, pos);\n\t      return markText(this, pos, pos, realOpts, \"bookmark\");\n\t    },\n\t    findMarksAt: function(pos) {\n\t      pos = clipPos(this, pos);\n\t      var markers = [], spans = getLine(this, pos.line).markedSpans;\n\t      if (spans) for (var i = 0; i < spans.length; ++i) {\n\t        var span = spans[i];\n\t        if ((span.from == null || span.from <= pos.ch) &&\n\t            (span.to == null || span.to >= pos.ch))\n\t          markers.push(span.marker.parent || span.marker);\n\t      }\n\t      return markers;\n\t    },\n\t    findMarks: function(from, to, filter) {\n\t      from = clipPos(this, from); to = clipPos(this, to);\n\t      var found = [], lineNo = from.line;\n\t      this.iter(from.line, to.line + 1, function(line) {\n\t        var spans = line.markedSpans;\n\t        if (spans) for (var i = 0; i < spans.length; i++) {\n\t          var span = spans[i];\n\t          if (!(lineNo == from.line && from.ch > span.to ||\n\t                span.from == null && lineNo != from.line||\n\t                lineNo == to.line && span.from > to.ch) &&\n\t              (!filter || filter(span.marker)))\n\t            found.push(span.marker.parent || span.marker);\n\t        }\n\t        ++lineNo;\n\t      });\n\t      return found;\n\t    },\n\t    getAllMarks: function() {\n\t      var markers = [];\n\t      this.iter(function(line) {\n\t        var sps = line.markedSpans;\n\t        if (sps) for (var i = 0; i < sps.length; ++i)\n\t          if (sps[i].from != null) markers.push(sps[i].marker);\n\t      });\n\t      return markers;\n\t    },\n\t\n\t    posFromIndex: function(off) {\n\t      var ch, lineNo = this.first;\n\t      this.iter(function(line) {\n\t        var sz = line.text.length + 1;\n\t        if (sz > off) { ch = off; return true; }\n\t        off -= sz;\n\t        ++lineNo;\n\t      });\n\t      return clipPos(this, Pos(lineNo, ch));\n\t    },\n\t    indexFromPos: function (coords) {\n\t      coords = clipPos(this, coords);\n\t      var index = coords.ch;\n\t      if (coords.line < this.first || coords.ch < 0) return 0;\n\t      this.iter(this.first, coords.line, function (line) {\n\t        index += line.text.length + 1;\n\t      });\n\t      return index;\n\t    },\n\t\n\t    copy: function(copyHistory) {\n\t      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n\t                        this.modeOption, this.first, this.lineSep);\n\t      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n\t      doc.sel = this.sel;\n\t      doc.extend = false;\n\t      if (copyHistory) {\n\t        doc.history.undoDepth = this.history.undoDepth;\n\t        doc.setHistory(this.getHistory());\n\t      }\n\t      return doc;\n\t    },\n\t\n\t    linkedDoc: function(options) {\n\t      if (!options) options = {};\n\t      var from = this.first, to = this.first + this.size;\n\t      if (options.from != null && options.from > from) from = options.from;\n\t      if (options.to != null && options.to < to) to = options.to;\n\t      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n\t      if (options.sharedHist) copy.history = this.history;\n\t      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n\t      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n\t      copySharedMarkers(copy, findSharedMarkers(this));\n\t      return copy;\n\t    },\n\t    unlinkDoc: function(other) {\n\t      if (other instanceof CodeMirror) other = other.doc;\n\t      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n\t        var link = this.linked[i];\n\t        if (link.doc != other) continue;\n\t        this.linked.splice(i, 1);\n\t        other.unlinkDoc(this);\n\t        detachSharedMarkers(findSharedMarkers(this));\n\t        break;\n\t      }\n\t      // If the histories were shared, split them again\n\t      if (other.history == this.history) {\n\t        var splitIds = [other.id];\n\t        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n\t        other.history = new History(null);\n\t        other.history.done = copyHistoryArray(this.history.done, splitIds);\n\t        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n\t      }\n\t    },\n\t    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\t\n\t    getMode: function() {return this.mode;},\n\t    getEditor: function() {return this.cm;},\n\t\n\t    splitLines: function(str) {\n\t      if (this.lineSep) return str.split(this.lineSep);\n\t      return splitLinesAuto(str);\n\t    },\n\t    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n\t  });\n\t\n\t  // Public alias.\n\t  Doc.prototype.eachLine = Doc.prototype.iter;\n\t\n\t  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\t  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\t  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n\t    CodeMirror.prototype[prop] = (function(method) {\n\t      return function() {return method.apply(this.doc, arguments);};\n\t    })(Doc.prototype[prop]);\n\t\n\t  eventMixin(Doc);\n\t\n\t  // Call f for all linked documents.\n\t  function linkedDocs(doc, f, sharedHistOnly) {\n\t    function propagate(doc, skip, sharedHist) {\n\t      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n\t        var rel = doc.linked[i];\n\t        if (rel.doc == skip) continue;\n\t        var shared = sharedHist && rel.sharedHist;\n\t        if (sharedHistOnly && !shared) continue;\n\t        f(rel.doc, shared);\n\t        propagate(rel.doc, doc, shared);\n\t      }\n\t    }\n\t    propagate(doc, null, true);\n\t  }\n\t\n\t  // Attach a document to an editor.\n\t  function attachDoc(cm, doc) {\n\t    if (doc.cm) throw new Error(\"This document is already in use.\");\n\t    cm.doc = doc;\n\t    doc.cm = cm;\n\t    estimateLineHeights(cm);\n\t    loadMode(cm);\n\t    if (!cm.options.lineWrapping) findMaxLine(cm);\n\t    cm.options.mode = doc.modeOption;\n\t    regChange(cm);\n\t  }\n\t\n\t  // LINE UTILITIES\n\t\n\t  // Find the line object corresponding to the given line number.\n\t  function getLine(doc, n) {\n\t    n -= doc.first;\n\t    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n\t    for (var chunk = doc; !chunk.lines;) {\n\t      for (var i = 0;; ++i) {\n\t        var child = chunk.children[i], sz = child.chunkSize();\n\t        if (n < sz) { chunk = child; break; }\n\t        n -= sz;\n\t      }\n\t    }\n\t    return chunk.lines[n];\n\t  }\n\t\n\t  // Get the part of a document between two positions, as an array of\n\t  // strings.\n\t  function getBetween(doc, start, end) {\n\t    var out = [], n = start.line;\n\t    doc.iter(start.line, end.line + 1, function(line) {\n\t      var text = line.text;\n\t      if (n == end.line) text = text.slice(0, end.ch);\n\t      if (n == start.line) text = text.slice(start.ch);\n\t      out.push(text);\n\t      ++n;\n\t    });\n\t    return out;\n\t  }\n\t  // Get the lines between from and to, as array of strings.\n\t  function getLines(doc, from, to) {\n\t    var out = [];\n\t    doc.iter(from, to, function(line) { out.push(line.text); });\n\t    return out;\n\t  }\n\t\n\t  // Update the height of a line, propagating the height change\n\t  // upwards to parent nodes.\n\t  function updateLineHeight(line, height) {\n\t    var diff = height - line.height;\n\t    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n\t  }\n\t\n\t  // Given a line object, find its line number by walking up through\n\t  // its parent links.\n\t  function lineNo(line) {\n\t    if (line.parent == null) return null;\n\t    var cur = line.parent, no = indexOf(cur.lines, line);\n\t    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n\t      for (var i = 0;; ++i) {\n\t        if (chunk.children[i] == cur) break;\n\t        no += chunk.children[i].chunkSize();\n\t      }\n\t    }\n\t    return no + cur.first;\n\t  }\n\t\n\t  // Find the line at the given vertical position, using the height\n\t  // information in the document tree.\n\t  function lineAtHeight(chunk, h) {\n\t    var n = chunk.first;\n\t    outer: do {\n\t      for (var i = 0; i < chunk.children.length; ++i) {\n\t        var child = chunk.children[i], ch = child.height;\n\t        if (h < ch) { chunk = child; continue outer; }\n\t        h -= ch;\n\t        n += child.chunkSize();\n\t      }\n\t      return n;\n\t    } while (!chunk.lines);\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i], lh = line.height;\n\t      if (h < lh) break;\n\t      h -= lh;\n\t    }\n\t    return n + i;\n\t  }\n\t\n\t\n\t  // Find the height above the given line.\n\t  function heightAtLine(lineObj) {\n\t    lineObj = visualLine(lineObj);\n\t\n\t    var h = 0, chunk = lineObj.parent;\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i];\n\t      if (line == lineObj) break;\n\t      else h += line.height;\n\t    }\n\t    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n\t      for (var i = 0; i < p.children.length; ++i) {\n\t        var cur = p.children[i];\n\t        if (cur == chunk) break;\n\t        else h += cur.height;\n\t      }\n\t    }\n\t    return h;\n\t  }\n\t\n\t  // Get the bidi ordering for the given line (and cache it). Returns\n\t  // false for lines that are fully left-to-right, and an array of\n\t  // BidiSpan objects otherwise.\n\t  function getOrder(line) {\n\t    var order = line.order;\n\t    if (order == null) order = line.order = bidiOrdering(line.text);\n\t    return order;\n\t  }\n\t\n\t  // HISTORY\n\t\n\t  function History(startGen) {\n\t    // Arrays of change events and selections. Doing something adds an\n\t    // event to done and clears undo. Undoing moves events from done\n\t    // to undone, redoing moves them in the other direction.\n\t    this.done = []; this.undone = [];\n\t    this.undoDepth = Infinity;\n\t    // Used to track when changes can be merged into a single undo\n\t    // event\n\t    this.lastModTime = this.lastSelTime = 0;\n\t    this.lastOp = this.lastSelOp = null;\n\t    this.lastOrigin = this.lastSelOrigin = null;\n\t    // Used by the isClean() method\n\t    this.generation = this.maxGeneration = startGen || 1;\n\t  }\n\t\n\t  // Create a history change event from an updateDoc-style change\n\t  // object.\n\t  function historyChangeFromChange(doc, change) {\n\t    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n\t    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n\t    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n\t    return histChange;\n\t  }\n\t\n\t  // Pop all selection events off the end of a history array. Stop at\n\t  // a change event.\n\t  function clearSelectionEvents(array) {\n\t    while (array.length) {\n\t      var last = lst(array);\n\t      if (last.ranges) array.pop();\n\t      else break;\n\t    }\n\t  }\n\t\n\t  // Find the top change event in the history. Pop off selection\n\t  // events that are in the way.\n\t  function lastChangeEvent(hist, force) {\n\t    if (force) {\n\t      clearSelectionEvents(hist.done);\n\t      return lst(hist.done);\n\t    } else if (hist.done.length && !lst(hist.done).ranges) {\n\t      return lst(hist.done);\n\t    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n\t      hist.done.pop();\n\t      return lst(hist.done);\n\t    }\n\t  }\n\t\n\t  // Register a change in the history. Merges changes that are within\n\t  // a single operation, ore are close together with an origin that\n\t  // allows merging (starting with \"+\") into a single event.\n\t  function addChangeToHistory(doc, change, selAfter, opId) {\n\t    var hist = doc.history;\n\t    hist.undone.length = 0;\n\t    var time = +new Date, cur;\n\t\n\t    if ((hist.lastOp == opId ||\n\t         hist.lastOrigin == change.origin && change.origin &&\n\t         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n\t          change.origin.charAt(0) == \"*\")) &&\n\t        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n\t      // Merge this change into the last event\n\t      var last = lst(cur.changes);\n\t      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n\t        // Optimized case for simple insertion -- don't want to add\n\t        // new changesets for every character typed\n\t        last.to = changeEnd(change);\n\t      } else {\n\t        // Add new sub-event\n\t        cur.changes.push(historyChangeFromChange(doc, change));\n\t      }\n\t    } else {\n\t      // Can not be merged, start a new event.\n\t      var before = lst(hist.done);\n\t      if (!before || !before.ranges)\n\t        pushSelectionToHistory(doc.sel, hist.done);\n\t      cur = {changes: [historyChangeFromChange(doc, change)],\n\t             generation: hist.generation};\n\t      hist.done.push(cur);\n\t      while (hist.done.length > hist.undoDepth) {\n\t        hist.done.shift();\n\t        if (!hist.done[0].ranges) hist.done.shift();\n\t      }\n\t    }\n\t    hist.done.push(selAfter);\n\t    hist.generation = ++hist.maxGeneration;\n\t    hist.lastModTime = hist.lastSelTime = time;\n\t    hist.lastOp = hist.lastSelOp = opId;\n\t    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\t\n\t    if (!last) signal(doc, \"historyAdded\");\n\t  }\n\t\n\t  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n\t    var ch = origin.charAt(0);\n\t    return ch == \"*\" ||\n\t      ch == \"+\" &&\n\t      prev.ranges.length == sel.ranges.length &&\n\t      prev.somethingSelected() == sel.somethingSelected() &&\n\t      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n\t  }\n\t\n\t  // Called whenever the selection changes, sets the new selection as\n\t  // the pending selection in the history, and pushes the old pending\n\t  // selection into the 'done' array when it was significantly\n\t  // different (in number of selected ranges, emptiness, or time).\n\t  function addSelectionToHistory(doc, sel, opId, options) {\n\t    var hist = doc.history, origin = options && options.origin;\n\t\n\t    // A new event is started when the previous origin does not match\n\t    // the current, or the origins don't allow matching. Origins\n\t    // starting with * are always merged, those starting with + are\n\t    // merged when similar and close together in time.\n\t    if (opId == hist.lastSelOp ||\n\t        (origin && hist.lastSelOrigin == origin &&\n\t         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n\t          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n\t      hist.done[hist.done.length - 1] = sel;\n\t    else\n\t      pushSelectionToHistory(sel, hist.done);\n\t\n\t    hist.lastSelTime = +new Date;\n\t    hist.lastSelOrigin = origin;\n\t    hist.lastSelOp = opId;\n\t    if (options && options.clearRedo !== false)\n\t      clearSelectionEvents(hist.undone);\n\t  }\n\t\n\t  function pushSelectionToHistory(sel, dest) {\n\t    var top = lst(dest);\n\t    if (!(top && top.ranges && top.equals(sel)))\n\t      dest.push(sel);\n\t  }\n\t\n\t  // Used to store marked span information in the history.\n\t  function attachLocalSpans(doc, change, from, to) {\n\t    var existing = change[\"spans_\" + doc.id], n = 0;\n\t    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n\t      if (line.markedSpans)\n\t        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n\t      ++n;\n\t    });\n\t  }\n\t\n\t  // When un/re-doing restores text containing marked spans, those\n\t  // that have been explicitly cleared should not be restored.\n\t  function removeClearedSpans(spans) {\n\t    if (!spans) return null;\n\t    for (var i = 0, out; i < spans.length; ++i) {\n\t      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n\t      else if (out) out.push(spans[i]);\n\t    }\n\t    return !out ? spans : out.length ? out : null;\n\t  }\n\t\n\t  // Retrieve and filter the old marked spans stored in a change event.\n\t  function getOldSpans(doc, change) {\n\t    var found = change[\"spans_\" + doc.id];\n\t    if (!found) return null;\n\t    for (var i = 0, nw = []; i < change.text.length; ++i)\n\t      nw.push(removeClearedSpans(found[i]));\n\t    return nw;\n\t  }\n\t\n\t  // Used both to provide a JSON-safe object in .getHistory, and, when\n\t  // detaching a document, to split the history in two\n\t  function copyHistoryArray(events, newGroup, instantiateSel) {\n\t    for (var i = 0, copy = []; i < events.length; ++i) {\n\t      var event = events[i];\n\t      if (event.ranges) {\n\t        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n\t        continue;\n\t      }\n\t      var changes = event.changes, newChanges = [];\n\t      copy.push({changes: newChanges});\n\t      for (var j = 0; j < changes.length; ++j) {\n\t        var change = changes[j], m;\n\t        newChanges.push({from: change.from, to: change.to, text: change.text});\n\t        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n\t          if (indexOf(newGroup, Number(m[1])) > -1) {\n\t            lst(newChanges)[prop] = change[prop];\n\t            delete change[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return copy;\n\t  }\n\t\n\t  // Rebasing/resetting history to deal with externally-sourced changes\n\t\n\t  function rebaseHistSelSingle(pos, from, to, diff) {\n\t    if (to < pos.line) {\n\t      pos.line += diff;\n\t    } else if (from < pos.line) {\n\t      pos.line = from;\n\t      pos.ch = 0;\n\t    }\n\t  }\n\t\n\t  // Tries to rebase an array of history events given a change in the\n\t  // document. If the change touches the same lines as the event, the\n\t  // event, and everything 'behind' it, is discarded. If the change is\n\t  // before the event, the event's positions are updated. Uses a\n\t  // copy-on-write scheme for the positions, to avoid having to\n\t  // reallocate them all on every rebase, but also avoid problems with\n\t  // shared position objects being unsafely updated.\n\t  function rebaseHistArray(array, from, to, diff) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t      var sub = array[i], ok = true;\n\t      if (sub.ranges) {\n\t        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n\t        for (var j = 0; j < sub.ranges.length; j++) {\n\t          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n\t          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n\t        }\n\t        continue;\n\t      }\n\t      for (var j = 0; j < sub.changes.length; ++j) {\n\t        var cur = sub.changes[j];\n\t        if (to < cur.from.line) {\n\t          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n\t          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n\t        } else if (from <= cur.to.line) {\n\t          ok = false;\n\t          break;\n\t        }\n\t      }\n\t      if (!ok) {\n\t        array.splice(0, i + 1);\n\t        i = 0;\n\t      }\n\t    }\n\t  }\n\t\n\t  function rebaseHist(hist, change) {\n\t    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n\t    rebaseHistArray(hist.done, from, to, diff);\n\t    rebaseHistArray(hist.undone, from, to, diff);\n\t  }\n\t\n\t  // EVENT UTILITIES\n\t\n\t  // Due to the fact that we still support jurassic IE versions, some\n\t  // compatibility wrappers are needed.\n\t\n\t  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n\t    if (e.preventDefault) e.preventDefault();\n\t    else e.returnValue = false;\n\t  };\n\t  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n\t    if (e.stopPropagation) e.stopPropagation();\n\t    else e.cancelBubble = true;\n\t  };\n\t  function e_defaultPrevented(e) {\n\t    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n\t  }\n\t  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\t\n\t  function e_target(e) {return e.target || e.srcElement;}\n\t  function e_button(e) {\n\t    var b = e.which;\n\t    if (b == null) {\n\t      if (e.button & 1) b = 1;\n\t      else if (e.button & 2) b = 3;\n\t      else if (e.button & 4) b = 2;\n\t    }\n\t    if (mac && e.ctrlKey && b == 1) b = 3;\n\t    return b;\n\t  }\n\t\n\t  // EVENT HANDLING\n\t\n\t  // Lightweight event framework. on/off also work on DOM nodes,\n\t  // registering native DOM handlers.\n\t\n\t  var on = CodeMirror.on = function(emitter, type, f) {\n\t    if (emitter.addEventListener)\n\t      emitter.addEventListener(type, f, false);\n\t    else if (emitter.attachEvent)\n\t      emitter.attachEvent(\"on\" + type, f);\n\t    else {\n\t      var map = emitter._handlers || (emitter._handlers = {});\n\t      var arr = map[type] || (map[type] = []);\n\t      arr.push(f);\n\t    }\n\t  };\n\t\n\t  var noHandlers = []\n\t  function getHandlers(emitter, type, copy) {\n\t    var arr = emitter._handlers && emitter._handlers[type]\n\t    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n\t    else return arr || noHandlers\n\t  }\n\t\n\t  var off = CodeMirror.off = function(emitter, type, f) {\n\t    if (emitter.removeEventListener)\n\t      emitter.removeEventListener(type, f, false);\n\t    else if (emitter.detachEvent)\n\t      emitter.detachEvent(\"on\" + type, f);\n\t    else {\n\t      var handlers = getHandlers(emitter, type, false)\n\t      for (var i = 0; i < handlers.length; ++i)\n\t        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n\t    }\n\t  };\n\t\n\t  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n\t    var handlers = getHandlers(emitter, type, true)\n\t    if (!handlers.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n\t  };\n\t\n\t  var orphanDelayedCallbacks = null;\n\t\n\t  // Often, we want to signal events at a point where we are in the\n\t  // middle of some work, but don't want the handler to start calling\n\t  // other methods on the editor, which might be in an inconsistent\n\t  // state or simply not expect any other events to happen.\n\t  // signalLater looks whether there are any handlers, and schedules\n\t  // them to be executed when the last operation ends, or, if no\n\t  // operation is active, when a timeout fires.\n\t  function signalLater(emitter, type /*, values...*/) {\n\t    var arr = getHandlers(emitter, type, false)\n\t    if (!arr.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2), list;\n\t    if (operationGroup) {\n\t      list = operationGroup.delayedCallbacks;\n\t    } else if (orphanDelayedCallbacks) {\n\t      list = orphanDelayedCallbacks;\n\t    } else {\n\t      list = orphanDelayedCallbacks = [];\n\t      setTimeout(fireOrphanDelayed, 0);\n\t    }\n\t    function bnd(f) {return function(){f.apply(null, args);};};\n\t    for (var i = 0; i < arr.length; ++i)\n\t      list.push(bnd(arr[i]));\n\t  }\n\t\n\t  function fireOrphanDelayed() {\n\t    var delayed = orphanDelayedCallbacks;\n\t    orphanDelayedCallbacks = null;\n\t    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  // The DOM events that CodeMirror handles can be overridden by\n\t  // registering a (non-DOM) handler on the editor for the event name,\n\t  // and preventDefault-ing the event in that handler.\n\t  function signalDOMEvent(cm, e, override) {\n\t    if (typeof e == \"string\")\n\t      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n\t    signal(cm, override || e.type, cm, e);\n\t    return e_defaultPrevented(e) || e.codemirrorIgnore;\n\t  }\n\t\n\t  function signalCursorActivity(cm) {\n\t    var arr = cm._handlers && cm._handlers.cursorActivity;\n\t    if (!arr) return;\n\t    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\t    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n\t      set.push(arr[i]);\n\t  }\n\t\n\t  function hasHandler(emitter, type) {\n\t    return getHandlers(emitter, type).length > 0\n\t  }\n\t\n\t  // Add on and off methods to a constructor's prototype, to make\n\t  // registering events on such objects more convenient.\n\t  function eventMixin(ctor) {\n\t    ctor.prototype.on = function(type, f) {on(this, type, f);};\n\t    ctor.prototype.off = function(type, f) {off(this, type, f);};\n\t  }\n\t\n\t  // MISC UTILITIES\n\t\n\t  // Number of pixels added to scroller and sizer to hide scrollbar\n\t  var scrollerGap = 30;\n\t\n\t  // Returned or thrown by various protocols to signal 'I'm not\n\t  // handling this'.\n\t  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\t\n\t  // Reused option objects for setSelection & friends\n\t  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\t\n\t  function Delayed() {this.id = null;}\n\t  Delayed.prototype.set = function(ms, f) {\n\t    clearTimeout(this.id);\n\t    this.id = setTimeout(f, ms);\n\t  };\n\t\n\t  // Counts the column offset in a string, taking tabs into account.\n\t  // Used mostly to find indentation.\n\t  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n\t    if (end == null) {\n\t      end = string.search(/[^\\s\\u00a0]/);\n\t      if (end == -1) end = string.length;\n\t    }\n\t    for (var i = startIndex || 0, n = startValue || 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", i);\n\t      if (nextTab < 0 || nextTab >= end)\n\t        return n + (end - i);\n\t      n += nextTab - i;\n\t      n += tabSize - (n % tabSize);\n\t      i = nextTab + 1;\n\t    }\n\t  };\n\t\n\t  // The inverse of countColumn -- find the offset that corresponds to\n\t  // a particular column.\n\t  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n\t    for (var pos = 0, col = 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", pos);\n\t      if (nextTab == -1) nextTab = string.length;\n\t      var skipped = nextTab - pos;\n\t      if (nextTab == string.length || col + skipped >= goal)\n\t        return pos + Math.min(skipped, goal - col);\n\t      col += nextTab - pos;\n\t      col += tabSize - (col % tabSize);\n\t      pos = nextTab + 1;\n\t      if (col >= goal) return pos;\n\t    }\n\t  }\n\t\n\t  var spaceStrs = [\"\"];\n\t  function spaceStr(n) {\n\t    while (spaceStrs.length <= n)\n\t      spaceStrs.push(lst(spaceStrs) + \" \");\n\t    return spaceStrs[n];\n\t  }\n\t\n\t  function lst(arr) { return arr[arr.length-1]; }\n\t\n\t  var selectInput = function(node) { node.select(); };\n\t  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n\t    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n\t  else if (ie) // Suppress mysterious IE10 errors\n\t    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\t\n\t  function indexOf(array, elt) {\n\t    for (var i = 0; i < array.length; ++i)\n\t      if (array[i] == elt) return i;\n\t    return -1;\n\t  }\n\t  function map(array, f) {\n\t    var out = [];\n\t    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n\t    return out;\n\t  }\n\t\n\t  function nothing() {}\n\t\n\t  function createObj(base, props) {\n\t    var inst;\n\t    if (Object.create) {\n\t      inst = Object.create(base);\n\t    } else {\n\t      nothing.prototype = base;\n\t      inst = new nothing();\n\t    }\n\t    if (props) copyObj(props, inst);\n\t    return inst;\n\t  };\n\t\n\t  function copyObj(obj, target, overwrite) {\n\t    if (!target) target = {};\n\t    for (var prop in obj)\n\t      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n\t        target[prop] = obj[prop];\n\t    return target;\n\t  }\n\t\n\t  function bind(f) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return function(){return f.apply(null, args);};\n\t  }\n\t\n\t  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\t  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n\t    return /\\w/.test(ch) || ch > \"\\x80\" &&\n\t      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n\t  };\n\t  function isWordChar(ch, helper) {\n\t    if (!helper) return isWordCharBasic(ch);\n\t    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n\t    return helper.test(ch);\n\t  }\n\t\n\t  function isEmpty(obj) {\n\t    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\t    return true;\n\t  }\n\t\n\t  // Extending unicode characters. A series of a non-extending char +\n\t  // any number of extending chars is treated as a single unit as far\n\t  // as editing and measuring is concerned. This is not fully correct,\n\t  // since some scripts/fonts/browsers also treat other configurations\n\t  // of code points as a group.\n\t  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\t  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\t\n\t  // DOM UTILITIES\n\t\n\t  function elt(tag, content, className, style) {\n\t    var e = document.createElement(tag);\n\t    if (className) e.className = className;\n\t    if (style) e.style.cssText = style;\n\t    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n\t    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n\t    return e;\n\t  }\n\t\n\t  var range;\n\t  if (document.createRange) range = function(node, start, end, endNode) {\n\t    var r = document.createRange();\n\t    r.setEnd(endNode || node, end);\n\t    r.setStart(node, start);\n\t    return r;\n\t  };\n\t  else range = function(node, start, end) {\n\t    var r = document.body.createTextRange();\n\t    try { r.moveToElementText(node.parentNode); }\n\t    catch(e) { return r; }\n\t    r.collapse(true);\n\t    r.moveEnd(\"character\", end);\n\t    r.moveStart(\"character\", start);\n\t    return r;\n\t  };\n\t\n\t  function removeChildren(e) {\n\t    for (var count = e.childNodes.length; count > 0; --count)\n\t      e.removeChild(e.firstChild);\n\t    return e;\n\t  }\n\t\n\t  function removeChildrenAndAdd(parent, e) {\n\t    return removeChildren(parent).appendChild(e);\n\t  }\n\t\n\t  var contains = CodeMirror.contains = function(parent, child) {\n\t    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n\t      child = child.parentNode;\n\t    if (parent.contains)\n\t      return parent.contains(child);\n\t    do {\n\t      if (child.nodeType == 11) child = child.host;\n\t      if (child == parent) return true;\n\t    } while (child = child.parentNode);\n\t  };\n\t\n\t  function activeElt() {\n\t    var activeElement = document.activeElement;\n\t    while (activeElement && activeElement.root && activeElement.root.activeElement)\n\t      activeElement = activeElement.root.activeElement;\n\t    return activeElement;\n\t  }\n\t  // Older versions of IE throws unspecified error when touching\n\t  // document.activeElement in some cases (during loading, in iframe)\n\t  if (ie && ie_version < 11) activeElt = function() {\n\t    try { return document.activeElement; }\n\t    catch(e) { return document.body; }\n\t  };\n\t\n\t  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n\t  var rmClass = CodeMirror.rmClass = function(node, cls) {\n\t    var current = node.className;\n\t    var match = classTest(cls).exec(current);\n\t    if (match) {\n\t      var after = current.slice(match.index + match[0].length);\n\t      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n\t    }\n\t  };\n\t  var addClass = CodeMirror.addClass = function(node, cls) {\n\t    var current = node.className;\n\t    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n\t  };\n\t  function joinClasses(a, b) {\n\t    var as = a.split(\" \");\n\t    for (var i = 0; i < as.length; i++)\n\t      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n\t    return b;\n\t  }\n\t\n\t  // WINDOW-WIDE EVENTS\n\t\n\t  // These must be handled carefully, because naively registering a\n\t  // handler for each editor will cause the editors to never be\n\t  // garbage collected.\n\t\n\t  function forEachCodeMirror(f) {\n\t    if (!document.body.getElementsByClassName) return;\n\t    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n\t    for (var i = 0; i < byClass.length; i++) {\n\t      var cm = byClass[i].CodeMirror;\n\t      if (cm) f(cm);\n\t    }\n\t  }\n\t\n\t  var globalsRegistered = false;\n\t  function ensureGlobalHandlers() {\n\t    if (globalsRegistered) return;\n\t    registerGlobalHandlers();\n\t    globalsRegistered = true;\n\t  }\n\t  function registerGlobalHandlers() {\n\t    // When the window resizes, we need to refresh active editors.\n\t    var resizeTimer;\n\t    on(window, \"resize\", function() {\n\t      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n\t        resizeTimer = null;\n\t        forEachCodeMirror(onResize);\n\t      }, 100);\n\t    });\n\t    // When the window loses focus, we want to show the editor as blurred\n\t    on(window, \"blur\", function() {\n\t      forEachCodeMirror(onBlur);\n\t    });\n\t  }\n\t\n\t  // FEATURE DETECTION\n\t\n\t  // Detect drag-and-drop\n\t  var dragAndDrop = function() {\n\t    // There is *some* kind of drag-and-drop support in IE6-8, but I\n\t    // couldn't get it to work yet.\n\t    if (ie && ie_version < 9) return false;\n\t    var div = elt('div');\n\t    return \"draggable\" in div || \"dragDrop\" in div;\n\t  }();\n\t\n\t  var zwspSupported;\n\t  function zeroWidthElement(measure) {\n\t    if (zwspSupported == null) {\n\t      var test = elt(\"span\", \"\\u200b\");\n\t      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\t      if (measure.firstChild.offsetHeight != 0)\n\t        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n\t    }\n\t    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n\t      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n\t    node.setAttribute(\"cm-text\", \"\");\n\t    return node;\n\t  }\n\t\n\t  // Feature-detect IE's crummy client rect reporting for bidi text\n\t  var badBidiRects;\n\t  function hasBadBidiRects(measure) {\n\t    if (badBidiRects != null) return badBidiRects;\n\t    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n\t    var r0 = range(txt, 0, 1).getBoundingClientRect();\n\t    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n\t    var r1 = range(txt, 1, 2).getBoundingClientRect();\n\t    return badBidiRects = (r1.right - r0.right < 3);\n\t  }\n\t\n\t  // See if \"\".split is the broken IE version, if so, provide an\n\t  // alternative way to split lines.\n\t  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n\t    var pos = 0, result = [], l = string.length;\n\t    while (pos <= l) {\n\t      var nl = string.indexOf(\"\\n\", pos);\n\t      if (nl == -1) nl = string.length;\n\t      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n\t      var rt = line.indexOf(\"\\r\");\n\t      if (rt != -1) {\n\t        result.push(line.slice(0, rt));\n\t        pos += rt + 1;\n\t      } else {\n\t        result.push(line);\n\t        pos = nl + 1;\n\t      }\n\t    }\n\t    return result;\n\t  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\t\n\t  var hasSelection = window.getSelection ? function(te) {\n\t    try { return te.selectionStart != te.selectionEnd; }\n\t    catch(e) { return false; }\n\t  } : function(te) {\n\t    try {var range = te.ownerDocument.selection.createRange();}\n\t    catch(e) {}\n\t    if (!range || range.parentElement() != te) return false;\n\t    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n\t  };\n\t\n\t  var hasCopyEvent = (function() {\n\t    var e = elt(\"div\");\n\t    if (\"oncopy\" in e) return true;\n\t    e.setAttribute(\"oncopy\", \"return;\");\n\t    return typeof e.oncopy == \"function\";\n\t  })();\n\t\n\t  var badZoomedRects = null;\n\t  function hasBadZoomedRects(measure) {\n\t    if (badZoomedRects != null) return badZoomedRects;\n\t    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n\t    var normal = node.getBoundingClientRect();\n\t    var fromRange = range(node, 0, 1).getBoundingClientRect();\n\t    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n\t  }\n\t\n\t  // KEY NAMES\n\t\n\t  var keyNames = CodeMirror.keyNames = {\n\t    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n\t    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n\t    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n\t    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n\t    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n\t    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n\t    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n\t  };\n\t  (function() {\n\t    // Number keys\n\t    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n\t    // Alphabetic keys\n\t    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n\t    // Function keys\n\t    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n\t  })();\n\t\n\t  // BIDI HELPERS\n\t\n\t  function iterateBidiSections(order, from, to, f) {\n\t    if (!order) return f(from, to, \"ltr\");\n\t    var found = false;\n\t    for (var i = 0; i < order.length; ++i) {\n\t      var part = order[i];\n\t      if (part.from < to && part.to > from || from == to && part.to == from) {\n\t        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n\t        found = true;\n\t      }\n\t    }\n\t    if (!found) f(from, to, \"ltr\");\n\t  }\n\t\n\t  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n\t  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\t\n\t  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n\t  function lineRight(line) {\n\t    var order = getOrder(line);\n\t    if (!order) return line.text.length;\n\t    return bidiRight(lst(order));\n\t  }\n\t\n\t  function lineStart(cm, lineN) {\n\t    var line = getLine(cm.doc, lineN);\n\t    var visual = visualLine(line);\n\t    if (visual != line) lineN = lineNo(visual);\n\t    var order = getOrder(visual);\n\t    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n\t    return Pos(lineN, ch);\n\t  }\n\t  function lineEnd(cm, lineN) {\n\t    var merged, line = getLine(cm.doc, lineN);\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      lineN = null;\n\t    }\n\t    var order = getOrder(line);\n\t    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n\t    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n\t  }\n\t  function lineStartSmart(cm, pos) {\n\t    var start = lineStart(cm, pos.line);\n\t    var line = getLine(cm.doc, start.line);\n\t    var order = getOrder(line);\n\t    if (!order || order[0].level == 0) {\n\t      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n\t      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n\t      return Pos(start.line, inWS ? 0 : firstNonWS);\n\t    }\n\t    return start;\n\t  }\n\t\n\t  function compareBidiLevel(order, a, b) {\n\t    var linedir = order[0].level;\n\t    if (a == linedir) return true;\n\t    if (b == linedir) return false;\n\t    return a < b;\n\t  }\n\t  var bidiOther;\n\t  function getBidiPartAt(order, pos) {\n\t    bidiOther = null;\n\t    for (var i = 0, found; i < order.length; ++i) {\n\t      var cur = order[i];\n\t      if (cur.from < pos && cur.to > pos) return i;\n\t      if ((cur.from == pos || cur.to == pos)) {\n\t        if (found == null) {\n\t          found = i;\n\t        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n\t          if (cur.from != cur.to) bidiOther = found;\n\t          return i;\n\t        } else {\n\t          if (cur.from != cur.to) bidiOther = i;\n\t          return found;\n\t        }\n\t      }\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function moveInLine(line, pos, dir, byUnit) {\n\t    if (!byUnit) return pos + dir;\n\t    do pos += dir;\n\t    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n\t    return pos;\n\t  }\n\t\n\t  // This is needed in order to move 'visually' through bi-directional\n\t  // text -- i.e., pressing left should make the cursor go left, even\n\t  // when in RTL text. The tricky part is the 'jumps', where RTL and\n\t  // LTR text touch each other. This often requires the cursor offset\n\t  // to move more than one unit, in order to visually move one unit.\n\t  function moveVisually(line, start, dir, byUnit) {\n\t    var bidi = getOrder(line);\n\t    if (!bidi) return moveLogically(line, start, dir, byUnit);\n\t    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n\t    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\t\n\t    for (;;) {\n\t      if (target > part.from && target < part.to) return target;\n\t      if (target == part.from || target == part.to) {\n\t        if (getBidiPartAt(bidi, target) == pos) return target;\n\t        part = bidi[pos += dir];\n\t        return (dir > 0) == part.level % 2 ? part.to : part.from;\n\t      } else {\n\t        part = bidi[pos += dir];\n\t        if (!part) return null;\n\t        if ((dir > 0) == part.level % 2)\n\t          target = moveInLine(line, part.to, -1, byUnit);\n\t        else\n\t          target = moveInLine(line, part.from, 1, byUnit);\n\t      }\n\t    }\n\t  }\n\t\n\t  function moveLogically(line, start, dir, byUnit) {\n\t    var target = start + dir;\n\t    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n\t    return target < 0 || target > line.text.length ? null : target;\n\t  }\n\t\n\t  // Bidirectional ordering algorithm\n\t  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n\t  // that this (partially) implements.\n\t\n\t  // One-char codes used for character types:\n\t  // L (L):   Left-to-Right\n\t  // R (R):   Right-to-Left\n\t  // r (AL):  Right-to-Left Arabic\n\t  // 1 (EN):  European Number\n\t  // + (ES):  European Number Separator\n\t  // % (ET):  European Number Terminator\n\t  // n (AN):  Arabic Number\n\t  // , (CS):  Common Number Separator\n\t  // m (NSM): Non-Spacing Mark\n\t  // b (BN):  Boundary Neutral\n\t  // s (B):   Paragraph Separator\n\t  // t (S):   Segment Separator\n\t  // w (WS):  Whitespace\n\t  // N (ON):  Other Neutrals\n\t\n\t  // Returns null if characters are ordered as they appear\n\t  // (left-to-right), or an array of sections ({from, to, level}\n\t  // objects) in the order in which they occur visually.\n\t  var bidiOrdering = (function() {\n\t    // Character types for codepoints 0 to 0xff\n\t    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n\t    // Character types for codepoints 0x600 to 0x6ff\n\t    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n\t    function charType(code) {\n\t      if (code <= 0xf7) return lowTypes.charAt(code);\n\t      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n\t      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n\t      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n\t      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n\t      else if (code == 0x200c) return \"b\";\n\t      else return \"L\";\n\t    }\n\t\n\t    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\t    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\t    // Browsers seem to always treat the boundaries of block elements as being L.\n\t    var outerType = \"L\";\n\t\n\t    function BidiSpan(level, from, to) {\n\t      this.level = level;\n\t      this.from = from; this.to = to;\n\t    }\n\t\n\t    return function(str) {\n\t      if (!bidiRE.test(str)) return false;\n\t      var len = str.length, types = [];\n\t      for (var i = 0, type; i < len; ++i)\n\t        types.push(type = charType(str.charCodeAt(i)));\n\t\n\t      // W1. Examine each non-spacing mark (NSM) in the level run, and\n\t      // change the type of the NSM to the type of the previous\n\t      // character. If the NSM is at the start of the level run, it will\n\t      // get the type of sor.\n\t      for (var i = 0, prev = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"m\") types[i] = prev;\n\t        else prev = type;\n\t      }\n\t\n\t      // W2. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, AL, or sor) is found. If an\n\t      // AL is found, change the type of the European number to Arabic\n\t      // number.\n\t      // W3. Change all ALs to R.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n\t        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n\t      }\n\t\n\t      // W4. A single European separator between two European numbers\n\t      // changes to a European number. A single common separator between\n\t      // two numbers of the same type changes to that type.\n\t      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n\t        var type = types[i];\n\t        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n\t        else if (type == \",\" && prev == types[i+1] &&\n\t                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n\t        prev = type;\n\t      }\n\t\n\t      // W5. A sequence of European terminators adjacent to European\n\t      // numbers changes to all European numbers.\n\t      // W6. Otherwise, separators and terminators change to Other\n\t      // Neutral.\n\t      for (var i = 0; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \",\") types[i] = \"N\";\n\t        else if (type == \"%\") {\n\t          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\t          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // W7. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, or sor) is found. If an L is\n\t      // found, then change the type of the European number to L.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n\t        else if (isStrong.test(type)) cur = type;\n\t      }\n\t\n\t      // N1. A sequence of neutrals takes the direction of the\n\t      // surrounding strong text if the text on both sides has the same\n\t      // direction. European and Arabic numbers act as if they were R in\n\t      // terms of their influence on neutrals. Start-of-level-run (sor)\n\t      // and end-of-level-run (eor) are used at level run boundaries.\n\t      // N2. Any remaining neutrals take the embedding direction.\n\t      for (var i = 0; i < len; ++i) {\n\t        if (isNeutral.test(types[i])) {\n\t          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\t          var before = (i ? types[i-1] : outerType) == \"L\";\n\t          var after = (end < len ? types[end] : outerType) == \"L\";\n\t          var replace = before || after ? \"L\" : \"R\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // Here we depart from the documented algorithm, in order to avoid\n\t      // building up an actual levels array. Since there are only three\n\t      // levels (0, 1, 2) in an implementation that doesn't take\n\t      // explicit embedding into account, we can build up the order on\n\t      // the fly, without following the level-based algorithm.\n\t      var order = [], m;\n\t      for (var i = 0; i < len;) {\n\t        if (countsAsLeft.test(types[i])) {\n\t          var start = i;\n\t          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\t          order.push(new BidiSpan(0, start, i));\n\t        } else {\n\t          var pos = i, at = order.length;\n\t          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\t          for (var j = pos; j < i;) {\n\t            if (countsAsNum.test(types[j])) {\n\t              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n\t              var nstart = j;\n\t              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\t              order.splice(at, 0, new BidiSpan(2, nstart, j));\n\t              pos = j;\n\t            } else ++j;\n\t          }\n\t          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n\t        }\n\t      }\n\t      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n\t        order[0].from = m[0].length;\n\t        order.unshift(new BidiSpan(0, 0, m[0].length));\n\t      }\n\t      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n\t        lst(order).to -= m[0].length;\n\t        order.push(new BidiSpan(0, len - m[0].length, len));\n\t      }\n\t      if (order[0].level == 2)\n\t        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n\t      if (order[0].level != lst(order).level)\n\t        order.push(new BidiSpan(order[0].level, len, len));\n\t\n\t      return order;\n\t    };\n\t  })();\n\t\n\t  // THE END\n\t\n\t  CodeMirror.version = \"5.11.0\";\n\t\n\t  return CodeMirror;\n\t});\n\n\n/***/ },\n\n/***/ 361:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360), __webpack_require__(362), __webpack_require__(365));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\", \"../markdown/markdown\", \"../../addon/mode/overlay\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tvar urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\\.beep|\\.lwz|\\.xpc|\\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\\.beeps?|xmpp|xri|ymsgr|z39\\.50[rs]?):(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]|\\([^\\s()<>]*\\))+(?:\\([^\\s()<>]*\\)|[^\\s`*!()\\[\\]{};:'\".,<>?]))/i\n\t\n\tCodeMirror.defineMode(\"gfm\", function(config, modeConfig) {\n\t  var codeDepth = 0;\n\t  function blankLine(state) {\n\t    state.code = false;\n\t    return null;\n\t  }\n\t  var gfmOverlay = {\n\t    startState: function() {\n\t      return {\n\t        code: false,\n\t        codeBlock: false,\n\t        ateSpace: false\n\t      };\n\t    },\n\t    copyState: function(s) {\n\t      return {\n\t        code: s.code,\n\t        codeBlock: s.codeBlock,\n\t        ateSpace: s.ateSpace\n\t      };\n\t    },\n\t    token: function(stream, state) {\n\t      state.combineTokens = null;\n\t\n\t      // Hack to prevent formatting override inside code blocks (block and inline)\n\t      if (state.codeBlock) {\n\t        if (stream.match(/^```+/)) {\n\t          state.codeBlock = false;\n\t          return null;\n\t        }\n\t        stream.skipToEnd();\n\t        return null;\n\t      }\n\t      if (stream.sol()) {\n\t        state.code = false;\n\t      }\n\t      if (stream.sol() && stream.match(/^```+/)) {\n\t        stream.skipToEnd();\n\t        state.codeBlock = true;\n\t        return null;\n\t      }\n\t      // If this block is changed, it may need to be updated in Markdown mode\n\t      if (stream.peek() === '`') {\n\t        stream.next();\n\t        var before = stream.pos;\n\t        stream.eatWhile('`');\n\t        var difference = 1 + stream.pos - before;\n\t        if (!state.code) {\n\t          codeDepth = difference;\n\t          state.code = true;\n\t        } else {\n\t          if (difference === codeDepth) { // Must be exact\n\t            state.code = false;\n\t          }\n\t        }\n\t        return null;\n\t      } else if (state.code) {\n\t        stream.next();\n\t        return null;\n\t      }\n\t      // Check if space. If so, links can be formatted later on\n\t      if (stream.eatSpace()) {\n\t        state.ateSpace = true;\n\t        return null;\n\t      }\n\t      if (stream.sol() || state.ateSpace) {\n\t        state.ateSpace = false;\n\t        if (modeConfig.gitHubSpice !== false) {\n\t          if(stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+@)?(?:[a-f0-9]{7,40}\\b)/)) {\n\t            // User/Project@SHA\n\t            // User@SHA\n\t            // SHA\n\t            state.combineTokens = true;\n\t            return \"link\";\n\t          } else if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+)?#[0-9]+\\b/)) {\n\t            // User/Project#Num\n\t            // User#Num\n\t            // #Num\n\t            state.combineTokens = true;\n\t            return \"link\";\n\t          }\n\t        }\n\t      }\n\t      if (stream.match(urlRE) &&\n\t          stream.string.slice(stream.start - 2, stream.start) != \"](\" &&\n\t          (stream.start == 0 || /\\W/.test(stream.string.charAt(stream.start - 1)))) {\n\t        // URLs\n\t        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n\t        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine\n\t        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL\n\t        state.combineTokens = true;\n\t        return \"link\";\n\t      }\n\t      stream.next();\n\t      return null;\n\t    },\n\t    blankLine: blankLine\n\t  };\n\t\n\t  var markdownConfig = {\n\t    underscoresBreakWords: false,\n\t    taskLists: true,\n\t    fencedCodeBlocks: '```',\n\t    strikethrough: true\n\t  };\n\t  for (var attr in modeConfig) {\n\t    markdownConfig[attr] = modeConfig[attr];\n\t  }\n\t  markdownConfig.name = \"markdown\";\n\t  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);\n\t\n\t}, \"markdown\");\n\t\n\t  CodeMirror.defineMIME(\"text/x-gfm\", \"gfm\");\n\t});\n\n\n/***/ },\n\n/***/ 362:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360), __webpack_require__(363), __webpack_require__(364));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\n\t\n\t  var htmlFound = CodeMirror.modes.hasOwnProperty(\"xml\");\n\t  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: \"xml\", htmlMode: true} : \"text/plain\");\n\t\n\t  function getMode(name) {\n\t    if (CodeMirror.findModeByName) {\n\t      var found = CodeMirror.findModeByName(name);\n\t      if (found) name = found.mime || found.mimes[0];\n\t    }\n\t    var mode = CodeMirror.getMode(cmCfg, name);\n\t    return mode.name == \"null\" ? null : mode;\n\t  }\n\t\n\t  // Should characters that affect highlighting be highlighted separate?\n\t  // Does not include characters that will be output (such as `1.` and `-` for lists)\n\t  if (modeCfg.highlightFormatting === undefined)\n\t    modeCfg.highlightFormatting = false;\n\t\n\t  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\n\t  // Excess `>` will emit `error` token.\n\t  if (modeCfg.maxBlockquoteDepth === undefined)\n\t    modeCfg.maxBlockquoteDepth = 0;\n\t\n\t  // Should underscores in words open/close em/strong?\n\t  if (modeCfg.underscoresBreakWords === undefined)\n\t    modeCfg.underscoresBreakWords = true;\n\t\n\t  // Use `fencedCodeBlocks` to configure fenced code blocks. false to\n\t  // disable, string to specify a precise regexp that the fence should\n\t  // match, and true to allow three or more backticks or tildes (as\n\t  // per CommonMark).\n\t\n\t  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\n\t  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\n\t\n\t  // Turn on strikethrough syntax\n\t  if (modeCfg.strikethrough === undefined)\n\t    modeCfg.strikethrough = false;\n\t\n\t  // Allow token types to be overridden by user-provided token types.\n\t  if (modeCfg.tokenTypeOverrides === undefined)\n\t    modeCfg.tokenTypeOverrides = {};\n\t\n\t  var codeDepth = 0;\n\t\n\t  var tokenTypes = {\n\t    header: \"header\",\n\t    code: \"comment\",\n\t    quote: \"quote\",\n\t    list1: \"variable-2\",\n\t    list2: \"variable-3\",\n\t    list3: \"keyword\",\n\t    hr: \"hr\",\n\t    image: \"tag\",\n\t    formatting: \"formatting\",\n\t    linkInline: \"link\",\n\t    linkEmail: \"link\",\n\t    linkText: \"link\",\n\t    linkHref: \"string\",\n\t    em: \"em\",\n\t    strong: \"strong\",\n\t    strikethrough: \"strikethrough\"\n\t  };\n\t\n\t  for (var tokenType in tokenTypes) {\n\t    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\n\t      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\n\t    }\n\t  }\n\t\n\t  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\n\t  ,   ulRE = /^[*\\-+]\\s+/\n\t  ,   olRE = /^[0-9]+([.)])\\s+/\n\t  ,   taskListRE = /^\\[(x| )\\](?=\\s)/ // Must follow ulRE or olRE\n\t  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\n\t  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\n\t  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~]+/\n\t  ,   fencedCodeRE = new RegExp(\"^(\" + (modeCfg.fencedCodeBlocks === true ? \"~~~+|```+\" : modeCfg.fencedCodeBlocks) +\n\t                                \")[ \\\\t]*([\\\\w+#]*)\");\n\t\n\t  function switchInline(stream, state, f) {\n\t    state.f = state.inline = f;\n\t    return f(stream, state);\n\t  }\n\t\n\t  function switchBlock(stream, state, f) {\n\t    state.f = state.block = f;\n\t    return f(stream, state);\n\t  }\n\t\n\t  function lineIsEmpty(line) {\n\t    return !line || !/\\S/.test(line.string)\n\t  }\n\t\n\t  // Blocks\n\t\n\t  function blankLine(state) {\n\t    // Reset linkTitle state\n\t    state.linkTitle = false;\n\t    // Reset EM state\n\t    state.em = false;\n\t    // Reset STRONG state\n\t    state.strong = false;\n\t    // Reset strikethrough state\n\t    state.strikethrough = false;\n\t    // Reset state.quote\n\t    state.quote = 0;\n\t    // Reset state.indentedCode\n\t    state.indentedCode = false;\n\t    if (!htmlFound && state.f == htmlBlock) {\n\t      state.f = inlineNormal;\n\t      state.block = blockNormal;\n\t    }\n\t    // Reset state.trailingSpace\n\t    state.trailingSpace = 0;\n\t    state.trailingSpaceNewLine = false;\n\t    // Mark this line as blank\n\t    state.prevLine = state.thisLine\n\t    state.thisLine = null\n\t    return null;\n\t  }\n\t\n\t  function blockNormal(stream, state) {\n\t\n\t    var sol = stream.sol();\n\t\n\t    var prevLineIsList = state.list !== false,\n\t        prevLineIsIndentedCode = state.indentedCode;\n\t\n\t    state.indentedCode = false;\n\t\n\t    if (prevLineIsList) {\n\t      if (state.indentationDiff >= 0) { // Continued list\n\t        if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block\n\t          state.indentation -= state.indentationDiff;\n\t        }\n\t        state.list = null;\n\t      } else if (state.indentation > 0) {\n\t        state.list = null;\n\t        state.listDepth = Math.floor(state.indentation / 4);\n\t      } else { // No longer a list\n\t        state.list = false;\n\t        state.listDepth = 0;\n\t      }\n\t    }\n\t\n\t    var match = null;\n\t    if (state.indentationDiff >= 4) {\n\t      stream.skipToEnd();\n\t      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {\n\t        state.indentation -= 4;\n\t        state.indentedCode = true;\n\t        return tokenTypes.code;\n\t      } else {\n\t        return null;\n\t      }\n\t    } else if (stream.eatSpace()) {\n\t      return null;\n\t    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\n\t      state.header = match[1].length;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n\t      state.f = state.inline;\n\t      return getType(state);\n\t    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&\n\t               !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {\n\t      state.header = match[0].charAt(0) == '=' ? 1 : 2;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n\t      state.f = state.inline;\n\t      return getType(state);\n\t    } else if (stream.eat('>')) {\n\t      state.quote = sol ? 1 : state.quote + 1;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\n\t      stream.eatSpace();\n\t      return getType(state);\n\t    } else if (stream.peek() === '[') {\n\t      return switchInline(stream, state, footnoteLink);\n\t    } else if (stream.match(hrRE, true)) {\n\t      state.hr = true;\n\t      return tokenTypes.hr;\n\t    } else if ((lineIsEmpty(state.prevLine) || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {\n\t      var listType = null;\n\t      if (stream.match(ulRE, true)) {\n\t        listType = 'ul';\n\t      } else {\n\t        stream.match(olRE, true);\n\t        listType = 'ol';\n\t      }\n\t      state.indentation = stream.column() + stream.current().length;\n\t      state.list = true;\n\t      state.listDepth++;\n\t      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\n\t        state.taskList = true;\n\t      }\n\t      state.f = state.inline;\n\t      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\n\t      return getType(state);\n\t    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {\n\t      state.fencedChars = match[1]\n\t      // try switching mode\n\t      state.localMode = getMode(match[2]);\n\t      if (state.localMode) state.localState = state.localMode.startState();\n\t      state.f = state.block = local;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n\t      state.code = true;\n\t      return getType(state);\n\t    }\n\t\n\t    return switchInline(stream, state, state.inline);\n\t  }\n\t\n\t  function htmlBlock(stream, state) {\n\t    var style = htmlMode.token(stream, state.htmlState);\n\t    if ((htmlFound && state.htmlState.tagStart === null &&\n\t         (!state.htmlState.context && state.htmlState.tokenize.isInText)) ||\n\t        (state.md_inside && stream.current().indexOf(\">\") > -1)) {\n\t      state.f = inlineNormal;\n\t      state.block = blockNormal;\n\t      state.htmlState = null;\n\t    }\n\t    return style;\n\t  }\n\t\n\t  function local(stream, state) {\n\t    if (state.fencedChars && stream.match(state.fencedChars, false)) {\n\t      state.localMode = state.localState = null;\n\t      state.f = state.block = leavingLocal;\n\t      return null;\n\t    } else if (state.localMode) {\n\t      return state.localMode.token(stream, state.localState);\n\t    } else {\n\t      stream.skipToEnd();\n\t      return tokenTypes.code;\n\t    }\n\t  }\n\t\n\t  function leavingLocal(stream, state) {\n\t    stream.match(state.fencedChars);\n\t    state.block = blockNormal;\n\t    state.f = inlineNormal;\n\t    state.fencedChars = null;\n\t    if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n\t    state.code = true;\n\t    var returnType = getType(state);\n\t    state.code = false;\n\t    return returnType;\n\t  }\n\t\n\t  // Inline\n\t  function getType(state) {\n\t    var styles = [];\n\t\n\t    if (state.formatting) {\n\t      styles.push(tokenTypes.formatting);\n\t\n\t      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\n\t\n\t      for (var i = 0; i < state.formatting.length; i++) {\n\t        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\n\t\n\t        if (state.formatting[i] === \"header\") {\n\t          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\n\t        }\n\t\n\t        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\n\t        // Add `error` instead if the maximum blockquote nesting depth is passed\n\t        if (state.formatting[i] === \"quote\") {\n\t          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n\t            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\n\t          } else {\n\t            styles.push(\"error\");\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (state.taskOpen) {\n\t      styles.push(\"meta\");\n\t      return styles.length ? styles.join(' ') : null;\n\t    }\n\t    if (state.taskClosed) {\n\t      styles.push(\"property\");\n\t      return styles.length ? styles.join(' ') : null;\n\t    }\n\t\n\t    if (state.linkHref) {\n\t      styles.push(tokenTypes.linkHref, \"url\");\n\t    } else { // Only apply inline styles to non-url text\n\t      if (state.strong) { styles.push(tokenTypes.strong); }\n\t      if (state.em) { styles.push(tokenTypes.em); }\n\t      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\n\t      if (state.linkText) { styles.push(tokenTypes.linkText); }\n\t      if (state.code) { styles.push(tokenTypes.code); }\n\t    }\n\t\n\t    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\n\t\n\t    if (state.quote) {\n\t      styles.push(tokenTypes.quote);\n\t\n\t      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\n\t      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n\t        styles.push(tokenTypes.quote + \"-\" + state.quote);\n\t      } else {\n\t        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\n\t      }\n\t    }\n\t\n\t    if (state.list !== false) {\n\t      var listMod = (state.listDepth - 1) % 3;\n\t      if (!listMod) {\n\t        styles.push(tokenTypes.list1);\n\t      } else if (listMod === 1) {\n\t        styles.push(tokenTypes.list2);\n\t      } else {\n\t        styles.push(tokenTypes.list3);\n\t      }\n\t    }\n\t\n\t    if (state.trailingSpaceNewLine) {\n\t      styles.push(\"trailing-space-new-line\");\n\t    } else if (state.trailingSpace) {\n\t      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\n\t    }\n\t\n\t    return styles.length ? styles.join(' ') : null;\n\t  }\n\t\n\t  function handleText(stream, state) {\n\t    if (stream.match(textRE, true)) {\n\t      return getType(state);\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function inlineNormal(stream, state) {\n\t    var style = state.text(stream, state);\n\t    if (typeof style !== 'undefined')\n\t      return style;\n\t\n\t    if (state.list) { // List marker (*, +, -, 1., etc)\n\t      state.list = null;\n\t      return getType(state);\n\t    }\n\t\n\t    if (state.taskList) {\n\t      var taskOpen = stream.match(taskListRE, true)[1] !== \"x\";\n\t      if (taskOpen) state.taskOpen = true;\n\t      else state.taskClosed = true;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"task\";\n\t      state.taskList = false;\n\t      return getType(state);\n\t    }\n\t\n\t    state.taskOpen = false;\n\t    state.taskClosed = false;\n\t\n\t    if (state.header && stream.match(/^#+$/, true)) {\n\t      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n\t      return getType(state);\n\t    }\n\t\n\t    // Get sol() value now, before character is consumed\n\t    var sol = stream.sol();\n\t\n\t    var ch = stream.next();\n\t\n\t    if (ch === '\\\\') {\n\t      stream.next();\n\t      if (modeCfg.highlightFormatting) {\n\t        var type = getType(state);\n\t        var formattingEscape = tokenTypes.formatting + \"-escape\";\n\t        return type ? type + \" \" + formattingEscape : formattingEscape;\n\t      }\n\t    }\n\t\n\t    // Matches link titles present on next line\n\t    if (state.linkTitle) {\n\t      state.linkTitle = false;\n\t      var matchCh = ch;\n\t      if (ch === '(') {\n\t        matchCh = ')';\n\t      }\n\t      matchCh = (matchCh+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n\t      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\n\t      if (stream.match(new RegExp(regex), true)) {\n\t        return tokenTypes.linkHref;\n\t      }\n\t    }\n\t\n\t    // If this block is changed, it may need to be updated in GFM mode\n\t    if (ch === '`') {\n\t      var previousFormatting = state.formatting;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"code\";\n\t      var t = getType(state);\n\t      var before = stream.pos;\n\t      stream.eatWhile('`');\n\t      var difference = 1 + stream.pos - before;\n\t      if (!state.code) {\n\t        codeDepth = difference;\n\t        state.code = true;\n\t        return getType(state);\n\t      } else {\n\t        if (difference === codeDepth) { // Must be exact\n\t          state.code = false;\n\t          return t;\n\t        }\n\t        state.formatting = previousFormatting;\n\t        return getType(state);\n\t      }\n\t    } else if (state.code) {\n\t      return getType(state);\n\t    }\n\t\n\t    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\n\t      stream.match(/\\[[^\\]]*\\]/);\n\t      state.inline = state.f = linkHref;\n\t      return tokenTypes.image;\n\t    }\n\t\n\t    if (ch === '[' && stream.match(/.*\\](\\(.*\\)| ?\\[.*\\])/, false)) {\n\t      state.linkText = true;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      return getType(state);\n\t    }\n\t\n\t    if (ch === ']' && state.linkText && stream.match(/\\(.*\\)| ?\\[.*\\]/, false)) {\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      state.linkText = false;\n\t      state.inline = state.f = linkHref;\n\t      return type;\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\n\t      state.f = state.inline = linkInline;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      if (type){\n\t        type += \" \";\n\t      } else {\n\t        type = \"\";\n\t      }\n\t      return type + tokenTypes.linkInline;\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\n\t      state.f = state.inline = linkInline;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      if (type){\n\t        type += \" \";\n\t      } else {\n\t        type = \"\";\n\t      }\n\t      return type + tokenTypes.linkEmail;\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^(!--|\\w)/, false)) {\n\t      var end = stream.string.indexOf(\">\", stream.pos);\n\t      if (end != -1) {\n\t        var atts = stream.string.substring(stream.start, end);\n\t        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\n\t      }\n\t      stream.backUp(1);\n\t      state.htmlState = CodeMirror.startState(htmlMode);\n\t      return switchBlock(stream, state, htmlBlock);\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^\\/\\w*?>/)) {\n\t      state.md_inside = false;\n\t      return \"tag\";\n\t    }\n\t\n\t    var ignoreUnderscore = false;\n\t    if (!modeCfg.underscoresBreakWords) {\n\t      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\\w)/, false)) {\n\t        var prevPos = stream.pos - 2;\n\t        if (prevPos >= 0) {\n\t          var prevCh = stream.string.charAt(prevPos);\n\t          if (prevCh !== '_' && prevCh.match(/(\\w)/, false)) {\n\t            ignoreUnderscore = true;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {\n\t      if (sol && stream.peek() === ' ') {\n\t        // Do nothing, surrounded by newline and space\n\t      } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG\n\t        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n\t        var t = getType(state);\n\t        state.strong = false;\n\t        return t;\n\t      } else if (!state.strong && stream.eat(ch)) { // Add STRONG\n\t        state.strong = ch;\n\t        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n\t        return getType(state);\n\t      } else if (state.em === ch) { // Remove EM\n\t        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n\t        var t = getType(state);\n\t        state.em = false;\n\t        return t;\n\t      } else if (!state.em) { // Add EM\n\t        state.em = ch;\n\t        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n\t        return getType(state);\n\t      }\n\t    } else if (ch === ' ') {\n\t      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\n\t        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n\t          return getType(state);\n\t        } else { // Not surrounded by spaces, back up pointer\n\t          stream.backUp(1);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (modeCfg.strikethrough) {\n\t      if (ch === '~' && stream.eatWhile(ch)) {\n\t        if (state.strikethrough) {// Remove strikethrough\n\t          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n\t          var t = getType(state);\n\t          state.strikethrough = false;\n\t          return t;\n\t        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\n\t          state.strikethrough = true;\n\t          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n\t          return getType(state);\n\t        }\n\t      } else if (ch === ' ') {\n\t        if (stream.match(/^~~/, true)) { // Probably surrounded by space\n\t          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n\t            return getType(state);\n\t          } else { // Not surrounded by spaces, back up pointer\n\t            stream.backUp(2);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (ch === ' ') {\n\t      if (stream.match(/ +$/, false)) {\n\t        state.trailingSpace++;\n\t      } else if (state.trailingSpace) {\n\t        state.trailingSpaceNewLine = true;\n\t      }\n\t    }\n\t\n\t    return getType(state);\n\t  }\n\t\n\t  function linkInline(stream, state) {\n\t    var ch = stream.next();\n\t\n\t    if (ch === \">\") {\n\t      state.f = state.inline = inlineNormal;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      if (type){\n\t        type += \" \";\n\t      } else {\n\t        type = \"\";\n\t      }\n\t      return type + tokenTypes.linkInline;\n\t    }\n\t\n\t    stream.match(/^[^>]+/, true);\n\t\n\t    return tokenTypes.linkInline;\n\t  }\n\t\n\t  function linkHref(stream, state) {\n\t    // Check if space, and return NULL if so (to avoid marking the space)\n\t    if(stream.eatSpace()){\n\t      return null;\n\t    }\n\t    var ch = stream.next();\n\t    if (ch === '(' || ch === '[') {\n\t      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n\t      state.linkHref = true;\n\t      return getType(state);\n\t    }\n\t    return 'error';\n\t  }\n\t\n\t  function getLinkHrefInside(endChar) {\n\t    return function(stream, state) {\n\t      var ch = stream.next();\n\t\n\t      if (ch === endChar) {\n\t        state.f = state.inline = inlineNormal;\n\t        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n\t        var returnState = getType(state);\n\t        state.linkHref = false;\n\t        return returnState;\n\t      }\n\t\n\t      if (stream.match(inlineRE(endChar), true)) {\n\t        stream.backUp(1);\n\t      }\n\t\n\t      state.linkHref = true;\n\t      return getType(state);\n\t    };\n\t  }\n\t\n\t  function footnoteLink(stream, state) {\n\t    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\n\t      state.f = footnoteLinkInside;\n\t      stream.next(); // Consume [\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      state.linkText = true;\n\t      return getType(state);\n\t    }\n\t    return switchInline(stream, state, inlineNormal);\n\t  }\n\t\n\t  function footnoteLinkInside(stream, state) {\n\t    if (stream.match(/^\\]:/, true)) {\n\t      state.f = state.inline = footnoteUrl;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var returnType = getType(state);\n\t      state.linkText = false;\n\t      return returnType;\n\t    }\n\t\n\t    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\n\t\n\t    return tokenTypes.linkText;\n\t  }\n\t\n\t  function footnoteUrl(stream, state) {\n\t    // Check if space, and return NULL if so (to avoid marking the space)\n\t    if(stream.eatSpace()){\n\t      return null;\n\t    }\n\t    // Match URL\n\t    stream.match(/^[^\\s]+/, true);\n\t    // Check for link title\n\t    if (stream.peek() === undefined) { // End of line, set flag to check next line\n\t      state.linkTitle = true;\n\t    } else { // More content on line, check if link title\n\t      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\n\t    }\n\t    state.f = state.inline = inlineNormal;\n\t    return tokenTypes.linkHref + \" url\";\n\t  }\n\t\n\t  var savedInlineRE = [];\n\t  function inlineRE(endChar) {\n\t    if (!savedInlineRE[endChar]) {\n\t      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)\n\t      endChar = (endChar+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n\t      // Match any non-endChar, escaped character, as well as the closing\n\t      // endChar.\n\t      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\\\\\]|\\\\\\\\.)*?(' + endChar + ')');\n\t    }\n\t    return savedInlineRE[endChar];\n\t  }\n\t\n\t  var mode = {\n\t    startState: function() {\n\t      return {\n\t        f: blockNormal,\n\t\n\t        prevLine: null,\n\t        thisLine: null,\n\t\n\t        block: blockNormal,\n\t        htmlState: null,\n\t        indentation: 0,\n\t\n\t        inline: inlineNormal,\n\t        text: handleText,\n\t\n\t        formatting: false,\n\t        linkText: false,\n\t        linkHref: false,\n\t        linkTitle: false,\n\t        em: false,\n\t        strong: false,\n\t        header: 0,\n\t        hr: false,\n\t        taskList: false,\n\t        list: false,\n\t        listDepth: 0,\n\t        quote: 0,\n\t        trailingSpace: 0,\n\t        trailingSpaceNewLine: false,\n\t        strikethrough: false,\n\t        fencedChars: null\n\t      };\n\t    },\n\t\n\t    copyState: function(s) {\n\t      return {\n\t        f: s.f,\n\t\n\t        prevLine: s.prevLine,\n\t        thisLine: s.thisLine,\n\t\n\t        block: s.block,\n\t        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\n\t        indentation: s.indentation,\n\t\n\t        localMode: s.localMode,\n\t        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\n\t\n\t        inline: s.inline,\n\t        text: s.text,\n\t        formatting: false,\n\t        linkTitle: s.linkTitle,\n\t        code: s.code,\n\t        em: s.em,\n\t        strong: s.strong,\n\t        strikethrough: s.strikethrough,\n\t        header: s.header,\n\t        hr: s.hr,\n\t        taskList: s.taskList,\n\t        list: s.list,\n\t        listDepth: s.listDepth,\n\t        quote: s.quote,\n\t        indentedCode: s.indentedCode,\n\t        trailingSpace: s.trailingSpace,\n\t        trailingSpaceNewLine: s.trailingSpaceNewLine,\n\t        md_inside: s.md_inside,\n\t        fencedChars: s.fencedChars\n\t      };\n\t    },\n\t\n\t    token: function(stream, state) {\n\t\n\t      // Reset state.formatting\n\t      state.formatting = false;\n\t\n\t      if (stream != state.thisLine) {\n\t        var forceBlankLine = state.header || state.hr;\n\t\n\t        // Reset state.header and state.hr\n\t        state.header = 0;\n\t        state.hr = false;\n\t\n\t        if (stream.match(/^\\s*$/, true) || forceBlankLine) {\n\t          blankLine(state);\n\t          if (!forceBlankLine) return null\n\t          state.prevLine = null\n\t        }\n\t\n\t        state.prevLine = state.thisLine\n\t        state.thisLine = stream\n\t\n\t        // Reset state.taskList\n\t        state.taskList = false;\n\t\n\t        // Reset state.trailingSpace\n\t        state.trailingSpace = 0;\n\t        state.trailingSpaceNewLine = false;\n\t\n\t        state.f = state.block;\n\t        var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, '    ').length;\n\t        var difference = Math.floor((indentation - state.indentation) / 4) * 4;\n\t        if (difference > 4) difference = 4;\n\t        var adjustedIndentation = state.indentation + difference;\n\t        state.indentationDiff = adjustedIndentation - state.indentation;\n\t        state.indentation = adjustedIndentation;\n\t        if (indentation > 0) return null;\n\t      }\n\t      return state.f(stream, state);\n\t    },\n\t\n\t    innerMode: function(state) {\n\t      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\n\t      if (state.localState) return {state: state.localState, mode: state.localMode};\n\t      return {state: state, mode: mode};\n\t    },\n\t\n\t    blankLine: blankLine,\n\t\n\t    getType: getType,\n\t\n\t    fold: \"markdown\"\n\t  };\n\t  return mode;\n\t}, \"xml\");\n\t\n\tCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\n\t\n\t});\n\n\n/***/ },\n\n/***/ 363:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tvar htmlConfig = {\n\t  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n\t                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n\t                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n\t                    'track': true, 'wbr': true, 'menuitem': true},\n\t  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n\t                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n\t                     'th': true, 'tr': true},\n\t  contextGrabbers: {\n\t    'dd': {'dd': true, 'dt': true},\n\t    'dt': {'dd': true, 'dt': true},\n\t    'li': {'li': true},\n\t    'option': {'option': true, 'optgroup': true},\n\t    'optgroup': {'optgroup': true},\n\t    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n\t          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n\t          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n\t          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n\t          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n\t    'rp': {'rp': true, 'rt': true},\n\t    'rt': {'rp': true, 'rt': true},\n\t    'tbody': {'tbody': true, 'tfoot': true},\n\t    'td': {'td': true, 'th': true},\n\t    'tfoot': {'tbody': true},\n\t    'th': {'td': true, 'th': true},\n\t    'thead': {'tbody': true, 'tfoot': true},\n\t    'tr': {'tr': true}\n\t  },\n\t  doNotIndent: {\"pre\": true},\n\t  allowUnquoted: true,\n\t  allowMissing: true,\n\t  caseFold: true\n\t}\n\t\n\tvar xmlConfig = {\n\t  autoSelfClosers: {},\n\t  implicitlyClosed: {},\n\t  contextGrabbers: {},\n\t  doNotIndent: {},\n\t  allowUnquoted: false,\n\t  allowMissing: false,\n\t  caseFold: false\n\t}\n\t\n\tCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n\t  var indentUnit = editorConf.indentUnit\n\t  var config = {}\n\t  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n\t  for (var prop in defaults) config[prop] = defaults[prop]\n\t  for (var prop in config_) config[prop] = config_[prop]\n\t\n\t  // Return variables for tokenizers\n\t  var type, setStyle;\n\t\n\t  function inText(stream, state) {\n\t    function chain(parser) {\n\t      state.tokenize = parser;\n\t      return parser(stream, state);\n\t    }\n\t\n\t    var ch = stream.next();\n\t    if (ch == \"<\") {\n\t      if (stream.eat(\"!\")) {\n\t        if (stream.eat(\"[\")) {\n\t          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n\t          else return null;\n\t        } else if (stream.match(\"--\")) {\n\t          return chain(inBlock(\"comment\", \"-->\"));\n\t        } else if (stream.match(\"DOCTYPE\", true, true)) {\n\t          stream.eatWhile(/[\\w\\._\\-]/);\n\t          return chain(doctype(1));\n\t        } else {\n\t          return null;\n\t        }\n\t      } else if (stream.eat(\"?\")) {\n\t        stream.eatWhile(/[\\w\\._\\-]/);\n\t        state.tokenize = inBlock(\"meta\", \"?>\");\n\t        return \"meta\";\n\t      } else {\n\t        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t        state.tokenize = inTag;\n\t        return \"tag bracket\";\n\t      }\n\t    } else if (ch == \"&\") {\n\t      var ok;\n\t      if (stream.eat(\"#\")) {\n\t        if (stream.eat(\"x\")) {\n\t          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t        } else {\n\t          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t        }\n\t      } else {\n\t        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t      }\n\t      return ok ? \"atom\" : \"error\";\n\t    } else {\n\t      stream.eatWhile(/[^&<]/);\n\t      return null;\n\t    }\n\t  }\n\t  inText.isInText = true;\n\t\n\t  function inTag(stream, state) {\n\t    var ch = stream.next();\n\t    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t      state.tokenize = inText;\n\t      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t      return \"tag bracket\";\n\t    } else if (ch == \"=\") {\n\t      type = \"equals\";\n\t      return null;\n\t    } else if (ch == \"<\") {\n\t      state.tokenize = inText;\n\t      state.state = baseState;\n\t      state.tagName = state.tagStart = null;\n\t      var next = state.tokenize(stream, state);\n\t      return next ? next + \" tag error\" : \"tag error\";\n\t    } else if (/[\\'\\\"]/.test(ch)) {\n\t      state.tokenize = inAttribute(ch);\n\t      state.stringStartCol = stream.column();\n\t      return state.tokenize(stream, state);\n\t    } else {\n\t      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n\t      return \"word\";\n\t    }\n\t  }\n\t\n\t  function inAttribute(quote) {\n\t    var closure = function(stream, state) {\n\t      while (!stream.eol()) {\n\t        if (stream.next() == quote) {\n\t          state.tokenize = inTag;\n\t          break;\n\t        }\n\t      }\n\t      return \"string\";\n\t    };\n\t    closure.isInAttribute = true;\n\t    return closure;\n\t  }\n\t\n\t  function inBlock(style, terminator) {\n\t    return function(stream, state) {\n\t      while (!stream.eol()) {\n\t        if (stream.match(terminator)) {\n\t          state.tokenize = inText;\n\t          break;\n\t        }\n\t        stream.next();\n\t      }\n\t      return style;\n\t    };\n\t  }\n\t  function doctype(depth) {\n\t    return function(stream, state) {\n\t      var ch;\n\t      while ((ch = stream.next()) != null) {\n\t        if (ch == \"<\") {\n\t          state.tokenize = doctype(depth + 1);\n\t          return state.tokenize(stream, state);\n\t        } else if (ch == \">\") {\n\t          if (depth == 1) {\n\t            state.tokenize = inText;\n\t            break;\n\t          } else {\n\t            state.tokenize = doctype(depth - 1);\n\t            return state.tokenize(stream, state);\n\t          }\n\t        }\n\t      }\n\t      return \"meta\";\n\t    };\n\t  }\n\t\n\t  function Context(state, tagName, startOfLine) {\n\t    this.prev = state.context;\n\t    this.tagName = tagName;\n\t    this.indent = state.indented;\n\t    this.startOfLine = startOfLine;\n\t    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n\t      this.noIndent = true;\n\t  }\n\t  function popContext(state) {\n\t    if (state.context) state.context = state.context.prev;\n\t  }\n\t  function maybePopContext(state, nextTagName) {\n\t    var parentTagName;\n\t    while (true) {\n\t      if (!state.context) {\n\t        return;\n\t      }\n\t      parentTagName = state.context.tagName;\n\t      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n\t          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t        return;\n\t      }\n\t      popContext(state);\n\t    }\n\t  }\n\t\n\t  function baseState(type, stream, state) {\n\t    if (type == \"openTag\") {\n\t      state.tagStart = stream.column();\n\t      return tagNameState;\n\t    } else if (type == \"closeTag\") {\n\t      return closeTagNameState;\n\t    } else {\n\t      return baseState;\n\t    }\n\t  }\n\t  function tagNameState(type, stream, state) {\n\t    if (type == \"word\") {\n\t      state.tagName = stream.current();\n\t      setStyle = \"tag\";\n\t      return attrState;\n\t    } else {\n\t      setStyle = \"error\";\n\t      return tagNameState;\n\t    }\n\t  }\n\t  function closeTagNameState(type, stream, state) {\n\t    if (type == \"word\") {\n\t      var tagName = stream.current();\n\t      if (state.context && state.context.tagName != tagName &&\n\t          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n\t        popContext(state);\n\t      if (state.context && state.context.tagName == tagName) {\n\t        setStyle = \"tag\";\n\t        return closeState;\n\t      } else {\n\t        setStyle = \"tag error\";\n\t        return closeStateErr;\n\t      }\n\t    } else {\n\t      setStyle = \"error\";\n\t      return closeStateErr;\n\t    }\n\t  }\n\t\n\t  function closeState(type, _stream, state) {\n\t    if (type != \"endTag\") {\n\t      setStyle = \"error\";\n\t      return closeState;\n\t    }\n\t    popContext(state);\n\t    return baseState;\n\t  }\n\t  function closeStateErr(type, stream, state) {\n\t    setStyle = \"error\";\n\t    return closeState(type, stream, state);\n\t  }\n\t\n\t  function attrState(type, _stream, state) {\n\t    if (type == \"word\") {\n\t      setStyle = \"attribute\";\n\t      return attrEqState;\n\t    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n\t      var tagName = state.tagName, tagStart = state.tagStart;\n\t      state.tagName = state.tagStart = null;\n\t      if (type == \"selfcloseTag\" ||\n\t          config.autoSelfClosers.hasOwnProperty(tagName)) {\n\t        maybePopContext(state, tagName);\n\t      } else {\n\t        maybePopContext(state, tagName);\n\t        state.context = new Context(state, tagName, tagStart == state.indented);\n\t      }\n\t      return baseState;\n\t    }\n\t    setStyle = \"error\";\n\t    return attrState;\n\t  }\n\t  function attrEqState(type, stream, state) {\n\t    if (type == \"equals\") return attrValueState;\n\t    if (!config.allowMissing) setStyle = \"error\";\n\t    return attrState(type, stream, state);\n\t  }\n\t  function attrValueState(type, stream, state) {\n\t    if (type == \"string\") return attrContinuedState;\n\t    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n\t    setStyle = \"error\";\n\t    return attrState(type, stream, state);\n\t  }\n\t  function attrContinuedState(type, stream, state) {\n\t    if (type == \"string\") return attrContinuedState;\n\t    return attrState(type, stream, state);\n\t  }\n\t\n\t  return {\n\t    startState: function(baseIndent) {\n\t      var state = {tokenize: inText,\n\t                   state: baseState,\n\t                   indented: baseIndent || 0,\n\t                   tagName: null, tagStart: null,\n\t                   context: null}\n\t      if (baseIndent != null) state.baseIndent = baseIndent\n\t      return state\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (!state.tagName && stream.sol())\n\t        state.indented = stream.indentation();\n\t\n\t      if (stream.eatSpace()) return null;\n\t      type = null;\n\t      var style = state.tokenize(stream, state);\n\t      if ((style || type) && style != \"comment\") {\n\t        setStyle = null;\n\t        state.state = state.state(type || style, stream, state);\n\t        if (setStyle)\n\t          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n\t      }\n\t      return style;\n\t    },\n\t\n\t    indent: function(state, textAfter, fullLine) {\n\t      var context = state.context;\n\t      // Indent multi-line strings (e.g. css).\n\t      if (state.tokenize.isInAttribute) {\n\t        if (state.tagStart == state.indented)\n\t          return state.stringStartCol + 1;\n\t        else\n\t          return state.indented + indentUnit;\n\t      }\n\t      if (context && context.noIndent) return CodeMirror.Pass;\n\t      if (state.tokenize != inTag && state.tokenize != inText)\n\t        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n\t      // Indent the starts of attribute names.\n\t      if (state.tagName) {\n\t        if (config.multilineTagIndentPastTag !== false)\n\t          return state.tagStart + state.tagName.length + 2;\n\t        else\n\t          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n\t      }\n\t      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n\t      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n\t      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n\t        while (context) {\n\t          if (context.tagName == tagAfter[2]) {\n\t            context = context.prev;\n\t            break;\n\t          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n\t            context = context.prev;\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t      } else if (tagAfter) { // Opening tag spotted\n\t        while (context) {\n\t          var grabbers = config.contextGrabbers[context.tagName];\n\t          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n\t            context = context.prev;\n\t          else\n\t            break;\n\t        }\n\t      }\n\t      while (context && context.prev && !context.startOfLine)\n\t        context = context.prev;\n\t      if (context) return context.indent + indentUnit;\n\t      else return state.baseIndent || 0;\n\t    },\n\t\n\t    electricInput: /<\\/[\\s\\w:]+>$/,\n\t    blockCommentStart: \"<!--\",\n\t    blockCommentEnd: \"-->\",\n\t\n\t    configuration: config.htmlMode ? \"html\" : \"xml\",\n\t    helperType: config.htmlMode ? \"html\" : \"xml\",\n\t\n\t    skipAttribute: function(state) {\n\t      if (state.state == attrValueState)\n\t        state.state = attrState\n\t    }\n\t  };\n\t});\n\t\n\tCodeMirror.defineMIME(\"text/xml\", \"xml\");\n\tCodeMirror.defineMIME(\"application/xml\", \"xml\");\n\tif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n\t  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\t\n\t});\n\n\n/***/ },\n\n/***/ 364:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  CodeMirror.modeInfo = [\n\t    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\n\t    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"pgp\"]},\n\t    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\n\t    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\n\t    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\n\t    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\"]},\n\t    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\n\t    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\n\t    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\n\t    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\"]},\n\t    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\n\t    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\n\t    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\n\t    {name: \"CoffeeScript\", mime: \"text/x-coffeescript\", mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\n\t    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\n\t    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\n\t    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\n\t    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\n\t    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\n\t    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\n\t    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\n\t    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\n\t    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\n\t    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\n\t    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\n\t    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\n\t    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\n\t    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\n\t    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\n\t    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\n\t    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\n\t    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\n\t    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\n\t    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\n\t    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\n\t    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\n\t    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\"]},\n\t    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\n\t    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\n\t    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\n\t    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\n\t    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\n\t    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\"]},\n\t    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\n\t    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\n\t    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\n\t    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\n\t    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\n\t    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\n\t    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\"], alias: [\"xhtml\"]},\n\t    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\n\t    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\n\t    {name: \"Jade\", mime: \"text/x-jade\", mode: \"jade\", ext: [\"jade\"]},\n\t    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\n\t    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\n\t    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\n\t     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\n\t    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\n\t    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\n\t    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\n\t    {name: \"Jinja2\", mime: \"null\", mode: \"jinja2\"},\n\t    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\n\t    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\n\t    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\n\t    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\n\t    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\n\t    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\n\t    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\n\t    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\n\t    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\n\t    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\n\t    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\"},\n\t    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\n\t    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\n\t    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\n\t    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\n\t    {name: \"NTriples\", mime: \"text/n-triples\", mode: \"ntriples\", ext: [\"nt\"]},\n\t    {name: \"Objective C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"]},\n\t    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\n\t    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\n\t    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\n\t    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\n\t    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\n\t    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\n\t    {name: \"PHP\", mime: \"application/x-httpd-php\", mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"phtml\"]},\n\t    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\n\t    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\n\t    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\n\t    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\n\t    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"py\", \"pyw\"]},\n\t    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\n\t    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\n\t    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\"], alias: [\"rscript\"]},\n\t    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\n\t    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\n\t    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\n\t    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\n\t    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\n\t    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\n\t    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\n\t    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\n\t    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\n\t    {name: \"Shell\", mime: \"text/x-sh\", mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\n\t    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\n\t    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\n\t    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\n\t    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\n\t    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\n\t    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\n\t    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\n\t    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\n\t    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\n\t    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\n\t    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\n\t    {name: \"MariaDB\", mime: \"text/x-mariadb\", mode: \"sql\"},\n\t    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\n\t    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\"], alias: [\"tex\"]},\n\t    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\"]},\n\t    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\n\t    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\n\t    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\n\t    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\n\t    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\n\t    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\n\t    {name: \"troff\", mime: \"troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\n\t    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\n\t    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\n\t    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\n\t    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\n\t    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\n\t    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\n\t    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\n\t    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\n\t    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\n\t    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\n\t    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\n\t    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\n\t    {name: \"YAML\", mime: \"text/x-yaml\", mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\n\t    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\n\t    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\n\t    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\n\t    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\n\t  ];\n\t  // Ensure all modes have a mime property for backwards compatibility\n\t  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t    var info = CodeMirror.modeInfo[i];\n\t    if (info.mimes) info.mime = info.mimes[0];\n\t  }\n\t\n\t  CodeMirror.findModeByMIME = function(mime) {\n\t    mime = mime.toLowerCase();\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.mime == mime) return info;\n\t      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\n\t        if (info.mimes[j] == mime) return info;\n\t    }\n\t  };\n\t\n\t  CodeMirror.findModeByExtension = function(ext) {\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.ext) for (var j = 0; j < info.ext.length; j++)\n\t        if (info.ext[j] == ext) return info;\n\t    }\n\t  };\n\t\n\t  CodeMirror.findModeByFileName = function(filename) {\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.file && info.file.test(filename)) return info;\n\t    }\n\t    var dot = filename.lastIndexOf(\".\");\n\t    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n\t    if (ext) return CodeMirror.findModeByExtension(ext);\n\t  };\n\t\n\t  CodeMirror.findModeByName = function(name) {\n\t    name = name.toLowerCase();\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.name.toLowerCase() == name) return info;\n\t      if (info.alias) for (var j = 0; j < info.alias.length; j++)\n\t        if (info.alias[j].toLowerCase() == name) return info;\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n\n/***/ 365:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// Utility function that allows modes to be combined. The mode given\n\t// as the base argument takes care of most of the normal mode\n\t// functionality, but a second (typically simple) mode is used, which\n\t// can override the style of text. Both modes get to parse all of the\n\t// text, but when both assign a non-null style to a piece of code, the\n\t// overlay wins, unless the combine argument was true and not overridden,\n\t// or state.overlay.combineTokens was true, in which case the styles are\n\t// combined.\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.overlayMode = function(base, overlay, combine) {\n\t  return {\n\t    startState: function() {\n\t      return {\n\t        base: CodeMirror.startState(base),\n\t        overlay: CodeMirror.startState(overlay),\n\t        basePos: 0, baseCur: null,\n\t        overlayPos: 0, overlayCur: null,\n\t        streamSeen: null\n\t      };\n\t    },\n\t    copyState: function(state) {\n\t      return {\n\t        base: CodeMirror.copyState(base, state.base),\n\t        overlay: CodeMirror.copyState(overlay, state.overlay),\n\t        basePos: state.basePos, baseCur: null,\n\t        overlayPos: state.overlayPos, overlayCur: null\n\t      };\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (stream != state.streamSeen ||\n\t          Math.min(state.basePos, state.overlayPos) < stream.start) {\n\t        state.streamSeen = stream;\n\t        state.basePos = state.overlayPos = stream.start;\n\t      }\n\t\n\t      if (stream.start == state.basePos) {\n\t        state.baseCur = base.token(stream, state.base);\n\t        state.basePos = stream.pos;\n\t      }\n\t      if (stream.start == state.overlayPos) {\n\t        stream.pos = stream.start;\n\t        state.overlayCur = overlay.token(stream, state.overlay);\n\t        state.overlayPos = stream.pos;\n\t      }\n\t      stream.pos = Math.min(state.basePos, state.overlayPos);\n\t\n\t      // state.overlay.combineTokens always takes precedence over combine,\n\t      // unless set to null\n\t      if (state.overlayCur == null) return state.baseCur;\n\t      else if (state.baseCur != null &&\n\t               state.overlay.combineTokens ||\n\t               combine && state.overlay.combineTokens == null)\n\t        return state.baseCur + \" \" + state.overlayCur;\n\t      else return state.overlayCur;\n\t    },\n\t\n\t    indent: base.indent && function(state, textAfter) {\n\t      return base.indent(state.base, textAfter);\n\t    },\n\t    electricChars: base.electricChars,\n\t\n\t    innerMode: function(state) { return {state: state.base, mode: base}; },\n\t\n\t    blankLine: function(state) {\n\t      if (base.blankLine) base.blankLine(state.base);\n\t      if (overlay.blankLine) overlay.blankLine(state.overlay);\n\t    }\n\t  };\n\t};\n\t\n\t});\n\n\n/***/ },\n\n/***/ 366:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jade = __webpack_require__(158);\n\t\n\tmodule.exports = function template(locals) {\n\tvar buf = [];\n\tvar jade_mixins = {};\n\tvar jade_interp;\n\t;var locals_for_with = (locals || {});(function (bem, buttons) {\n\tbuf.push(\"\");\n\tvar bem_chain = [];\n\tjade_mixins[\"b\"] = jade_interp = function(tag, isElement, noBlockClass){\n\tvar block = (this && this.block), attributes = (this && this.attributes) || {};\n\tbem.call(this, buf, bem_chain, tag, isElement, noBlockClass)\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tjade_mixins[\"e\"] = jade_interp = function(tag){\n\tvar block = (this && this.block), attributes = (this && this.attributes) || {};\n\tjade_mixins[\"b\"].call({\n\tblock: function(){\n\tblock && block();\n\t},\n\tattributes: jade.merge([attributes])\n\t}, tag, true);\n\t};\n\tjade_mixins[\"b\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\t// iterate buttons\n\t;(function(){\n\t  var $$obj = buttons;\n\t  if ('number' == typeof $$obj.length) {\n\t\n\t    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n\t      var button = $$obj[$index];\n\t\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"class\": \"button-icon\"}\n\t}, 'i');\n\t},\n\tattributes: {\"data-action\": (typeof (jade_interp = button.action) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"title\": jade.escape(button.title),\"class\": \"button\"}\n\t}, 'li');\n\t    }\n\t\n\t  } else {\n\t    var $$l = 0;\n\t    for (var $index in $$obj) {\n\t      $$l++;      var button = $$obj[$index];\n\t\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"class\": \"button-icon\"}\n\t}, 'i');\n\t},\n\tattributes: {\"data-action\": (typeof (jade_interp = button.action) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"title\": jade.escape(button.title),\"class\": \"button\"}\n\t}, 'li');\n\t    }\n\t\n\t  }\n\t}).call(this);\n\t\n\t},\n\tattributes: {\"class\": \"button-row\"}\n\t}, 'ul');\n\t},\n\tattributes: {\"class\": \"button-bar\"}\n\t});\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"class\": \"input\"}\n\t}, 'textarea');\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tbuf.push(\"\");\n\t}\n\t}, 'h2');\n\t},\n\tattributes: {\"class\": \"title-preview\"}\n\t});\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"class\": \"preview\"}\n\t});\n\t},\n\tattributes: {\"class\": \"mdeditor\"}\n\t});}.call(this,\"bem\" in locals_for_with?locals_for_with.bem:typeof bem!==\"undefined\"?bem:undefined,\"buttons\" in locals_for_with?locals_for_with.buttons:typeof buttons!==\"undefined\"?buttons:undefined));;return buf.join(\"\");\n\t}\n\n/***/ },\n\n/***/ 367:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./en.yml\": 368,\n\t\t\"./ru.yml\": 369\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 367;\n\n\n/***/ },\n\n/***/ 368:\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"heading\": \"Heading\",\n\t\t\"bold\": \"bold text\",\n\t\t\"italic\": \"italic text\",\n\t\t\"code\": \"code\",\n\t\t\"code_multiline\": \"multiline code here\",\n\t\t\"ol_item\": \"List item\",\n\t\t\"ul_item\": \"List item\",\n\t\t\"alt\": \"Image desciption\"\n\t};\n\n/***/ },\n\n/***/ 369:\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"heading\": \"\",\n\t\t\"bold\": \" \",\n\t\t\"italic\": \" \",\n\t\t\"code\": \"\",\n\t\t\"code_multiline\": \"  \",\n\t\t\"ol_item\": \" \",\n\t\t\"ul_item\": \" \",\n\t\t\"alt\": \" \"\n\t};\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** mdeditor.10a4b79a3818d8a82138.js\n **/","'use strict';\n\nrequire('./styles');\nconst MdEditor = require('./mdeditor');\n\n\nfunction init() {\n  let editorElems = document.querySelectorAll('.mdeditor');\n\n  for (var i = 0; i < editorElems.length; i++) {\n    var editorElem = editorElems[i];\n    new MdEditor({\n      elem: editorElem\n    });\n  }\n}\n\n// must be on document ready\ninit();\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/mdeditor/client/index.js\n **/","'use strict';\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    a['class'] = ac.concat(bc).filter(nulls);\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {*} val\n * @return {Boolean}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null && val !== '';\n}\n\n/**\n * join array as classes.\n *\n * @param {*} val\n * @return {String}\n */\nexports.joinClasses = joinClasses;\nfunction joinClasses(val) {\n  return (Array.isArray(val) ? val.map(joinClasses) :\n    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :\n    [val]).filter(nulls).join(' ');\n}\n\n/**\n * Render the given classes.\n *\n * @param {Array} classes\n * @param {Array.<Boolean>} escaped\n * @return {String}\n */\nexports.cls = function cls(classes, escaped) {\n  var buf = [];\n  for (var i = 0; i < classes.length; i++) {\n    if (escaped && escaped[i]) {\n      buf.push(exports.escape(joinClasses([classes[i]])));\n    } else {\n      buf.push(joinClasses(classes[i]));\n    }\n  }\n  var text = joinClasses(buf);\n  if (text.length) {\n    return ' class=\"' + text + '\"';\n  } else {\n    return '';\n  }\n};\n\n\nexports.style = function (val) {\n  if (val && typeof val === 'object') {\n    return Object.keys(val).map(function (style) {\n      return style + ':' + val[style];\n    }).join(';');\n  } else {\n    return val;\n  }\n};\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = function attr(key, val, escaped, terse) {\n  if (key === 'style') {\n    val = exports.style(val);\n  }\n  if ('boolean' == typeof val || null == val) {\n    if (val) {\n      return ' ' + (terse ? key : key + '=\"' + key + '\"');\n    } else {\n      return '';\n    }\n  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n    if (JSON.stringify(val).indexOf('&') !== -1) {\n      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +\n                   'will be escaped to `&amp;`');\n    };\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will eliminate the double quotes around dates in ' +\n                   'ISO form after 2.0.0');\n    }\n    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\n  } else if (escaped) {\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n    }\n    return ' ' + key + '=\"' + exports.escape(val) + '\"';\n  } else {\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n    }\n    return ' ' + key + '=\"' + val + '\"';\n  }\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n */\nexports.attrs = function attrs(obj, terse){\n  var buf = [];\n\n  var keys = Object.keys(obj);\n\n  if (keys.length) {\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('class' == key) {\n        if (val = joinClasses(val)) {\n          buf.push(' ' + key + '=\"' + val + '\"');\n        }\n      } else {\n        buf.push(exports.attr(key, val, false, terse));\n      }\n    }\n  }\n\n  return buf.join('');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nvar jade_encode_html_rules = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\nvar jade_match_html = /[&<>\"]/g;\n\nfunction jade_encode_char(c) {\n  return jade_encode_html_rules[c] || c;\n}\n\nexports.escape = jade_escape;\nfunction jade_escape(html){\n  var result = String(html).replace(jade_match_html, jade_encode_char);\n  if (result === '' + html) return html;\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str = str || require('fs').readFileSync(filename, 'utf8')\n  } catch (ex) {\n    rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\nexports.DebugItem = function DebugItem(lineno, filename) {\n  this.lineno = lineno;\n  this.filename = filename;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/jade/lib/runtime.js\n **/","var bem = require('bem-jade')();\nvar thumb = require('client/image').thumb;\n\nmodule.exports = function(template, locals) {\n  locals = locals ? Object.create(locals) : {};\n  addStandardHelpers(locals);\n\n  return template(locals);\n};\n\nfunction addStandardHelpers(locals) {\n  locals.bem = bem;\n\n  locals.thumb = thumb;\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/clientRender.js\n **/","// Adapted from bemto.jade, copyright(c) 2012 Roman Komarov <kizu@kizu.ru>\n\n/* jshint -W106 */\n\nvar jade = require('jade/lib/runtime');\n\nmodule.exports = function(settings) {\n  settings = settings || {};\n\n  settings.prefix = settings.prefix || '';\n  settings.element = settings.element || '__';\n  settings.modifier = settings.modifier || '_';\n\n  return function(buf, bem_chain, tag, isElement) {\n    //console.log(\"-->\", arguments);\n    var block = this.block;\n    var attributes = this.attributes || {};\n\n    if (!attributes.class && tag && !isElement) {\n      throw new Error(\"Block without class: \" + tag);\n    }\n\n    // Rewriting the class for elements and modifiers\n    if (attributes.class) {\n      var bem_classes = attributes.class;\n\n      if (bem_classes instanceof Array) {\n        bem_classes = bem_classes.join(' ');\n      }\n      bem_classes = bem_classes.split(' ');\n\n      var bem_block;\n      try {\n        bem_block = bem_classes[0].match(new RegExp('^(((?!' + settings.element + '|' + settings.modifier + ').)+)'))[1];\n      } catch (e) {\n        throw new Error(\"Incorrect bem class: \" + bem_classes[0]);\n      }\n\n      if (!isElement) {\n        bem_chain[bem_chain.length] = bem_block;\n      } else {\n        bem_classes[0] = bem_chain[bem_chain.length - 1] + settings.element + bem_classes[0];\n      }\n\n      var current_block = (isElement ? bem_chain[bem_chain.length - 1] + settings.element : '') + bem_block;\n\n      // Adding the block if there is only modifier and/or element\n      if (bem_classes.indexOf(current_block) === -1) {\n        bem_classes[bem_classes.length] = current_block;\n      }\n\n      for (var i = 0; i < bem_classes.length; i++) {\n        var klass = bem_classes[i];\n\n        if (klass.match(new RegExp('^(?!' + settings.element + ')' + settings.modifier))) {\n          // Expanding the modifiers\n          bem_classes[i] = current_block + klass;\n        } else if (klass.match(new RegExp('^' + settings.element))) {\n          //- Expanding the mixed in elements\n          if (bem_chain[bem_chain.length - 2]) {\n            bem_classes[i] = bem_chain[bem_chain.length - 2] + klass;\n          } else {\n            bem_classes[i] = bem_chain[bem_chain.length - 1] + klass;\n          }\n        }\n\n        // Adding prefixes\n        if (bem_classes[i].match(new RegExp('^' + current_block + '($|(?=' + settings.element + '|' + settings.modifier + '))'))) {\n          bem_classes[i] = settings.prefix + bem_classes[i];\n        }\n      }\n\n      // Write modified classes to attributes in the correct order\n      attributes.class = bem_classes.sort().join(' ');\n    }\n\n    bem_tag(buf, block, attributes, bem_chain, tag);\n\n    // Closing actions (remove the current block from the chain)\n    if (!isElement) {\n      bem_chain.pop();\n    }\n  };\n\n\n  // used for tweaking what tag we are throwing and do we need to wrap anything here\n  function bem_tag(buf, block, attributes, bem_chain, tag) {\n    // rewriting tag name on different contexts\n    var newTag = tag || 'div';\n\n    switch (newTag) {\n    case 'img':\n      // If there is no title we don't need it to show even if there is some alt\n      if (attributes.alt && !attributes.title) {\n        attributes.title = '';\n      }\n      // If we have title, we must have it in alt if it's not set\n      if (attributes.title && !attributes.alt) {\n        attributes.alt = attributes.title;\n      }\n      if (!attributes.alt) {\n        attributes.alt = '';\n      }\n      break;\n    case 'input':\n      if (!attributes.type) {\n        attributes.type = \"text\";\n      }\n      break;\n    case 'html':\n      buf.push('<!DOCTYPE HTML>');\n      break;\n    case 'a':\n      if (!attributes.href) {\n        attributes.href = '#';\n      }\n    }\n\n    buf.push('<' + newTag + jade.attrs(jade.merge([attributes]), true) + \">\");\n\n    if (block) block();\n\n    if (['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'].indexOf(newTag) == -1) {\n      buf.push('</' + newTag + '>');\n    }\n\n  }\n\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/bem-jade.js\n **/","\nexports.thumb = function(url, width, height) {\n  // sometimes this may be called without url\n  if (!url) return url;\n\n  var pixelRatio = window.devicePixelRatio;\n\n  // return pixelRatio times larger image for retina\n  width *= pixelRatio;\n  height *= pixelRatio;\n\n  var modifier = (width <= 160 && height <= 160) ? 't' :\n    (width <= 320 && height <= 320) ? 'm' :\n      (width <= 640 && height <= 640) ? 'i' :\n        (width <= 1024 && height <= 1024) ? 'h' : '';\n\n  return url.slice(0, url.lastIndexOf('.')) + modifier + url.slice(url.lastIndexOf('.'));\n};\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/image.js\n **/","module.exports = {\n  lang: LANG\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/config.js\n **/","'use strict';\n\nconst BabelFish = require('babelfish');\n\nconst i18n = new BabelFish('en');\n\nconst LANG = require('config').lang;\n\nfunction t() {\n  let args = [LANG];\n  for (let i = 0; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n  return i18n.t.apply(i18n, args);\n}\n\nlet docs = {};\n\nt.i18n = i18n;\n\nt.requirePhrase = function(packageName, doc) {\n  // if same phrase with same doc was processed - don't redo it\n  if (docs[packageName] && docs[packageName].indexOf(doc) != -1) return;\n\n  if (!docs[packageName]) docs[packageName] = [];\n  docs[packageName].push(doc);\n\n  i18n.addPhrase(LANG, packageName, doc);\n};\n\n\nmodule.exports = t;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/i18n/index.js\n **/","module.exports = require('./lib/babelfish');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/babelfish/index.js\n **/","/**\n *  class BabelFish\n *\n *  Internalization and localization library that makes i18n and l10n fun again.\n *\n *  ##### Example\n *\n *  ```javascript\n *  var BabelFish = require('babelfish'),\n *      i18n = new BabelFish();\n *  ```\n *\n *  or\n *\n *  ```javascript\n *  var babelfish = require('babelfish'),\n *      i18n = babelfish();\n *  ```\n **/\n\n\n'use strict';\n\n\nvar parser = require('./parser');\nvar plural = require('plurals-cldr');\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction isString(obj)   { return _class(obj) === '[object String]'; }\nfunction isNumber(obj)   { return !isNaN(obj) && isFinite(obj); }\nfunction isBoolean(obj)  { return obj === true || obj === false; }\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\nfunction isObject(obj)   { return _class(obj) === '[object Object]'; }\n\n/*istanbul ignore next*/\nvar isArray = Array.isArray || function _isArray(obj) {\n  return _class(obj) === '[object Array]';\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n// The following two utilities (forEach and extend) are modified from Underscore\n//\n// http://underscorejs.org\n//\n// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//\n// Underscore may be freely distributed under the MIT license\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar nativeForEach = Array.prototype.forEach;\n\n\n// The cornerstone, an `each` implementation, aka `forEach`.\n// Handles objects with the built-in `forEach`, arrays, and raw objects.\n// Delegates to **ECMAScript 5**'s native `forEach` if available.\n/*istanbul ignore next*/\nfunction forEach(obj, iterator, context) {\n  if (obj === null) {\n    return;\n  }\n  if (nativeForEach && obj.forEach === nativeForEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, l = obj.length; i < l; i += 1) {\n      iterator.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        iterator.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n\nvar formatRegExp = /%[sdj%]/g;\n\n/*istanbul ignore next*/\nfunction format(f) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') { return '%'; }\n    if (i >= len) { return x; }\n    switch (x) {\n      case '%s':\n        return String(args[i++]);\n      case '%d':\n        return Number(args[i++]);\n      case '%j':\n        return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  return str;\n}\n\n\n// helpers\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Last resort locale, that exists for sure\nvar GENERIC_LOCALE = 'en';\n\n\n// flatten(obj) -> Object\n//\n// Flattens object into one-level dictionary.\n//\n// ##### Example\n//\n//     var obj = {\n//       abc: { def: 'foo' },\n//       hij: 'bar'\n//     };\n//\n//     flatten(obj);\n//     // -> { 'abc.def': 'foo', 'hij': 'bar' };\n//\nfunction flatten(obj) {\n  var params = {};\n\n  forEach(obj || {}, function (val, key) {\n    if (val && typeof val === 'object') {\n      forEach(flatten(val), function (sub_val, sub_key) {\n        params[key + '.' + sub_key] = sub_val;\n      });\n      return;\n    }\n\n    params[key] = val;\n  });\n\n  return params;\n}\n\n\nvar keySeparator = '#@$';\n\nfunction makePhraseKey(locale, phrase) {\n  return locale + keySeparator + phrase;\n}\n\n\nfunction searchPhraseKey(self, locale, phrase) {\n  var key = makePhraseKey(locale, phrase);\n  var storage = self._storage;\n\n  // direct search first\n  if (storage.hasOwnProperty(key)) { return key; }\n\n  // don't try follbacks for default locale\n  if (locale === self._defaultLocale) { return null; }\n\n  // search via fallback map cache\n  var fb_cache = self._fallbacks_cache;\n  if (fb_cache.hasOwnProperty(key)) { return fb_cache[key]; }\n\n  // scan fallbacks & cache result\n  var fb = self._fallbacks[locale] || [ self._defaultLocale ];\n  var fb_key;\n\n  for (var i = 0, l = fb.length; i < l; i++) {\n    fb_key = makePhraseKey(fb[i], phrase);\n    if (storage.hasOwnProperty(fb_key)) {\n      // found - update cache and return result\n      fb_cache[key] = fb_key;\n      return fb_cache[key];\n    }\n  }\n\n  // mark fb_cache entry empty for fast lookup on next request\n  fb_cache[key] = null;\n  return null;\n}\n\n\nfunction pluralizer(lang, val, forms) {\n  var idx = plural.indexOf(lang, val);\n\n  if (idx === -1) {\n    return format('[pluralizer for \"%s\" locale not found]', lang);\n  }\n\n  if (typeof forms[idx] === 'undefined') {\n    return format('[plural form %d (\"%s\") not found in translation]',\n                      idx, plural.forms(lang)[idx]);\n  }\n\n  return forms[idx];\n}\n\n// public api (module)\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new BabelFish([defaultLocale = 'en'])\n *\n *  Initiates new instance of BabelFish.\n *\n *  __Note!__ you can omit `new` for convenience, direct call will return\n * new instance too.\n **/\nfunction BabelFish(defaultLocale) {\n  if (!(this instanceof BabelFish)) { return new BabelFish(defaultLocale); }\n\n  this._defaultLocale = defaultLocale ? String(defaultLocale) : GENERIC_LOCALE;\n\n  // hash of locale => [ fallback1, fallback2, ... ] pairs\n  this._fallbacks = {};\n\n  // fallback cache for each phrase\n  //\n  // {\n  //   locale_key: fallback_key\n  // }\n  //\n  // fallback_key can be null if search failed\n  //\n  this._fallbacks_cache = {};\n\n  // storage of compiled translations\n  //\n  // {\n  //   locale + @#$ + phrase_key: {\n  //     locale:      locale name - can be different for fallbacks\n  //     translation: original translation phrase or data variable/object\n  //     raw:         true/false - does translation contain plain data or\n  //                  string to compile\n  //     compiled:    copiled translation fn or plain string\n  //   }\n  //   ...\n  // }\n  //\n  this._storage = {};\n\n  // cache for complex plural parts (with params)\n  //\n  // {\n  //   language: new BabelFish(language)\n  // }\n  //\n  this._plurals_cache = {};\n}\n\n\n// public api (instance)\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  BabelFish#addPhrase(locale, phrase, translation [, flattenLevel]) -> BabelFish\n *  - locale (String): Locale of translation\n *  - phrase (String|Null): Phrase ID, e.g. `apps.forum`\n *  - translation (String|Object|Array|Number|Boolean): Translation or an object\n *    with nested phrases, or a pure object.\n *  - flattenLevel (Number|Boolean): Optional, 0..infinity. `Infinity` by default.\n *    Define \"flatten\" deepness for loaded object.  You can also use\n *    `true` as `0` or `false` as `Infinity`.\n *\n *\n *  ##### Flatten & using JS objects\n *\n *  By default all nested properties are normalized to strings like \"foo.bar.baz\",\n *  and if value is string, it will be compiled with babelfish notation.\n *  If deepness is above `flattenLevel` OR value is not object and not string,\n *  it will be used \"as is\". Note, only JSON stringifiable data should be used.\n *\n *  In short: you can safely pass `Array`, `Number` or `Boolean`. For objects you\n *  should define flatten level or disable it compleetely, to work with pure data.\n *\n *  Pure objects can be useful to prepare bulk data for external libraries, like\n *  calendars, time/date generators and so on.\n *\n *  ##### Example\n *\n *  ```javascript\n *  i18n.addPhrase('ru-RU',\n *    'apps.forums.replies_count',\n *    '#{count} %{||}:count  ');\n *\n *  // equals to:\n *  i18n.addPhrase('ru-RU',\n *    'apps.forums',\n *    { replies_count: '#{count} %{||}:count  ' });\n *  ```\n **/\nBabelFish.prototype.addPhrase = function _addPhrase(locale, phrase, translation, flattenLevel) {\n  var self = this, fl;\n\n  // Calculate flatten level. Infinity by default\n  if (isBoolean(flattenLevel)) {\n    fl = flattenLevel ? Infinity : 0;\n  } else if (isNumber(flattenLevel)) {\n    fl = Math.floor(flattenLevel);\n    if (fl < 0) {\n      throw new TypeError('Invalid flatten level (should be >= 0).');\n    }\n  } else {\n    fl = Infinity;\n  }\n\n  if (isObject(translation) && (fl > 0)) {\n    // recursive object walk, until flattenLevel allows\n    forEach(translation, function (val, key) {\n      self.addPhrase(locale, (phrase ? phrase + '.' : '') + key, val, fl - 1);\n    });\n    return this;\n  }\n\n  if (isString(translation)) {\n    this._storage[makePhraseKey(locale, phrase)] = {\n      translation: translation,\n      locale: locale,\n      raw: false\n    };\n  } else if (isArray(translation) ||\n             isNumber(translation) ||\n             isBoolean(translation) ||\n             (fl === 0 && isObject(translation))) {\n    // Pure objects are stored without compilation\n    // Limit allowed types.\n    this._storage[makePhraseKey(locale, phrase)] = {\n      translation: translation,\n      locale: locale,\n      raw: true\n    };\n  } else {\n    // `Regex`, `Date`, `Uint8Array` and others types will\n    //  fuckup `stringify()`. Don't allow here.\n    // `undefined` also means wrong param in real life.\n    // `null` can be allowed when examples from real life available.\n    throw new TypeError('Invalid translation - [String|Object|Array|Number|Boolean] expected.');\n  }\n\n  self._fallbacks_cache = {};\n\n  return this;\n};\n\n\n/**\n *  BabelFish#setFallback(locale, fallbacks) -> BabelFish\n *  - locale (String): Target locale\n *  - fallbacks (Array): List of fallback locales\n *\n *  Set fallbacks for given locale.\n *\n *  When `locale` has no translation for the phrase, `fallbacks[0]` will be\n *  tried, if translation still not found, then `fallbacks[1]` will be tried\n *  and so on. If none of fallbacks have translation,\n *  default locale will be tried as last resort.\n *\n *  ##### Errors\n *\n *  - throws `Error`, when `locale` equals default locale\n *\n *  ##### Example\n *\n *  ```javascript\n *  i18n.setFallback('ua-UK', ['ua', 'ru']);\n *  ```\n **/\nBabelFish.prototype.setFallback = function _setFallback(locale, fallbacks) {\n  var def = this._defaultLocale;\n\n  if (def === locale) {\n    throw new Error(\"Default locale can't have fallbacks\");\n  }\n\n  var fb = isArray(fallbacks) ? fallbacks.slice() : [ fallbacks ];\n  if (fb[fb.length - 1] !== def) { fb.push(def); }\n\n  this._fallbacks[locale] = fb;\n  this._fallbacks_cache = {};\n\n  return this;\n};\n\n\nvar CAN_HAVE_DIRECTIVES_RE = /#\\{|\\(\\(|\\\\\\\\/;\n\n// Compiles given string into function. Used to compile phrases,\n// which contains `plurals`, `variables`, etc.\nfunction compile(self, str, locale) {\n  var nodes, buf, key, strict_exec, forms_exec, plurals_cache;\n\n  // Quick check to avoid parse in most cases :)\n  if (!CAN_HAVE_DIRECTIVES_RE.test(str)) { return str; }\n\n  nodes = parser.parse(str);\n\n  if (nodes.length === 1 && nodes[0].type === 'literal') {\n    return nodes[0].text;\n  }\n\n  // init cache instance for plural parts, if not exists yet.\n  if (!self._plurals_cache[locale]) {\n    self._plurals_cache[locale] = new BabelFish(locale);\n  }\n  plurals_cache = self._plurals_cache[locale];\n\n  buf = [];\n  buf.push([ 'var str = \"\", strict, strict_exec, forms, forms_exec, plrl, cache, loc, loc_plzr, anchor;' ]);\n  buf.push('params = flatten(params);');\n\n  forEach(nodes, function (node) {\n    if (node.type === 'literal') {\n      buf.push(format('str += %j;', node.text));\n      return;\n    }\n\n    if (node.type === 'variable') {\n      key = node.anchor;\n      buf.push(format(\n        'str += (\"undefined\" === typeof (params[%j])) ? \"[missed variable: %s]\" : params[%j];',\n        key, key, key\n      ));\n      return;\n    }\n\n    // should never happen\n    /*istanbul ignore next*/\n    if (node.type !== 'plural') { throw new Error('Unknown node type'); }\n\n    //\n    // Compile plural\n    //\n\n    key = node.anchor;\n    // check if plural parts are plain strings or executable,\n    // and add executable to \"cache\" instance of babelfish\n    // plural part text will be used as translation key\n    strict_exec = {};\n    forEach(node.strict, function (text, k) {\n      var parsed = parser.parse(text);\n      if (parsed.length === 1 && parsed[0].type === 'literal') {\n        strict_exec[k] = false;\n        // patch with unescaped value for direct extract\n        node.strict[k] = parsed[0].text;\n        return;\n      }\n\n      strict_exec[k] = true;\n      if (!plurals_cache.hasPhrase(locale, text, true)) {\n        plurals_cache.addPhrase(locale, text, text);\n      }\n    });\n\n    forms_exec = {};\n    forEach(node.forms, function (text, idx) {\n      var parsed = parser.parse(text), unescaped;\n      if (parsed.length === 1 && parsed[0].type === 'literal') {\n        // patch with unescaped value for direct extract\n        unescaped = parsed[0].text;\n        node.forms[idx] = unescaped;\n        forms_exec[unescaped] = false;\n        return;\n      }\n\n      forms_exec[text] = true;\n      if (!plurals_cache.hasPhrase(locale, text, true)) {\n        plurals_cache.addPhrase(locale, text, text);\n      }\n    });\n    /*eslint-disable space-in-parens*/\n    buf.push(format('loc = %j;', locale));\n    buf.push(format('loc_plzr = %j;', locale.split(/[-_]/)[0]));\n    buf.push(format('anchor = params[%j];', key));\n    buf.push(format('cache = this._plurals_cache[loc];'));\n    buf.push(format('strict = %j;', node.strict));\n    buf.push(format('strict_exec = %j;', strict_exec));\n    buf.push(format('forms = %j;', node.forms));\n    buf.push(format('forms_exec = %j;', forms_exec));\n    buf.push(       'if (+(anchor) != anchor) {');\n    buf.push(format('  str += \"[invalid plurals amount: %s(\" + anchor + \")]\";', key));\n    buf.push(       '} else {');\n    buf.push(       '  if (strict[anchor] !== undefined) {');\n    buf.push(       '    plrl = strict[anchor];');\n    buf.push(       '    str += strict_exec[anchor] ? cache.t(loc, plrl, params) : plrl;');\n    buf.push(       '  } else {');\n    buf.push(       '    plrl = pluralizer(loc_plzr, +anchor, forms);');\n    buf.push(       '    str += forms_exec[plrl] ? cache.t(loc, plrl, params) : plrl;');\n    buf.push(       '  }');\n    buf.push(       '}');\n    return;\n  });\n\n  buf.push('return str;');\n\n  /*eslint-disable no-new-func*/\n  return new Function('params', 'flatten', 'pluralizer', buf.join('\\n'));\n}\n\n\n/**\n *  BabelFish#translate(locale, phrase[, params]) -> String\n *  - locale (String): Locale of translation\n *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n *  - params (Object|Number|String): Params for translation. `Number` & `String`\n *    will be  coerced to `{ count: X, value: X }`\n *\n *  ##### Example\n *\n *  ```javascript\n *  i18n.addPhrase('ru-RU',\n *     'apps.forums.replies_count',\n *     '#{count} ((||))  ');\n *\n *  // ...\n *\n *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 1 });\n *  i18n.translate('ru-RU', 'app.forums.replies_count', 1});\n *  // -> '1 '\n *\n *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 2 });\n *  i18n.translate('ru-RU', 'app.forums.replies_count', 2);\n *  // -> '2 a'\n *  ```\n **/\nBabelFish.prototype.translate = function _translate(locale, phrase, params) {\n  var key = searchPhraseKey(this, locale, phrase);\n  var data;\n\n  if (!key) {\n    return locale + ': No translation for [' + phrase + ']';\n  }\n\n  data = this._storage[key];\n\n  // simple string or other pure object\n  if (data.raw) { return data.translation; }\n\n  // compile data if not done yet\n  if (!data.hasOwnProperty('compiled')) {\n    // We should use locale from phrase, because of possible fallback,\n    // to keep plural locales in sync.\n    data.compiled = compile(this, data.translation, data.locale);\n  }\n\n  // return simple string immediately\n  if (!isFunction(data.compiled)) {\n    return data.compiled;\n  }\n\n  //\n  // Generate \"complex\" phrase\n  //\n\n  // Sugar: coerce numbers & strings to { count: X, value: X }\n  if (isNumber(params) || isString(params)) {\n    params = { count: params, value: params };\n  }\n\n  return data.compiled.call(this, params, flatten, pluralizer);\n};\n\n\n/**\n *  BabelFish#hasPhrase(locale, phrase) -> Boolean\n *  - locale (String): Locale of translation\n *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n *  - noFallback (Boolean): Disable search in fallbacks\n *\n *  Returns whenever or not there's a translation of a `phrase`.\n **/\nBabelFish.prototype.hasPhrase = function _hasPhrase(locale, phrase, noFallback) {\n  return noFallback ?\n    this._storage.hasOwnProperty(makePhraseKey(locale, phrase))\n  :\n    searchPhraseKey(this, locale, phrase) ? true : false;\n};\n\n\n/**\n *  BabelFish#getLocale(locale, phrase) -> String|null\n *  - locale (String): Locale of translation\n *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n *  - noFallback (Boolean): Disable search in fallbacks\n *\n *  Similar to [[BabelFish#hasPhrase]], but returns real locale of requested\n *  phrase, or `null` if nothing found. Can be useful for dynamic dependencies\n *  init. For example, when you fetch i10n config as single object and create\n *  phrases from it's content.\n **/\nBabelFish.prototype.getLocale = function _getLocale(locale, phrase, noFallback) {\n  if (noFallback) {\n    return this._storage.hasOwnProperty(makePhraseKey(locale, phrase)) ? locale : null;\n  }\n\n  var key = searchPhraseKey(this, locale, phrase);\n\n  return key ? key.split(keySeparator, 2)[0] : null;\n};\n\n\n/** alias of: BabelFish#translate\n *  BabelFish#t(locale, phrase[, params]) -> String\n **/\nBabelFish.prototype.t = BabelFish.prototype.translate;\n\n\n/**\n *  BabelFish#stringify(locale) -> String\n *  - locale (String): Locale of translation\n *\n *  Returns serialized locale data, uncluding fallbacks.\n *  It can be loaded back via `load()` method.\n **/\nBabelFish.prototype.stringify = function _stringify(locale) {\n  var self = this;\n\n  // Collect unique keys\n  var unique = {};\n\n  forEach(this._storage, function (val, key) {\n    unique[key.split(keySeparator)[1]] = true;\n  });\n\n  // Collect phrases (with fallbacks)\n  var result = {};\n\n  forEach(unique, function(val, key) {\n    var k = searchPhraseKey(self, locale, key);\n    // if key was just a garbage from another\n    // and doesn't fit into fallback chain for current locale - skip it\n    if (!k) { return; }\n    // create namespace if not exists\n    var l = self._storage[k].locale;\n    if (!result[l]) { result[l] = {}; }\n    result[l][key] = self._storage[k].translation;\n  });\n\n  var out = {\n    fallback: {},\n    locales: result\n  };\n\n  // Get fallback rule. Cut auto-added fallback to default locale\n  var fallback = (self._fallbacks[locale] || []).slice(0, -1);\n  if (fallback.length) {\n    out.fallback[locale] = fallback;\n  }\n\n  return JSON.stringify(out);\n};\n\n\n/**\n *  BabelFish#load(data) -> BabelFish\n *  - data (Object|String): data from `stringify()` method, as object or string.\n *\n *  Batch load phrases data, prepared with `stringify()` method.\n *  Useful at browser side.\n **/\nBabelFish.prototype.load = function _load(data) {\n  var self = this;\n\n  if (isString(data)) { data = JSON.parse(data); }\n\n  forEach(data.locales, function (phrases, locale) {\n    forEach(phrases, function(translation, key) {\n      self.addPhrase(locale, key, translation, 0);\n    });\n  });\n\n  forEach(data.fallback, function (rule, locale) {\n    self.setFallback(locale, rule);\n  });\n\n  return this;\n};\n\n// export module\nmodule.exports = BabelFish;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/babelfish/lib/babelfish.js\n **/","module.exports = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = [],\n        peg$c1 = peg$FAILED,\n        peg$c2 = \"((\",\n        peg$c3 = { type: \"literal\", value: \"((\", description: \"\\\"((\\\"\" },\n        peg$c4 = \"))\",\n        peg$c5 = { type: \"literal\", value: \"))\", description: \"\\\"))\\\"\" },\n        peg$c6 = null,\n        peg$c7 = function(forms, anchor) {\n              return {\n                type:   'plural',\n                forms:  regularForms(forms),\n                strict: strictForms(forms),\n                anchor: anchor || 'count'\n              };\n            },\n        peg$c8 = \"|\",\n        peg$c9 = { type: \"literal\", value: \"|\", description: \"\\\"|\\\"\" },\n        peg$c10 = function(part, more) {\n              return [part].concat(more);\n            },\n        peg$c11 = function(part) {\n              return [part];\n            },\n        peg$c12 = \"=\",\n        peg$c13 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c14 = /^[0-9]/,\n        peg$c15 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c16 = \" \",\n        peg$c17 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n        peg$c18 = function(strict, form) {\n              return {\n                strict: strict.join(''),\n                text: form.join('')\n              }\n            },\n        peg$c19 = function() {\n              return {\n                text: text()\n              };\n            },\n        peg$c20 = \"\\\\\",\n        peg$c21 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n        peg$c22 = /^[\\\\|)(]/,\n        peg$c23 = { type: \"class\", value: \"[\\\\\\\\|)(]\", description: \"[\\\\\\\\|)(]\" },\n        peg$c24 = function(char) {\n              return char;\n            },\n        peg$c25 = void 0,\n        peg$c26 = { type: \"any\", description: \"any character\" },\n        peg$c27 = function() {\n              return text();\n            },\n        peg$c28 = \":\",\n        peg$c29 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c30 = function(name) {\n              return name;\n            },\n        peg$c31 = \"#{\",\n        peg$c32 = { type: \"literal\", value: \"#{\", description: \"\\\"#{\\\"\" },\n        peg$c33 = \"}\",\n        peg$c34 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c35 = function(anchor) {\n              return {\n                type:   'variable',\n                anchor: anchor\n              };\n            },\n        peg$c36 = \".\",\n        peg$c37 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c38 = function() {\n              return text()\n            },\n        peg$c39 = /^[a-zA-Z_$]/,\n        peg$c40 = { type: \"class\", value: \"[a-zA-Z_$]\", description: \"[a-zA-Z_$]\" },\n        peg$c41 = /^[a-zA-Z0-9_$]/,\n        peg$c42 = { type: \"class\", value: \"[a-zA-Z0-9_$]\", description: \"[a-zA-Z0-9_$]\" },\n        peg$c43 = function(lc) { return lc; },\n        peg$c44 = function(literal_chars) {\n              return {\n                type: 'literal',\n                text: literal_chars.join('')\n              };\n            },\n        peg$c45 = /^[\\\\#()|]/,\n        peg$c46 = { type: \"class\", value: \"[\\\\\\\\#()|]\", description: \"[\\\\\\\\#()|]\" },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1;\n\n      s0 = [];\n      s1 = peg$parseliteral();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseplural();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsevariable();\n        }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parseliteral();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseplural();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsevariable();\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c2) {\n        s1 = peg$c2;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseplural_forms();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c4) {\n            s3 = peg$c4;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseplural_anchor();\n            if (s4 === peg$FAILED) {\n              s4 = peg$c6;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c1;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_forms() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseplural_part();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s2 = peg$c8;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c9); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseplural_forms();\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c10(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseplural_part();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c11(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_part() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s1 = peg$c12;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c13); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c14.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c14.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c15); }\n            }\n          }\n        } else {\n          s2 = peg$c1;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s3 = peg$c16;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c6;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseplural_char();\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parseplural_char();\n              }\n            } else {\n              s4 = peg$c1;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c18(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c1;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseplural_char();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parseplural_char();\n          }\n        } else {\n          s1 = peg$c1;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c19();\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_char() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c22.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c23); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c24(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s2 = peg$c8;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c9); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c4) {\n            s2 = peg$c4;\n            peg$currPos += 2;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = peg$c25;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c1;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c26); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c27();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_anchor() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifier();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c30(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsevariable() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c31) {\n        s1 = peg$c31;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifier();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s3 = peg$c33;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c35(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifier_part();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c36;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseidentifier();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseidentifier();\n            }\n          } else {\n            s3 = peg$c1;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c38();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier_part();\n      }\n\n      return s0;\n    }\n\n    function peg$parseidentifier_part() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (peg$c39.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c41.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c41.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c42); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c27();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseliteral() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parseplural();\n      if (s4 === peg$FAILED) {\n        s4 = peg$parsevariable();\n      }\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c25;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c1;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseliteral_char();\n        if (s4 !== peg$FAILED) {\n          peg$reportedPos = s2;\n          s3 = peg$c43(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c1;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseplural();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsevariable();\n          }\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c25;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c1;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseliteral_char();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s2;\n              s3 = peg$c43(s4);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c1;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c1;\n          }\n        }\n      } else {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseliteral_char() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c45.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c24(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c26); }\n        }\n      }\n\n      return s0;\n    }\n\n\n      function regularForms(forms) {\n        var result = [];\n        for (var i=0; i<forms.length; i++) {\n          if (forms[i].strict === undefined) { result.push(forms[i].text); }\n        }\n        return result;\n      }\n      function strictForms(forms) {\n        var result = {};\n        for (var i=0; i<forms.length; i++) {\n          if (forms[i].strict !== undefined) { result[forms[i].strict] = forms[i].text; }\n        }\n        return result;\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/babelfish/lib/parser.js\n **/","/*\n * Plural functions support (cardinal & ordinal forms)\n *\n * Autogenerated from CLDR:\n *\n *   Version:   28\n *   $Revision: 12002 $\n */\n\n'use strict';\n\n\n// pluralizers cache\nvar s = {};\n\nfunction normalize(loc) {\n  var l;\n  if (s[loc]) { return loc; }\n  l = loc.toLowerCase().replace('_', '-');\n  if (s[l]) { return l; }\n  l = l.split('-')[0];\n  if (s[l]) { return l; }\n  return null;\n}\n\nfunction forms(loc) {\n  var l = normalize(loc);\n  return s[l] ? s[l].c : null;\n}\n\nfunction indexOf(loc, value) {\n  var l = normalize(loc);\n  if (!l) {\n    return -1;\n  }\n\n  if (!s[l].cFn) {\n    return 0;\n  }\n\n  var sval  = String(value),\n      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n      v = f.length,\n      n = +value,\n      i = +(sval.split('.')[0]),\n      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\n  return s[l].cFn(n, i, v, +f, t);\n}\n\nfunction plural(loc, value) {\n  var l = normalize(loc);\n  if (!l) {\n    return null;\n  }\n  return s[l].c[indexOf(l, value)];\n}\n\n\nfunction o_forms(loc) {\n  var l = normalize(loc);\n  return s[l] ? s[l].o : null;\n}\n\nfunction o_indexOf(loc, value) {\n  var l = normalize(loc);\n  if (!l) {\n    return -1;\n  }\n\n  if (!s[l].oFn) {\n    return 0;\n  }\n\n  var sval  = String(value),\n      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n      v = f.length,\n      n = +value,\n      i = +(sval.split('.')[0]),\n      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\n  return s[l].oFn(n, i, v, +f, t);\n}\n\nfunction ordinal(loc, value) {\n  var l = normalize(loc);\n  if (!s[l]) {\n    return null;\n  }\n  return s[l].o[o_indexOf(l, value)];\n}\n\nmodule.exports                  = plural;\nmodule.exports.indexOf          = indexOf;\nmodule.exports.forms            = forms;\nmodule.exports.ordinal          = ordinal;\nmodule.exports.ordinal.indexOf  = o_indexOf;\nmodule.exports.ordinal.forms    = o_forms;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar FORMS = [ 'zero', 'one', 'two', 'few', 'many', 'other' ];\n\nfunction unpack(i) { return FORMS[i]; }\n\n// adds given `rule` pluralizer for given `locales` into `storage`\nfunction add(locales, rule) {\n  var i;\n\n  rule.c = rule.c ? rule.c.map(unpack) : [ 'other' ];\n  rule.o = rule.o ? rule.o.map(unpack) : [ 'other' ];\n\n  for (i = 0; i < locales.length; i++) {\n    s[locales[i]] = rule;\n  }\n}\n\nfunction B(x, y, val) { return x <= val && val <= y && val % 1 === 0; }\nfunction IN(set, val) { return set.indexOf(val) >= 0; }\n\n\nadd([ 'af', 'asa', 'bem', 'bez', 'bg', 'brx', 'ce', 'cgg', 'chr', 'ckb', 'dv', 'ee', 'el', 'eo', 'es', 'eu', 'fo', 'fur', 'gsw', 'ha', 'haw', 'jgo', 'jmc', 'kaj', 'kcg', 'kkj', 'kl', 'ks', 'ksb', 'ku', 'ky', 'lb', 'lg', 'mas', 'mgo', 'ml', 'mn', 'nah', 'nb', 'nd', 'nn', 'nnh', 'no', 'nr', 'ny', 'nyn', 'om', 'or', 'os', 'pap', 'ps', 'rm', 'rof', 'rwk', 'saq', 'sdh', 'seh', 'sn', 'so', 'ss', 'ssy', 'st', 'syr', 'ta', 'te', 'teo', 'tig', 'tk', 'tn', 'tr', 'ts', 'ug', 'uz', 've', 'vo', 'vun', 'wae', 'xh', 'xog' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'ak', 'bh', 'guw', 'ln', 'mg', 'nso', 'pa', 'ti', 'wa' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return B(0, 1, n) ? 0 : 1;\n  }\n});\n\nadd([ 'am', 'fa', 'kn', 'zu' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'ar' ], {\n  c: [ 0, 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    var n100 = n % 100;\n    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : B(3, 10, n100) ? 3 : B(11, 99, n100) ? 4 : 5;\n  }\n});\n\nadd([ 'as', 'bn' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 4, 5 ],\n  oFn: function (n) {\n    return IN([ 1, 5, 7, 8, 9, 10 ], n) ? 0 : IN([ 2, 3 ], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n  }\n});\n\nadd([ 'ast', 'de', 'et', 'fi', 'fy', 'gl', 'ji', 'nl', 'sw', 'ur', 'yi' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  }\n});\n\nadd([ 'az' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 3, 4, 5 ],\n  oFn: function (n, i) {\n    var i10 = i % 10, i100 = i % 100, i1000 = i % 1000;\n    return IN([ 1, 2, 5, 7, 8 ], i10) || IN([ 20, 50, 70, 80 ], i100) ? 0 : IN([ 3, 4 ], i10) || IN([ 100, 200, 300, 400, 500, 600, 700, 800, 900 ], i1000) ? 1 : i === 0 || i10 === 6 || IN([ 40, 60, 90 ], i100) ? 2 : 3;\n  }\n});\n\nadd([ 'be' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 1 && n100 !== 11 ? 0 : B(2, 4, n10) && !B(12, 14, n100) ? 1 : n10 === 0 || B(5, 9, n10) || B(11, 14, n100) ? 2 : 3;\n  },\n  o: [ 3, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return IN([ 2, 3 ], n10) && !IN([ 12, 13 ], n100) ? 0 : 1;\n  }\n});\n\nadd([ 'bm', 'bo', 'dz', 'id', 'ig', 'ii', 'in', 'ja', 'jbo', 'jv', 'jw', 'kde', 'kea', 'km', 'ko', 'lkt', 'my', 'nqo', 'root', 'sah', 'ses', 'sg', 'th', 'to', 'wo', 'yo', 'zh' ], {\n});\n\nadd([ 'br' ], {\n  c: [ 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    var n10 = n % 10, n100 = n % 100, n1000000 = n % 1000000;\n    return n10 === 1 && !IN([ 11, 71, 91 ], n100) ? 0 : n10 === 2 && !IN([ 12, 72, 92 ], n100) ? 1 : (B(3, 4, n10) || n10 === 9) && (!B(10, 19, n100) && !B(70, 79, n100) && !B(90, 99, n100)) ? 2 : n !== 0 && n1000000 === 0 ? 3 : 4;\n  }\n});\n\nadd([ 'bs', 'hr', 'sh', 'sr' ], {\n  c: [ 1, 3, 5 ],\n  cFn: function (n, i, v, f) {\n    var i10 = i % 10, i100 = i % 100, f10 = f % 10, f100 = f % 100;\n    return v === 0 && i10 === 1 && i100 !== 11 || f10 === 1 && f100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) || B(2, 4, f10) && !B(12, 14, f100) ? 1 : 2;\n  }\n});\n\nadd([ 'ca' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 5 ],\n  oFn: function (n) {\n    return IN([ 1, 3 ], n) ? 0 : n === 2 ? 1 : n === 4 ? 2 : 3;\n  }\n});\n\nadd([ 'cs', 'sk' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : B(2, 4, i) && v === 0 ? 1 : v !== 0 ? 2 : 3;\n  }\n});\n\nadd([ 'cy' ], {\n  c: [ 0, 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n === 3 ? 3 : n === 6 ? 4 : 5;\n  },\n  o: [ 0, 1, 2, 3, 4, 5 ],\n  oFn: function (n) {\n    return IN([ 0, 7, 8, 9 ], n) ? 0 : n === 1 ? 1 : n === 2 ? 2 : IN([ 3, 4 ], n) ? 3 : IN([ 5, 6 ], n) ? 4 : 5;\n  }\n});\n\nadd([ 'da' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f, t) {\n    return n === 1 || t !== 0 && IN([ 0, 1 ], i) ? 0 : 1;\n  }\n});\n\nadd([ 'dsb', 'hsb' ], {\n  c: [ 1, 2, 3, 5 ],\n  cFn: function (n, i, v, f) {\n    var i100 = i % 100, f100 = f % 100;\n    return v === 0 && i100 === 1 || f100 === 1 ? 0 : v === 0 && i100 === 2 || f100 === 2 ? 1 : v === 0 && B(3, 4, i100) || B(3, 4, f100) ? 2 : 3;\n  }\n});\n\nadd([ 'en' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 1 && n100 !== 11 ? 0 : n10 === 2 && n100 !== 12 ? 1 : n10 === 3 && n100 !== 13 ? 2 : 3;\n  }\n});\n\nadd([ 'ff', 'kab' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return IN([ 0, 1 ], i) ? 0 : 1;\n  }\n});\n\nadd([ 'fil', 'tl' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f) {\n    var i10 = i % 10, f10 = f % 10;\n    return v === 0 && IN([ 1, 2, 3 ], i) || v === 0 && !IN([ 4, 6, 9 ], i10) || v !== 0 && !IN([ 4, 6, 9 ], f10) ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'fr', 'hy' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return IN([ 0, 1 ], i) ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'ga' ], {\n  c: [ 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : n === 2 ? 1 : B(3, 6, n) ? 2 : B(7, 10, n) ? 3 : 4;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'gd' ], {\n  c: [ 1, 2, 3, 5 ],\n  cFn: function (n) {\n    return IN([ 1, 11 ], n) ? 0 : IN([ 2, 12 ], n) ? 1 : (B(3, 10, n) || B(13, 19, n)) ? 2 : 3;\n  }\n});\n\nadd([ 'gu', 'hi' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 4, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : IN([ 2, 3 ], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n  }\n});\n\nadd([ 'gv' ], {\n  c: [ 1, 2, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return v === 0 && i10 === 1 ? 0 : v === 0 && i10 === 2 ? 1 : v === 0 && IN([ 0, 20, 40, 60, 80 ], i100) ? 2 : v !== 0 ? 3 : 4;\n  }\n});\n\nadd([ 'he', 'iw' ], {\n  c: [ 1, 2, 4, 5 ],\n  cFn: function (n, i, v) {\n    var n10 = n % 10;\n    return i === 1 && v === 0 ? 0 : i === 2 && v === 0 ? 1 : v === 0 && !B(0, 10, n) && n10 === 0 ? 2 : 3;\n  }\n});\n\nadd([ 'hu' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return IN([ 1, 5 ], n) ? 0 : 1;\n  }\n});\n\nadd([ 'is' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f, t) {\n    var i10 = i % 10, i100 = i % 100;\n    return t === 0 && i10 === 1 && i100 !== 11 || t !== 0 ? 0 : 1;\n  }\n});\n\nadd([ 'it' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 4, 5 ],\n  oFn: function (n) {\n    return IN([ 11, 8, 80, 800 ], n) ? 0 : 1;\n  }\n});\n\nadd([ 'iu', 'kw', 'naq', 'se', 'sma', 'smi', 'smj', 'smn', 'sms' ], {\n  c: [ 1, 2, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : n === 2 ? 1 : 2;\n  }\n});\n\nadd([ 'ka' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 4, 5 ],\n  oFn: function (n, i) {\n    var i100 = i % 100;\n    return i === 1 ? 0 : i === 0 || (B(2, 20, i100) || i100 === 40 || i100 === 60 || i100 === 80) ? 1 : 2;\n  }\n});\n\nadd([ 'kk' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 4, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10;\n    return n10 === 6 || n10 === 9 || n10 === 0 && n !== 0 ? 0 : 1;\n  }\n});\n\nadd([ 'ksh' ], {\n  c: [ 0, 1, 5 ],\n  cFn: function (n) {\n    return n === 0 ? 0 : n === 1 ? 1 : 2;\n  }\n});\n\nadd([ 'lag' ], {\n  c: [ 0, 1, 5 ],\n  cFn: function (n, i) {\n    return n === 0 ? 0 : IN([ 0, 1 ], i) && n !== 0 ? 1 : 2;\n  }\n});\n\nadd([ 'lo', 'ms', 'vi' ], {\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'lt' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v, f) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 1 && !B(11, 19, n100) ? 0 : B(2, 9, n10) && !B(11, 19, n100) ? 1 : f !== 0 ? 2 : 3;\n  }\n});\n\nadd([ 'lv', 'prg' ], {\n  c: [ 0, 1, 5 ],\n  cFn: function (n, i, v, f) {\n    var n10 = n % 10, n100 = n % 100, f100 = f % 100, f10 = f % 10;\n    return n10 === 0 || B(11, 19, n100) || v === 2 && B(11, 19, f100) ? 0 : n10 === 1 && n100 !== 11 || v === 2 && f10 === 1 && f100 !== 11 || v !== 2 && f10 === 1 ? 1 : 2;\n  }\n});\n\nadd([ 'mk' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f) {\n    var i10 = i % 10, f10 = f % 10;\n    return v === 0 && i10 === 1 || f10 === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 4, 5 ],\n  oFn: function (n, i) {\n    var i10 = i % 10, i100 = i % 100;\n    return i10 === 1 && i100 !== 11 ? 0 : i10 === 2 && i100 !== 12 ? 1 : IN([ 7, 8 ], i10) && !IN([ 17, 18 ], i100) ? 2 : 3;\n  }\n});\n\nadd([ 'mo', 'ro' ], {\n  c: [ 1, 3, 5 ],\n  cFn: function (n, i, v) {\n    var n100 = n % 100;\n    return i === 1 && v === 0 ? 0 : v !== 0 || n === 0 || n !== 1 && B(1, 19, n100) ? 1 : 2;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'mr' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : IN([ 2, 3 ], n) ? 1 : n === 4 ? 2 : 3;\n  }\n});\n\nadd([ 'mt' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n) {\n    var n100 = n % 100;\n    return n === 1 ? 0 : n === 0 || B(2, 10, n100) ? 1 : B(11, 19, n100) ? 2 : 3;\n  }\n});\n\nadd([ 'ne' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return B(1, 4, n) ? 0 : 1;\n  }\n});\n\nadd([ 'pl' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return i === 1 && v === 0 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i !== 1 && B(0, 1, i10) || v === 0 && B(5, 9, i10) || v === 0 && B(12, 14, i100) ? 2 : 3;\n  }\n});\n\nadd([ 'pt' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return B(0, 2, n) && n !== 2 ? 0 : 1;\n  }\n});\n\nadd([ 'pt-pt' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return n === 1 && v === 0 ? 0 : 1;\n  }\n});\n\nadd([ 'ru' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n  }\n});\n\nadd([ 'shi' ], {\n  c: [ 1, 3, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : B(2, 10, n) ? 1 : 2;\n  }\n});\n\nadd([ 'si' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f) {\n    return IN([ 0, 1 ], n) || i === 0 && f === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'sl' ], {\n  c: [ 1, 2, 3, 5 ],\n  cFn: function (n, i, v) {\n    var i100 = i % 100;\n    return v === 0 && i100 === 1 ? 0 : v === 0 && i100 === 2 ? 1 : v === 0 && B(3, 4, i100) || v !== 0 ? 2 : 3;\n  }\n});\n\nadd([ 'sq' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 4, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n === 1 ? 0 : n10 === 4 && n100 !== 14 ? 1 : 2;\n  }\n});\n\nadd([ 'sv' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return IN([ 1, 2 ], n10) && !IN([ 11, 12 ], n100) ? 0 : 1;\n  }\n});\n\nadd([ 'tzm' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return B(0, 1, n) || B(11, 99, n) ? 0 : 1;\n  }\n});\n\nadd([ 'uk' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n  },\n  o: [ 3, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 3 && n100 !== 13 ? 0 : 1;\n  }\n});\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/plurals-cldr/index.js\n **/","'use strict';\n\nconst CodeMirror = require('codemirror');\nrequire('codemirror/mode/gfm/gfm');\n\nvar template = require('../templates/editor.jade');\n\nvar clientRender = require('client/clientRender');\n\n\nconst delegate = require('client/delegate');\n\nconst t = require('i18n');\n\nconst LANG = require('config').lang;\n\nt.requirePhrase('mdedit', require('../locales/' + LANG + '.yml'));\n\nclass MdEditor {\n\n  actionBold() {\n    this.replaceSelection(\"**\", \"**\", 2, t(\"bold\"));\n  }\n\n\n  actionItalic() {\n    this.replaceSelection(\"*\", \"*\", 1, t(\"italic\"));\n  }\n\n  actionCode() {\n    this.replaceSelection(\"`\", \"`\", 0, t(\"code\"));\n  }\n\n  actionRedo() {\n    this.codemirror.redo();\n  }\n\n  actionUndo() {\n    this.codemirror.undo();\n  }\n\n  actionFencedCode() {\n    this.replaceSelection(\"\\n```js\\n\", \"\\n```\\n\", 0, t(\"code_multiline\"));\n  }\n\n  actionLink() {\n\n    let selection = this.codemirror.getSelection();\n    let text = '';\n    let link = 'http://';\n\n    if (selection.match(/^https?:\\/\\//)) {\n      link = selection;\n    } else {\n      text = selection;\n    }\n\n    if (link) {\n      text = 'link text';\n    }\n    this.codemirror.replaceSelection('[' + text + '](' + link + ')');\n    let cursorPos = this.codemirror.getCursor();\n    this.codemirror.setCursor(cursorPos.line, cursorPos.ch - (3 + link.length));\n  }\n\n  actionOl() {\n    this.replaceSelection(\"1. \", \"\\n\", 0, t('ol_item'));\n  }\n\n  actionUl() {\n    this.replaceSelection(\"- \", \"\\n\", 0, t('ul_item'));\n  }\n\n  actionHeading() {\n    this.replaceSelection(\"# \", \"\\n\", 0, t(\"heading\"));\n  }\n\n  actionImage() {\n    let selection = this.codemirror.getSelection();\n    let text = t(\"alt\");\n\n    if (!selection) {\n      selection = \"http://my.jpg\";\n    }\n    this.codemirror.replaceSelection('![' + text + '](' + selection + ')');\n    let cursorPos = this.codemirror.getCursor();\n    this.codemirror.setCursor(cursorPos.line, cursorPos.ch - (1 + selection.length));\n  }\n\n  replaceSelection(before, after, moveCursorCharsCount, defaultText) {\n\n    let selection = this.codemirror.getSelection();\n    if (!selection)\n      selection = defaultText;\n    this.codemirror.replaceSelection(before + selection + after);\n\n    let cursorPos = this.codemirror.getCursor();\n    this.codemirror.setCursor(cursorPos.line, cursorPos.ch - moveCursorCharsCount);\n  }\n\n  render(textArea) {\n    var allButtons = {\n      Bold:       'bold [Ctrl-B]',\n      Italic:     'italic [Ctrl-I]',\n      Code:       'inline code',\n      Undo:       'undo [Ctrl-Z]',\n      Redo:       'redo [Ctrl-Y]',\n      FencedCode: 'multiline code',\n      Link:       'link',\n      Ul:         'itemized list',\n      Ol:         'ordered list',\n      Heading:    'heading',\n      Image:      'insert image'\n    };\n\n    function makeButtonsFromActions(actions) {\n      var buttons = [];\n      for (var i = 0; i < actions.length; i++) {\n        buttons.push({action: actions[i], title: allButtons[actions[i]]});\n      }\n      return buttons;\n    }\n\n    var buttons;\n    switch (this.options.buttonSet) {\n    default:\n      buttons = makeButtonsFromActions(\n        'Bold Italic Code Undo Redo FencedCode Link Ul Ol Heading Image'.split(' ')\n      );\n    }\n\n    textArea.insertAdjacentHTML(\"afterEnd\", clientRender(template, {\n      buttons: buttons\n    }));\n\n    this.elem = textArea.nextElementSibling;\n\n    let templateArea = this.elem.querySelector('textarea');\n    templateArea.replace(textArea);\n\n    textArea.classList.remove('mdeditor');\n    // move all classes from template textarea to the existing one\n    for (var i = 0; i < templateArea.classList.length; i++) {\n      var cls = templateArea.classList[i];\n      textArea.classList.add(cls);\n    }\n  }\n\n  constructor(options) {\n    this.options = Object.create(options);\n    if (!options.buttonSet) this.options.buttonSet = 'standard';\n\n    this.render(options.elem);\n    this.value = this.elem.value;\n\n    this.delegate('[data-action]', function(e) {\n      let actionName = 'action' + this.delegateTarget.getAtribute('data-action');\n      if (!this[actionName]) return;\n\n      e.preventDefault();\n      this[actionName]();\n    });\n\n    return;\n\n    this.codemirror = CodeMirror.fromTextArea(this.elem.querySelector('textarea'), {\n      tabSize:     2,\n      //lineNumbers: false,\n      mode:        'gfm'\n    });\n\n    this.codemirror.setOption(\"extraKeys\", {\n      'Ctrl-B': () => this.actionBold(),\n      'Ctrl-I': () => this.actionItalic()\n    });\n\n\n    /*\n     editor.on(\"change\", function(cm, change) {\n     document.getElementById(\"qa-preview\").innerHTML = cm.getValue();\n     });\n     */\n\n  }\n}\n\ndelegate.delegateMixin(MdEditor.prototype);\n\nmodule.exports = MdEditor;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/mdeditor/client/mdeditor.js\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    (this || window).CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) display.input.focus();\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    var cm = this;\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || cm.hasFocus())\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) options.finishInit(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      display.lineDiv.style.textRendering = \"auto\";\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\n    if (place) {\n      if (place.appendChild) place.appendChild(d.wrapper);\n      else place(d.wrapper);\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function() {\n      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n    });\n    on(horiz, \"scroll\", function() {\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n  }\n\n  NativeScrollbars.prototype = copyObj({\n    update: function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n\n      if (needsV) {\n        this.vert.style.display = \"block\";\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        // A bug in IE8 can cause this value to be negative, so guard it.\n        this.vert.firstChild.style.height =\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n      } else {\n        this.vert.style.display = \"\";\n        this.vert.firstChild.style.height = \"0\";\n      }\n\n      if (needsH) {\n        this.horiz.style.display = \"block\";\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n        this.horiz.style.left = measure.barLeft + \"px\";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width =\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n      } else {\n        this.horiz.style.display = \"\";\n        this.horiz.firstChild.style.width = \"0\";\n      }\n\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n        if (sWidth == 0) this.zeroWidthHack();\n        this.checkedZeroWidth = true;\n      }\n\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n    },\n    setScrollLeft: function(pos) {\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n    },\n    setScrollTop: function(pos) {\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n    },\n    zeroWidthHack: function() {\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n      this.horiz.style.height = this.vert.style.width = w;\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n      this.disableHoriz = new Delayed;\n      this.disableVert = new Delayed;\n    },\n    enableZeroWidthBar: function(bar, delay) {\n      bar.style.pointerEvents = \"auto\";\n      function maybeDisable() {\n        // To find out whether the scrollbar is still visible, we\n        // check whether the element under the pixel in the bottom\n        // left corner of the scrollbar box is the scrollbar box\n        // itself (when the bar is still visible) or its filler child\n        // (when the bar is hidden). If it is still visible, we keep\n        // it enabled, if it's hidden, we disable pointer events.\n        var box = bar.getBoundingClientRect();\n        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n        if (elt != bar) bar.style.pointerEvents = \"none\";\n        else delay.set(1000, maybeDisable);\n      }\n      delay.set(1000, maybeDisable);\n    },\n    clear: function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    }\n  }, NativeScrollbars.prototype);\n\n  function NullScrollbars() {}\n\n  NullScrollbars.prototype = copyObj({\n    update: function() { return {bottom: 0, right: 0}; },\n    setScrollLeft: function() {},\n    setScrollTop: function() {},\n    clear: function() {}\n  }, NullScrollbars.prototype);\n\n  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function() {\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function(pos, axis) {\n      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n      else setScrollTop(cm, pos);\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n  }\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        updateHeightsInViewport(cm);\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter && view[i].gutter)\n        view[i].gutter.style.left = left;\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  }\n\n  DisplayUpdate.prototype.signal = function(emitter, type) {\n    if (hasHandler(emitter, type))\n      this.events.push(arguments);\n  };\n  DisplayUpdate.prototype.finish = function() {\n    for (var i = 0; i < this.events.length; i++)\n      signal.apply(null, this.events[i]);\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    var total = measure.docHeight + cm.display.barHeight;\n    cm.display.heightForcer.style.top = total + \"px\";\n    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // INPUT HANDLING\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  // This will be set to an array of strings when copying, so that,\n  // when pasting, we know what kind of selections the copied text\n  // was made out of.\n  var lastCopied = null;\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) sel = doc.sel;\n\n    var paste = cm.state.pasteIncoming || origin == \"paste\";\n    var textLines = doc.splitLines(inserted), multiPaste = null;\n    // When pasing N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.length; i++)\n            multiPaste.push(doc.splitLines(lastCopied[i]));\n        }\n      } else if (textLines.length == sel.ranges.length) {\n        multiPaste = map(textLines, function(l) { return [l]; });\n      }\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          from = Pos(from.line, from.ch - deleted);\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n      }\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      triggerElectric(cm, inserted);\n\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          indented = indentLine(cm, range.head.line, \"smart\");\n      }\n      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges};\n  }\n\n  function disableBrowserMagic(field) {\n    field.setAttribute(\"autocorrect\", \"off\");\n    field.setAttribute(\"autocapitalize\", \"off\");\n    field.setAttribute(\"spellcheck\", \"false\");\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  function TextareaInput(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Tracks when input.reset has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    this.inaccurateSelection = false;\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) te.style.width = \"1000px\";\n    else te.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) te.style.border = \"1px solid black\";\n    disableBrowserMagic(te);\n    return div;\n  }\n\n  TextareaInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = this.cm;\n\n      // Wraps and hides input textarea\n      var div = this.wrapper = hiddenTextarea();\n      // The semihidden textarea that is focused when the editor is\n      // focused, and receives input.\n      var te = this.textarea = div.firstChild;\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n      if (ios) te.style.width = \"0px\";\n\n      on(te, \"input\", function() {\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n        input.poll();\n      });\n\n      on(te, \"paste\", function(e) {\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\n        cm.state.pasteIncoming = true;\n        input.fastPoll();\n      });\n\n      function prepareCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (input.inaccurateSelection) {\n            input.prevInput = \"\";\n            input.inaccurateSelection = false;\n            te.value = lastCopied.join(\"\\n\");\n            selectInput(te);\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = \"\";\n            te.value = ranges.text.join(\"\\n\");\n            selectInput(te);\n          }\n        }\n        if (e.type == \"cut\") cm.state.cutIncoming = true;\n      }\n      on(te, \"cut\", prepareCopyCut);\n      on(te, \"copy\", prepareCopyCut);\n\n      on(display.scroller, \"paste\", function(e) {\n        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n        cm.state.pasteIncoming = true;\n        input.focus();\n      });\n\n      // Prevent normal selection in the editor (we handle our own)\n      on(display.lineSpace, \"selectstart\", function(e) {\n        if (!eventInWidget(display, e)) e_preventDefault(e);\n      });\n\n      on(te, \"compositionstart\", function() {\n        var start = cm.getCursor(\"from\");\n        if (input.composing) input.composing.range.clear()\n        input.composing = {\n          start: start,\n          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n        };\n      });\n      on(te, \"compositionend\", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    },\n\n    prepareSelection: function() {\n      // Redraw the selection and/or cursor\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result = prepareSelection(cm);\n\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                            headPos.top + lineOff.top - wrapOff.top));\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                             headPos.left + lineOff.left - wrapOff.left));\n      }\n\n      return result;\n    },\n\n    showSelection: function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + \"px\";\n        this.wrapper.style.left = drawn.teLeft + \"px\";\n      }\n    },\n\n    // Reset the input to correspond to the selection (or to be empty,\n    // when not typing and nothing is selected)\n    reset: function(typing) {\n      if (this.contextMenuPending) return;\n      var minimal, selected, cm = this.cm, doc = cm.doc;\n      if (cm.somethingSelected()) {\n        this.prevInput = \"\";\n        var range = doc.sel.primary();\n        minimal = hasCopyEvent &&\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n        var content = minimal ? \"-\" : selected || cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) selectInput(this.textarea);\n        if (ie && ie_version >= 9) this.hasSelection = content;\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = \"\";\n        if (ie && ie_version >= 9) this.hasSelection = null;\n      }\n      this.inaccurateSelection = minimal;\n    },\n\n    getField: function() { return this.textarea; },\n\n    supportsTouch: function() { return false; },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n        try { this.textarea.focus(); }\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n      }\n    },\n\n    blur: function() { this.textarea.blur(); },\n\n    resetPosition: function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    },\n\n    receivedFocus: function() { this.slowPoll(); },\n\n    // Poll for input changes, using the normal rate of polling. This\n    // runs as long as the editor is focused.\n    slowPoll: function() {\n      var input = this;\n      if (input.pollingFast) return;\n      input.polling.set(this.cm.options.pollInterval, function() {\n        input.poll();\n        if (input.cm.state.focused) input.slowPoll();\n      });\n    },\n\n    // When an event has just come in that is likely to add or change\n    // something in the input textarea, we poll faster, to ensure that\n    // the change appears on the screen quickly.\n    fastPoll: function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p() {\n        var changed = input.poll();\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n        else {input.pollingFast = false; input.slowPoll();}\n      }\n      input.polling.set(20, p);\n    },\n\n    // Read input from the textarea, and update the document to match.\n    // When something is selected, it is present in the textarea, and\n    // selected (unless it is huge, in which case a placeholder is\n    // used). When nothing is selected, the cursor sits after previously\n    // seen text (can be empty), which is stored in prevInput (we must\n    // not reset the textarea when typing, because that breaks IME).\n    poll: function() {\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      // Since this is called a *lot*, try to bail out as cheaply as\n      // possible when it is clear that nothing happened. hasSelection\n      // will be the case when there is a lot of text in the textarea,\n      // in which case reading its value would be expensive.\n      if (this.contextMenuPending || !cm.state.focused ||\n          (hasSelection(input) && !prevInput && !this.composing) ||\n          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n        return false;\n\n      var text = input.value;\n      // If nothing changed, bail.\n      if (text == prevInput && !cm.somethingSelected()) return false;\n      // Work around nonsensical selection resetting in IE9/10, and\n      // inexplicable appearance of private area unicode characters on\n      // some key combos in Mac (#2689).\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\n          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n        cm.display.input.reset();\n        return false;\n      }\n\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text.charCodeAt(0);\n        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n      }\n      // Find the part of the input that is actually new\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\n      var self = this;\n      runInOp(cm, function() {\n        applyTextInput(cm, text.slice(same), prevInput.length - same,\n                       null, self.composing ? \"*compose\" : null);\n\n        // Don't leave long text in the textarea, since it makes further polling slow\n        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n        else self.prevInput = text;\n\n        if (self.composing) {\n          self.composing.range.clear();\n          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n                                             {className: \"CodeMirror-composing\"});\n        }\n      });\n      return true;\n    },\n\n    ensurePolled: function() {\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\n    },\n\n    onKeyPress: function() {\n      if (ie && ie_version >= 9) this.hasSelection = null;\n      this.fastPoll();\n    },\n\n    onContextMenu: function(e) {\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) return; // Opera is difficult.\n\n      // Reset the current text selection only if the click is done outside of the selection\n      // and 'resetSelectionOnContextMenu' option is true.\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1)\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n      var oldCSS = te.style.cssText;\n      input.wrapper.style.position = \"absolute\";\n      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n      display.input.focus();\n      if (webkit) window.scrollTo(null, oldScrollY);\n      display.input.reset();\n      // Adds \"Select all\" to context menu in FF\n      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n      input.contextMenuPending = true;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n\n      // Select-all will be greyed out if there's nothing to select, so\n      // this adds a zero-width space so that we can later check whether\n      // it got selected.\n      function prepareSelectAllHack() {\n        if (te.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n          te.value = \"\\u21da\"; // Used to catch context-menu undo\n          te.value = extval;\n          input.prevInput = selected ? \"\" : \"\\u200b\";\n          te.selectionStart = 1; te.selectionEnd = extval.length;\n          // Re-set this, in case some other handler touched the\n          // selection in the meantime.\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      function rehide() {\n        input.contextMenuPending = false;\n        input.wrapper.style.position = \"relative\";\n        te.style.cssText = oldCSS;\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\n        // Try to detect the user choosing select-all\n        if (te.selectionStart != null) {\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n          var i = 0, poll = function() {\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n              operation(cm, commands.selectAll)(cm);\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n            else display.input.reset();\n          };\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n\n      if (ie && ie_version >= 9) prepareSelectAllHack();\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = function() {\n          off(window, \"mouseup\", mouseup);\n          setTimeout(rehide, 20);\n        };\n        on(window, \"mouseup\", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    },\n\n    readOnlyChanged: function(val) {\n      if (!val) this.reset();\n    },\n\n    setUneditable: nothing,\n\n    needsContentAttribute: false\n  }, TextareaInput.prototype);\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.gracePeriod = false;\n  }\n\n  ContentEditableInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = input.cm;\n      var div = input.div = display.lineDiv;\n      disableBrowserMagic(div);\n\n      on(div, \"paste\", function(e) {\n        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);\n      })\n\n      on(div, \"compositionstart\", function(e) {\n        var data = e.data;\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n        if (!data) return;\n        var prim = cm.doc.sel.primary();\n        var line = cm.getLine(prim.head.line);\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n        if (found > -1 && found <= prim.head.ch)\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n                                                Pos(prim.head.line, found + data.length));\n      });\n      on(div, \"compositionupdate\", function(e) {\n        input.composing.data = e.data;\n      });\n      on(div, \"compositionend\", function(e) {\n        var ours = input.composing;\n        if (!ours) return;\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n          ours.data = e.data;\n        // Need a small delay to prevent other code (input event,\n        // selection polling) from doing damage when fired right after\n        // compositionend.\n        setTimeout(function() {\n          if (!ours.handled)\n            input.applyComposition(ours);\n          if (input.composing == ours)\n            input.composing = null;\n        }, 50);\n      });\n\n      on(div, \"touchstart\", function() {\n        input.forceCompositionEnd();\n      });\n\n      on(div, \"input\", function() {\n        if (input.composing) return;\n        if (cm.isReadOnly() || !input.pollContent())\n          runInOp(input.cm, function() {regChange(cm);});\n      });\n\n      function onCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection(\"\", null, \"cut\");\n            });\n          }\n        }\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        if (e.clipboardData && !ios) {\n          e.preventDefault();\n          e.clipboardData.clearData();\n          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n        } else {\n          // Old-fashioned briefly-focus-a-textarea hack\n          var kludge = hiddenTextarea(), te = kludge.firstChild;\n          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n          te.value = lastCopied.join(\"\\n\");\n          var hadFocus = document.activeElement;\n          selectInput(te);\n          setTimeout(function() {\n            cm.display.lineSpace.removeChild(kludge);\n            hadFocus.focus();\n          }, 50);\n        }\n      }\n      on(div, \"copy\", onCopyCut);\n      on(div, \"cut\", onCopyCut);\n    },\n\n    prepareSelection: function() {\n      var result = prepareSelection(this.cm, false);\n      result.focus = this.cm.state.focused;\n      return result;\n    },\n\n    showSelection: function(info) {\n      if (!info || !this.cm.display.view.length) return;\n      if (info.focus) this.showPrimarySelection();\n      this.showMultipleSelections(info);\n    },\n\n    showPrimarySelection: function() {\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n        return;\n\n      var start = posToDOM(this.cm, prim.from());\n      var end = posToDOM(this.cm, prim.to());\n      if (!start && !end) return;\n\n      var view = this.cm.display.view;\n      var old = sel.rangeCount && sel.getRangeAt(0);\n      if (!start) {\n        start = {node: view[0].measure.map[2], offset: 0};\n      } else if (!end) { // FIXME dangerously hacky\n        var measure = view[view.length - 1].measure;\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n      }\n\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n      if (rng) {\n        if (!gecko && this.cm.state.focused) {\n          sel.collapse(start.node, start.offset);\n          if (!rng.collapsed) sel.addRange(rng);\n        } else {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n        if (old && sel.anchorNode == null) sel.addRange(old);\n        else if (gecko) this.startGracePeriod();\n      }\n      this.rememberSelection();\n    },\n\n    startGracePeriod: function() {\n      var input = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        input.gracePeriod = false;\n        if (input.selectionChanged())\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n      }, 20);\n    },\n\n    showMultipleSelections: function(info) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    },\n\n    rememberSelection: function() {\n      var sel = window.getSelection();\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n    },\n\n    selectionInEditor: function() {\n      var sel = window.getSelection();\n      if (!sel.rangeCount) return false;\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n    },\n    blur: function() { this.div.blur(); },\n    getField: function() { return this.div; },\n\n    supportsTouch: function() { return true; },\n\n    receivedFocus: function() {\n      var input = this;\n      if (this.selectionInEditor())\n        this.pollSelection();\n      else\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      this.polling.set(this.cm.options.pollInterval, poll);\n    },\n\n    selectionChanged: function() {\n      var sel = window.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    },\n\n    pollSelection: function() {\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n        var sel = window.getSelection(), cm = this.cm;\n        this.rememberSelection();\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (anchor && head) runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n        });\n      }\n    },\n\n    pollContent: function() {\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\n      var fromIndex;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        var fromLine = lineNo(display.view[0].line);\n        var fromNode = display.view[0].node;\n      } else {\n        var fromLine = lineNo(display.view[fromIndex].line);\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      if (toIndex == display.view.length - 1) {\n        var toLine = display.viewTo - 1;\n        var toNode = display.lineDiv.lastChild;\n      } else {\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        var toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n        else break;\n      }\n\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n        ++cutFront;\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n        ++cutEnd;\n\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n      newText[0] = newText[0].slice(cutFront);\n\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n        return true;\n      }\n    },\n\n    ensurePolled: function() {\n      this.forceCompositionEnd();\n    },\n    reset: function() {\n      this.forceCompositionEnd();\n    },\n    forceCompositionEnd: function() {\n      if (!this.composing || this.composing.handled) return;\n      this.applyComposition(this.composing);\n      this.composing.handled = true;\n      this.div.blur();\n      this.div.focus();\n    },\n    applyComposition: function(composing) {\n      if (this.cm.isReadOnly())\n        operation(this.cm, regChange)(this.cm)\n      else if (composing.data && composing.data != composing.startData)\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n    },\n\n    setUneditable: function(node) {\n      node.contentEditable = \"false\"\n    },\n\n    onKeyPress: function(e) {\n      e.preventDefault();\n      if (!this.cm.isReadOnly())\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    },\n\n    readOnlyChanged: function(val) {\n      this.div.contentEditable = String(val != \"nocursor\")\n    },\n\n    onContextMenu: nothing,\n    resetPosition: nothing,\n\n    needsContentAttribute: true\n  }, ContentEditableInput.prototype);\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) return null;\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        return locateNodeInLineView(lineView, node, offset);\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) offset = textNode.nodeValue.length;\n    }\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) return badPos(found, bad);\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        return badPos(Pos(found.line, found.ch + dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText != null) {\n          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n          text += cmText;\n          return;\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find()))\n            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n          return;\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n        for (var i = 0; i < node.childNodes.length; i++)\n          walk(node.childNodes[i]);\n        if (/^(pre|div|p)$/i.test(node.nodeName))\n          closing = true;\n      } else if (node.nodeType == 3) {\n        var val = node.nodeValue;\n        if (!val) return;\n        if (closing) {\n          text += lineSep;\n          closing = false;\n        }\n        text += val;\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) break;\n      from = from.nextSibling;\n    }\n    return text;\n  }\n\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel, options);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) break;\n            else {--i; continue;}\n          }\n        }\n        if (!m.atomic) continue;\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff;\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) near = movePos(doc, near, -dir, line);\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            return skipAtomicInner(doc, near, pos, dir, mayClear);\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) far = movePos(doc, far, dir, line);\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n      }\n    }\n    return pos;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0);\n    }\n    return found;\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n      else return null;\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n      else return null;\n    } else {\n      return new Pos(pos.line, pos.ch + dir);\n    }\n  }\n\n  // SELECTION DRAWING\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (primary === false && i == doc.sel.primIndex) continue;\n      var range = doc.sel.ranges[i];\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range.head, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n    return result;\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else if (ie && cm.options.lineWrapping) {\n          var rects = range(node, start, end).getClientRects();\n          if (rects.length)\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n          else\n            rect = nullRect;\n        } else {\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n        }\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i].call(null);\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.preparedSelection = display.input.prepareSelection();\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    if (op.preparedSelection)\n      cm.display.input.showSelection(op.preparedSelection);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      cm.display.input.reset(op.typing);\n    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))\n      ensureFocus(op.cm);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scrollbars.setScrollTop(doc.scrollTop);\n      display.scroller.scrollTop = doc.scrollTop;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\n      display.scroller.scrollLeft = doc.scrollLeft;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n    if (op.update)\n      op.update.finish();\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    };\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) return false;\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n    function farAway(touch, other) {\n      if (other.left == null) return true;\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n    on(d.scroller, \"touchstart\", function(e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function() {\n      if (d.activeTouch) d.activeTouch.moved = true;\n    });\n    on(d.scroller, \"touchend\", function(e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          range = new Range(pos, pos);\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          range = cm.findWordAt(pos);\n        else // Triple tap\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function(e){onDragStart(cm, e);},\n      drop: operation(cm, onDrop),\n      leave: function() {clearDragCursor(cm);}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", bind(onFocus, cm));\n    on(inp, \"blur\", bind(onBlur, cm));\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != CodeMirror.Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n      return;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      // #3261: make sure, that we're not starting a second selection\n      if (cm.state.selectingText)\n        cm.state.selectingText(e);\n      else if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(function() {display.input.focus();}, 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      else delayBlurEvent(cm);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n    else cm.curOp.focus = activeElt();\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display, startTime = +new Date;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier && +new Date - 200 < startTime)\n          extendSelection(cm.doc, start);\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n        else\n          display.input.focus();\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          return;\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function() {cm.display.input.focus();}, 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) return;\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  var wheelEventDelta = function(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n    return {x: dx, y: dy};\n  };\n  CodeMirror.wheelEventPixels = function(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  };\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) return result;\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm);\n  }\n\n  var stopSeq = new Delayed;\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) return \"handled\";\n      stopSeq.set(50, function() {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      });\n      name = seq + \" \" + name;\n    }\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      cm.state.keySeq = name;\n    if (result == \"handled\")\n      signalLater(cm, \"keyHandled\", cm, name, e);\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    if (seq && !result && /\\'$/.test(name)) {\n      e_preventDefault(e);\n      return true;\n    }\n    return !!result;\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) return false;\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n          || dispatchKey(cm, name, e, function(b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 return doHandleBinding(cm, b);\n             });\n    } else {\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n                       function(b) { return doHandleBinding(cm, b, true); });\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    cm.display.input.onKeyPress(e);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function() {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n        onBlur(cm);\n      }\n    }, 100);\n  }\n\n  function onFocus(cm) {\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.delayingBlurEvent) return;\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    cm.display.input.onContextMenu(e);\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      regChange(cm);\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = doc.splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) break;\n    }\n    return coords;\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return false\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return false\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") {\n      moveOnce()\n    } else if (unit == \"column\") {\n      moveOnce(true)\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n    if (!cmp(pos, result)) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || maps[i].name == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise);\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true);\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return found;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) line = this.doc.first;\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd].call(null, this);\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input.getField();},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function(cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) return;\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function(line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) break;\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n  });\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != CodeMirror.Init) cm.refresh();\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n  }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function(cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != CodeMirror.Init && getKeyMap(old);\n    if (prev && prev.detach) prev.detach(cm, next);\n    if (next.attach) next.attach(cm, prev || null);\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n  option(\"scrollbarStyle\", \"native\", function(cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val)\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.input.resetPosition();\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.getField().tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                                prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n        }\n        ensureCursorVisible(cm);\n      });\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n      else if (/^s(hift)$/i.test(mod)) shift = true;\n      else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) name = \"Alt-\" + name;\n    if (ctrl) name = \"Ctrl-\" + name;\n    if (cmd) name = \"Cmd-\" + name;\n    if (shift) name = \"Shift-\" + name;\n    return name;\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  CodeMirror.normalizeKeyMap = function(keymap) {\n    var copy = {};\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n      if (value == \"...\") { delete keymap[keyname]; continue; }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val, name;\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) copy[name] = val;\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n      }\n      delete keymap[keyname];\n    }\n    for (var prop in copy) keymap[prop] = copy[prop];\n    return keymap;\n  };\n\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        return lookupKey(key, map.fallthrough, handle, context);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) return result;\n      }\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var base = keyNames[event.keyCode], name = base;\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n    return name;\n  };\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  }\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      options.tabindex = textarea.tabIndex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function(cm) {\n      cm.save = save;\n      cm.getTextArea = function() { return textarea; };\n      cm.toTextArea = function() {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            textarea.form.submit = realSubmit;\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var nextMarkerId = 0;\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) return null;\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.doc = doc;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(line, line.height + diff);\n    if (cm) runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    var cm = widget.doc.cm;\n    if (!cm) return 0;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      if (widget.noHScroll)\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight;\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    function getObj(copy) {\n      return {start: stream.start, end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: copy ? copyState(doc.mode, state) : state};\n    }\n\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n    if (asArray) tokens = [];\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, state);\n      if (asArray) tokens.push(getObj(true));\n    }\n    return asArray ? tokens : getObj();\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 50000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var state = getStateBefore(cm, lineNo(line));\n      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n      line.stateAfter = state;\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol()) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n      builder.content.className = \"cm-tab-wrap-hack\";\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n    if (!text) return;\n    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt.setAttribute(\"role\", \"presentation\");\n          txt.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function splitSpaces(old) {\n    var out = \" \";\n    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n    out += \" \";\n    return out;\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title, css) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\n        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n          if (collapsed.to == pos) collapsed = false;\n        }\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      for (var i = start, result = []; i < end; ++i)\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      return result;\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added = linesFor(1, text.length - 1);\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added = linesFor(1, text.length - 1);\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.extend = false;\n\n    if (typeof text == \"string\") text = this.splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || this.lineSeparator());\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (classTest(cls).test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(lineNo == from.line && from.ch > span.to ||\n                span.from == null && lineNo != from.line||\n                lineNo == to.line && span.from > to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;},\n\n    splitLines: function(str) {\n      if (this.lineSep) return str.split(this.lineSep);\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, ore are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var noHandlers = []\n  function getHandlers(emitter, type, copy) {\n    var arr = emitter._handlers && emitter._handlers[type]\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n    else return arr || noHandlers\n  }\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var handlers = getHandlers(emitter, type, false)\n      for (var i = 0; i < handlers.length; ++i)\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type, true)\n    if (!handlers.length) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type, false)\n    if (!arr.length) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r; }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  var contains = CodeMirror.contains = function(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      child = child.parentNode;\n    if (parent.contains)\n      return parent.contains(child);\n    do {\n      if (child.nodeType == 11) child = child.host;\n      if (child == parent) return true;\n    } while (child = child.parentNode);\n  };\n\n  function activeElt() {\n    var activeElement = document.activeElement;\n    while (activeElement && activeElement.root && activeElement.root.activeElement)\n      activeElement = activeElement.root.activeElement;\n    return activeElement;\n  }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n  var addClass = CodeMirror.addClass = function(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n  };\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = CodeMirror.keyNames = {\n    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level == 2)\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"5.11.0\";\n\n  return CodeMirror;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/lib/codemirror.js\n ** module id = 360\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../markdown/markdown\"), require(\"../../addon/mode/overlay\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../markdown/markdown\", \"../../addon/mode/overlay\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\\.beep|\\.lwz|\\.xpc|\\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\\.beeps?|xmpp|xri|ymsgr|z39\\.50[rs]?):(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]|\\([^\\s()<>]*\\))+(?:\\([^\\s()<>]*\\)|[^\\s`*!()\\[\\]{};:'\".,<>?]))/i\n\nCodeMirror.defineMode(\"gfm\", function(config, modeConfig) {\n  var codeDepth = 0;\n  function blankLine(state) {\n    state.code = false;\n    return null;\n  }\n  var gfmOverlay = {\n    startState: function() {\n      return {\n        code: false,\n        codeBlock: false,\n        ateSpace: false\n      };\n    },\n    copyState: function(s) {\n      return {\n        code: s.code,\n        codeBlock: s.codeBlock,\n        ateSpace: s.ateSpace\n      };\n    },\n    token: function(stream, state) {\n      state.combineTokens = null;\n\n      // Hack to prevent formatting override inside code blocks (block and inline)\n      if (state.codeBlock) {\n        if (stream.match(/^```+/)) {\n          state.codeBlock = false;\n          return null;\n        }\n        stream.skipToEnd();\n        return null;\n      }\n      if (stream.sol()) {\n        state.code = false;\n      }\n      if (stream.sol() && stream.match(/^```+/)) {\n        stream.skipToEnd();\n        state.codeBlock = true;\n        return null;\n      }\n      // If this block is changed, it may need to be updated in Markdown mode\n      if (stream.peek() === '`') {\n        stream.next();\n        var before = stream.pos;\n        stream.eatWhile('`');\n        var difference = 1 + stream.pos - before;\n        if (!state.code) {\n          codeDepth = difference;\n          state.code = true;\n        } else {\n          if (difference === codeDepth) { // Must be exact\n            state.code = false;\n          }\n        }\n        return null;\n      } else if (state.code) {\n        stream.next();\n        return null;\n      }\n      // Check if space. If so, links can be formatted later on\n      if (stream.eatSpace()) {\n        state.ateSpace = true;\n        return null;\n      }\n      if (stream.sol() || state.ateSpace) {\n        state.ateSpace = false;\n        if (modeConfig.gitHubSpice !== false) {\n          if(stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+@)?(?:[a-f0-9]{7,40}\\b)/)) {\n            // User/Project@SHA\n            // User@SHA\n            // SHA\n            state.combineTokens = true;\n            return \"link\";\n          } else if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+)?#[0-9]+\\b/)) {\n            // User/Project#Num\n            // User#Num\n            // #Num\n            state.combineTokens = true;\n            return \"link\";\n          }\n        }\n      }\n      if (stream.match(urlRE) &&\n          stream.string.slice(stream.start - 2, stream.start) != \"](\" &&\n          (stream.start == 0 || /\\W/.test(stream.string.charAt(stream.start - 1)))) {\n        // URLs\n        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine\n        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL\n        state.combineTokens = true;\n        return \"link\";\n      }\n      stream.next();\n      return null;\n    },\n    blankLine: blankLine\n  };\n\n  var markdownConfig = {\n    underscoresBreakWords: false,\n    taskLists: true,\n    fencedCodeBlocks: '```',\n    strikethrough: true\n  };\n  for (var attr in modeConfig) {\n    markdownConfig[attr] = modeConfig[attr];\n  }\n  markdownConfig.name = \"markdown\";\n  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);\n\n}, \"markdown\");\n\n  CodeMirror.defineMIME(\"text/x-gfm\", \"gfm\");\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/gfm/gfm.js\n ** module id = 361\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../meta\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\n\n  var htmlFound = CodeMirror.modes.hasOwnProperty(\"xml\");\n  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: \"xml\", htmlMode: true} : \"text/plain\");\n\n  function getMode(name) {\n    if (CodeMirror.findModeByName) {\n      var found = CodeMirror.findModeByName(name);\n      if (found) name = found.mime || found.mimes[0];\n    }\n    var mode = CodeMirror.getMode(cmCfg, name);\n    return mode.name == \"null\" ? null : mode;\n  }\n\n  // Should characters that affect highlighting be highlighted separate?\n  // Does not include characters that will be output (such as `1.` and `-` for lists)\n  if (modeCfg.highlightFormatting === undefined)\n    modeCfg.highlightFormatting = false;\n\n  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\n  // Excess `>` will emit `error` token.\n  if (modeCfg.maxBlockquoteDepth === undefined)\n    modeCfg.maxBlockquoteDepth = 0;\n\n  // Should underscores in words open/close em/strong?\n  if (modeCfg.underscoresBreakWords === undefined)\n    modeCfg.underscoresBreakWords = true;\n\n  // Use `fencedCodeBlocks` to configure fenced code blocks. false to\n  // disable, string to specify a precise regexp that the fence should\n  // match, and true to allow three or more backticks or tildes (as\n  // per CommonMark).\n\n  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\n  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\n\n  // Turn on strikethrough syntax\n  if (modeCfg.strikethrough === undefined)\n    modeCfg.strikethrough = false;\n\n  // Allow token types to be overridden by user-provided token types.\n  if (modeCfg.tokenTypeOverrides === undefined)\n    modeCfg.tokenTypeOverrides = {};\n\n  var codeDepth = 0;\n\n  var tokenTypes = {\n    header: \"header\",\n    code: \"comment\",\n    quote: \"quote\",\n    list1: \"variable-2\",\n    list2: \"variable-3\",\n    list3: \"keyword\",\n    hr: \"hr\",\n    image: \"tag\",\n    formatting: \"formatting\",\n    linkInline: \"link\",\n    linkEmail: \"link\",\n    linkText: \"link\",\n    linkHref: \"string\",\n    em: \"em\",\n    strong: \"strong\",\n    strikethrough: \"strikethrough\"\n  };\n\n  for (var tokenType in tokenTypes) {\n    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\n      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\n    }\n  }\n\n  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\n  ,   ulRE = /^[*\\-+]\\s+/\n  ,   olRE = /^[0-9]+([.)])\\s+/\n  ,   taskListRE = /^\\[(x| )\\](?=\\s)/ // Must follow ulRE or olRE\n  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\n  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\n  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~]+/\n  ,   fencedCodeRE = new RegExp(\"^(\" + (modeCfg.fencedCodeBlocks === true ? \"~~~+|```+\" : modeCfg.fencedCodeBlocks) +\n                                \")[ \\\\t]*([\\\\w+#]*)\");\n\n  function switchInline(stream, state, f) {\n    state.f = state.inline = f;\n    return f(stream, state);\n  }\n\n  function switchBlock(stream, state, f) {\n    state.f = state.block = f;\n    return f(stream, state);\n  }\n\n  function lineIsEmpty(line) {\n    return !line || !/\\S/.test(line.string)\n  }\n\n  // Blocks\n\n  function blankLine(state) {\n    // Reset linkTitle state\n    state.linkTitle = false;\n    // Reset EM state\n    state.em = false;\n    // Reset STRONG state\n    state.strong = false;\n    // Reset strikethrough state\n    state.strikethrough = false;\n    // Reset state.quote\n    state.quote = 0;\n    // Reset state.indentedCode\n    state.indentedCode = false;\n    if (!htmlFound && state.f == htmlBlock) {\n      state.f = inlineNormal;\n      state.block = blockNormal;\n    }\n    // Reset state.trailingSpace\n    state.trailingSpace = 0;\n    state.trailingSpaceNewLine = false;\n    // Mark this line as blank\n    state.prevLine = state.thisLine\n    state.thisLine = null\n    return null;\n  }\n\n  function blockNormal(stream, state) {\n\n    var sol = stream.sol();\n\n    var prevLineIsList = state.list !== false,\n        prevLineIsIndentedCode = state.indentedCode;\n\n    state.indentedCode = false;\n\n    if (prevLineIsList) {\n      if (state.indentationDiff >= 0) { // Continued list\n        if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block\n          state.indentation -= state.indentationDiff;\n        }\n        state.list = null;\n      } else if (state.indentation > 0) {\n        state.list = null;\n        state.listDepth = Math.floor(state.indentation / 4);\n      } else { // No longer a list\n        state.list = false;\n        state.listDepth = 0;\n      }\n    }\n\n    var match = null;\n    if (state.indentationDiff >= 4) {\n      stream.skipToEnd();\n      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {\n        state.indentation -= 4;\n        state.indentedCode = true;\n        return tokenTypes.code;\n      } else {\n        return null;\n      }\n    } else if (stream.eatSpace()) {\n      return null;\n    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\n      state.header = match[1].length;\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      state.f = state.inline;\n      return getType(state);\n    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&\n               !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {\n      state.header = match[0].charAt(0) == '=' ? 1 : 2;\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      state.f = state.inline;\n      return getType(state);\n    } else if (stream.eat('>')) {\n      state.quote = sol ? 1 : state.quote + 1;\n      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\n      stream.eatSpace();\n      return getType(state);\n    } else if (stream.peek() === '[') {\n      return switchInline(stream, state, footnoteLink);\n    } else if (stream.match(hrRE, true)) {\n      state.hr = true;\n      return tokenTypes.hr;\n    } else if ((lineIsEmpty(state.prevLine) || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {\n      var listType = null;\n      if (stream.match(ulRE, true)) {\n        listType = 'ul';\n      } else {\n        stream.match(olRE, true);\n        listType = 'ol';\n      }\n      state.indentation = stream.column() + stream.current().length;\n      state.list = true;\n      state.listDepth++;\n      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\n        state.taskList = true;\n      }\n      state.f = state.inline;\n      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\n      return getType(state);\n    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {\n      state.fencedChars = match[1]\n      // try switching mode\n      state.localMode = getMode(match[2]);\n      if (state.localMode) state.localState = state.localMode.startState();\n      state.f = state.block = local;\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n      state.code = true;\n      return getType(state);\n    }\n\n    return switchInline(stream, state, state.inline);\n  }\n\n  function htmlBlock(stream, state) {\n    var style = htmlMode.token(stream, state.htmlState);\n    if ((htmlFound && state.htmlState.tagStart === null &&\n         (!state.htmlState.context && state.htmlState.tokenize.isInText)) ||\n        (state.md_inside && stream.current().indexOf(\">\") > -1)) {\n      state.f = inlineNormal;\n      state.block = blockNormal;\n      state.htmlState = null;\n    }\n    return style;\n  }\n\n  function local(stream, state) {\n    if (state.fencedChars && stream.match(state.fencedChars, false)) {\n      state.localMode = state.localState = null;\n      state.f = state.block = leavingLocal;\n      return null;\n    } else if (state.localMode) {\n      return state.localMode.token(stream, state.localState);\n    } else {\n      stream.skipToEnd();\n      return tokenTypes.code;\n    }\n  }\n\n  function leavingLocal(stream, state) {\n    stream.match(state.fencedChars);\n    state.block = blockNormal;\n    state.f = inlineNormal;\n    state.fencedChars = null;\n    if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n    state.code = true;\n    var returnType = getType(state);\n    state.code = false;\n    return returnType;\n  }\n\n  // Inline\n  function getType(state) {\n    var styles = [];\n\n    if (state.formatting) {\n      styles.push(tokenTypes.formatting);\n\n      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\n\n      for (var i = 0; i < state.formatting.length; i++) {\n        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\n\n        if (state.formatting[i] === \"header\") {\n          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\n        }\n\n        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\n        // Add `error` instead if the maximum blockquote nesting depth is passed\n        if (state.formatting[i] === \"quote\") {\n          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\n          } else {\n            styles.push(\"error\");\n          }\n        }\n      }\n    }\n\n    if (state.taskOpen) {\n      styles.push(\"meta\");\n      return styles.length ? styles.join(' ') : null;\n    }\n    if (state.taskClosed) {\n      styles.push(\"property\");\n      return styles.length ? styles.join(' ') : null;\n    }\n\n    if (state.linkHref) {\n      styles.push(tokenTypes.linkHref, \"url\");\n    } else { // Only apply inline styles to non-url text\n      if (state.strong) { styles.push(tokenTypes.strong); }\n      if (state.em) { styles.push(tokenTypes.em); }\n      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\n      if (state.linkText) { styles.push(tokenTypes.linkText); }\n      if (state.code) { styles.push(tokenTypes.code); }\n    }\n\n    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\n\n    if (state.quote) {\n      styles.push(tokenTypes.quote);\n\n      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\n      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n        styles.push(tokenTypes.quote + \"-\" + state.quote);\n      } else {\n        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\n      }\n    }\n\n    if (state.list !== false) {\n      var listMod = (state.listDepth - 1) % 3;\n      if (!listMod) {\n        styles.push(tokenTypes.list1);\n      } else if (listMod === 1) {\n        styles.push(tokenTypes.list2);\n      } else {\n        styles.push(tokenTypes.list3);\n      }\n    }\n\n    if (state.trailingSpaceNewLine) {\n      styles.push(\"trailing-space-new-line\");\n    } else if (state.trailingSpace) {\n      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\n    }\n\n    return styles.length ? styles.join(' ') : null;\n  }\n\n  function handleText(stream, state) {\n    if (stream.match(textRE, true)) {\n      return getType(state);\n    }\n    return undefined;\n  }\n\n  function inlineNormal(stream, state) {\n    var style = state.text(stream, state);\n    if (typeof style !== 'undefined')\n      return style;\n\n    if (state.list) { // List marker (*, +, -, 1., etc)\n      state.list = null;\n      return getType(state);\n    }\n\n    if (state.taskList) {\n      var taskOpen = stream.match(taskListRE, true)[1] !== \"x\";\n      if (taskOpen) state.taskOpen = true;\n      else state.taskClosed = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"task\";\n      state.taskList = false;\n      return getType(state);\n    }\n\n    state.taskOpen = false;\n    state.taskClosed = false;\n\n    if (state.header && stream.match(/^#+$/, true)) {\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      return getType(state);\n    }\n\n    // Get sol() value now, before character is consumed\n    var sol = stream.sol();\n\n    var ch = stream.next();\n\n    if (ch === '\\\\') {\n      stream.next();\n      if (modeCfg.highlightFormatting) {\n        var type = getType(state);\n        var formattingEscape = tokenTypes.formatting + \"-escape\";\n        return type ? type + \" \" + formattingEscape : formattingEscape;\n      }\n    }\n\n    // Matches link titles present on next line\n    if (state.linkTitle) {\n      state.linkTitle = false;\n      var matchCh = ch;\n      if (ch === '(') {\n        matchCh = ')';\n      }\n      matchCh = (matchCh+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\n      if (stream.match(new RegExp(regex), true)) {\n        return tokenTypes.linkHref;\n      }\n    }\n\n    // If this block is changed, it may need to be updated in GFM mode\n    if (ch === '`') {\n      var previousFormatting = state.formatting;\n      if (modeCfg.highlightFormatting) state.formatting = \"code\";\n      var t = getType(state);\n      var before = stream.pos;\n      stream.eatWhile('`');\n      var difference = 1 + stream.pos - before;\n      if (!state.code) {\n        codeDepth = difference;\n        state.code = true;\n        return getType(state);\n      } else {\n        if (difference === codeDepth) { // Must be exact\n          state.code = false;\n          return t;\n        }\n        state.formatting = previousFormatting;\n        return getType(state);\n      }\n    } else if (state.code) {\n      return getType(state);\n    }\n\n    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\n      stream.match(/\\[[^\\]]*\\]/);\n      state.inline = state.f = linkHref;\n      return tokenTypes.image;\n    }\n\n    if (ch === '[' && stream.match(/.*\\](\\(.*\\)| ?\\[.*\\])/, false)) {\n      state.linkText = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      return getType(state);\n    }\n\n    if (ch === ']' && state.linkText && stream.match(/\\(.*\\)| ?\\[.*\\]/, false)) {\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      state.linkText = false;\n      state.inline = state.f = linkHref;\n      return type;\n    }\n\n    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkEmail;\n    }\n\n    if (ch === '<' && stream.match(/^(!--|\\w)/, false)) {\n      var end = stream.string.indexOf(\">\", stream.pos);\n      if (end != -1) {\n        var atts = stream.string.substring(stream.start, end);\n        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\n      }\n      stream.backUp(1);\n      state.htmlState = CodeMirror.startState(htmlMode);\n      return switchBlock(stream, state, htmlBlock);\n    }\n\n    if (ch === '<' && stream.match(/^\\/\\w*?>/)) {\n      state.md_inside = false;\n      return \"tag\";\n    }\n\n    var ignoreUnderscore = false;\n    if (!modeCfg.underscoresBreakWords) {\n      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\\w)/, false)) {\n        var prevPos = stream.pos - 2;\n        if (prevPos >= 0) {\n          var prevCh = stream.string.charAt(prevPos);\n          if (prevCh !== '_' && prevCh.match(/(\\w)/, false)) {\n            ignoreUnderscore = true;\n          }\n        }\n      }\n    }\n    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {\n      if (sol && stream.peek() === ' ') {\n        // Do nothing, surrounded by newline and space\n      } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG\n        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n        var t = getType(state);\n        state.strong = false;\n        return t;\n      } else if (!state.strong && stream.eat(ch)) { // Add STRONG\n        state.strong = ch;\n        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n        return getType(state);\n      } else if (state.em === ch) { // Remove EM\n        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n        var t = getType(state);\n        state.em = false;\n        return t;\n      } else if (!state.em) { // Add EM\n        state.em = ch;\n        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n        return getType(state);\n      }\n    } else if (ch === ' ') {\n      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\n        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n          return getType(state);\n        } else { // Not surrounded by spaces, back up pointer\n          stream.backUp(1);\n        }\n      }\n    }\n\n    if (modeCfg.strikethrough) {\n      if (ch === '~' && stream.eatWhile(ch)) {\n        if (state.strikethrough) {// Remove strikethrough\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          var t = getType(state);\n          state.strikethrough = false;\n          return t;\n        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\n          state.strikethrough = true;\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          return getType(state);\n        }\n      } else if (ch === ' ') {\n        if (stream.match(/^~~/, true)) { // Probably surrounded by space\n          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n            return getType(state);\n          } else { // Not surrounded by spaces, back up pointer\n            stream.backUp(2);\n          }\n        }\n      }\n    }\n\n    if (ch === ' ') {\n      if (stream.match(/ +$/, false)) {\n        state.trailingSpace++;\n      } else if (state.trailingSpace) {\n        state.trailingSpaceNewLine = true;\n      }\n    }\n\n    return getType(state);\n  }\n\n  function linkInline(stream, state) {\n    var ch = stream.next();\n\n    if (ch === \">\") {\n      state.f = state.inline = inlineNormal;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    stream.match(/^[^>]+/, true);\n\n    return tokenTypes.linkInline;\n  }\n\n  function linkHref(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    var ch = stream.next();\n    if (ch === '(' || ch === '[') {\n      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\n      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n      state.linkHref = true;\n      return getType(state);\n    }\n    return 'error';\n  }\n\n  function getLinkHrefInside(endChar) {\n    return function(stream, state) {\n      var ch = stream.next();\n\n      if (ch === endChar) {\n        state.f = state.inline = inlineNormal;\n        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n        var returnState = getType(state);\n        state.linkHref = false;\n        return returnState;\n      }\n\n      if (stream.match(inlineRE(endChar), true)) {\n        stream.backUp(1);\n      }\n\n      state.linkHref = true;\n      return getType(state);\n    };\n  }\n\n  function footnoteLink(stream, state) {\n    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\n      state.f = footnoteLinkInside;\n      stream.next(); // Consume [\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      state.linkText = true;\n      return getType(state);\n    }\n    return switchInline(stream, state, inlineNormal);\n  }\n\n  function footnoteLinkInside(stream, state) {\n    if (stream.match(/^\\]:/, true)) {\n      state.f = state.inline = footnoteUrl;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var returnType = getType(state);\n      state.linkText = false;\n      return returnType;\n    }\n\n    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\n\n    return tokenTypes.linkText;\n  }\n\n  function footnoteUrl(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    // Match URL\n    stream.match(/^[^\\s]+/, true);\n    // Check for link title\n    if (stream.peek() === undefined) { // End of line, set flag to check next line\n      state.linkTitle = true;\n    } else { // More content on line, check if link title\n      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\n    }\n    state.f = state.inline = inlineNormal;\n    return tokenTypes.linkHref + \" url\";\n  }\n\n  var savedInlineRE = [];\n  function inlineRE(endChar) {\n    if (!savedInlineRE[endChar]) {\n      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)\n      endChar = (endChar+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n      // Match any non-endChar, escaped character, as well as the closing\n      // endChar.\n      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\\\\\]|\\\\\\\\.)*?(' + endChar + ')');\n    }\n    return savedInlineRE[endChar];\n  }\n\n  var mode = {\n    startState: function() {\n      return {\n        f: blockNormal,\n\n        prevLine: null,\n        thisLine: null,\n\n        block: blockNormal,\n        htmlState: null,\n        indentation: 0,\n\n        inline: inlineNormal,\n        text: handleText,\n\n        formatting: false,\n        linkText: false,\n        linkHref: false,\n        linkTitle: false,\n        em: false,\n        strong: false,\n        header: 0,\n        hr: false,\n        taskList: false,\n        list: false,\n        listDepth: 0,\n        quote: 0,\n        trailingSpace: 0,\n        trailingSpaceNewLine: false,\n        strikethrough: false,\n        fencedChars: null\n      };\n    },\n\n    copyState: function(s) {\n      return {\n        f: s.f,\n\n        prevLine: s.prevLine,\n        thisLine: s.thisLine,\n\n        block: s.block,\n        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\n        indentation: s.indentation,\n\n        localMode: s.localMode,\n        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\n\n        inline: s.inline,\n        text: s.text,\n        formatting: false,\n        linkTitle: s.linkTitle,\n        code: s.code,\n        em: s.em,\n        strong: s.strong,\n        strikethrough: s.strikethrough,\n        header: s.header,\n        hr: s.hr,\n        taskList: s.taskList,\n        list: s.list,\n        listDepth: s.listDepth,\n        quote: s.quote,\n        indentedCode: s.indentedCode,\n        trailingSpace: s.trailingSpace,\n        trailingSpaceNewLine: s.trailingSpaceNewLine,\n        md_inside: s.md_inside,\n        fencedChars: s.fencedChars\n      };\n    },\n\n    token: function(stream, state) {\n\n      // Reset state.formatting\n      state.formatting = false;\n\n      if (stream != state.thisLine) {\n        var forceBlankLine = state.header || state.hr;\n\n        // Reset state.header and state.hr\n        state.header = 0;\n        state.hr = false;\n\n        if (stream.match(/^\\s*$/, true) || forceBlankLine) {\n          blankLine(state);\n          if (!forceBlankLine) return null\n          state.prevLine = null\n        }\n\n        state.prevLine = state.thisLine\n        state.thisLine = stream\n\n        // Reset state.taskList\n        state.taskList = false;\n\n        // Reset state.trailingSpace\n        state.trailingSpace = 0;\n        state.trailingSpaceNewLine = false;\n\n        state.f = state.block;\n        var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, '    ').length;\n        var difference = Math.floor((indentation - state.indentation) / 4) * 4;\n        if (difference > 4) difference = 4;\n        var adjustedIndentation = state.indentation + difference;\n        state.indentationDiff = adjustedIndentation - state.indentation;\n        state.indentation = adjustedIndentation;\n        if (indentation > 0) return null;\n      }\n      return state.f(stream, state);\n    },\n\n    innerMode: function(state) {\n      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\n      if (state.localState) return {state: state.localState, mode: state.localMode};\n      return {state: state, mode: mode};\n    },\n\n    blankLine: blankLine,\n\n    getType: getType,\n\n    fold: \"markdown\"\n  };\n  return mode;\n}, \"xml\");\n\nCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/markdown/markdown.js\n ** module id = 362\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if (state.context && state.context.tagName == tagName) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/xml/xml.js\n ** module id = 363\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.modeInfo = [\n    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\n    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"pgp\"]},\n    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\n    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\n    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\n    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\"]},\n    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\n    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\n    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\n    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\"]},\n    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\n    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\n    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\n    {name: \"CoffeeScript\", mime: \"text/x-coffeescript\", mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\n    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\n    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\n    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\n    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\n    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\n    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\n    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\n    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\n    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\n    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\n    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\n    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\n    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\n    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\n    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\n    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\n    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\n    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\n    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\n    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\n    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\n    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\n    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\"]},\n    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\n    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\n    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\n    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\n    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\n    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\"]},\n    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\n    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\n    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\n    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\n    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\n    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\n    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\"], alias: [\"xhtml\"]},\n    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\n    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\n    {name: \"Jade\", mime: \"text/x-jade\", mode: \"jade\", ext: [\"jade\"]},\n    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\n    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\n    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\n     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\n    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\n    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\n    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\n    {name: \"Jinja2\", mime: \"null\", mode: \"jinja2\"},\n    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\n    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\n    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\n    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\n    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\n    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\n    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\n    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\n    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\n    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\n    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\"},\n    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\n    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\n    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\n    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\n    {name: \"NTriples\", mime: \"text/n-triples\", mode: \"ntriples\", ext: [\"nt\"]},\n    {name: \"Objective C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"]},\n    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\n    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\n    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\n    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\n    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\n    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\n    {name: \"PHP\", mime: \"application/x-httpd-php\", mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"phtml\"]},\n    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\n    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\n    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\n    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\n    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"py\", \"pyw\"]},\n    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\n    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\n    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\"], alias: [\"rscript\"]},\n    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\n    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\n    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\n    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\n    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\n    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\n    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\n    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\n    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\n    {name: \"Shell\", mime: \"text/x-sh\", mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\n    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\n    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\n    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\n    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\n    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\n    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\n    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\n    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\n    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\n    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\n    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\n    {name: \"MariaDB\", mime: \"text/x-mariadb\", mode: \"sql\"},\n    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\n    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\"], alias: [\"tex\"]},\n    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\"]},\n    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\n    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\n    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\n    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\n    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\n    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\n    {name: \"troff\", mime: \"troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\n    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\n    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\n    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\n    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\n    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\n    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\n    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\n    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\n    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\n    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\n    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\n    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\n    {name: \"YAML\", mime: \"text/x-yaml\", mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\n    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\n    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\n    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\n    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\n  ];\n  // Ensure all modes have a mime property for backwards compatibility\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n    var info = CodeMirror.modeInfo[i];\n    if (info.mimes) info.mime = info.mimes[0];\n  }\n\n  CodeMirror.findModeByMIME = function(mime) {\n    mime = mime.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.mime == mime) return info;\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\n        if (info.mimes[j] == mime) return info;\n    }\n  };\n\n  CodeMirror.findModeByExtension = function(ext) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.ext) for (var j = 0; j < info.ext.length; j++)\n        if (info.ext[j] == ext) return info;\n    }\n  };\n\n  CodeMirror.findModeByFileName = function(filename) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.file && info.file.test(filename)) return info;\n    }\n    var dot = filename.lastIndexOf(\".\");\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n    if (ext) return CodeMirror.findModeByExtension(ext);\n  };\n\n  CodeMirror.findModeByName = function(name) {\n    name = name.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.name.toLowerCase() == name) return info;\n      if (info.alias) for (var j = 0; j < info.alias.length; j++)\n        if (info.alias[j].toLowerCase() == name) return info;\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/meta.js\n ** module id = 364\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Utility function that allows modes to be combined. The mode given\n// as the base argument takes care of most of the normal mode\n// functionality, but a second (typically simple) mode is used, which\n// can override the style of text. Both modes get to parse all of the\n// text, but when both assign a non-null style to a piece of code, the\n// overlay wins, unless the combine argument was true and not overridden,\n// or state.overlay.combineTokens was true, in which case the styles are\n// combined.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.overlayMode = function(base, overlay, combine) {\n  return {\n    startState: function() {\n      return {\n        base: CodeMirror.startState(base),\n        overlay: CodeMirror.startState(overlay),\n        basePos: 0, baseCur: null,\n        overlayPos: 0, overlayCur: null,\n        streamSeen: null\n      };\n    },\n    copyState: function(state) {\n      return {\n        base: CodeMirror.copyState(base, state.base),\n        overlay: CodeMirror.copyState(overlay, state.overlay),\n        basePos: state.basePos, baseCur: null,\n        overlayPos: state.overlayPos, overlayCur: null\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream != state.streamSeen ||\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\n        state.streamSeen = stream;\n        state.basePos = state.overlayPos = stream.start;\n      }\n\n      if (stream.start == state.basePos) {\n        state.baseCur = base.token(stream, state.base);\n        state.basePos = stream.pos;\n      }\n      if (stream.start == state.overlayPos) {\n        stream.pos = stream.start;\n        state.overlayCur = overlay.token(stream, state.overlay);\n        state.overlayPos = stream.pos;\n      }\n      stream.pos = Math.min(state.basePos, state.overlayPos);\n\n      // state.overlay.combineTokens always takes precedence over combine,\n      // unless set to null\n      if (state.overlayCur == null) return state.baseCur;\n      else if (state.baseCur != null &&\n               state.overlay.combineTokens ||\n               combine && state.overlay.combineTokens == null)\n        return state.baseCur + \" \" + state.overlayCur;\n      else return state.overlayCur;\n    },\n\n    indent: base.indent && function(state, textAfter) {\n      return base.indent(state.base, textAfter);\n    },\n    electricChars: base.electricChars,\n\n    innerMode: function(state) { return {state: state.base, mode: base}; },\n\n    blankLine: function(state) {\n      if (base.blankLine) base.blankLine(state.base);\n      if (overlay.blankLine) overlay.blankLine(state.overlay);\n    }\n  };\n};\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/mode/overlay.js\n ** module id = 365\n ** module chunks = 29\n **/","var jade = require(\"/js/build/node_modules/jade/lib/runtime.js\");\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n;var locals_for_with = (locals || {});(function (bem, buttons) {\nbuf.push(\"\");\nvar bem_chain = [];\njade_mixins[\"b\"] = jade_interp = function(tag, isElement, noBlockClass){\nvar block = (this && this.block), attributes = (this && this.attributes) || {};\nbem.call(this, buf, bem_chain, tag, isElement, noBlockClass)\n};\n\n\n\n\n\n\n\n\n\njade_mixins[\"e\"] = jade_interp = function(tag){\nvar block = (this && this.block), attributes = (this && this.attributes) || {};\njade_mixins[\"b\"].call({\nblock: function(){\nblock && block();\n},\nattributes: jade.merge([attributes])\n}, tag, true);\n};\njade_mixins[\"b\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nblock: function(){\n// iterate buttons\n;(function(){\n  var $$obj = buttons;\n  if ('number' == typeof $$obj.length) {\n\n    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n      var button = $$obj[$index];\n\njade_mixins[\"e\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nattributes: {\"class\": \"button-icon\"}\n}, 'i');\n},\nattributes: {\"data-action\": (typeof (jade_interp = button.action) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"title\": jade.escape(button.title),\"class\": \"button\"}\n}, 'li');\n    }\n\n  } else {\n    var $$l = 0;\n    for (var $index in $$obj) {\n      $$l++;      var button = $$obj[$index];\n\njade_mixins[\"e\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nattributes: {\"class\": \"button-icon\"}\n}, 'i');\n},\nattributes: {\"data-action\": (typeof (jade_interp = button.action) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"title\": jade.escape(button.title),\"class\": \"button\"}\n}, 'li');\n    }\n\n  }\n}).call(this);\n\n},\nattributes: {\"class\": \"button-row\"}\n}, 'ul');\n},\nattributes: {\"class\": \"button-bar\"}\n});\njade_mixins[\"e\"].call({\nattributes: {\"class\": \"input\"}\n}, 'textarea');\njade_mixins[\"e\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nblock: function(){\nbuf.push(\"\");\n}\n}, 'h2');\n},\nattributes: {\"class\": \"title-preview\"}\n});\njade_mixins[\"e\"].call({\nattributes: {\"class\": \"preview\"}\n});\n},\nattributes: {\"class\": \"mdeditor\"}\n});}.call(this,\"bem\" in locals_for_with?locals_for_with.bem:typeof bem!==\"undefined\"?bem:undefined,\"buttons\" in locals_for_with?locals_for_with.buttons:typeof buttons!==\"undefined\"?buttons:undefined));;return buf.join(\"\");\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/templates/editor.jade\n ** module id = 366\n ** module chunks = 29\n **/","var map = {\n\t\"./en.yml\": 368,\n\t\"./ru.yml\": 369\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 367;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/locales ^\\.\\/.*\\.yml$\n ** module id = 367\n ** module chunks = 29\n **/","module.exports = {\n\t\"heading\": \"Heading\",\n\t\"bold\": \"bold text\",\n\t\"italic\": \"italic text\",\n\t\"code\": \"code\",\n\t\"code_multiline\": \"multiline code here\",\n\t\"ol_item\": \"List item\",\n\t\"ul_item\": \"List item\",\n\t\"alt\": \"Image desciption\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/locales/en.yml\n ** module id = 368\n ** module chunks = 29\n **/","module.exports = {\n\t\"heading\": \"\",\n\t\"bold\": \" \",\n\t\"italic\": \" \",\n\t\"code\": \"\",\n\t\"code_multiline\": \"  \",\n\t\"ol_item\": \" \",\n\t\"ul_item\": \" \",\n\t\"alt\": \" \"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/locales/ru.yml\n ** module id = 369\n ** module chunks = 29\n **/"],"sourceRoot":""}