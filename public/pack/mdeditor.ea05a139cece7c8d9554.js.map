{"version":3,"sources":["webpack:///mdeditor.ea05a139cece7c8d9554.js","webpack:///./modules/mdeditor/client/index.js","webpack:///./~/prismjs/components/prism-core.js?bce1","webpack:///./~/prismjs/components/prism-markup.js?74fe","webpack:///./~/prismjs/components/prism-css.js?fa60","webpack:///./~/prismjs/components/prism-css-extras.js?3ef4","webpack:///./~/prismjs/components/prism-clike.js?7b11","webpack:///./~/prismjs/components/prism-javascript.js?621b","webpack:///./~/prismjs/components/prism-coffeescript.js?161a","webpack:///./~/prismjs/components/prism-http.js?ee7a","webpack:///./~/prismjs/components/prism-scss.js?c3b0","webpack:///./~/prismjs/components/prism-sql.js?a48e","webpack:///./~/prismjs/components/prism-php.js?c6de","webpack:///./~/prismjs/components/prism-php-extras.js?1520","webpack:///./~/prismjs/components/prism-python.js?d569","webpack:///./~/prismjs/components/prism-ruby.js?73e3","webpack:///./~/prismjs/components/prism-java.js?ccac","webpack:///./~/jade/lib/runtime.js?12d0*","webpack:///./client/clientRender.js?5dc5*","webpack:///./modules/bem-jade.js?9eb7*","webpack:///./client/image.js?8da9*","webpack:///(webpack)/buildin/module.js","webpack:///./client/prism/index.js?d72b","webpack:///./client/prism/codeBox.js?3d71","webpack:///./client/isScrolledIntoView.js?0655","webpack:///./client/prism/addLineNumbers.js?870d","webpack:///./client/prism/codeTabsBox.js?623f","webpack:///./modules/markit/basicParser.js","webpack:///./client/config.js?7c1e*","webpack:///./~/markdown-it/index.js","webpack:///./~/markdown-it/lib/index.js","webpack:///./~/markdown-it/lib/common/utils.js","webpack:///./~/markdown-it/lib/common/entities.js","webpack:///./~/entities/maps/entities.json","webpack:///./~/uc.micro/categories/P/regex.js","webpack:///./~/mdurl/index.js","webpack:///./~/mdurl/encode.js","webpack:///./~/mdurl/decode.js","webpack:///./~/mdurl/format.js","webpack:///./~/mdurl/parse.js","webpack:///./~/uc.micro/index.js","webpack:///./~/uc.micro/properties/Any/regex.js","webpack:///./~/uc.micro/categories/Cc/regex.js","webpack:///./~/uc.micro/categories/Cf/regex.js","webpack:///./~/uc.micro/categories/Z/regex.js","webpack:///./~/markdown-it/lib/helpers/index.js","webpack:///./~/markdown-it/lib/helpers/parse_link_label.js","webpack:///./~/markdown-it/lib/helpers/parse_link_destination.js","webpack:///./~/markdown-it/lib/helpers/parse_link_title.js","webpack:///./~/markdown-it/lib/renderer.js","webpack:///./~/markdown-it/lib/parser_core.js","webpack:///./~/markdown-it/lib/ruler.js","webpack:///./~/markdown-it/lib/rules_core/normalize.js","webpack:///./~/markdown-it/lib/rules_core/block.js","webpack:///./~/markdown-it/lib/rules_core/inline.js","webpack:///./~/markdown-it/lib/rules_core/linkify.js","webpack:///./~/markdown-it/lib/rules_core/replacements.js","webpack:///./~/markdown-it/lib/rules_core/smartquotes.js","webpack:///./~/markdown-it/lib/rules_core/state_core.js","webpack:///./~/markdown-it/lib/token.js","webpack:///./~/markdown-it/lib/parser_block.js","webpack:///./~/markdown-it/lib/rules_block/table.js","webpack:///./~/markdown-it/lib/rules_block/code.js","webpack:///./~/markdown-it/lib/rules_block/fence.js","webpack:///./~/markdown-it/lib/rules_block/blockquote.js","webpack:///./~/markdown-it/lib/rules_block/hr.js","webpack:///./~/markdown-it/lib/rules_block/list.js","webpack:///./~/markdown-it/lib/rules_block/reference.js","webpack:///./~/markdown-it/lib/rules_block/heading.js","webpack:///./~/markdown-it/lib/rules_block/lheading.js","webpack:///./~/markdown-it/lib/rules_block/html_block.js","webpack:///./~/markdown-it/lib/common/html_blocks.js","webpack:///./~/markdown-it/lib/common/html_re.js","webpack:///./~/markdown-it/lib/rules_block/paragraph.js","webpack:///./~/markdown-it/lib/rules_block/state_block.js","webpack:///./~/markdown-it/lib/parser_inline.js","webpack:///./~/markdown-it/lib/rules_inline/text.js","webpack:///./~/markdown-it/lib/rules_inline/newline.js","webpack:///./~/markdown-it/lib/rules_inline/escape.js","webpack:///./~/markdown-it/lib/rules_inline/backticks.js","webpack:///./~/markdown-it/lib/rules_inline/strikethrough.js","webpack:///./~/markdown-it/lib/rules_inline/emphasis.js","webpack:///./~/markdown-it/lib/rules_inline/link.js","webpack:///./~/markdown-it/lib/rules_inline/image.js","webpack:///./~/markdown-it/lib/rules_inline/autolink.js","webpack:///./~/markdown-it/lib/rules_inline/html_inline.js","webpack:///./~/markdown-it/lib/rules_inline/entity.js","webpack:///./~/markdown-it/lib/rules_inline/balance_pairs.js","webpack:///./~/markdown-it/lib/rules_inline/text_collapse.js","webpack:///./~/markdown-it/lib/rules_inline/state_inline.js","webpack:///./~/linkify-it/index.js","webpack:///./~/linkify-it/lib/re.js","webpack:///./~/punycode/punycode.js","webpack:///./~/markdown-it/lib/presets/default.js","webpack:///./~/markdown-it/lib/presets/zero.js","webpack:///./~/markdown-it/lib/presets/commonmark.js","webpack:///./modules/markit/plugins/extendedCode.js","webpack:///./modules/markit/plugins/outlinedBlocks.js","webpack:///./~/markdown-it-container/index.js","webpack:///./modules/markit/utils/parseAttrs.js","webpack:///./modules/i18n/index.js?917f*","webpack:///./~/babelfish/index.js?4989*","webpack:///./~/babelfish/lib/babelfish.js?2a74*","webpack:///./~/babelfish/lib/parser.js?7712*","webpack:///./~/plurals-cldr/index.js?edd1*","webpack:///./modules/markit/locales/outlined ^\\.\\/.*\\.yml$","webpack:///./modules/markit/locales/outlined/en.yml","webpack:///./modules/markit/locales/outlined/ru.yml","webpack:///./modules/markit/plugins/sourceBlocks.js","webpack:///./modules/textUtil/stripIndents.js","webpack:///./modules/markit/utils/source/extractHighlight.js","webpack:///./modules/markit/getPrismLanguage.js","webpack:///./modules/markit/plugins/imgDescToAttrs.js","webpack:///./modules/markit/utils/token.js","webpack:///./modules/markit/plugins/markdownError.js","webpack:///./modules/markit/plugins/blockTags/plugin.js","webpack:///./~/markdown-it-deflist/index.js","webpack:///./modules/markit/plugins/charTypography.js","webpack:///./modules/markit/locales/code ^\\.\\/.*\\.yml$","webpack:///./modules/markit/locales/code/en.yml","webpack:///./modules/markit/locales/code/ru.yml","webpack:///./modules/mdeditor/client/mdeditor.js","webpack:///./~/codemirror/lib/codemirror.js","webpack:///./~/codemirror/mode/gfm/gfm.js","webpack:///./~/codemirror/mode/markdown/markdown.js","webpack:///./~/codemirror/mode/xml/xml.js","webpack:///./~/codemirror/mode/meta.js","webpack:///./~/codemirror/addon/mode/overlay.js","webpack:///./modules/mdeditor/templates/editor.jade","webpack:///./modules/mdeditor/locales ^\\.\\/.*\\.yml$","webpack:///./modules/mdeditor/locales/en.yml","webpack:///./modules/mdeditor/locales/ru.yml","webpack:///./~/lodash/throttle.js","webpack:///./~/lodash/debounce.js","webpack:///./~/lodash/isObject.js","webpack:///./~/lodash/now.js","webpack:///./~/lodash/toNumber.js","webpack:///./~/lodash/isFunction.js"],"names":["mdeditor","webpackJsonp_name_","module","exports","__webpack_require__","init","editorElems","document","querySelectorAll","i","length","editorElem","MdEditor","elem","_self","window","WorkerGlobalScope","self","Prism","lang","uniqueId","_","util","encode","tokens","Token","type","content","alias","map","replace","o","Object","prototype","toString","call","match","objId","obj","defineProperty","value","clone","key","hasOwnProperty","v","languages","extend","id","redef","insertBefore","inside","before","insert","root","grammar","arguments","newToken","ret","token","DFS","this","callback","visited","plugins","highlightAll","async","element","elements","highlightElement","language","parent","test","className","parentNode","nodeName","code","textContent","env","hooks","run","Worker","worker","filename","onmessage","evt","highlightedCode","data","innerHTML","postMessage","JSON","stringify","immediateClose","highlight","text","tokenize","strarr","rest","tokenloop","patterns","j","pattern","lookbehind","lookbehindLength","str","lastIndex","exec","from","index","slice","len","to","after","args","push","wrapped","Array","splice","apply","all","add","name","callbacks","join","tag","classes","attributes","aliases","addEventListener","message","parse","close","script","currentScript","getElementsByTagName","pop","src","hasAttribute","global","markup","comment","prolog","doctype","cdata","punctuation","namespace","attr-value","attr-name","entity","xml","html","mathml","svg","css","atrule","rule","url","selector","string","property","important","function","style","style-attr","pseudo-element","pseudo-class","class","hexcode","number","clike","class-name","keyword","boolean","operator","javascript","regex","template-string","interpolation","interpolation-punctuation","js","coffeescript","class-member","multiline-comment","block-regex","inline-javascript","delimiter","multiline-string","http","request-line","response-status","header-name","httpLanguages","application/json","application/xml","text/xml","text/html","contentType","options","RegExp","scss","placeholder","variable","statement","null","sql","php","constant","shell-comment","package","tokenStack","backupCode","t","scope","python","triple-quoted-string","ruby","symbol","builtin","java","nulls","val","joinClasses","isArray","keys","filter","jade_encode_char","c","jade_encode_html_rules","jade_escape","result","String","jade_match_html","merge","a","b","attrs","ac","bc","concat","cls","escaped","buf","escape","attr","terse","indexOf","toISOString","&","<",">","\"","rethrow","err","lineno","Error","readFileSync","ex","context","lines","split","start","Math","max","end","min","line","curr","path","DebugItem","addStandardHelpers","locals","bem","thumb","template","create","jade","settings","bem_tag","block","bem_chain","newTag","alt","title","href","prefix","modifier","isElement","bem_classes","bem_block","e","current_block","klass","sort","width","height","pixelRatio","devicePixelRatio","lastIndexOf","webpackPolyfill","deprecate","paths","children","initCodeBoxes","container","codeExampleElems","codeExampleElem","CodeBox","setAttribute","initCodeTabsBox","elems","CodeTabsBox","tokenTag","removeEventListener","postJSFrame","win","jsFrame","contentWindow","alert","runHTML","frame","htmlResult","remove","querySelector","createElement","random","getAttribute","display","appendChild","isTrusted","doc","contentDocument","open","write","normalizeHtml","ebookType","setTimeout","forEach","resizeOnload","iframe","isFirstRun","isScrolledIntoView","scrollIntoView","form","method","enctype","action","target","textarea","nextSibling","submit","onload","globalEval","head","removeChild","runJS","border","body","edit","isHTML","codeIndented","input","location","codeLc","toLowerCase","hasBodyStart","hasBodyEnd","hasHtmlStart","hasHtmlEnd","hasDocType","isJS","preElem","codeElem","addLineNumbers","addBlockHighlight","addInlineHighlight","classList","contains","isNoStrict","runElem","onclick","blur","editElem","pre","range","ranges","mask","insertAdjacentHTML","piece","lineNum","strRange","coords","getBoundingClientRect","visibleHeight","top","bottom","innerHeight","lineNumbersWrapper","linesNum","counterReset","dataset","translateX","switchesElem","switchesElemItems","firstElementChild","arrowLeft","arrowRight","preventDefault","offsetWidth","renderTranslate","bind","delegate","onSwitchClick","selectedIndex","siblings","delegateTarget","tabs","switchElem","tabElem","highlightTab","tab","highlighted","transform","removeAttribute","delegateMixin","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","LANG","MarkdownIt","charTypographyPlugin","extendedCodePlugin","outlinedBlocksPlugin","sourceBlocksPlugin","imgDescToAttrsPlugin","markdownErrorPlugin","blockTagsPlugin","deflistPlugin","getPrismLanguage","BasicParser","md","assign","typographer","blockTags","allSupported","linkHeaderTag","quotes","parseInline","renderer","render","validateLink","trim","BAD_PROTO_RE","GOOD_DATA_RE","normalizeLink","parsed","mdurl","hostname","protocol","RECODE_HOSTNAME_FOR","punycode","toASCII","er","format","normalizeLinkText","toUnicode","decode","presetName","utils","isString","inline","ParserInline","ParserBlock","core","ParserCore","Renderer","linkify","LinkifyIt","helpers","configure","set","config","default","zero","commonmark","presets","components","rules","ruler","enableOnly","rules2","ruler2","enable","list","ignoreInvalid","chain","missed","disable","use","plugin","state","State","process","inlineMode","renderInline","_class","has","object","_hasOwnProperty","sources","source","arrayReplaceAt","pos","newElements","isValidEntityCode","fromCodePoint","surrogate1","surrogate2","fromCharCode","replaceEntityPattern","entities","charCodeAt","DIGITAL_ENTITY_TEST_RE","parseInt","unescapeMd","UNESCAPE_MD_RE","unescapeAll","UNESCAPE_ALL_RE","replaceUnsafeChar","ch","HTML_REPLACEMENTS","escapeHtml","HTML_ESCAPE_TEST_RE","HTML_ESCAPE_REPLACE_RE","escapeRE","REGEXP_ESCAPE_RE","isSpace","isWhiteSpace","isPunctChar","UNICODE_PUNCT_RE","isMdAsciiPunct","normalizeReference","toUpperCase","ENTITY_RE","lib","ucmicro","Aacute","aacute","Abreve","abreve","acd","acE","Acirc","acirc","acute","Acy","acy","AElig","aelig","af","Afr","afr","Agrave","agrave","alefsym","aleph","Alpha","alpha","Amacr","amacr","amalg","amp","AMP","andand","And","and","andd","andslope","andv","ang","ange","angle","angmsdaa","angmsdab","angmsdac","angmsdad","angmsdae","angmsdaf","angmsdag","angmsdah","angmsd","angrt","angrtvb","angrtvbd","angsph","angst","angzarr","Aogon","aogon","Aopf","aopf","apacir","ap","apE","ape","apid","apos","ApplyFunction","approx","approxeq","Aring","aring","Ascr","ascr","Assign","ast","asymp","asympeq","Atilde","atilde","Auml","auml","awconint","awint","backcong","backepsilon","backprime","backsim","backsimeq","Backslash","Barv","barvee","barwed","Barwed","barwedge","bbrk","bbrktbrk","bcong","Bcy","bcy","bdquo","becaus","because","Because","bemptyv","bepsi","bernou","Bernoullis","Beta","beta","beth","between","Bfr","bfr","bigcap","bigcirc","bigcup","bigodot","bigoplus","bigotimes","bigsqcup","bigstar","bigtriangledown","bigtriangleup","biguplus","bigvee","bigwedge","bkarow","blacklozenge","blacksquare","blacktriangle","blacktriangledown","blacktriangleleft","blacktriangleright","blank","blk12","blk14","blk34","bne","bnequiv","bNot","bnot","Bopf","bopf","bot","bowtie","boxbox","boxdl","boxdL","boxDl","boxDL","boxdr","boxdR","boxDr","boxDR","boxh","boxH","boxhd","boxHd","boxhD","boxHD","boxhu","boxHu","boxhU","boxHU","boxminus","boxplus","boxtimes","boxul","boxuL","boxUl","boxUL","boxur","boxuR","boxUr","boxUR","boxv","boxV","boxvh","boxvH","boxVh","boxVH","boxvl","boxvL","boxVl","boxVL","boxvr","boxvR","boxVr","boxVR","bprime","breve","Breve","brvbar","bscr","Bscr","bsemi","bsim","bsime","bsolb","bsol","bsolhsub","bull","bullet","bump","bumpE","bumpe","Bumpeq","bumpeq","Cacute","cacute","capand","capbrcup","capcap","cap","Cap","capcup","capdot","CapitalDifferentialD","caps","caret","caron","Cayleys","ccaps","Ccaron","ccaron","Ccedil","ccedil","Ccirc","ccirc","Cconint","ccups","ccupssm","Cdot","cdot","cedil","Cedilla","cemptyv","cent","centerdot","CenterDot","cfr","Cfr","CHcy","chcy","check","checkmark","Chi","chi","circ","circeq","circlearrowleft","circlearrowright","circledast","circledcirc","circleddash","CircleDot","circledR","circledS","CircleMinus","CirclePlus","CircleTimes","cir","cirE","cire","cirfnint","cirmid","cirscir","ClockwiseContourIntegral","CloseCurlyDoubleQuote","CloseCurlyQuote","clubs","clubsuit","colon","Colon","Colone","colone","coloneq","comma","commat","comp","compfn","complement","complexes","cong","congdot","Congruent","conint","Conint","ContourIntegral","copf","Copf","coprod","Coproduct","copy","COPY","copysr","CounterClockwiseContourIntegral","crarr","cross","Cross","Cscr","cscr","csub","csube","csup","csupe","ctdot","cudarrl","cudarrr","cuepr","cuesc","cularr","cularrp","cupbrcap","cupcap","CupCap","cup","Cup","cupcup","cupdot","cupor","cups","curarr","curarrm","curlyeqprec","curlyeqsucc","curlyvee","curlywedge","curren","curvearrowleft","curvearrowright","cuvee","cuwed","cwconint","cwint","cylcty","dagger","Dagger","daleth","darr","Darr","dArr","dash","Dashv","dashv","dbkarow","dblac","Dcaron","dcaron","Dcy","dcy","ddagger","ddarr","DD","dd","DDotrahd","ddotseq","deg","Del","Delta","delta","demptyv","dfisht","Dfr","dfr","dHar","dharl","dharr","DiacriticalAcute","DiacriticalDot","DiacriticalDoubleAcute","DiacriticalGrave","DiacriticalTilde","diam","diamond","Diamond","diamondsuit","diams","die","DifferentialD","digamma","disin","div","divide","divideontimes","divonx","DJcy","djcy","dlcorn","dlcrop","dollar","Dopf","dopf","Dot","dot","DotDot","doteq","doteqdot","DotEqual","dotminus","dotplus","dotsquare","doublebarwedge","DoubleContourIntegral","DoubleDot","DoubleDownArrow","DoubleLeftArrow","DoubleLeftRightArrow","DoubleLeftTee","DoubleLongLeftArrow","DoubleLongLeftRightArrow","DoubleLongRightArrow","DoubleRightArrow","DoubleRightTee","DoubleUpArrow","DoubleUpDownArrow","DoubleVerticalBar","DownArrowBar","downarrow","DownArrow","Downarrow","DownArrowUpArrow","DownBreve","downdownarrows","downharpoonleft","downharpoonright","DownLeftRightVector","DownLeftTeeVector","DownLeftVectorBar","DownLeftVector","DownRightTeeVector","DownRightVectorBar","DownRightVector","DownTeeArrow","DownTee","drbkarow","drcorn","drcrop","Dscr","dscr","DScy","dscy","dsol","Dstrok","dstrok","dtdot","dtri","dtrif","duarr","duhar","dwangle","DZcy","dzcy","dzigrarr","Eacute","eacute","easter","Ecaron","ecaron","Ecirc","ecirc","ecir","ecolon","Ecy","ecy","eDDot","Edot","edot","eDot","ee","efDot","Efr","efr","eg","Egrave","egrave","egs","egsdot","el","Element","elinters","ell","els","elsdot","Emacr","emacr","empty","emptyset","EmptySmallSquare","emptyv","EmptyVerySmallSquare","emsp13","emsp14","emsp","ENG","eng","ensp","Eogon","eogon","Eopf","eopf","epar","eparsl","eplus","epsi","Epsilon","epsilon","epsiv","eqcirc","eqcolon","eqsim","eqslantgtr","eqslantless","Equal","equals","EqualTilde","equest","Equilibrium","equiv","equivDD","eqvparsl","erarr","erDot","escr","Escr","esdot","Esim","esim","Eta","eta","ETH","eth","Euml","euml","euro","excl","exist","Exists","expectation","exponentiale","ExponentialE","fallingdotseq","Fcy","fcy","female","ffilig","fflig","ffllig","Ffr","ffr","filig","FilledSmallSquare","FilledVerySmallSquare","fjlig","flat","fllig","fltns","fnof","Fopf","fopf","forall","ForAll","fork","forkv","Fouriertrf","fpartint","frac12","frac13","frac14","frac15","frac16","frac18","frac23","frac25","frac34","frac35","frac38","frac45","frac56","frac58","frac78","frasl","frown","fscr","Fscr","gacute","Gamma","gamma","Gammad","gammad","gap","Gbreve","gbreve","Gcedil","Gcirc","gcirc","Gcy","gcy","Gdot","gdot","ge","gE","gEl","gel","geq","geqq","geqslant","gescc","ges","gesdot","gesdoto","gesdotol","gesl","gesles","Gfr","gfr","gg","Gg","ggg","gimel","GJcy","gjcy","gla","gl","glE","glj","gnap","gnapprox","gne","gnE","gneq","gneqq","gnsim","Gopf","gopf","grave","GreaterEqual","GreaterEqualLess","GreaterFullEqual","GreaterGreater","GreaterLess","GreaterSlantEqual","GreaterTilde","Gscr","gscr","gsim","gsime","gsiml","gtcc","gtcir","gt","GT","Gt","gtdot","gtlPar","gtquest","gtrapprox","gtrarr","gtrdot","gtreqless","gtreqqless","gtrless","gtrsim","gvertneqq","gvnE","Hacek","hairsp","half","hamilt","HARDcy","hardcy","harrcir","harr","hArr","harrw","Hat","hbar","Hcirc","hcirc","hearts","heartsuit","hellip","hercon","hfr","Hfr","HilbertSpace","hksearow","hkswarow","hoarr","homtht","hookleftarrow","hookrightarrow","hopf","Hopf","horbar","HorizontalLine","hscr","Hscr","hslash","Hstrok","hstrok","HumpDownHump","HumpEqual","hybull","hyphen","Iacute","iacute","ic","Icirc","icirc","Icy","icy","Idot","IEcy","iecy","iexcl","iff","ifr","Ifr","Igrave","igrave","ii","iiiint","iiint","iinfin","iiota","IJlig","ijlig","Imacr","imacr","image","ImaginaryI","imagline","imagpart","imath","Im","imof","imped","Implies","incare","in","infin","infintie","inodot","intcal","int","Int","integers","Integral","intercal","Intersection","intlarhk","intprod","InvisibleComma","InvisibleTimes","IOcy","iocy","Iogon","iogon","Iopf","iopf","Iota","iota","iprod","iquest","iscr","Iscr","isin","isindot","isinE","isins","isinsv","isinv","it","Itilde","itilde","Iukcy","iukcy","Iuml","iuml","Jcirc","jcirc","Jcy","jcy","Jfr","jfr","jmath","Jopf","jopf","Jscr","jscr","Jsercy","jsercy","Jukcy","jukcy","Kappa","kappa","kappav","Kcedil","kcedil","Kcy","kcy","Kfr","kfr","kgreen","KHcy","khcy","KJcy","kjcy","Kopf","kopf","Kscr","kscr","lAarr","Lacute","lacute","laemptyv","lagran","Lambda","lambda","Lang","langd","langle","lap","Laplacetrf","laquo","larrb","larrbfs","larr","Larr","lArr","larrfs","larrhk","larrlp","larrpl","larrsim","larrtl","latail","lAtail","lat","late","lates","lbarr","lBarr","lbbrk","lbrace","lbrack","lbrke","lbrksld","lbrkslu","Lcaron","lcaron","Lcedil","lcedil","lceil","lcub","Lcy","lcy","ldca","ldquo","ldquor","ldrdhar","ldrushar","ldsh","le","lE","LeftAngleBracket","LeftArrowBar","leftarrow","LeftArrow","Leftarrow","LeftArrowRightArrow","leftarrowtail","LeftCeiling","LeftDoubleBracket","LeftDownTeeVector","LeftDownVectorBar","LeftDownVector","LeftFloor","leftharpoondown","leftharpoonup","leftleftarrows","leftrightarrow","LeftRightArrow","Leftrightarrow","leftrightarrows","leftrightharpoons","leftrightsquigarrow","LeftRightVector","LeftTeeArrow","LeftTee","LeftTeeVector","leftthreetimes","LeftTriangleBar","LeftTriangle","LeftTriangleEqual","LeftUpDownVector","LeftUpTeeVector","LeftUpVectorBar","LeftUpVector","LeftVectorBar","LeftVector","lEg","leg","leq","leqq","leqslant","lescc","les","lesdot","lesdoto","lesdotor","lesg","lesges","lessapprox","lessdot","lesseqgtr","lesseqqgtr","LessEqualGreater","LessFullEqual","LessGreater","lessgtr","LessLess","lesssim","LessSlantEqual","LessTilde","lfisht","lfloor","Lfr","lfr","lg","lgE","lHar","lhard","lharu","lharul","lhblk","LJcy","ljcy","llarr","ll","Ll","llcorner","Lleftarrow","llhard","lltri","Lmidot","lmidot","lmoustache","lmoust","lnap","lnapprox","lne","lnE","lneq","lneqq","lnsim","loang","loarr","lobrk","longleftarrow","LongLeftArrow","Longleftarrow","longleftrightarrow","LongLeftRightArrow","Longleftrightarrow","longmapsto","longrightarrow","LongRightArrow","Longrightarrow","looparrowleft","looparrowright","lopar","Lopf","lopf","loplus","lotimes","lowast","lowbar","LowerLeftArrow","LowerRightArrow","loz","lozenge","lozf","lpar","lparlt","lrarr","lrcorner","lrhar","lrhard","lrm","lrtri","lsaquo","lscr","Lscr","lsh","Lsh","lsim","lsime","lsimg","lsqb","lsquo","lsquor","Lstrok","lstrok","ltcc","ltcir","lt","LT","Lt","ltdot","lthree","ltimes","ltlarr","ltquest","ltri","ltrie","ltrif","ltrPar","lurdshar","luruhar","lvertneqq","lvnE","macr","male","malt","maltese","Map","mapsto","mapstodown","mapstoleft","mapstoup","marker","mcomma","Mcy","mcy","mdash","mDDot","measuredangle","MediumSpace","Mellintrf","Mfr","mfr","mho","micro","midast","midcir","mid","middot","minusb","minus","minusd","minusdu","MinusPlus","mlcp","mldr","mnplus","models","Mopf","mopf","mp","mscr","Mscr","mstpos","Mu","mu","multimap","mumap","nabla","Nacute","nacute","nang","nap","napE","napid","napos","napprox","natural","naturals","natur","nbsp","nbump","nbumpe","ncap","Ncaron","ncaron","Ncedil","ncedil","ncong","ncongdot","ncup","Ncy","ncy","ndash","nearhk","nearr","neArr","nearrow","ne","nedot","NegativeMediumSpace","NegativeThickSpace","NegativeThinSpace","NegativeVeryThinSpace","nequiv","nesear","nesim","NestedGreaterGreater","NestedLessLess","NewLine","nexist","nexists","Nfr","nfr","ngE","nge","ngeq","ngeqq","ngeqslant","nges","nGg","ngsim","nGt","ngt","ngtr","nGtv","nharr","nhArr","nhpar","ni","nis","nisd","niv","NJcy","njcy","nlarr","nlArr","nldr","nlE","nle","nleftarrow","nLeftarrow","nleftrightarrow","nLeftrightarrow","nleq","nleqq","nleqslant","nles","nless","nLl","nlsim","nLt","nlt","nltri","nltrie","nLtv","nmid","NoBreak","NonBreakingSpace","nopf","Nopf","Not","not","NotCongruent","NotCupCap","NotDoubleVerticalBar","NotElement","NotEqual","NotEqualTilde","NotExists","NotGreater","NotGreaterEqual","NotGreaterFullEqual","NotGreaterGreater","NotGreaterLess","NotGreaterSlantEqual","NotGreaterTilde","NotHumpDownHump","NotHumpEqual","notin","notindot","notinE","notinva","notinvb","notinvc","NotLeftTriangleBar","NotLeftTriangle","NotLeftTriangleEqual","NotLess","NotLessEqual","NotLessGreater","NotLessLess","NotLessSlantEqual","NotLessTilde","NotNestedGreaterGreater","NotNestedLessLess","notni","notniva","notnivb","notnivc","NotPrecedes","NotPrecedesEqual","NotPrecedesSlantEqual","NotReverseElement","NotRightTriangleBar","NotRightTriangle","NotRightTriangleEqual","NotSquareSubset","NotSquareSubsetEqual","NotSquareSuperset","NotSquareSupersetEqual","NotSubset","NotSubsetEqual","NotSucceeds","NotSucceedsEqual","NotSucceedsSlantEqual","NotSucceedsTilde","NotSuperset","NotSupersetEqual","NotTilde","NotTildeEqual","NotTildeFullEqual","NotTildeTilde","NotVerticalBar","nparallel","npar","nparsl","npart","npolint","npr","nprcue","nprec","npreceq","npre","nrarrc","nrarr","nrArr","nrarrw","nrightarrow","nRightarrow","nrtri","nrtrie","nsc","nsccue","nsce","Nscr","nscr","nshortmid","nshortparallel","nsim","nsime","nsimeq","nsmid","nspar","nsqsube","nsqsupe","nsub","nsubE","nsube","nsubset","nsubseteq","nsubseteqq","nsucc","nsucceq","nsup","nsupE","nsupe","nsupset","nsupseteq","nsupseteqq","ntgl","Ntilde","ntilde","ntlg","ntriangleleft","ntrianglelefteq","ntriangleright","ntrianglerighteq","Nu","nu","num","numero","numsp","nvap","nvdash","nvDash","nVdash","nVDash","nvge","nvgt","nvHarr","nvinfin","nvlArr","nvle","nvlt","nvltrie","nvrArr","nvrtrie","nvsim","nwarhk","nwarr","nwArr","nwarrow","nwnear","Oacute","oacute","oast","Ocirc","ocirc","ocir","Ocy","ocy","odash","Odblac","odblac","odiv","odot","odsold","OElig","oelig","ofcir","Ofr","ofr","ogon","Ograve","ograve","ogt","ohbar","ohm","oint","olarr","olcir","olcross","oline","olt","Omacr","omacr","Omega","omega","Omicron","omicron","omid","ominus","Oopf","oopf","opar","OpenCurlyDoubleQuote","OpenCurlyQuote","operp","oplus","orarr","Or","or","ord","order","orderof","ordf","ordm","origof","oror","orslope","orv","oS","Oscr","oscr","Oslash","oslash","osol","Otilde","otilde","otimesas","Otimes","otimes","Ouml","ouml","ovbar","OverBar","OverBrace","OverBracket","OverParenthesis","para","parallel","par","parsim","parsl","part","PartialD","Pcy","pcy","percnt","period","permil","perp","pertenk","Pfr","pfr","Phi","phi","phiv","phmmat","phone","Pi","pi","pitchfork","piv","planck","planckh","plankv","plusacir","plusb","pluscir","plus","plusdo","plusdu","pluse","PlusMinus","plusmn","plussim","plustwo","pm","Poincareplane","pointint","popf","Popf","pound","prap","Pr","pr","prcue","precapprox","prec","preccurlyeq","Precedes","PrecedesEqual","PrecedesSlantEqual","PrecedesTilde","preceq","precnapprox","precneqq","precnsim","prE","precsim","prime","Prime","primes","prnap","prnE","prnsim","prod","Product","profalar","profline","profsurf","prop","Proportional","Proportion","propto","prsim","prurel","Pscr","pscr","Psi","psi","puncsp","Qfr","qfr","qint","qopf","Qopf","qprime","Qscr","qscr","quaternions","quatint","quest","questeq","quot","QUOT","rAarr","race","Racute","racute","radic","raemptyv","rang","Rang","rangd","rangle","raquo","rarrap","rarrb","rarrbfs","rarrc","rarr","Rarr","rArr","rarrfs","rarrhk","rarrlp","rarrpl","rarrsim","Rarrtl","rarrtl","rarrw","ratail","rAtail","ratio","rationals","rbarr","rBarr","RBarr","rbbrk","rbrace","rbrack","rbrke","rbrksld","rbrkslu","Rcaron","rcaron","Rcedil","rcedil","rceil","rcub","Rcy","rcy","rdca","rdldhar","rdquo","rdquor","rdsh","real","realine","realpart","reals","Re","rect","reg","REG","ReverseElement","ReverseEquilibrium","ReverseUpEquilibrium","rfisht","rfloor","rfr","Rfr","rHar","rhard","rharu","rharul","Rho","rho","rhov","RightAngleBracket","RightArrowBar","rightarrow","RightArrow","Rightarrow","RightArrowLeftArrow","rightarrowtail","RightCeiling","RightDoubleBracket","RightDownTeeVector","RightDownVectorBar","RightDownVector","RightFloor","rightharpoondown","rightharpoonup","rightleftarrows","rightleftharpoons","rightrightarrows","rightsquigarrow","RightTeeArrow","RightTee","RightTeeVector","rightthreetimes","RightTriangleBar","RightTriangle","RightTriangleEqual","RightUpDownVector","RightUpTeeVector","RightUpVectorBar","RightUpVector","RightVectorBar","RightVector","ring","risingdotseq","rlarr","rlhar","rlm","rmoustache","rmoust","rnmid","roang","roarr","robrk","ropar","ropf","Ropf","roplus","rotimes","RoundImplies","rpar","rpargt","rppolint","rrarr","Rrightarrow","rsaquo","rscr","Rscr","rsh","Rsh","rsqb","rsquo","rsquor","rthree","rtimes","rtri","rtrie","rtrif","rtriltri","RuleDelayed","ruluhar","rx","Sacute","sacute","sbquo","scap","Scaron","scaron","Sc","sc","sccue","sce","scE","Scedil","scedil","Scirc","scirc","scnap","scnE","scnsim","scpolint","scsim","Scy","scy","sdotb","sdot","sdote","searhk","searr","seArr","searrow","sect","semi","seswar","setminus","setmn","sext","Sfr","sfr","sfrown","sharp","SHCHcy","shchcy","SHcy","shcy","ShortDownArrow","ShortLeftArrow","shortmid","shortparallel","ShortRightArrow","ShortUpArrow","shy","Sigma","sigma","sigmaf","sigmav","sim","simdot","sime","simeq","simg","simgE","siml","simlE","simne","simplus","simrarr","slarr","SmallCircle","smallsetminus","smashp","smeparsl","smid","smile","smt","smte","smtes","SOFTcy","softcy","solbar","solb","sol","Sopf","sopf","spades","spadesuit","spar","sqcap","sqcaps","sqcup","sqcups","Sqrt","sqsub","sqsube","sqsubset","sqsubseteq","sqsup","sqsupe","sqsupset","sqsupseteq","square","Square","SquareIntersection","SquareSubset","SquareSubsetEqual","SquareSuperset","SquareSupersetEqual","SquareUnion","squarf","squ","squf","srarr","Sscr","sscr","ssetmn","ssmile","sstarf","Star","star","starf","straightepsilon","straightphi","strns","sub","Sub","subdot","subE","sube","subedot","submult","subnE","subne","subplus","subrarr","subset","Subset","subseteq","subseteqq","SubsetEqual","subsetneq","subsetneqq","subsim","subsub","subsup","succapprox","succ","succcurlyeq","Succeeds","SucceedsEqual","SucceedsSlantEqual","SucceedsTilde","succeq","succnapprox","succneqq","succnsim","succsim","SuchThat","sum","Sum","sung","sup1","sup2","sup3","sup","Sup","supdot","supdsub","supE","supe","supedot","Superset","SupersetEqual","suphsol","suphsub","suplarr","supmult","supnE","supne","supplus","supset","Supset","supseteq","supseteqq","supsetneq","supsetneqq","supsim","supsub","supsup","swarhk","swarr","swArr","swarrow","swnwar","szlig","Tab","Tau","tau","tbrk","Tcaron","tcaron","Tcedil","tcedil","Tcy","tcy","tdot","telrec","Tfr","tfr","there4","therefore","Therefore","Theta","theta","thetasym","thetav","thickapprox","thicksim","ThickSpace","ThinSpace","thinsp","thkap","thksim","THORN","thorn","tilde","Tilde","TildeEqual","TildeFullEqual","TildeTilde","timesbar","timesb","times","timesd","tint","toea","topbot","topcir","Topf","topf","topfork","tosa","tprime","trade","TRADE","triangle","triangledown","triangleleft","trianglelefteq","triangleq","triangleright","trianglerighteq","tridot","trie","triminus","TripleDot","triplus","trisb","tritime","trpezium","Tscr","tscr","TScy","tscy","TSHcy","tshcy","Tstrok","tstrok","twixt","twoheadleftarrow","twoheadrightarrow","Uacute","uacute","uarr","Uarr","uArr","Uarrocir","Ubrcy","ubrcy","Ubreve","ubreve","Ucirc","ucirc","Ucy","ucy","udarr","Udblac","udblac","udhar","ufisht","Ufr","ufr","Ugrave","ugrave","uHar","uharl","uharr","uhblk","ulcorn","ulcorner","ulcrop","ultri","Umacr","umacr","uml","UnderBar","UnderBrace","UnderBracket","UnderParenthesis","Union","UnionPlus","Uogon","uogon","Uopf","uopf","UpArrowBar","uparrow","UpArrow","Uparrow","UpArrowDownArrow","updownarrow","UpDownArrow","Updownarrow","UpEquilibrium","upharpoonleft","upharpoonright","uplus","UpperLeftArrow","UpperRightArrow","upsi","Upsi","upsih","Upsilon","upsilon","UpTeeArrow","UpTee","upuparrows","urcorn","urcorner","urcrop","Uring","uring","urtri","Uscr","uscr","utdot","Utilde","utilde","utri","utrif","uuarr","Uuml","uuml","uwangle","vangrt","varepsilon","varkappa","varnothing","varphi","varpi","varpropto","varr","vArr","varrho","varsigma","varsubsetneq","varsubsetneqq","varsupsetneq","varsupsetneqq","vartheta","vartriangleleft","vartriangleright","vBar","Vbar","vBarv","Vcy","vcy","vdash","vDash","Vdash","VDash","Vdashl","veebar","vee","Vee","veeeq","vellip","verbar","Verbar","vert","Vert","VerticalBar","VerticalLine","VerticalSeparator","VerticalTilde","VeryThinSpace","Vfr","vfr","vltri","vnsub","vnsup","Vopf","vopf","vprop","vrtri","Vscr","vscr","vsubnE","vsubne","vsupnE","vsupne","Vvdash","vzigzag","Wcirc","wcirc","wedbar","wedge","Wedge","wedgeq","weierp","Wfr","wfr","Wopf","wopf","wp","wr","wreath","Wscr","wscr","xcap","xcirc","xcup","xdtri","Xfr","xfr","xharr","xhArr","Xi","xi","xlarr","xlArr","xmap","xnis","xodot","Xopf","xopf","xoplus","xotime","xrarr","xrArr","Xscr","xscr","xsqcup","xuplus","xutri","xvee","xwedge","Yacute","yacute","YAcy","yacy","Ycirc","ycirc","Ycy","ycy","yen","Yfr","yfr","YIcy","yicy","Yopf","yopf","Yscr","yscr","YUcy","yucy","yuml","Yuml","Zacute","zacute","Zcaron","zcaron","Zcy","zcy","Zdot","zdot","zeetrf","ZeroWidthSpace","Zeta","zeta","zfr","Zfr","ZHcy","zhcy","zigrarr","zopf","Zopf","Zscr","zscr","zwj","zwnj","getEncodeCache","exclude","cache","encodeCache","keepEscaped","l","nextCode","defaultChars","encodeURIComponent","componentChars","getDecodeCache","decodeCache","seq","b1","b2","b3","b4","chr","slashes","auth","port","pathname","search","hash","Url","urlParse","slashesDenoteHost","u","protocolPattern","portPattern","simplePathPattern","delims","unwise","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","hostlessProtocol","javascript:","slashedProtocol","https","ftp","gopher","file","http:","https:","ftp:","gopher:","file:","lowerProto","hec","simplePath","proto","substr","hostEnd","atSign","host","parseHost","ipv6Hostname","hostparts","newpart","k","validParts","notHost","bit","unshift","qm","Any","Cc","Cf","P","Z","parseLinkLabel","parseLinkDestination","parseLinkTitle","disableNested","level","found","prevPos","labelEnd","posMax","oldPos","skipToken","ok","default_rules","code_inline","idx","code_block","fence","slf","info","langName","attrJoin","langPrefix","renderAttrs","attrIndex","renderInlineAsText","renderToken","hardbreak","xhtmlOut","softbreak","breaks","html_block","html_inline","nextToken","needLf","hidden","nesting","Core","Ruler","_rules","getRules","__rules__","__cache__","__find__","__compile__","chains","enabled","altName","fn","at","opt","beforeName","ruleName","afterName","chainName","NEWLINES_RE","NULL_RE","tok","isLinkOpen","isLinkClose","currentToken","nodes","ln","lastPos","htmlLinkLevel","fullUrl","urlText","links","blockTokens","pretest","schema","replaceFn","SCOPED_ABBR","replace_scoped","inlineTokens","SCOPED_ABBR_RE","replace_rare","RARE_RE","SCOPED_ABBR_TEST_RE","r","p","tm","blkIdx","replaceAt","process_inlines","thisLevel","item","lastChar","nextChar","isLastPunctChar","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","canOpen","canClose","isSingle","stack","openQuote","closeQuote","OUTER","QUOTE_RE","single","APOSTROPHE","QUOTE_TEST_RE","StateCore","meta","attrPush","attrData","attrSet","startLine","endLine","hasEmptyLines","maxNesting","skipEmptyLines","sCount","blkIndent","tight","isEmpty","parentType","outTokens","lineMax","getLine","bMarks","eMarks","escapedSplit","escapes","backTicked","lastBackTick","substring","silent","lineText","nextLine","columns","columnCount","aligns","tableLines","tbodyLines","tShift","last","emptyLines","getLines","params","mem","haveEndMarker","skipChars","skipSpaces","lastLineEmpty","oldTShift","oldSCount","oldBMarks","oldIndent","oldParentType","initial","offset","terminatorRules","terminate","cnt","skipBulletListMarker","skipOrderedListMarker","markTightParagraphs","indent","oldLIndent","oldTight","posAfterMarker","indentAfterMarker","markerValue","markerCharCode","isOrdered","contentStart","listTokIdx","prevEmptyEnd","listLines","itemLines","_endLine","destEndPos","destEndLineNo","label","res","references","tmp","skipSpacesBack","skipCharsBack","block_names","HTML_OPEN_CLOSE_TAG_RE","HTML_SEQUENCES","attr_name","unquoted","single_quoted","double_quoted","attr_value","attribute","open_tag","close_tag","processing","declaration","HTML_TAG_RE","StateBlock","s","indent_found","ddIndent","begin","keepLastLF","lineIndent","first","queue","lineStart","_rules2","postProcess","pending","pushPending","isTerminatorChar","pmax","ESCAPED","matchStart","matchEnd","scanned","scanDelims","delimiters","jump","can_open","can_close","startDelim","endDelim","loneMarkers","isStrong","labelStart","ref","EMAIL_RE","AUTOLINK_RE","tail","linkMatch","emailMatch","isLetter","lc","DIGITAL_RE","NAMED_RE","lastDelim","currDelim","StateInline","pendingLevel","canSplitWord","count","left_flanking","right_flanking","isObject","isRegExp","isFunction","isOptionsObj","reduce","acc","defaultOptions","resetScanCache","__index__","__text_cache__","createValidator","re","createNormalizer","normalize","compile","untpl","tpl","src_tlds","schemaError","tlds","__tlds__","__tlds_replaced__","tlds_2ch_src_re","src_xn","email_fuzzy","tpl_email_fuzzy","link_fuzzy","tpl_link_fuzzy","link_no_ip_fuzzy","tpl_link_no_ip_fuzzy","host_fuzzy_test","tpl_host_fuzzy_test","__compiled__","__schemas__","compiled","validate","link","slist","schema_test","src_ZPCc","schema_search","Match","shift","__last_index__","__schema__","raw","createMatch","schemas","__opts__","defaultSchemas","tlds_default","fuzzyLink","fuzzyEmail","fuzzyIP","src_auth","src_host_port_strict","src_path","//","no_http","mailto:","mailto","src_email_name","src_host_strict","definition","m","ml","me","next","tld_pos","at_pos","testSchemaAt","keepOld","arr","reverse","src_Any","src_Cc","src_Z","src_P","src_ZCc","src_pseudo_letter","src_pseudo_letter_non_d","src_ip4","src_port","src_host_terminator","src_domain_root","src_domain","src_host","tpl_host_fuzzy","tpl_host_no_ip_fuzzy","tpl_host_fuzzy_strict","tpl_host_port_fuzzy_strict","tpl_host_port_no_ip_fuzzy_strict","__WEBPACK_AMD_DEFINE_RESULT__","error","RangeError","errors","array","mapDomain","parts","regexSeparators","labels","encoded","ucs2decode","extra","output","counter","ucs2encode","stringFromCharCode","basicToDigit","codePoint","base","digitToBasic","digit","flag","adapt","numPoints","firstTime","floor","damp","baseMinusTMin","tMax","skew","out","basic","oldi","w","baseMinusT","inputLength","n","initialN","bias","initialBias","maxInt","tMin","handledCPCount","basicLength","q","currentValue","handledCPCountPlusOne","qMinusT","regexPunycode","regexNonASCII","freeGlobal","nodeType","overflow","not-basic","invalid-input","version","ucs2","undefined","renderKey","results","plusLabel","codePrefixes","startsWith","markdownItContainer","parseAttrs","requirePhrase","header","validateDefault","renderDefault","_options","marker_count","old_parent","old_line_max","auto_closed","marker_char","marker_str","marker_len","min_markers","attrsReg","withBlockName","attrsObject","blockName","i18n","BabelFish","docs","packageName","addPhrase","isNumber","isNaN","isFinite","isBoolean","iterator","nativeForEach","f","formatRegExp","x","flatten","sub_val","sub_key","makePhraseKey","locale","phrase","keySeparator","searchPhraseKey","storage","_storage","_defaultLocale","fb_cache","_fallbacks_cache","fb_key","fb","_fallbacks","pluralizer","forms","plural","defaultLocale","GENERIC_LOCALE","_plurals_cache","strict_exec","forms_exec","plurals_cache","CAN_HAVE_DIRECTIVES_RE","parser","node","anchor","strict","hasPhrase","unescaped","Function","translation","flattenLevel","fl","Infinity","setFallback","fallbacks","def","translate","noFallback","getLocale","unique","fallback","locales","load","phrases","peg$subclass","child","ctor","constructor","SyntaxError","expected","column","peg$reportedPos","peg$currPos","peg$computePosDetails","advance","details","startPos","endPos","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$maxFailExpected","peg$buildException","cleanupExpected","description","buildMessage","stringEscape","hex","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","s1","peg$parseliteral","peg$FAILED","peg$parseplural","peg$parsevariable","s2","s3","s4","peg$c2","peg$silentFails","peg$c3","peg$parseplural_forms","peg$c4","peg$c5","peg$parseplural_anchor","peg$c6","peg$c7","peg$c1","peg$parseplural_part","peg$c8","peg$c9","peg$c10","peg$c11","s5","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$parseplural_char","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$parseidentifier","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$parseidentifier_part","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$parseliteral_char","peg$c43","peg$c44","peg$c45","peg$c46","regularForms","strictForms","peg$result","peg$startRuleFunctions","peg$startRuleFunction","more","char","literal_chars","startRule","loc","cFn","sval","o_forms","o_indexOf","oFn","ordinal","unpack","FORMS","B","y","IN","n100","i10","i100","i1000","n10","n1000000","f10","f100","webpackContext","req","webpackContextResolve","./en.yml","./ru.yml","resolve","smart","warn","ponder","rewriteFenceToSource","langOrExt","blockTagAttrs","stripIndents","extractHighlight","blocktag_source","prismLanguage","untrusted","autorun","refresh","demo","toolbarHtml","codeResultHtml","stripFirstEmptyLines","rtrim","rtrimLines","stripSpaceIndent","stripPattern","indentLen","stripTabIndent","deTab","wholeMatch","m1","leadingText","numSpaces","newText","fromPos","toPos","ext2language","coffee","","readImgAttrs","processImg","imgToken","lastTextToken","_name","tokenUtils","attrReplace","inlineToken","addClass","classAttr","attrGet","attrDel","markdown_error_block","markdown_error_inline","rewriteInlineToBlockTags","blockTagMatch","tokenType","blockTagToken","skipMarker","deflist","ddLine","dtLine","oldDDIndent","charTypography","doReplacementsInToken","scheme","show","sandbox","CodeMirror","prism","throttle","clientRender","buttonSets","standard","_this","buttonSet","actionName","codemirror","focus","onResizeMouseDown","onResizeMouseMove","onResizeMouseUp","renderPreviewThrottled","renderPreview","highlightInPreviewThrottled","highlightInPreview","fromTextArea","tabSize","mode","setOption","Ctrl-B","actionBold","Ctrl-I","actionItalic","Cmd-B","Cmd-I","on","replaceSelection","redo","undo","hadSelection","getSelection","cursorPos","getCursor","setCursor","setSelection","selection","substitution","defaultText","defaultTextUsed","textArea","buttons","nextElementSibling","templateArea","getWrapperElement","clientY","setSize","getValue","rendered","mod","place","copyObj","defaults","setGuttersForLineNumbers","Doc","lineSeparator","inputStyles","inputStyle","Display","wrapper","updateGutters","themeChanged","lineWrapping","autofocus","mobile","initScrollbars","keyMaps","overlays","modeGen","overwrite","delayingBlurEvent","focused","suppressEdits","pasteIncoming","cutIncoming","selectingText","draggingText","Delayed","keySeq","specialChars","cm","ie","ie_version","reset","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","forceUpdate","attachDoc","hasFocus","onFocus","onBlur","optionHandlers","Init","maybeUpdateLineNumberWidth","finishInit","initHooks","endOperation","webkit","getComputedStyle","lineDiv","textRendering","d","scrollbarFiller","elt","gutterFiller","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","zIndex","paddingRight","gecko","draggable","viewFrom","viewTo","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","selForContextMenu","activeTouch","loadMode","getMode","modeOption","resetModeState","iter","stateAfter","styles","frontier","startWorker","regChange","wrappingChanged","minWidth","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","textHeight","wrapping","perLine","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","ceil","est","estHeight","updateLineHeight","theme","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","updateGutterSpace","marginLeft","lineLength","merged","cur","collapsedSpanAtStart","find","collapsedSpanAtEnd","lineNumbers","measureForScrollbars","gutterW","docH","round","paddingVert","clientHeight","viewHeight","scrollWidth","viewWidth","barLeft","fixedGutter","docHeight","scrollHeight","scrollGap","gutterWidth","NativeScrollbars","scroll","horiz","scrollTop","scrollLeft","checkedZeroWidth","minHeight","NullScrollbars","scrollbars","clear","scrollbarModel","scrollbarStyle","axis","setScrollLeft","setScrollTop","startWidth","startHeight","updateScrollbarsInner","updateHeightsInViewport","sizes","update","right","paddingBottom","coverGutterNextToScrollbar","visibleLines","viewport","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","lastLine","firstChild","compensateForHScroll","left","gutter","align","alignable","lineNumberFor","size","innerW","padding","lineNumberFormatter","firstLineNumber","DisplayUpdate","force","visible","editorIsHidden","wrapperHeight","wrapperWidth","oldDisplayWidth","displayWidth","dims","getDimensions","events","maybeClipScrollbars","marginBottom","borderRightWidth","updateDisplayIfNeeded","resetView","countDirtyView","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","activeElt","patchDisplay","offsetHeight","postUpdateDisplay","displayHeight","barMeasure","updateSelection","setDocumentHeight","signal","updateDisplaySimple","finish","total","prevBottom","offsetTop","box","diff","updateWidgetHeight","gutterLeft","clientLeft","offsetLeft","fixedPos","gutterTotalWidth","updateNumbersFrom","rm","mac","currentWheelTarget","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","createTextNode","buildLineElement","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","bgClass","background","wrap","getLineContent","ext","built","buildLineContent","textClass","wrapClass","gutterBackground","markers","gutterMarkers","gutterWrap","setUneditable","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","positionLineWidget","above","signalLater","noHScroll","coverGutter","paddingLeft","position","copyPos","Pos","maxPos","cmp","minPos","ensureFocus","applyTextInput","inserted","deleted","sel","origin","paste","textLines","splitLines","multiPaste","lastCopied","lst","updateInput","changeEvent","makeChange","triggerElectric","ensureCursorVisible","typing","handlePaste","pasted","clipboardData","getData","isReadOnly","disableInput","runInOp","electricChars","smartIndent","getModeAt","indented","indentLine","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","TextareaInput","prevInput","pollingFast","polling","inaccurateSelection","hasSelection","composing","hiddenTextarea","te","ios","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","gracePeriod","posToDOM","findViewForLine","mapFromLineView","getOrder","side","partPos","getBidiPartAt","nodeAndOffsetInLineMap","collapse","badPos","bad","domToPos","lineNode","childNodes","clipPos","locateNodeInLineView","textNode","topNode","maps","curNode","lineNo","nodeValue","dist","previousSibling","domTextBetween","fromLine","toLine","recognizeMarker","walk","cmText","markerID","findMarks","getBetween","lineSep","closing","Selection","primIndex","Range","normalizeSelection","prim","prev","inv","simpleSelection","clipLine","clipToLen","linelen","isLine","clipPosArray","extendRange","other","posBefore","extendSelection","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","done","history","setSelectionNoUndo","addSelectionToHistory","NaN","hasHandler","setSelectionInner","skipAtomicInSelection","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","old","newAnchor","skipAtomic","newHead","skipAtomicInner","dir","markedSpans","sp","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","near","movePos","far","cantEdit","showSelection","prepareSelection","curFragment","cursors","createDocumentFragment","selFragment","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","cursorCoords","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","fragment","rightSide","drawForLine","fromArg","toArg","charCoords","lineObj","lineLen","iterateBidiSections","rightPos","leftPos","leftSide","paddingH","sFrom","sTo","singleVLine","visualLine","leftEnd","rightStart","restartBlink","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","time","startState","highlightWorker","Date","workTime","copyState","getStateBefore","changedLines","oldStyles","tooLong","maxHighlightLength","highlightLine","oldCls","styleClasses","newCls","ischange","processLine","workDelay","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","countColumn","save","removeChildrenAndAdd","currentStyle","ensureLineHeights","curWidth","heights","rects","getClientRects","abs","caches","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewIndex","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","mStart","mEnd","insertLeft","coverStart","coverEnd","isExtendingChar","nullRect","maybeUpdateRectForZooming","rSpan","rbot","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageXOffset","documentElement","pageScrollY","pageYOffset","intoCoordSystem","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","get","getBidi","bidiLeft","bidiRight","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","step","middle","middleX","measureText","viewChanged","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","preparedSelection","forceScroll","scrollPosIntoView","margin","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","operation","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","cutTop","cutBot","oldN","newN","dirty","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","dx","dy","onMouseDown","signalDOMEvent","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","word","findWordAt","captureRightClick","onContextMenu","clearTimeout","now","moved","pageX","pageY","onScrollWheel","dragFunctions","enter","e_stop","over","onDragOver","onDragStart","drop","onDrop","leave","clearDragCursor","inp","getField","onKeyUp","onKeyDown","onKeyPress","dragDropChanged","wasOn","funcs","toggle","off","onResize","e_target","liberal","forRect","space","clientX","colDiff","supportsTouch","shiftKey","e_button","leftButtonDown","lastMiddleDown","delayBlurEvent","lastDoubleClick","lastClick","contained","metaKey","ctrlKey","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","startTime","dragEnd","e2","addNew","extendTo","startCol","posCol","findColumn","startSel","ourIndex","oldRange","ourRange","sel_mouse","curCount","editorSize","move","up","lastSelOrigin","altKey","gutterEvent","prevent","mX","mY","lineBox","e_defaultPrevented","g","lastDrop","files","dataTransfer","FileReader","File","read","loadFile","allowDropFileTypes","reader","change","changeEnd","readAsText","selected","listSelections","replaceRange","setData","setDragImage","safari","img","presto","_top","frag","dragCursor","isScroller","wheelEventDelta","canScrollX","canScrollY","outer","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","commands","ensurePolled","prevShift","Pass","lookupKeyForEditor","handle","lookupKey","extraKeys","keyMap","dispatchKey","isModifierKey","stopSeq","handleKeyBinding","keyName","motion","handleCharBinding","keyCode","returnValue","handled","lastStoppedKey","hasCopyEvent","showCrossHair","charCode","which","readOnly","receivedFocus","contextMenuInGutter","adjustForChange","computeSelAfterChange","offsetPos","nw","computeReplacedSel","hint","oldPrev","newPrev","filterChange","canceled","cancel","ignoreReadOnly","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","event","hist","undone","dest","lastOrigin","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","historyChangeFromChange","mergeOldSpans","shiftDoc","distance","spans","removed","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","full","isWholeLineUpdate","changesHandler","changeHandler","doScroll","phantom","scrollNode","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","cursorScrollMargin","sPos","scrollTo","how","aggressive","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","spaceStr","changeLine","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","unit","visually","findNextLine","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","option","deflt","notOnInit","normalizeKeyName","ctrl","cmd","getKeyMap","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clearHistory","nextMarkerId","startStyle","endStyle","cloneNode","linked","isParent","SharedTextMarker","findSharedMarkers","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","span","removeMarkedSpan","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","clearEmptySpans","newMarkers","gapMarkers","getOldSpans","stretched","oldCur","stretchCur","mark","mk","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","callBlankLine","blankLine","inner","readToken","stream","takeToken","asArray","getObj","current","StringStream","eol","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","addModeClass","mName","st","overlay","i_end","opaque","getLineStyles","updateFrontier","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","col","splitSpaces","getOption","addToken","buildToken","hasBadBidiRects","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","zeroWidthElement","lastChild","defaultSpecialCharPlaceholder","displayText","special","mustWrap","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","buildCollapsedSpan","ignoreWidget","needsContentAttribute","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","endStyles","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","added","LeafChunk","BranchChunk","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","sz","h","lh","bidiOrdering","History","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","somethingSelected","existing","removeClearedSpans","copyHistoryArray","newGroup","instantiateSel","deepCopy","newChanges","rebaseHistSelSingle","rebaseHistArray","copied","defaultPrevented","srcElement","button","getHandlers","emitter","_handlers","noHandlers","bnd","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","spaceStrs","nothing","createObj","inst","isWordCharBasic","extendingChars","cssText","activeElement","classTest","as","forEachCodeMirror","getElementsByClassName","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","zwspSupported","badBidiRects","r0","r1","badZoomedRects","normal","fromRange","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","userAgent","navigator","platform","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","mac_geMountainLion","windows","presto_version","flipCtrlCmd","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","delay","maybeDisable","elementFromPoint","native","cmpPos","prepareCopyCut","getSelections","selectInput","lineWiseCopyCut","setSelections","poll","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","resetPosition","slowPoll","pollInterval","execCommand","same","prepareSelectAllHack","selectionStart","extval","selectionEnd","rehide","oldCSS","selectAll","detectingSelectAll","resetSelectionOnContextMenu","oldScrollY","scrollY","mouseup","readOnlyChanged","onCopyCut","clearData","kludge","hadFocus","startData","ours","applyComposition","forceCompositionEnd","pollContent","showPrimarySelection","showMultipleSelections","curAnchor","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","rangeCount","getRangeAt","rng","addRange","removeAllRanges","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","pollSelection","fromIndex","fromNode","toIndex","toNode","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","contenteditable","here","there","wheelDeltaX","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","help","helperType","_global","pred","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","lineInfo","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","toggleOverwrite","getScrollInfo","interpret","oldHeight","swapDoc","getInputField","getScrollerElement","getGutterElement","setValue","newBreaks","detach","attach","integer","disabled","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","skipToEnd","extendMode","properties","defineExtension","func","defineDocExtension","defineOption","defineInitHook","registerHelper","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","emacsy","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","normalizeKeyMap","keymap","keyname","keyNames","noShift","altGraphKey","tabindex","leaveSubmitMethodAlone","realSubmit","wrappedSubmit","getTextArea","toTextArea","lastColumnPos","lastColumnValue","peek","eat","eatWhile","eatSpace","skipTo","backUp","consume","caseInsensitive","cased","hideFirstChars","withOp","dHeight","oldH","removeInner","insertInner","iterN","spilled","newleaf","maybeSpill","sibling","myIndex","used","nextDocId","cleanGeneration","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","indexFromPos","copyHistory","linkedDoc","unlinkDoc","splitIds","iterLinkedDocs","getEditor","splitLinesAuto","eachLine","dontDelegate","e_stopPropagation","stopPropagation","cancelBubble","attachEvent","detachEvent","handlers","ms","startIndex","startValue","nextTab","goal","select","_e","nonASCIISingleCaseWordChar","createRange","endNode","setEnd","setStart","createTextRange","moveToElementText","moveEnd","moveStart","nl","rt","ownerDocument","parentElement","compareEndPoints","oncopy",3,8,9,13,16,17,18,19,20,27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,106,107,109,110,111,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","countsAsLeft","countsAsNum","outerType","types","nstart","urlRE","modeConfig","codeDepth","gfmOverlay","codeBlock","ateSpace","combineTokens","difference","gitHubSpice","markdownConfig","underscoresBreakWords","taskLists","fencedCodeBlocks","strikethrough","overlayMode","cmCfg","modeCfg","findModeByName","mimes","switchInline","switchBlock","lineIsEmpty","linkTitle","em","strong","quote","indentedCode","htmlFound","htmlBlock","inlineNormal","blockNormal","trailingSpace","trailingSpaceNewLine","prevLine","thisLine","prevLineIsList","prevLineIsIndentedCode","indentationDiff","listDepth","tokenTypes","atxHeaderRE","highlightFormatting","formatting","getType","setextHeaderRE","footnoteLink","hrRE","hr","ulRE","olRE","listType","taskListRE","taskList","fencedCodeRE","fencedChars","localMode","localState","local","htmlMode","htmlState","tagStart","isInText","md_inside","leavingLocal","returnType","maxBlockquoteDepth","taskOpen","taskClosed","linkHref","linkText","listMod","list2","list3","list1","handleText","textRE","formattingEscape","matchCh","previousFormatting","linkInline","linkEmail","atts","ignoreUnderscore","prevCh","getLinkHrefInside","endChar","returnState","inlineRE","footnoteLinkInside","footnoteUrl","savedInlineRE","tokenTypeOverrides","allowAtxHeaderWithoutSpace","forceBlankLine","adjustedIndentation","fold","htmlConfig","autoSelfClosers","area","br","command","embed","keygen","param","track","wbr","menuitem","implicitlyClosed","li","optgroup","rp","tbody","td","tfoot","tr","contextGrabbers","dt","address","article","aside","blockquote","dl","fieldset","footer","h1","h2","h3","h4","h5","h6","hgroup","menu","nav","ol","section","table","ul","thead","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","editorConf","config_","inText","inBlock","inTag","baseState","tagName","inAttribute","stringStartCol","closure","isInAttribute","terminator","depth","Context","startOfLine","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","setStyle","attrState","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","baseIndent","textAfter","fullLine","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","grabbers","blockCommentStart","blockCommentEnd","configuration","skipAttribute","modeInfo","findModeByMIME","findModeByExtension","findModeByFileName","combine","basePos","baseCur","overlayPos","overlayCur","streamSeen","jade_interp","jade_mixins","locals_for_with","noBlockClass","$$obj","$index","$$l","tooltip","data-action","data-tooltip","data-mdeditor-resize","data-editor-preview","bold","italic","heading","fencedCode","wait","leading","trailing","FUNC_ERROR_TEXT","debounce","maxWait","timeoutId","maxTimeoutId","lastCalled","thisArg","trailingCall","complete","isCalled","remaining","stamp","flush","maxDelayed","debounced","leadingCall","toNumber","nativeMax","valueOf","reTrim","isBinary","reIsBinary","reIsOctal","freeParseInt","reIsBadHex","NAN","objectToString","funcTag","genTag","objectProto"],"mappings":"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","file":"mdeditor.ea05a139cece7c8d9554.js","sourcesContent":["var mdeditor =\nwebpackJsonp_name_([29],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(358);\n\tvar MdEditor = __webpack_require__(359);\n\t\n\tfunction init() {\n\t  var editorElems = document.querySelectorAll('.mdeditor');\n\t\n\t  for (var i = 0; i < editorElems.length; i++) {\n\t    var editorElem = editorElems[i];\n\t    new MdEditor({\n\t      elem: editorElem\n\t    });\n\t  }\n\t}\n\t\n\t// must be on document ready\n\tinit();\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */,\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */,\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */,\n/* 41 */,\n/* 42 */,\n/* 43 */,\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */,\n/* 48 */,\n/* 49 */,\n/* 50 */,\n/* 51 */,\n/* 52 */,\n/* 53 */,\n/* 54 */,\n/* 55 */,\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */\n/***/ function(module, exports) {\n\n\tvar _self = (typeof window !== 'undefined')\n\t\t? window   // if in browser\n\t\t: (\n\t\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t\t);\n\t\n\t/**\n\t * Prism: Lightweight, robust, elegant syntax highlighting\n\t * MIT license http://www.opensource.org/licenses/mit-license.php/\n\t * @author Lea Verou http://lea.verou.me\n\t */\n\t\n\tvar Prism = (function(){\n\t\n\t// Private helper vars\n\tvar lang = /\\blang(?:uage)?-(\\w+)\\b/i;\n\tvar uniqueId = 0;\n\t\n\tvar _ = _self.Prism = {\n\t\tutil: {\n\t\t\tencode: function (tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t\t},\n\t\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\t\n\t\t\t// Deep clone a language definition (e.g. to extend it)\n\t\t\tclone: function (o) {\n\t\t\t\tvar type = _.util.type(o);\n\t\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tvar clone = {};\n\t\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn clone;\n\t\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\t// Check for existence for IE8\n\t\t\t\t\t\treturn o.map && o.map(function(v) { return _.util.clone(v); });\n\t\t\t\t}\n\t\n\t\t\t\treturn o;\n\t\t\t}\n\t\t},\n\t\n\t\tlanguages: {\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\t\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\t\n\t\t\t\treturn lang;\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Insert a token before another token in a language literal\n\t\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n\t\t\t * we cannot just provide an object, we need anobject and a key.\n\t\t\t * @param inside The key (or language id) of the parent\n\t\t\t * @param before The key to insert before. If not provided, the function appends instead.\n\t\t\t * @param insert Object with the key/value pairs to insert\n\t\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || _.languages;\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t\n\t\t\t\tif (arguments.length == 2) {\n\t\t\t\t\tinsert = arguments[1];\n\t\t\t\t\t\n\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn grammar;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar ret = {};\n\t\n\t\t\t\tfor (var token in grammar) {\n\t\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\t\n\t\t\t\t\t\tif (token == before) {\n\t\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function(key, value) {\n\t\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\treturn root[inside] = ret;\n\t\t\t},\n\t\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\t\n\t\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tplugins: {},\n\t\t\n\t\thighlightAll: function(async, callback) {\n\t\t\tvar elements = document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code');\n\t\n\t\t\tfor (var i=0, element; element = elements[i++];) {\n\t\t\t\t_.highlightElement(element, async === true, callback);\n\t\t\t}\n\t\t},\n\t\n\t\thighlightElement: function(element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language, grammar, parent = element;\n\t\n\t\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\n\t\t\tif (parent) {\n\t\t\t\tlanguage = (parent.className.match(lang) || [,''])[1];\n\t\t\t\tgrammar = _.languages[language];\n\t\t\t}\n\t\n\t\t\t// Set language on the element, if not present\n\t\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\n\t\t\t// Set language on the parent, for styling\n\t\t\tparent = element.parentNode;\n\t\n\t\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t\t}\n\t\n\t\t\tvar code = element.textContent;\n\t\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\t\n\t\t\tif (!code || !grammar) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t_.hooks.run('before-highlight', env);\n\t\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\t\n\t\t\t\tworker.onmessage = function(evt) {\n\t\t\t\t\tenv.highlightedCode = evt.data;\n\t\n\t\t\t\t\t_.hooks.run('before-insert', env);\n\t\n\t\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\t\n\t\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\t};\n\t\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\t\n\t\t\t\t_.hooks.run('before-insert', env);\n\t\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\t\n\t\t\t\tcallback && callback.call(element);\n\t\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t}\n\t\t},\n\t\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar tokens = _.tokenize(text, grammar);\n\t\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t\t},\n\t\n\t\ttokenize: function(text, grammar, language) {\n\t\t\tvar Token = _.Token;\n\t\n\t\t\tvar strarr = [text];\n\t\n\t\t\tvar rest = grammar.rest;\n\t\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\t\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\t\n\t\t\ttokenloop: for (var token in grammar) {\n\t\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tvar patterns = grammar[token];\n\t\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\t\n\t\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\t\tinside = pattern.inside,\n\t\t\t\t\t\tlookbehind = !!pattern.lookbehind,\n\t\t\t\t\t\tlookbehindLength = 0,\n\t\t\t\t\t\talias = pattern.alias;\n\t\n\t\t\t\t\tpattern = pattern.pattern || pattern;\n\t\n\t\t\t\t\tfor (var i=0; i<strarr.length; i++) { // Dont cache length as it changes during the loop\n\t\n\t\t\t\t\t\tvar str = strarr[i];\n\t\n\t\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tpattern.lastIndex = 0;\n\t\n\t\t\t\t\t\tvar match = pattern.exec(str);\n\t\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tif(lookbehind) {\n\t\t\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar from = match.index - 1 + lookbehindLength,\n\t\t\t\t\t\t\t\tmatch = match[0].slice(lookbehindLength),\n\t\t\t\t\t\t\t\tlen = match.length,\n\t\t\t\t\t\t\t\tto = from + len,\n\t\t\t\t\t\t\t\tbefore = str.slice(0, from + 1),\n\t\t\t\t\t\t\t\tafter = str.slice(to + 1);\n\t\n\t\t\t\t\t\t\tvar args = [i, 1];\n\t\n\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);\n\t\n\t\t\t\t\t\t\targs.push(wrapped);\n\t\n\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn strarr;\n\t\t},\n\t\n\t\thooks: {\n\t\t\tall: {},\n\t\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\t\n\t\t\t\thooks[name] = hooks[name] || [];\n\t\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\t\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\t\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar Token = _.Token = function(type, content, alias) {\n\t\tthis.type = type;\n\t\tthis.content = content;\n\t\tthis.alias = alias;\n\t};\n\t\n\tToken.stringify = function(o, language, parent) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\n\t\tif (_.util.type(o) === 'Array') {\n\t\t\treturn o.map(function(element) {\n\t\t\t\treturn Token.stringify(element, language, o);\n\t\t\t}).join('');\n\t\t}\n\t\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: Token.stringify(o.content, language, parent),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language,\n\t\t\tparent: parent\n\t\t};\n\t\n\t\tif (env.type == 'comment') {\n\t\t\tenv.attributes['spellcheck'] = 'true';\n\t\t}\n\t\n\t\tif (o.alias) {\n\t\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t}\n\t\n\t\t_.hooks.run('wrap', env);\n\t\n\t\tvar attributes = '';\n\t\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += (attributes ? ' ' : '') + name + '=\"' + (env.attributes[name] || '') + '\"';\n\t\t}\n\t\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t\n\t};\n\t\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _self.Prism;\n\t\t}\n\t \t// In worker\n\t\t_self.addEventListener('message', function(evt) {\n\t\t\tvar message = JSON.parse(evt.data),\n\t\t\t    lang = message.language,\n\t\t\t    code = message.code,\n\t\t\t    immediateClose = message.immediateClose;\n\t\n\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\tif (immediateClose) {\n\t\t\t\t_self.close();\n\t\t\t}\n\t\t}, false);\n\t\n\t\treturn _self.Prism;\n\t}\n\t\n\t//Get current script and highlight\n\tvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\n\t\n\tif (script) {\n\t\t_.filename = script.src;\n\t\n\t\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t\t}\n\t}\n\t\n\treturn _self.Prism;\n\t\n\t})();\n\t\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = Prism;\n\t}\n\t\n\t// hack for components to work correctly in node.js\n\tif (typeof global !== 'undefined') {\n\t\tglobal.Prism = Prism;\n\t}\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports) {\n\n\tPrism.languages.markup = {\n\t\t'comment': /<!--[\\w\\W]*?-->/,\n\t\t'prolog': /<\\?[\\w\\W]+?\\?>/,\n\t\t'doctype': /<!DOCTYPE[\\w\\W]+?>/,\n\t\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t\t'tag': {\n\t\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=.$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\w\\W])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n\t\t\tinside: {\n\t\t\t\t'tag': {\n\t\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/i,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /[=>\"']/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\/?>/,\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t},\n\t\t'entity': /&#?[\\da-z]{1,8};/i\n\t};\n\t\n\t// Plugin to make entity title show the real entity, idea by Roman Komarov\n\tPrism.hooks.add('wrap', function(env) {\n\t\n\t\tif (env.type === 'entity') {\n\t\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t\t}\n\t});\n\t\n\tPrism.languages.xml = Prism.languages.markup;\n\tPrism.languages.html = Prism.languages.markup;\n\tPrism.languages.mathml = Prism.languages.markup;\n\tPrism.languages.svg = Prism.languages.markup;\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports) {\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\t\tinside: {\n\t\t\t\t'rule': /@[\\w-]+/\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': /url\\((?:([\"'])(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n\t\t'selector': /[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,\n\t\t'string': /(\"|')(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t\t'important': /\\B!important\\b/i,\n\t\t'function': /[-a-z0-9]+(?=\\()/i,\n\t\t'punctuation': /[(){};:]/\n\t};\n\t\n\tPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\n\t\n\tif (Prism.languages.markup) {\n\t\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t\t'style': {\n\t\t\t\tpattern: /(<style[\\w\\W]*?>)[\\w\\W]*?(?=<\\/style>)/i,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.css,\n\t\t\t\talias: 'language-css'\n\t\t\t}\n\t\t});\n\t\t\n\t\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t\t'style-attr': {\n\t\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'attr-name': {\n\t\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t\t},\n\t\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t\t'attr-value': {\n\t\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\talias: 'language-css'\n\t\t\t}\n\t\t}, Prism.languages.markup.tag);\n\t}\n\n/***/ },\n/* 90 */\n/***/ function(module, exports) {\n\n\tPrism.languages.css.selector = {\n\t\tpattern: /[^\\{\\}\\s][^\\{\\}]*(?=\\s*\\{)/,\n\t\tinside: {\n\t\t\t'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n\t\t\t'pseudo-class': /:[-\\w]+(?:\\(.*\\))?/,\n\t\t\t'class': /\\.[-:\\.\\w]+/,\n\t\t\t'id': /#[-:\\.\\w]+/\n\t\t}\n\t};\n\t\n\tPrism.languages.insertBefore('css', 'function', {\n\t\t'hexcode': /#[\\da-f]{3,6}/i,\n\t\t'entity': /\\\\[\\da-f]{1,8}/i,\n\t\t'number': /[\\d%\\.]+/\n\t});\n\n/***/ },\n/* 91 */\n/***/ function(module, exports) {\n\n\tPrism.languages.clike = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'string': /([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\t'class-name': {\n\t\t\tpattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t\t}\n\t\t},\n\t\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t\t'boolean': /\\b(true|false)\\b/,\n\t\t'function': /[a-z0-9_]+(?=\\()/i,\n\t\t'number': /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\n\t\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n\t\t'punctuation': /[{}[\\];(),.:]/\n\t};\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports) {\n\n\tPrism.languages.javascript = Prism.languages.extend('clike', {\n\t\t'keyword': /\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n\t\t'number': /\\b-?(0x[\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\n\t\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t\t'function': /[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i\n\t});\n\t\n\tPrism.languages.insertBefore('javascript', 'keyword', {\n\t\t'regex': {\n\t\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\\\\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\t\tlookbehind: true\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('javascript', 'class-name', {\n\t\t'template-string': {\n\t\t\tpattern: /`(?:\\\\`|\\\\?[^`])*`/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t\t},\n\t\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t}\n\t});\n\t\n\tif (Prism.languages.markup) {\n\t\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t\t'script': {\n\t\t\t\tpattern: /(<script[\\w\\W]*?>)[\\w\\W]*?(?=<\\/script>)/i,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.javascript,\n\t\t\t\talias: 'language-javascript'\n\t\t\t}\n\t\t});\n\t}\n\t\n\tPrism.languages.js = Prism.languages.javascript;\n\n/***/ },\n/* 93 */\n/***/ function(module, exports) {\n\n\t(function(Prism) {\n\t\n\t// Ignore comments starting with { to privilege string interpolation highlighting\n\tvar comment = /#(?!\\{).+/,\n\t    interpolation = {\n\t    \tpattern: /#\\{[^}]+\\}/,\n\t    \talias: 'variable'\n\t    };\n\t\n\tPrism.languages.coffeescript = Prism.languages.extend('javascript', {\n\t\t'comment': comment,\n\t\t'string': [\n\t\n\t\t\t// Strings are multiline\n\t\t\t/'(?:\\\\?[^\\\\])*?'/,\n\t\n\t\t\t{\n\t\t\t\t// Strings are multiline\n\t\t\t\tpattern: /\"(?:\\\\?[^\\\\])*?\"/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'keyword': /\\b(and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n\t\t'class-member': {\n\t\t\tpattern: /@(?!\\d)\\w+/,\n\t\t\talias: 'variable'\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('coffeescript', 'comment', {\n\t\t'multiline-comment': {\n\t\t\tpattern: /###[\\s\\S]+?###/,\n\t\t\talias: 'comment'\n\t\t},\n\t\n\t\t// Block regexp can contain comments and interpolation\n\t\t'block-regex': {\n\t\t\tpattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n\t\t\talias: 'regex',\n\t\t\tinside: {\n\t\t\t\t'comment': comment,\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('coffeescript', 'string', {\n\t\t'inline-javascript': {\n\t\t\tpattern: /`(?:\\\\?[\\s\\S])*?`/,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^`|`$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.javascript\n\t\t\t}\n\t\t},\n\t\n\t\t// Block strings\n\t\t'multiline-string': [\n\t\t\t{\n\t\t\t\tpattern: /'''[\\s\\S]*?'''/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n\t\t\t\talias: 'string',\n\t\t\t\tinside: {\n\t\t\t\t\tinterpolation: interpolation\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t\n\t});\n\t\n\tPrism.languages.insertBefore('coffeescript', 'keyword', {\n\t\t// Object property\n\t\t'property': /(?!\\d)\\w+(?=\\s*:(?!:))/\n\t});\n\t\n\t}(Prism));\n\n/***/ },\n/* 94 */\n/***/ function(module, exports) {\n\n\tPrism.languages.http = {\n\t\t'request-line': {\n\t\t\tpattern: /^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b\\shttps?:\\/\\/\\S+\\sHTTP\\/[0-9.]+/m,\n\t\t\tinside: {\n\t\t\t\t// HTTP Verb\n\t\t\t\tproperty: /^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b/,\n\t\t\t\t// Path or query argument\n\t\t\t\t'attr-name': /:\\w+/\n\t\t\t}\n\t\t},\n\t\t'response-status': {\n\t\t\tpattern: /^HTTP\\/1.[01] [0-9]+.*/m,\n\t\t\tinside: {\n\t\t\t\t// Status, e.g. 200 OK\n\t\t\t\tproperty: {\n\t                pattern: /(^HTTP\\/1.[01] )[0-9]+.*/i,\n\t                lookbehind: true\n\t            }\n\t\t\t}\n\t\t},\n\t\t// HTTP header name\n\t\t'header-name': {\n\t        pattern: /^[\\w-]+:(?=.)/m,\n\t        alias: 'keyword'\n\t    }\n\t};\n\t\n\t// Create a mapping of Content-Type headers to language definitions\n\tvar httpLanguages = {\n\t\t'application/json': Prism.languages.javascript,\n\t\t'application/xml': Prism.languages.markup,\n\t\t'text/xml': Prism.languages.markup,\n\t\t'text/html': Prism.languages.markup\n\t};\n\t\n\t// Insert each content type parser that has its associated language\n\t// currently loaded.\n\tfor (var contentType in httpLanguages) {\n\t\tif (httpLanguages[contentType]) {\n\t\t\tvar options = {};\n\t\t\toptions[contentType] = {\n\t\t\t\tpattern: new RegExp('(content-type:\\\\s*' + contentType + '[\\\\w\\\\W]*?)(?:\\\\r?\\\\n|\\\\r){2}[\\\\w\\\\W]*', 'i'),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\trest: httpLanguages[contentType]\n\t\t\t\t}\n\t\t\t};\n\t\t\tPrism.languages.insertBefore('http', 'header-name', options);\n\t\t}\n\t}\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports) {\n\n\tPrism.languages.scss = Prism.languages.extend('css', {\n\t\t'comment': {\n\t\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'atrule': {\n\t\t\tpattern: /@[\\w-]+(?:\\([^()]+\\)|[^(])*?(?=\\s+[{;])/,\n\t\t\tinside: {\n\t\t\t\t'rule': /@[\\w-]+/\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t// url, compassified\n\t\t'url': /(?:[-a-z]+-)*url(?=\\()/i,\n\t\t// CSS selector regex is not appropriate for Sass\n\t\t// since there can be lot more things (var, @ directive, nesting..)\n\t\t// a selector must start at the end of a property or after a brace (end of other rules or nesting)\n\t\t// it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n\t\t// the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n\t\t// can \"pass\" as a selector- e.g: proper#{$erty})\n\t\t// this one was hard to do, so please be careful if you edit this one :)\n\t\t'selector': {\n\t\t\t// Initial look-ahead is used to prevent matching of blank selectors\n\t\t\tpattern: /(?=\\S)[^@;\\{\\}\\(\\)]?([^@;\\{\\}\\(\\)]|&|#\\{\\$[-_\\w]+\\})+(?=\\s*\\{(\\}|\\s|[^\\}]+(:|\\{)[^\\}]+))/m,\n\t\t\tinside: {\n\t\t\t\t'placeholder': /%[-_\\w]+/\n\t\t\t}\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('scss', 'atrule', {\n\t\t'keyword': [\n\t\t\t/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,\n\t\t\t{\n\t\t\t\tpattern: /( +)(?:from|through)(?= )/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t]\n\t});\n\t\n\tPrism.languages.insertBefore('scss', 'property', {\n\t\t// var and interpolated vars\n\t\t'variable': /\\$[-_\\w]+|#\\{\\$[-_\\w]+\\}/\n\t});\n\t\n\tPrism.languages.insertBefore('scss', 'function', {\n\t\t'placeholder': {\n\t\t\tpattern: /%[-_\\w]+/,\n\t\t\talias: 'selector'\n\t\t},\n\t\t'statement': /\\B!(?:default|optional)\\b/i,\n\t\t'boolean': /\\b(?:true|false)\\b/,\n\t\t'null': /\\bnull\\b/,\n\t\t'operator': {\n\t\t\tpattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|or|not)(?=\\s)/,\n\t\t\tlookbehind: true\n\t\t}\n\t});\n\t\n\tPrism.languages.scss['atrule'].inside.rest = Prism.util.clone(Prism.languages.scss);\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\n\tPrism.languages.sql= { \n\t\t'comment': {\n\t\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\w\\W]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string' : {\n\t\t\tpattern: /(^|[^@\\\\])(\"|')(?:\\\\?[\\s\\S])*?\\2/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'variable': /@[\\w.$]+|@(\"|'|`)(?:\\\\?[\\s\\S])+?\\1/,\n\t\t'function': /\\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\\s*\\()/i, // Should we highlight user defined functions too?\n\t\t'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR VARYING|CHARACTER (?:SET|VARYING)|CHARSET|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|DATA(?:BASES?)?|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE(?: PRECISION)?|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE(?:D BY)?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEYS?|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL(?: CHAR VARYING| CHARACTER(?: VARYING)?| VARCHAR)?|NATURAL|NCHAR(?: VARCHAR)?|NEXT|NO(?: SQL|CHECK|CYCLE)?|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READ(?:S SQL DATA|TEXT)?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START(?:ING BY)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED BY|TEXT(?:SIZE)?|THEN|TIMESTAMP|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNPIVOT|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?)\\b/i,\n\t\t'boolean': /\\b(?:TRUE|FALSE|NULL)\\b/i,\n\t\t'number': /\\b-?(?:0x)?\\d*\\.?[\\da-f]+\\b/,\n\t\t'operator': /[-+*\\/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n\t\t'punctuation': /[;[\\]()`,.]/\n\t};\n\n/***/ },\n/* 97 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/\n\t * Modified by Miles Johnson: http://milesj.me\n\t *\n\t * Supports the following:\n\t * \t\t- Extends clike syntax\n\t * \t\t- Support for PHP 5.3+ (namespaces, traits, generators, etc)\n\t * \t\t- Smarter constant and function matching\n\t *\n\t * Adds the following new token classes:\n\t * \t\tconstant, delimiter, variable, function, package\n\t */\n\t\n\tPrism.languages.php = Prism.languages.extend('clike', {\n\t\t'keyword': /\\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\\b/i,\n\t\t'constant': /\\b[A-Z0-9_]{2,}\\b/,\n\t\t'comment': {\n\t\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*)/,\n\t\t\tlookbehind: true\n\t\t}\n\t});\n\t\n\t// Shell-like comments are matched after strings, because they are less\n\t// common than strings containing hashes...\n\tPrism.languages.insertBefore('php', 'class-name', {\n\t\t'shell-comment': {\n\t\t\tpattern: /(^|[^\\\\])#.*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'comment'\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('php', 'keyword', {\n\t\t'delimiter': /\\?>|<\\?(?:php)?/i,\n\t\t'variable': /\\$\\w+\\b/i,\n\t\t'package': {\n\t\t\tpattern: /(\\\\|namespace\\s+|use\\s+)[\\w\\\\]+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tpunctuation: /\\\\/\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// Must be defined after the function pattern\n\tPrism.languages.insertBefore('php', 'operator', {\n\t\t'property': {\n\t\t\tpattern: /(->)[\\w]+/,\n\t\t\tlookbehind: true\n\t\t}\n\t});\n\t\n\t// Add HTML support of the markup language exists\n\tif (Prism.languages.markup) {\n\t\n\t\t// Tokenize all inline PHP blocks that are wrapped in <?php ?>\n\t\t// This allows for easy PHP + markup highlighting\n\t\tPrism.hooks.add('before-highlight', function(env) {\n\t\t\tif (env.language !== 'php') {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tenv.tokenStack = [];\n\t\n\t\t\tenv.backupCode = env.code;\n\t\t\tenv.code = env.code.replace(/(?:<\\?php|<\\?)[\\w\\W]*?(?:\\?>)/ig, function(match) {\n\t\t\t\tenv.tokenStack.push(match);\n\t\n\t\t\t\treturn '{{{PHP' + env.tokenStack.length + '}}}';\n\t\t\t});\n\t\t});\n\t\n\t\t// Restore env.code for other plugins (e.g. line-numbers)\n\t\tPrism.hooks.add('before-insert', function(env) {\n\t\t\tif (env.language === 'php') {\n\t\t\t\tenv.code = env.backupCode;\n\t\t\t\tdelete env.backupCode;\n\t\t\t}\n\t\t});\n\t\n\t\t// Re-insert the tokens after highlighting\n\t\tPrism.hooks.add('after-highlight', function(env) {\n\t\t\tif (env.language !== 'php') {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tfor (var i = 0, t; t = env.tokenStack[i]; i++) {\n\t\t\t\t// The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns\n\t\t\t\tenv.highlightedCode = env.highlightedCode.replace('{{{PHP' + (i + 1) + '}}}', Prism.highlight(t, env.grammar, 'php').replace(/\\$/g, '$$$$'));\n\t\t\t}\n\t\n\t\t\tenv.element.innerHTML = env.highlightedCode;\n\t\t});\n\t\n\t\t// Wrap tokens in classes that are missing them\n\t\tPrism.hooks.add('wrap', function(env) {\n\t\t\tif (env.language === 'php' && env.type === 'markup') {\n\t\t\t\tenv.content = env.content.replace(/(\\{\\{\\{PHP[0-9]+\\}\\}\\})/g, \"<span class=\\\"token php\\\">$1</span>\");\n\t\t\t}\n\t\t});\n\t\n\t\t// Add the rules before all others\n\t\tPrism.languages.insertBefore('php', 'comment', {\n\t\t\t'markup': {\n\t\t\t\tpattern: /<[^?]\\/?(.*?)>/,\n\t\t\t\tinside: Prism.languages.markup\n\t\t\t},\n\t\t\t'php': /\\{\\{\\{PHP[0-9]+\\}\\}\\}/\n\t\t});\n\t}\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\n\tPrism.languages.insertBefore('php', 'variable', {\n\t\t'this': /\\$this\\b/,\n\t\t'global': /\\$(?:_(?:SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE)|GLOBALS|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/,\n\t\t'scope': {\n\t\t\tpattern: /\\b[\\w\\\\]+::/,\n\t\t\tinside: {\n\t\t\t\tkeyword: /(static|self|parent)/,\n\t\t\t\tpunctuation: /(::|\\\\)/\n\t\t\t}\n\t\t}\n\t});\n\n/***/ },\n/* 99 */\n/***/ function(module, exports) {\n\n\tPrism.languages.python= {\n\t\t'triple-quoted-string': {\n\t\t\tpattern: /\"\"\"[\\s\\S]+?\"\"\"|'''[\\s\\S]+?'''/,\n\t\t\talias: 'string'\n\t\t},\n\t\t'comment': {\n\t\t\tpattern: /(^|[^\\\\])#.*/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': /(\"|')(?:\\\\?.)*?\\1/,\n\t\t'function' : {\n\t\t\tpattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\\()/g,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'class-name': {\n\t\t\tpattern: /(\\bclass\\s+)[a-z0-9_]+/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'keyword' : /\\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\\b/,\n\t\t'boolean' : /\\b(?:True|False)\\b/,\n\t\t'number' : /\\b-?(?:0[bo])?(?:(?:\\d|0x[\\da-f])[\\da-f]*\\.?\\d*|\\.\\d+)(?:e[+-]?\\d+)?j?\\b/i,\n\t\t'operator' : /[-+%=]=?|!=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]|\\b(?:or|and|not)\\b/,\n\t\t'punctuation' : /[{}[\\];(),.:]/\n\t};\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Original by Samuel Flores\n\t *\n\t * Adds the following new token classes:\n\t * \t\tconstant, builtin, variable, symbol, regex\n\t */\n\t(function(Prism) {\n\t\tPrism.languages.ruby = Prism.languages.extend('clike', {\n\t\t\t'comment': /#(?!\\{[^\\r\\n]*?\\}).*/,\n\t\t\t'keyword': /\\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\\b/\n\t\t});\n\t\n\t\tvar interpolation = {\n\t\t\tpattern: /#\\{[^}]+\\}/,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^#\\{|\\}$/,\n\t\t\t\t\talias: 'tag'\n\t\t\t\t},\n\t\t\t\trest: Prism.util.clone(Prism.languages.ruby)\n\t\t\t}\n\t\t};\n\t\n\t\tPrism.languages.insertBefore('ruby', 'keyword', {\n\t\t\t'regex': [\n\t\t\t\t{\n\t\t\t\t\tpattern: /%r([^a-zA-Z0-9\\s\\{\\(\\[<])(?:[^\\\\]|\\\\[\\s\\S])*?\\1[gim]{0,3}/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /%r\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)[gim]{0,3}/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Here we need to specifically allow interpolation\n\t\t\t\t\tpattern: /%r\\{(?:[^#{}\\\\]|#(?:\\{[^}]+\\})?|\\\\[\\s\\S])*\\}[gim]{0,3}/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /%r\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\][gim]{0,3}/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /%r<(?:[^<>\\\\]|\\\\[\\s\\S])*>[gim]{0,3}/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t],\n\t\t\t'variable': /[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\\b)/,\n\t\t\t'symbol': /:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\\b)/\n\t\t});\n\t\n\t\tPrism.languages.insertBefore('ruby', 'number', {\n\t\t\t'builtin': /\\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\\b/,\n\t\t\t'constant': /\\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\\b)/\n\t\t});\n\t\n\t\tPrism.languages.ruby.string = [\n\t\t\t{\n\t\t\t\tpattern: /%[qQiIwWxs]?([^a-zA-Z0-9\\s\\{\\(\\[<])(?:[^\\\\]|\\\\[\\s\\S])*?\\1/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /%[qQiIwWxs]?\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Here we need to specifically allow interpolation\n\t\t\t\tpattern: /%[qQiIwWxs]?\\{(?:[^#{}\\\\]|#(?:\\{[^}]+\\})?|\\\\[\\s\\S])*\\}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /%[qQiIwWxs]?\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\]/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /%[qQiIwWxs]?<(?:[^<>\\\\]|\\\\[\\s\\S])*>/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\"|')(#\\{[^}]+\\}|\\\\(?:\\r?\\n|\\r)|\\\\?.)*?\\1/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}(Prism));\n\n/***/ },\n/* 101 */\n/***/ function(module, exports) {\n\n\tPrism.languages.java = Prism.languages.extend('clike', {\n\t\t'keyword': /\\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\\b/,\n\t\t'number': /\\b0b[01]+\\b|\\b0x[\\da-f]*\\.?[\\da-fp\\-]+\\b|\\b\\d*\\.?\\d+(?:e[+-]?\\d+)?[df]?\\b/i,\n\t\t'operator': {\n\t\t\tpattern: /(^|[^.])(?:\\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\\|[|=]?|\\*=?|\\/=?|%=?|\\^=?|[?:~])/m,\n\t\t\tlookbehind: true\n\t\t}\n\t});\n\n/***/ },\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */,\n/* 107 */,\n/* 108 */,\n/* 109 */,\n/* 110 */,\n/* 111 */,\n/* 112 */,\n/* 113 */,\n/* 114 */,\n/* 115 */,\n/* 116 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 117 */,\n/* 118 */,\n/* 119 */,\n/* 120 */,\n/* 121 */,\n/* 122 */,\n/* 123 */,\n/* 124 */,\n/* 125 */,\n/* 126 */,\n/* 127 */,\n/* 128 */,\n/* 129 */,\n/* 130 */,\n/* 131 */,\n/* 132 */,\n/* 133 */,\n/* 134 */,\n/* 135 */,\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */,\n/* 142 */,\n/* 143 */,\n/* 144 */,\n/* 145 */,\n/* 146 */,\n/* 147 */,\n/* 148 */,\n/* 149 */,\n/* 150 */,\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */,\n/* 157 */,\n/* 158 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Merge two attribute objects giving precedence\n\t * to values in object `b`. Classes are special-cased\n\t * allowing for arrays and merging/joining appropriately\n\t * resulting in a string.\n\t *\n\t * @param {Object} a\n\t * @param {Object} b\n\t * @return {Object} a\n\t * @api private\n\t */\n\t\n\texports.merge = function merge(a, b) {\n\t  if (arguments.length === 1) {\n\t    var attrs = a[0];\n\t    for (var i = 1; i < a.length; i++) {\n\t      attrs = merge(attrs, a[i]);\n\t    }\n\t    return attrs;\n\t  }\n\t  var ac = a['class'];\n\t  var bc = b['class'];\n\t\n\t  if (ac || bc) {\n\t    ac = ac || [];\n\t    bc = bc || [];\n\t    if (!Array.isArray(ac)) ac = [ac];\n\t    if (!Array.isArray(bc)) bc = [bc];\n\t    a['class'] = ac.concat(bc).filter(nulls);\n\t  }\n\t\n\t  for (var key in b) {\n\t    if (key != 'class') {\n\t      a[key] = b[key];\n\t    }\n\t  }\n\t\n\t  return a;\n\t};\n\t\n\t/**\n\t * Filter null `val`s.\n\t *\n\t * @param {*} val\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction nulls(val) {\n\t  return val != null && val !== '';\n\t}\n\t\n\t/**\n\t * join array as classes.\n\t *\n\t * @param {*} val\n\t * @return {String}\n\t */\n\texports.joinClasses = joinClasses;\n\tfunction joinClasses(val) {\n\t  return (Array.isArray(val) ? val.map(joinClasses) : val && typeof val === 'object' ? Object.keys(val).filter(function (key) {\n\t    return val[key];\n\t  }) : [val]).filter(nulls).join(' ');\n\t}\n\t\n\t/**\n\t * Render the given classes.\n\t *\n\t * @param {Array} classes\n\t * @param {Array.<Boolean>} escaped\n\t * @return {String}\n\t */\n\texports.cls = function cls(classes, escaped) {\n\t  var buf = [];\n\t  for (var i = 0; i < classes.length; i++) {\n\t    if (escaped && escaped[i]) {\n\t      buf.push(exports.escape(joinClasses([classes[i]])));\n\t    } else {\n\t      buf.push(joinClasses(classes[i]));\n\t    }\n\t  }\n\t  var text = joinClasses(buf);\n\t  if (text.length) {\n\t    return ' class=\"' + text + '\"';\n\t  } else {\n\t    return '';\n\t  }\n\t};\n\t\n\texports.style = function (val) {\n\t  if (val && typeof val === 'object') {\n\t    return Object.keys(val).map(function (style) {\n\t      return style + ':' + val[style];\n\t    }).join(';');\n\t  } else {\n\t    return val;\n\t  }\n\t};\n\t/**\n\t * Render the given attribute.\n\t *\n\t * @param {String} key\n\t * @param {String} val\n\t * @param {Boolean} escaped\n\t * @param {Boolean} terse\n\t * @return {String}\n\t */\n\texports.attr = function attr(key, val, escaped, terse) {\n\t  if (key === 'style') {\n\t    val = exports.style(val);\n\t  }\n\t  if ('boolean' == typeof val || null == val) {\n\t    if (val) {\n\t      return ' ' + (terse ? key : key + '=\"' + key + '\"');\n\t    } else {\n\t      return '';\n\t    }\n\t  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n\t    if (JSON.stringify(val).indexOf('&') !== -1) {\n\t      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' + 'will be escaped to `&amp;`');\n\t    };\n\t    if (val && typeof val.toISOString === 'function') {\n\t      console.warn('Jade will eliminate the double quotes around dates in ' + 'ISO form after 2.0.0');\n\t    }\n\t    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\n\t  } else if (escaped) {\n\t    if (val && typeof val.toISOString === 'function') {\n\t      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n\t    }\n\t    return ' ' + key + '=\"' + exports.escape(val) + '\"';\n\t  } else {\n\t    if (val && typeof val.toISOString === 'function') {\n\t      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n\t    }\n\t    return ' ' + key + '=\"' + val + '\"';\n\t  }\n\t};\n\t\n\t/**\n\t * Render the given attributes object.\n\t *\n\t * @param {Object} obj\n\t * @param {Object} escaped\n\t * @return {String}\n\t */\n\texports.attrs = function attrs(obj, terse) {\n\t  var buf = [];\n\t\n\t  var keys = Object.keys(obj);\n\t\n\t  if (keys.length) {\n\t    for (var i = 0; i < keys.length; ++i) {\n\t      var key = keys[i],\n\t          val = obj[key];\n\t\n\t      if ('class' == key) {\n\t        if (val = joinClasses(val)) {\n\t          buf.push(' ' + key + '=\"' + val + '\"');\n\t        }\n\t      } else {\n\t        buf.push(exports.attr(key, val, false, terse));\n\t      }\n\t    }\n\t  }\n\t\n\t  return buf.join('');\n\t};\n\t\n\t/**\n\t * Escape the given string of `html`.\n\t *\n\t * @param {String} html\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tvar jade_encode_html_rules = {\n\t  '&': '&amp;',\n\t  '<': '&lt;',\n\t  '>': '&gt;',\n\t  '\"': '&quot;'\n\t};\n\tvar jade_match_html = /[&<>\"]/g;\n\t\n\tfunction jade_encode_char(c) {\n\t  return jade_encode_html_rules[c] || c;\n\t}\n\t\n\texports.escape = jade_escape;\n\tfunction jade_escape(html) {\n\t  var result = String(html).replace(jade_match_html, jade_encode_char);\n\t  if (result === '' + html) return html;else return result;\n\t};\n\t\n\t/**\n\t * Re-throw the given `err` in context to the\n\t * the jade in `filename` at the given `lineno`.\n\t *\n\t * @param {Error} err\n\t * @param {String} filename\n\t * @param {String} lineno\n\t * @api private\n\t */\n\t\n\texports.rethrow = function rethrow(err, filename, lineno, str) {\n\t  if (!(err instanceof Error)) throw err;\n\t  if ((typeof window != 'undefined' || !filename) && !str) {\n\t    err.message += ' on line ' + lineno;\n\t    throw err;\n\t  }\n\t  try {\n\t    str = str || __webpack_require__(116).readFileSync(filename, 'utf8');\n\t  } catch (ex) {\n\t    rethrow(err, null, lineno);\n\t  }\n\t  var context = 3,\n\t      lines = str.split('\\n'),\n\t      start = Math.max(lineno - context, 0),\n\t      end = Math.min(lines.length, lineno + context);\n\t\n\t  // Error context\n\t  var context = lines.slice(start, end).map(function (line, i) {\n\t    var curr = i + start + 1;\n\t    return (curr == lineno ? '  > ' : '    ') + curr + '| ' + line;\n\t  }).join('\\n');\n\t\n\t  // Alter exception message\n\t  err.path = filename;\n\t  err.message = (filename || 'Jade') + ':' + lineno + '\\n' + context + '\\n\\n' + err.message;\n\t  throw err;\n\t};\n\t\n\texports.DebugItem = function DebugItem(lineno, filename) {\n\t  this.lineno = lineno;\n\t  this.filename = filename;\n\t};\n\n/***/ },\n/* 159 */,\n/* 160 */,\n/* 161 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar bem = __webpack_require__(162)();\n\tvar thumb = __webpack_require__(163).thumb;\n\t\n\tvar t = __webpack_require__(326);\n\t\n\tmodule.exports = function (template, locals) {\n\t  locals = locals ? Object.create(locals) : {};\n\t  addStandardHelpers(locals);\n\t\n\t  return template(locals);\n\t};\n\t\n\tfunction addStandardHelpers(locals) {\n\t  locals.bem = bem;\n\t  locals.t = t;\n\t  locals.thumb = thumb;\n\t}\n\n/***/ },\n/* 162 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Adapted from bemto.jade, copyright(c) 2012 Roman Komarov <kizu@kizu.ru>\n\t\n\t/* jshint -W106 */\n\t\n\t'use strict';\n\t\n\tvar jade = __webpack_require__(158);\n\t\n\tmodule.exports = function (settings) {\n\t  settings = settings || {};\n\t\n\t  settings.prefix = settings.prefix || '';\n\t  settings.element = settings.element || '__';\n\t  settings.modifier = settings.modifier || '_';\n\t\n\t  return function (buf, bem_chain, tag, isElement) {\n\t    //console.log(\"-->\", arguments);\n\t    var block = this.block;\n\t    var attributes = this.attributes || {};\n\t\n\t    if (!attributes['class'] && tag && !isElement) {\n\t      throw new Error(\"Block without class: \" + tag);\n\t    }\n\t\n\t    // Rewriting the class for elements and modifiers\n\t    if (attributes['class']) {\n\t      var bem_classes = attributes['class'];\n\t\n\t      if (bem_classes instanceof Array) {\n\t        bem_classes = bem_classes.join(' ');\n\t      }\n\t      bem_classes = bem_classes.split(' ');\n\t\n\t      var bem_block;\n\t      try {\n\t        bem_block = bem_classes[0].match(new RegExp('^(((?!' + settings.element + '|' + settings.modifier + ').)+)'))[1];\n\t      } catch (e) {\n\t        throw new Error(\"Incorrect bem class: \" + bem_classes[0]);\n\t      }\n\t\n\t      if (!isElement) {\n\t        bem_chain[bem_chain.length] = bem_block;\n\t      } else {\n\t        bem_classes[0] = bem_chain[bem_chain.length - 1] + settings.element + bem_classes[0];\n\t      }\n\t\n\t      var current_block = (isElement ? bem_chain[bem_chain.length - 1] + settings.element : '') + bem_block;\n\t\n\t      // Adding the block if there is only modifier and/or element\n\t      if (bem_classes.indexOf(current_block) === -1) {\n\t        bem_classes[bem_classes.length] = current_block;\n\t      }\n\t\n\t      for (var i = 0; i < bem_classes.length; i++) {\n\t        var klass = bem_classes[i];\n\t\n\t        if (klass.match(new RegExp('^(?!' + settings.element + ')' + settings.modifier))) {\n\t          // Expanding the modifiers\n\t          bem_classes[i] = current_block + klass;\n\t        } else if (klass.match(new RegExp('^' + settings.element))) {\n\t          //- Expanding the mixed in elements\n\t          if (bem_chain[bem_chain.length - 2]) {\n\t            bem_classes[i] = bem_chain[bem_chain.length - 2] + klass;\n\t          } else {\n\t            bem_classes[i] = bem_chain[bem_chain.length - 1] + klass;\n\t          }\n\t        }\n\t\n\t        // Adding prefixes\n\t        if (bem_classes[i].match(new RegExp('^' + current_block + '($|(?=' + settings.element + '|' + settings.modifier + '))'))) {\n\t          bem_classes[i] = settings.prefix + bem_classes[i];\n\t        }\n\t      }\n\t\n\t      // Write modified classes to attributes in the correct order\n\t      attributes['class'] = bem_classes.sort().join(' ');\n\t    }\n\t\n\t    bem_tag(buf, block, attributes, bem_chain, tag);\n\t\n\t    // Closing actions (remove the current block from the chain)\n\t    if (!isElement) {\n\t      bem_chain.pop();\n\t    }\n\t  };\n\t\n\t  // used for tweaking what tag we are throwing and do we need to wrap anything here\n\t  function bem_tag(buf, block, attributes, bem_chain, tag) {\n\t    // rewriting tag name on different contexts\n\t    var newTag = tag || 'div';\n\t\n\t    switch (newTag) {\n\t      case 'img':\n\t        // If there is no title we don't need it to show even if there is some alt\n\t        if (attributes.alt && !attributes.title) {\n\t          attributes.title = '';\n\t        }\n\t        // If we have title, we must have it in alt if it's not set\n\t        if (attributes.title && !attributes.alt) {\n\t          attributes.alt = attributes.title;\n\t        }\n\t        if (!attributes.alt) {\n\t          attributes.alt = '';\n\t        }\n\t        break;\n\t      case 'input':\n\t        if (!attributes.type) {\n\t          attributes.type = \"text\";\n\t        }\n\t        break;\n\t      case 'html':\n\t        buf.push('<!DOCTYPE HTML>');\n\t        break;\n\t      case 'a':\n\t        if (!attributes.href) {\n\t          attributes.href = '#';\n\t        }\n\t    }\n\t\n\t    buf.push('<' + newTag + jade.attrs(jade.merge([attributes]), true) + \">\");\n\t\n\t    if (block) block();\n\t\n\t    if (['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'].indexOf(newTag) == -1) {\n\t      buf.push('</' + newTag + '>');\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 163 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.thumb = function (url, width, height) {\n\t  // sometimes this may be called without url\n\t  if (!url) return url;\n\t\n\t  var pixelRatio = window.devicePixelRatio;\n\t\n\t  // return pixelRatio times larger image for retina\n\t  width *= pixelRatio;\n\t  height *= pixelRatio;\n\t\n\t  var modifier = width <= 160 && height <= 160 ? 't' : width <= 320 && height <= 320 ? 'm' : width <= 640 && height <= 640 ? 'i' : width <= 1024 && height <= 1024 ? 'h' : '';\n\t\n\t  return url.slice(0, url.lastIndexOf('.')) + modifier + url.slice(url.lastIndexOf('.'));\n\t};\n\n/***/ },\n/* 164 */,\n/* 165 */,\n/* 166 */,\n/* 167 */,\n/* 168 */,\n/* 169 */,\n/* 170 */,\n/* 171 */,\n/* 172 */,\n/* 173 */,\n/* 174 */,\n/* 175 */,\n/* 176 */,\n/* 177 */,\n/* 178 */,\n/* 179 */,\n/* 180 */,\n/* 181 */,\n/* 182 */,\n/* 183 */,\n/* 184 */,\n/* 185 */,\n/* 186 */,\n/* 187 */,\n/* 188 */,\n/* 189 */,\n/* 190 */,\n/* 191 */,\n/* 192 */,\n/* 193 */,\n/* 194 */,\n/* 195 */,\n/* 196 */,\n/* 197 */,\n/* 198 */,\n/* 199 */,\n/* 200 */,\n/* 201 */,\n/* 202 */,\n/* 203 */,\n/* 204 */,\n/* 205 */,\n/* 206 */,\n/* 207 */,\n/* 208 */,\n/* 209 */,\n/* 210 */,\n/* 211 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = function (module) {\n\t\tif (!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function () {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t};\n\n/***/ },\n/* 212 */,\n/* 213 */,\n/* 214 */,\n/* 215 */,\n/* 216 */,\n/* 217 */,\n/* 218 */,\n/* 219 */,\n/* 220 */,\n/* 221 */,\n/* 222 */,\n/* 223 */,\n/* 224 */,\n/* 225 */,\n/* 226 */,\n/* 227 */,\n/* 228 */,\n/* 229 */,\n/* 230 */,\n/* 231 */,\n/* 232 */,\n/* 233 */,\n/* 234 */,\n/* 235 */,\n/* 236 */,\n/* 237 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(87);\n\t__webpack_require__(88);\n\t__webpack_require__(89);\n\t__webpack_require__(90);\n\t__webpack_require__(91);\n\t__webpack_require__(92);\n\t__webpack_require__(93);\n\t__webpack_require__(94);\n\t__webpack_require__(95);\n\t__webpack_require__(96);\n\t__webpack_require__(97);\n\t__webpack_require__(98);\n\t__webpack_require__(99);\n\t__webpack_require__(100);\n\t__webpack_require__(101);\n\t\n\tPrism.tokenTag = 'code'; // for iBooks to use monospace font\n\t\n\tvar CodeBox = __webpack_require__(238);\n\tvar CodeTabsBox = __webpack_require__(241);\n\t\n\tfunction initCodeBoxes(container) {\n\t\n\t  // highlight inline\n\t  var codeExampleElems = container.querySelectorAll('.code-example:not([data-prism-done])');\n\t\n\t  for (var i = 0; i < codeExampleElems.length; i++) {\n\t    var codeExampleElem = codeExampleElems[i];\n\t    new CodeBox(codeExampleElem);\n\t    codeExampleElem.setAttribute('data-prism-done', '1');\n\t  }\n\t}\n\t\n\tfunction initCodeTabsBox(container) {\n\t\n\t  var elems = container.querySelectorAll('div.code-tabs:not([data-prism-done])');\n\t\n\t  for (var i = 0; i < elems.length; i++) {\n\t    new CodeTabsBox(elems[i]);\n\t    elems[i].setAttribute('data-prism-done', '1');\n\t  }\n\t}\n\t\n\texports.init = function () {\n\t\n\t  document.removeEventListener('DOMContentLoaded', Prism.highlightAll);\n\t\n\t  document.addEventListener('DOMContentLoaded', function () {\n\t    highlight(document);\n\t  });\n\t};\n\t\n\tfunction highlight(elem) {\n\t  initCodeBoxes(elem);\n\t  initCodeTabsBox(elem);\n\t}\n\t\n\texports.highlight = highlight;\n\n/***/ },\n/* 238 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar resizeOnload = __webpack_require__(197);\n\tvar isScrolledIntoView = __webpack_require__(239);\n\tvar addLineNumbers = __webpack_require__(240);\n\t\n\tfunction CodeBox(elem) {\n\t\n\t  var preElem = elem.querySelector('pre');\n\t  var codeElem = preElem.querySelector('code');\n\t  var code = codeElem.textContent;\n\t\n\t  Prism.highlightElement(codeElem);\n\t  addLineNumbers(preElem);\n\t\n\t  addBlockHighlight(preElem, elem.getAttribute('data-highlight-block'));\n\t  addInlineHighlight(preElem, elem.getAttribute('data-highlight-inline'));\n\t\n\t  var isJS = preElem.classList.contains('language-javascript');\n\t  var isHTML = preElem.classList.contains('language-markup');\n\t  var isTrusted = +elem.getAttribute('data-trusted');\n\t  var isNoStrict = +elem.getAttribute('data-no-strict');\n\t\n\t  if (!isNoStrict && isJS) code = \"'use strict';\\n\" + code;\n\t\n\t  var jsFrame;\n\t  var htmlResult;\n\t  var isFirstRun = true;\n\t\n\t  if (!isJS && !isHTML) return;\n\t\n\t  var runElem = elem.querySelector('[data-action=\"run\"]');\n\t  if (runElem) {\n\t    runElem.onclick = function () {\n\t      this.blur();\n\t      run();\n\t      return false;\n\t    };\n\t  }\n\t\n\t  var editElem = elem.querySelector('[data-action=\"edit\"]');\n\t  if (editElem) {\n\t    editElem.onclick = function () {\n\t      this.blur();\n\t      edit();\n\t      return false;\n\t    };\n\t  }\n\t\n\t  // some code can't be shown by epub engine\n\t  if (elem.hasAttribute('data-autorun')) {\n\t    if (window.ebookType == 'epub' && elem.getAttribute('data-autorun') == 'no-epub') {\n\t      elem.querySelector('iframe').remove();\n\t    } else {\n\t      // timeout should be small, around 10ms, or remove it to make crawler process the autorun\n\t      setTimeout(run, 100);\n\t    }\n\t  }\n\t\n\t  function postJSFrame() {\n\t    var win = jsFrame.contentWindow;\n\t    if (typeof win.postMessage != 'function') {\n\t      alert(\",      \");\n\t      return;\n\t    }\n\t    win.postMessage(code, 'https://ru.lookatcode.com/showjs');\n\t  }\n\t\n\t  function runHTML() {\n\t\n\t    var frame;\n\t\n\t    if (htmlResult && elem.hasAttribute('data-refresh')) {\n\t      htmlResult.remove();\n\t      htmlResult = null;\n\t    }\n\t\n\t    if (!htmlResult) {\n\t      // take from HTML if exists there (in markup when autorun is specified)\n\t      htmlResult = elem.querySelector('.code-result');\n\t    }\n\t\n\t    if (!htmlResult) {\n\t      // otherwise create (or recreate if refresh)\n\t      htmlResult = document.createElement('div');\n\t      htmlResult.className = \"code-result code-example__result\";\n\t\n\t      frame = document.createElement('iframe');\n\t      frame.name = 'frame-' + Math.random();\n\t      frame.className = 'code-result__iframe';\n\t\n\t      if (elem.getAttribute('data-demo-height') === \"0\") {\n\t        // this html has nothing to show\n\t        frame.style.display = 'none';\n\t      } else if (elem.hasAttribute('data-demo-height')) {\n\t        var height = +elem.getAttribute('data-demo-height');\n\t        frame.style.height = height + 'px';\n\t      }\n\t      htmlResult.appendChild(frame);\n\t\n\t      elem.appendChild(htmlResult);\n\t    } else {\n\t      frame = htmlResult.querySelector('iframe');\n\t    }\n\t\n\t    if (isTrusted) {\n\t      var doc = frame.contentDocument || frame.contentWindow.document;\n\t\n\t      doc.open();\n\t      doc.write(normalizeHtml(code));\n\t      doc.close();\n\t\n\t      if (window.ebookType == 'epub') {\n\t        setTimeout(function () {\n\t          // remove script from iframes\n\t          // firefox saves the file with full iframe content (including script-generated) and the scripts\n\t          // scripts must not execute and autogenerate content again\n\t          [].forEach.call(doc.querySelectorAll('script'), function (script) {\n\t            script.remove();\n\t          });\n\t\n\t          // do it after timeout to allow external scripts (if any) to execute\n\t        }, 2000);\n\t      }\n\t\n\t      if (!elem.hasAttribute('data-demo-height')) {\n\t        resizeOnload.iframe(frame);\n\t      }\n\t\n\t      if (!(isFirstRun && elem.hasAttribute('data-autorun'))) {\n\t        if (!isScrolledIntoView(htmlResult)) {\n\t          htmlResult.scrollIntoView(false);\n\t        }\n\t      }\n\t    } else {\n\t      var form = document.createElement('form');\n\t      form.style.display = 'none';\n\t      form.method = 'POST';\n\t      form.enctype = \"multipart/form-data\";\n\t      form.action = \"https://ru.lookatcode.com/showhtml\";\n\t      form.target = frame.name;\n\t\n\t      var textarea = document.createElement('textarea');\n\t      textarea.name = 'code';\n\t      textarea.value = normalizeHtml(code);\n\t      form.appendChild(textarea);\n\t\n\t      frame.parentNode.insertBefore(form, frame.nextSibling);\n\t      form.submit();\n\t      form.remove();\n\t\n\t      if (!(isFirstRun && elem.hasAttribute('data-autorun'))) {\n\t        frame.onload = function () {\n\t\n\t          if (!elem.hasAttribute('data-demo-height')) {\n\t            resizeOnload.iframe(frame);\n\t          }\n\t\n\t          if (!isScrolledIntoView(htmlResult)) {\n\t            htmlResult.scrollIntoView(false);\n\t          }\n\t        };\n\t      }\n\t    }\n\t  }\n\t\n\t  // Evaluates a script in a global context\n\t  function globalEval(code) {\n\t    var script = document.createElement(\"script\");\n\t    script.text = code;\n\t    document.head.appendChild(script).parentNode.removeChild(script);\n\t  }\n\t\n\t  function runJS() {\n\t\n\t    //console.log(code);\n\t    if (isTrusted) {\n\t\n\t      if (elem.hasAttribute('data-autorun')) {\n\t        // make sure functions from \"autorun\" go to global scope\n\t        globalEval(code);\n\t        return;\n\t      }\n\t\n\t      try {\n\t        /* jshint -W061 */\n\t        window[\"eval\"].call(window, code);\n\t      } catch (e) {\n\t        alert(\"Error: \" + e.message);\n\t      }\n\t    } else {\n\t\n\t      if (elem.hasAttribute('data-refresh') && jsFrame) {\n\t        jsFrame.remove();\n\t        jsFrame = null;\n\t      }\n\t\n\t      if (!jsFrame) {\n\t        // create iframe for js\n\t        jsFrame = document.createElement('iframe');\n\t        jsFrame.className = 'js-frame';\n\t        jsFrame.src = 'https://ru.lookatcode.com/showjs';\n\t        jsFrame.style.width = 0;\n\t        jsFrame.style.height = 0;\n\t        jsFrame.style.border = 'none';\n\t        jsFrame.onload = function () {\n\t          postJSFrame();\n\t        };\n\t        document.body.appendChild(jsFrame);\n\t      } else {\n\t        postJSFrame();\n\t      }\n\t    }\n\t  }\n\t\n\t  function edit() {\n\t\n\t    var html;\n\t    if (isHTML) {\n\t      html = normalizeHtml(code);\n\t    } else {\n\t      var codeIndented = code.replace(/^/gim, '    ');\n\t      html = '<!DOCTYPE html>\\n<html>\\n\\n<body>\\n  <script>\\n' + codeIndented + '\\n  </script>\\n</body>\\n\\n</html>';\n\t    }\n\t\n\t    var form = document.createElement('form');\n\t    form.action = \"http://plnkr.co/edit/?p=preview\";\n\t    form.method = \"POST\";\n\t    form.target = \"_blank\";\n\t\n\t    document.body.appendChild(form);\n\t\n\t    var textarea = document.createElement('textarea');\n\t    textarea.name = \"files[index.html]\";\n\t    textarea.value = html;\n\t    form.appendChild(textarea);\n\t\n\t    var input = document.createElement('input');\n\t    input.name = \"description\";\n\t    input.value = \"Fork from \" + window.location;\n\t    form.appendChild(input);\n\t\n\t    form.submit();\n\t    form.remove();\n\t  }\n\t\n\t  function normalizeHtml() {\n\t    var codeLc = code.toLowerCase();\n\t    var hasBodyStart = codeLc.match('<body>');\n\t    var hasBodyEnd = codeLc.match('</body>');\n\t    var hasHtmlStart = codeLc.match('<html>');\n\t    var hasHtmlEnd = codeLc.match('</html>');\n\t\n\t    var hasDocType = codeLc.match(/^\\s*<!doctype/);\n\t\n\t    if (hasDocType) {\n\t      return code;\n\t    }\n\t\n\t    var result = code;\n\t\n\t    if (!hasHtmlStart) {\n\t      result = '<html>\\n' + result;\n\t    }\n\t\n\t    if (!hasHtmlEnd) {\n\t      result = result + '\\n</html>';\n\t    }\n\t\n\t    if (!hasBodyStart) {\n\t      result = result.replace('<html>', '<html>\\n<head>\\n  <meta charset=\"utf-8\">\\n</head><body>\\n');\n\t    }\n\t\n\t    if (!hasBodyEnd) {\n\t      result = result.replace('</html>', '\\n</body>\\n</html>');\n\t    }\n\t\n\t    result = '<!DOCTYPE HTML>\\n' + result;\n\t\n\t    return result;\n\t  }\n\t\n\t  function run() {\n\t    if (isJS) {\n\t      runJS();\n\t    } else {\n\t      runHTML();\n\t    }\n\t    isFirstRun = false;\n\t  }\n\t}\n\t\n\tfunction addBlockHighlight(pre, lines) {\n\t\n\t  if (!lines) {\n\t    return;\n\t  }\n\t\n\t  var ranges = lines.replace(/\\s+/g, '').split(',');\n\t\n\t  /*jshint -W084 */\n\t  for (var i = 0, range; range = ranges[i++];) {\n\t    range = range.split('-');\n\t\n\t    var start = +range[0],\n\t        end = +range[1] || start;\n\t\n\t    var mask = '<code class=\"block-highlight\" data-start=\"' + start + '\" data-end=\"' + end + '\">' + new Array(start + 1).join('\\n') + '<code class=\"mask\">' + new Array(end - start + 2).join('\\n') + '</code></code>';\n\t\n\t    pre.insertAdjacentHTML(\"afterBegin\", mask);\n\t  }\n\t}\n\t\n\tfunction addInlineHighlight(pre, ranges) {\n\t\n\t  // select code with the language text, not block-highlighter\n\t  var codeElem = pre.querySelector('code[class*=\"language-\"]');\n\t\n\t  ranges = ranges ? ranges.split(\",\") : [];\n\t\n\t  for (var i = 0; i < ranges.length; i++) {\n\t    var piece = ranges[i].split(':');\n\t    var lineNum = +piece[0],\n\t        strRange = piece[1].split('-');\n\t    var start = +strRange[0],\n\t        end = +strRange[1];\n\t    var mask = '<code class=\"inline-highlight\">' + new Array(lineNum + 1).join('\\n') + new Array(start + 1).join(' ') + '<code class=\"mask\">' + new Array(end - start + 1).join(' ') + '</code></code>';\n\t\n\t    codeElem.insertAdjacentHTML(\"afterBegin\", mask);\n\t  }\n\t}\n\t\n\tmodule.exports = CodeBox;\n\n/***/ },\n/* 239 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction isScrolledIntoView(elem) {\n\t  var coords = elem.getBoundingClientRect();\n\t\n\t  var visibleHeight = 0;\n\t\n\t  if (coords.top < 0) {\n\t    visibleHeight = coords.bottom;\n\t  } else if (coords.bottom > window.innerHeight) {\n\t    visibleHeight = window.innerHeight - top;\n\t  } else {\n\t    return true;\n\t  }\n\t\n\t  return visibleHeight > 10;\n\t}\n\t\n\tmodule.exports = isScrolledIntoView;\n\n/***/ },\n/* 240 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction addLineNumbers(pre) {\n\t\n\t  var linesNum = 1 + pre.innerHTML.split('\\n').length;\n\t  var lineNumbersWrapper;\n\t\n\t  var lines = new Array(linesNum);\n\t  lines = lines.join('<span></span>');\n\t\n\t  lineNumbersWrapper = document.createElement('span');\n\t  lineNumbersWrapper.className = 'line-numbers-rows';\n\t  lineNumbersWrapper.innerHTML = lines;\n\t\n\t  if (pre.hasAttribute('data-start')) {\n\t    pre.style.counterReset = 'linenumber ' + Number(pre.dataset.start) - 1;\n\t  }\n\t\n\t  pre.appendChild(lineNumbersWrapper);\n\t}\n\t\n\tmodule.exports = addLineNumbers;\n\n/***/ },\n/* 241 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar delegate = __webpack_require__(148);\n\tvar addLineNumbers = __webpack_require__(240);\n\t\n\tfunction CodeTabsBox(elem) {\n\t  if (window.ebookType) {\n\t    return;\n\t  }\n\t\n\t  this.elem = elem;\n\t  this.translateX = 0;\n\t\n\t  this.switchesElem = elem.querySelector('[data-code-tabs-switches]');\n\t  this.switchesElemItems = this.switchesElem.firstElementChild;\n\t  this.arrowLeft = elem.querySelector('[data-code-tabs-left]');\n\t  this.arrowRight = elem.querySelector('[data-code-tabs-right]');\n\t\n\t  this.arrowLeft.onclick = (function (e) {\n\t    e.preventDefault();\n\t\n\t    this.translateX = Math.max(0, this.translateX - this.switchesElem.offsetWidth);\n\t    this.renderTranslate();\n\t  }).bind(this);\n\t\n\t  this.arrowRight.onclick = (function (e) {\n\t    e.preventDefault();\n\t\n\t    this.translateX = Math.min(this.translateX + this.switchesElem.offsetWidth, this.switchesElemItems.offsetWidth - this.switchesElem.offsetWidth);\n\t    this.renderTranslate();\n\t  }).bind(this);\n\t\n\t  this.delegate('.code-tabs__switch', 'click', this.onSwitchClick);\n\t}\n\t\n\tCodeTabsBox.prototype.onSwitchClick = function (e) {\n\t  e.preventDefault();\n\t\n\t  var siblings = e.delegateTarget.parentNode.children;\n\t  var tabs = this.elem.querySelector('[data-code-tabs-content]').children;\n\t\n\t  var selectedIndex;\n\t  for (var i = 0; i < siblings.length; i++) {\n\t    var switchElem = siblings[i];\n\t    var tabElem = tabs[i];\n\t    if (switchElem == e.delegateTarget) {\n\t      selectedIndex = i;\n\t      tabElem.classList.add('code-tabs__section_current');\n\t      switchElem.classList.add('code-tabs__switch_current');\n\t    } else {\n\t      tabElem.classList.remove('code-tabs__section_current');\n\t      switchElem.classList.remove('code-tabs__switch_current');\n\t    }\n\t  }\n\t\n\t  if (selectedIndex === 0) {\n\t    this.elem.classList.add('code-tabs_result_on');\n\t  } else {\n\t    this.elem.classList.remove('code-tabs_result_on');\n\t\n\t    this.highlightTab(tabs[selectedIndex]);\n\t  }\n\t};\n\t\n\tCodeTabsBox.prototype.highlightTab = function (tab) {\n\t  if (tab.highlighted) return;\n\t  var preElem = tab.querySelector('pre');\n\t  var codeElem = preElem.querySelector('code');\n\t  Prism.highlightElement(codeElem);\n\t  addLineNumbers(preElem);\n\t  tab.highlighted = true;\n\t};\n\t\n\tCodeTabsBox.prototype.renderTranslate = function () {\n\t  this.switchesElemItems.style.transform = 'translateX(-' + this.translateX + 'px)';\n\t  if (this.translateX === 0) {\n\t    this.arrowLeft.setAttribute('disabled', '');\n\t  } else {\n\t    this.arrowLeft.removeAttribute('disabled');\n\t  }\n\t\n\t  if (this.translateX === this.switchesElemItems.offsetWidth - this.switchesElem.offsetWidth) {\n\t    this.arrowRight.setAttribute('disabled', '');\n\t  } else {\n\t    this.arrowRight.removeAttribute('disabled');\n\t  }\n\t};\n\t\n\tdelegate.delegateMixin(CodeTabsBox.prototype);\n\t\n\tmodule.exports = CodeTabsBox;\n\n/***/ },\n/* 242 */,\n/* 243 */,\n/* 244 */,\n/* 245 */,\n/* 246 */,\n/* 247 */,\n/* 248 */,\n/* 249 */,\n/* 250 */,\n/* 251 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar LANG = __webpack_require__(252).lang;\n\t\n\tvar MarkdownIt = __webpack_require__(253);\n\t\n\tvar charTypographyPlugin = __webpack_require__(344);\n\tvar extendedCodePlugin = __webpack_require__(322);\n\tvar outlinedBlocksPlugin = __webpack_require__(323);\n\tvar sourceBlocksPlugin = __webpack_require__(334);\n\t\n\tvar imgDescToAttrsPlugin = __webpack_require__(338);\n\t\n\tvar markdownErrorPlugin = __webpack_require__(340);\n\tvar blockTagsPlugin = __webpack_require__(341);\n\tvar deflistPlugin = __webpack_require__(343);\n\tvar getPrismLanguage = __webpack_require__(337);\n\t\n\tmodule.exports = (function () {\n\t  function BasicParser(options) {\n\t    _classCallCheck(this, BasicParser);\n\t\n\t    options = options || {};\n\t    this.options = options;\n\t\n\t    this.env = options.env || {};\n\t    this.md = MarkdownIt(Object.assign({\n\t      typographer: true,\n\t      blockTags: getPrismLanguage.allSupported,\n\t      linkHeaderTag: false,\n\t      html: false,\n\t      quotes: LANG == 'ru' ? '' : ''\n\t    }, options));\n\t\n\t    extendedCodePlugin(this.md);\n\t    outlinedBlocksPlugin(this.md);\n\t    sourceBlocksPlugin(this.md);\n\t    imgDescToAttrsPlugin(this.md);\n\t    markdownErrorPlugin(this.md);\n\t    blockTagsPlugin(this.md);\n\t    charTypographyPlugin(this.md);\n\t    deflistPlugin(this.md);\n\t  }\n\t\n\t  _createClass(BasicParser, [{\n\t    key: 'parse',\n\t    value: function parse(text) {\n\t      return this.md.parse(text, this.env);\n\t    }\n\t  }, {\n\t    key: 'parseInline',\n\t    value: function parseInline(text) {\n\t      return this.md.parseInline(text, this.env);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render(text) {\n\t      return this.md.renderer.render(this.parse(text), this.md.options, this.env);\n\t    }\n\t  }, {\n\t    key: 'renderInline',\n\t    value: function renderInline(text) {\n\t      var tokens = this.parseInline(text);\n\t      var result = this.md.renderer.render(tokens, this.md.options, this.env);\n\t      return result;\n\t    }\n\t  }, {\n\t    key: 'renderTokens',\n\t    value: function renderTokens(tokens) {\n\t      return this.md.renderer.render(tokens, this.md.options, this.env);\n\t    }\n\t  }]);\n\t\n\t  return BasicParser;\n\t})();\n\n/***/ },\n/* 252 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = {\n\t  lang: (\"ru\")\n\t};\n\n/***/ },\n/* 253 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(254);\n\n/***/ },\n/* 254 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Main perser class\n\t\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(255);\n\tvar helpers = __webpack_require__(269);\n\tvar Renderer = __webpack_require__(273);\n\tvar ParserCore = __webpack_require__(274);\n\tvar ParserBlock = __webpack_require__(284);\n\tvar ParserInline = __webpack_require__(299);\n\tvar LinkifyIt = __webpack_require__(315);\n\tvar mdurl = __webpack_require__(259);\n\tvar punycode = __webpack_require__(317);\n\t\n\tvar config = {\n\t  'default': __webpack_require__(318),\n\t  zero: __webpack_require__(319),\n\t  commonmark: __webpack_require__(320)\n\t};\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t//\n\t// This validator can prohibit more than really needed to prevent XSS. It's a\n\t// tradeoff to keep code simple and to be secure by default.\n\t//\n\t// If you need different setup - override validator method as you wish. Or\n\t// replace it with dummy function and use external sanitizer.\n\t//\n\t\n\tvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\n\tvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n\t\n\tfunction validateLink(url) {\n\t  // url should be normalized at this point, and existing entities are decoded\n\t  var str = url.trim().toLowerCase();\n\t\n\t  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];\n\t\n\tfunction normalizeLink(url) {\n\t  var parsed = mdurl.parse(url, true);\n\t\n\t  if (parsed.hostname) {\n\t    // Encode hostnames in urls like:\n\t    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n\t    //\n\t    // We don't encode unknown schemas, because it's likely that we encode\n\t    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n\t    //\n\t    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n\t      try {\n\t        parsed.hostname = punycode.toASCII(parsed.hostname);\n\t      } catch (er) {/**/}\n\t    }\n\t  }\n\t\n\t  return mdurl.encode(mdurl.format(parsed));\n\t}\n\t\n\tfunction normalizeLinkText(url) {\n\t  var parsed = mdurl.parse(url, true);\n\t\n\t  if (parsed.hostname) {\n\t    // Encode hostnames in urls like:\n\t    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n\t    //\n\t    // We don't encode unknown schemas, because it's likely that we encode\n\t    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n\t    //\n\t    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n\t      try {\n\t        parsed.hostname = punycode.toUnicode(parsed.hostname);\n\t      } catch (er) {/**/}\n\t    }\n\t  }\n\t\n\t  return mdurl.decode(mdurl.format(parsed));\n\t}\n\t\n\t/**\n\t * class MarkdownIt\n\t *\n\t * Main parser/renderer class.\n\t *\n\t * ##### Usage\n\t *\n\t * ```javascript\n\t * // node.js, \"classic\" way:\n\t * var MarkdownIt = require('markdown-it'),\n\t *     md = new MarkdownIt();\n\t * var result = md.render('# markdown-it rulezz!');\n\t *\n\t * // node.js, the same, but with sugar:\n\t * var md = require('markdown-it')();\n\t * var result = md.render('# markdown-it rulezz!');\n\t *\n\t * // browser without AMD, added to \"window\" on script load\n\t * // Note, there are no dash.\n\t * var md = window.markdownit();\n\t * var result = md.render('# markdown-it rulezz!');\n\t * ```\n\t *\n\t * Single line rendering, without paragraph wrap:\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t * var result = md.renderInline('__markdown-it__ rulezz!');\n\t * ```\n\t **/\n\t\n\t/**\n\t * new MarkdownIt([presetName, options])\n\t * - presetName (String): optional, `commonmark` / `zero`\n\t * - options (Object)\n\t *\n\t * Creates parser instanse with given config. Can be called without `new`.\n\t *\n\t * ##### presetName\n\t *\n\t * MarkdownIt provides named presets as a convenience to quickly\n\t * enable/disable active syntax rules and options for common use cases.\n\t *\n\t * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -\n\t *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n\t * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -\n\t *   similar to GFM, used when no preset name given. Enables all available rules,\n\t *   but still without html, typographer & autolinker.\n\t * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -\n\t *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n\t *   For example, when you need only `bold` and `italic` markup and nothing else.\n\t *\n\t * ##### options:\n\t *\n\t * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n\t *   That's not safe! You may need external sanitizer to protect output from XSS.\n\t *   It's better to extend features via plugins, instead of enabling HTML.\n\t * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n\t *   (`<br />`). This is needed only for full CommonMark compatibility. In real\n\t *   world you will need HTML output.\n\t * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\n\t * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n\t *   Can be useful for external highlighters.\n\t * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n\t * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n\t *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +\n\t *   quotes beautification (smartquotes).\n\t * - __quotes__ - ``, String or Array. Double + single quotes replacement\n\t *   pairs, when typographer enabled and smartquotes on. For example, you can\n\t *   use `''` for Russian, `''` for German, and\n\t *   `['\\xA0', '\\xA0', '\\xA0', '\\xA0']` for French (including nbsp).\n\t * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n\t *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n\t *   return empty string if the source was not changed and should be escaped\n\t *   externaly. If result starts with <pre... internal wrapper is skipped.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * // commonmark mode\n\t * var md = require('markdown-it')('commonmark');\n\t *\n\t * // default mode\n\t * var md = require('markdown-it')();\n\t *\n\t * // enable everything\n\t * var md = require('markdown-it')({\n\t *   html: true,\n\t *   linkify: true,\n\t *   typographer: true\n\t * });\n\t * ```\n\t *\n\t * ##### Syntax highlighting\n\t *\n\t * ```js\n\t * var hljs = require('highlight.js') // https://highlightjs.org/\n\t *\n\t * var md = require('markdown-it')({\n\t *   highlight: function (str, lang) {\n\t *     if (lang && hljs.getLanguage(lang)) {\n\t *       try {\n\t *         return hljs.highlight(lang, str, true).value;\n\t *       } catch (__) {}\n\t *     }\n\t *\n\t *     return ''; // use external default escaping\n\t *   }\n\t * });\n\t * ```\n\t *\n\t * Or with full wrapper override (if you need assign class to `<pre>`):\n\t *\n\t * ```javascript\n\t * var hljs = require('highlight.js') // https://highlightjs.org/\n\t *\n\t * // Actual default values\n\t * var md = require('markdown-it')({\n\t *   highlight: function (str, lang) {\n\t *     if (lang && hljs.getLanguage(lang)) {\n\t *       try {\n\t *         return '<pre class=\"hljs\"><code>' +\n\t *                hljs.highlight(lang, str, true).value +\n\t *                '</code></pre>';\n\t *       } catch (__) {}\n\t *     }\n\t *\n\t *     return '<pre class=\"hljs\"><code>' + md.utils.escapeHtml(str) + '</code></pre>';\n\t *   }\n\t * });\n\t * ```\n\t *\n\t **/\n\tfunction MarkdownIt(presetName, options) {\n\t  if (!(this instanceof MarkdownIt)) {\n\t    return new MarkdownIt(presetName, options);\n\t  }\n\t\n\t  if (!options) {\n\t    if (!utils.isString(presetName)) {\n\t      options = presetName || {};\n\t      presetName = 'default';\n\t    }\n\t  }\n\t\n\t  /**\n\t   * MarkdownIt#inline -> ParserInline\n\t   *\n\t   * Instance of [[ParserInline]]. You may need it to add new rules when\n\t   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n\t   * [[MarkdownIt.enable]].\n\t   **/\n\t  this.inline = new ParserInline();\n\t\n\t  /**\n\t   * MarkdownIt#block -> ParserBlock\n\t   *\n\t   * Instance of [[ParserBlock]]. You may need it to add new rules when\n\t   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n\t   * [[MarkdownIt.enable]].\n\t   **/\n\t  this.block = new ParserBlock();\n\t\n\t  /**\n\t   * MarkdownIt#core -> Core\n\t   *\n\t   * Instance of [[Core]] chain executor. You may need it to add new rules when\n\t   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n\t   * [[MarkdownIt.enable]].\n\t   **/\n\t  this.core = new ParserCore();\n\t\n\t  /**\n\t   * MarkdownIt#renderer -> Renderer\n\t   *\n\t   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n\t   * rules for new token types, generated by plugins.\n\t   *\n\t   * ##### Example\n\t   *\n\t   * ```javascript\n\t   * var md = require('markdown-it')();\n\t   *\n\t   * function myToken(tokens, idx, options, env, self) {\n\t   *   //...\n\t   *   return result;\n\t   * };\n\t   *\n\t   * md.renderer.rules['my_token'] = myToken\n\t   * ```\n\t   *\n\t   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).\n\t   **/\n\t  this.renderer = new Renderer();\n\t\n\t  /**\n\t   * MarkdownIt#linkify -> LinkifyIt\n\t   *\n\t   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n\t   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)\n\t   * rule.\n\t   **/\n\t  this.linkify = new LinkifyIt();\n\t\n\t  /**\n\t   * MarkdownIt#validateLink(url) -> Boolean\n\t   *\n\t   * Link validation function. CommonMark allows too much in links. By default\n\t   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n\t   * except some embedded image types.\n\t   *\n\t   * You can change this behaviour:\n\t   *\n\t   * ```javascript\n\t   * var md = require('markdown-it')();\n\t   * // enable everything\n\t   * md.validateLink = function () { return true; }\n\t   * ```\n\t   **/\n\t  this.validateLink = validateLink;\n\t\n\t  /**\n\t   * MarkdownIt#normalizeLink(url) -> String\n\t   *\n\t   * Function used to encode link url to a machine-readable format,\n\t   * which includes url-encoding, punycode, etc.\n\t   **/\n\t  this.normalizeLink = normalizeLink;\n\t\n\t  /**\n\t   * MarkdownIt#normalizeLinkText(url) -> String\n\t   *\n\t   * Function used to decode link url to a human-readable format`\n\t   **/\n\t  this.normalizeLinkText = normalizeLinkText;\n\t\n\t  // Expose utils & helpers for easy acces from plugins\n\t\n\t  /**\n\t   * MarkdownIt#utils -> utils\n\t   *\n\t   * Assorted utility functions, useful to write plugins. See details\n\t   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).\n\t   **/\n\t  this.utils = utils;\n\t\n\t  /**\n\t   * MarkdownIt#helpers -> helpers\n\t   *\n\t   * Link components parser functions, useful to write plugins. See details\n\t   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n\t   **/\n\t  this.helpers = helpers;\n\t\n\t  this.options = {};\n\t  this.configure(presetName);\n\t\n\t  if (options) {\n\t    this.set(options);\n\t  }\n\t}\n\t\n\t/** chainable\n\t * MarkdownIt.set(options)\n\t *\n\t * Set parser options (in the same format as in constructor). Probably, you\n\t * will never need it, but you can change options after constructor call.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')()\n\t *             .set({ html: true, breaks: true })\n\t *             .set({ typographer, true });\n\t * ```\n\t *\n\t * __Note:__ To achieve the best possible performance, don't modify a\n\t * `markdown-it` instance options on the fly. If you need multiple configurations\n\t * it's best to create multiple instances and initialize each with separate\n\t * config.\n\t **/\n\tMarkdownIt.prototype.set = function (options) {\n\t  utils.assign(this.options, options);\n\t  return this;\n\t};\n\t\n\t/** chainable, internal\n\t * MarkdownIt.configure(presets)\n\t *\n\t * Batch load of all options and compenent settings. This is internal method,\n\t * and you probably will not need it. But if you with - see available presets\n\t * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n\t *\n\t * We strongly recommend to use presets instead of direct config loads. That\n\t * will give better compatibility with next versions.\n\t **/\n\tMarkdownIt.prototype.configure = function (presets) {\n\t  var self = this,\n\t      presetName;\n\t\n\t  if (utils.isString(presets)) {\n\t    presetName = presets;\n\t    presets = config[presetName];\n\t    if (!presets) {\n\t      throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name');\n\t    }\n\t  }\n\t\n\t  if (!presets) {\n\t    throw new Error('Wrong `markdown-it` preset, can\\'t be empty');\n\t  }\n\t\n\t  if (presets.options) {\n\t    self.set(presets.options);\n\t  }\n\t\n\t  if (presets.components) {\n\t    Object.keys(presets.components).forEach(function (name) {\n\t      if (presets.components[name].rules) {\n\t        self[name].ruler.enableOnly(presets.components[name].rules);\n\t      }\n\t      if (presets.components[name].rules2) {\n\t        self[name].ruler2.enableOnly(presets.components[name].rules2);\n\t      }\n\t    });\n\t  }\n\t  return this;\n\t};\n\t\n\t/** chainable\n\t * MarkdownIt.enable(list, ignoreInvalid)\n\t * - list (String|Array): rule name or list of rule names to enable\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Enable list or rules. It will automatically find appropriate components,\n\t * containing rules with given names. If rule not found, and `ignoreInvalid`\n\t * not set - throws exception.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')()\n\t *             .enable(['sub', 'sup'])\n\t *             .disable('smartquotes');\n\t * ```\n\t **/\n\tMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n\t  var result = [];\n\t\n\t  if (!Array.isArray(list)) {\n\t    list = [list];\n\t  }\n\t\n\t  ['core', 'block', 'inline'].forEach(function (chain) {\n\t    result = result.concat(this[chain].ruler.enable(list, true));\n\t  }, this);\n\t\n\t  result = result.concat(this.inline.ruler2.enable(list, true));\n\t\n\t  var missed = list.filter(function (name) {\n\t    return result.indexOf(name) < 0;\n\t  });\n\t\n\t  if (missed.length && !ignoreInvalid) {\n\t    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/** chainable\n\t * MarkdownIt.disable(list, ignoreInvalid)\n\t * - list (String|Array): rule name or list of rule names to disable.\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * The same as [[MarkdownIt.enable]], but turn specified rules off.\n\t **/\n\tMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n\t  var result = [];\n\t\n\t  if (!Array.isArray(list)) {\n\t    list = [list];\n\t  }\n\t\n\t  ['core', 'block', 'inline'].forEach(function (chain) {\n\t    result = result.concat(this[chain].ruler.disable(list, true));\n\t  }, this);\n\t\n\t  result = result.concat(this.inline.ruler2.disable(list, true));\n\t\n\t  var missed = list.filter(function (name) {\n\t    return result.indexOf(name) < 0;\n\t  });\n\t\n\t  if (missed.length && !ignoreInvalid) {\n\t    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);\n\t  }\n\t  return this;\n\t};\n\t\n\t/** chainable\n\t * MarkdownIt.use(plugin, params)\n\t *\n\t * Load specified plugin with given params into current parser instance.\n\t * It's just a sugar to call `plugin(md, params)` with curring.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var iterator = require('markdown-it-for-inline');\n\t * var md = require('markdown-it')()\n\t *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n\t *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n\t *             });\n\t * ```\n\t **/\n\tMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n\t  var args = [this].concat(Array.prototype.slice.call(arguments, 1));\n\t  plugin.apply(plugin, args);\n\t  return this;\n\t};\n\t\n\t/** internal\n\t * MarkdownIt.parse(src, env) -> Array\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * Parse input string and returns list of block tokens (special token type\n\t * \"inline\" will contain list of inline tokens). You should not call this\n\t * method directly, until you write custom renderer (for example, to produce\n\t * AST).\n\t *\n\t * `env` is used to pass data between \"distributed\" rules and return additional\n\t * metadata like reference info, needed for the renderer. It also can be used to\n\t * inject data in specific cases. Usually, you will be ok to pass `{}`,\n\t * and then pass updated object to renderer.\n\t **/\n\tMarkdownIt.prototype.parse = function (src, env) {\n\t  var state = new this.core.State(src, this, env);\n\t\n\t  this.core.process(state);\n\t\n\t  return state.tokens;\n\t};\n\t\n\t/**\n\t * MarkdownIt.render(src [, env]) -> String\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * Render markdown string into html. It does all magic for you :).\n\t *\n\t * `env` can be used to inject additional metadata (`{}` by default).\n\t * But you will not need it with high probability. See also comment\n\t * in [[MarkdownIt.parse]].\n\t **/\n\tMarkdownIt.prototype.render = function (src, env) {\n\t  env = env || {};\n\t\n\t  return this.renderer.render(this.parse(src, env), this.options, env);\n\t};\n\t\n\t/** internal\n\t * MarkdownIt.parseInline(src, env) -> Array\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n\t * block tokens list with the single `inline` element, containing parsed inline\n\t * tokens in `children` property. Also updates `env` object.\n\t **/\n\tMarkdownIt.prototype.parseInline = function (src, env) {\n\t  var state = new this.core.State(src, this, env);\n\t\n\t  state.inlineMode = true;\n\t  this.core.process(state);\n\t\n\t  return state.tokens;\n\t};\n\t\n\t/**\n\t * MarkdownIt.renderInline(src [, env]) -> String\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n\t * will NOT be wrapped into `<p>` tags.\n\t **/\n\tMarkdownIt.prototype.renderInline = function (src, env) {\n\t  env = env || {};\n\t\n\t  return this.renderer.render(this.parseInline(src, env), this.options, env);\n\t};\n\t\n\tmodule.exports = MarkdownIt;\n\n/***/ },\n/* 255 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Utilities\n\t//\n\t'use strict';\n\t\n\tfunction _class(obj) {\n\t  return Object.prototype.toString.call(obj);\n\t}\n\t\n\tfunction isString(obj) {\n\t  return _class(obj) === '[object String]';\n\t}\n\t\n\tvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\tfunction has(object, key) {\n\t  return _hasOwnProperty.call(object, key);\n\t}\n\t\n\t// Merge objects\n\t//\n\tfunction assign(obj /*from1, from2, from3, ...*/) {\n\t  var sources = Array.prototype.slice.call(arguments, 1);\n\t\n\t  sources.forEach(function (source) {\n\t    if (!source) {\n\t      return;\n\t    }\n\t\n\t    if (typeof source !== 'object') {\n\t      throw new TypeError(source + 'must be object');\n\t    }\n\t\n\t    Object.keys(source).forEach(function (key) {\n\t      obj[key] = source[key];\n\t    });\n\t  });\n\t\n\t  return obj;\n\t}\n\t\n\t// Remove element from array and put another array at those position.\n\t// Useful for some operations with tokens\n\tfunction arrayReplaceAt(src, pos, newElements) {\n\t  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tfunction isValidEntityCode(c) {\n\t  /*eslint no-bitwise:0*/\n\t  // broken sequence\n\t  if (c >= 0xD800 && c <= 0xDFFF) {\n\t    return false;\n\t  }\n\t  // never used\n\t  if (c >= 0xFDD0 && c <= 0xFDEF) {\n\t    return false;\n\t  }\n\t  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {\n\t    return false;\n\t  }\n\t  // control codes\n\t  if (c >= 0x00 && c <= 0x08) {\n\t    return false;\n\t  }\n\t  if (c === 0x0B) {\n\t    return false;\n\t  }\n\t  if (c >= 0x0E && c <= 0x1F) {\n\t    return false;\n\t  }\n\t  if (c >= 0x7F && c <= 0x9F) {\n\t    return false;\n\t  }\n\t  // out of range\n\t  if (c > 0x10FFFF) {\n\t    return false;\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction fromCodePoint(c) {\n\t  /*eslint no-bitwise:0*/\n\t  if (c > 0xffff) {\n\t    c -= 0x10000;\n\t    var surrogate1 = 0xd800 + (c >> 10),\n\t        surrogate2 = 0xdc00 + (c & 0x3ff);\n\t\n\t    return String.fromCharCode(surrogate1, surrogate2);\n\t  }\n\t  return String.fromCharCode(c);\n\t}\n\t\n\tvar UNESCAPE_MD_RE = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\n\tvar ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\n\tvar UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');\n\t\n\tvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\t\n\tvar entities = __webpack_require__(256);\n\t\n\tfunction replaceEntityPattern(match, name) {\n\t  var code = 0;\n\t\n\t  if (has(entities, name)) {\n\t    return entities[name];\n\t  }\n\t\n\t  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n\t    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n\t    if (isValidEntityCode(code)) {\n\t      return fromCodePoint(code);\n\t    }\n\t  }\n\t\n\t  return match;\n\t}\n\t\n\t/*function replaceEntities(str) {\n\t  if (str.indexOf('&') < 0) { return str; }\n\t\n\t  return str.replace(ENTITY_RE, replaceEntityPattern);\n\t}*/\n\t\n\tfunction unescapeMd(str) {\n\t  if (str.indexOf('\\\\') < 0) {\n\t    return str;\n\t  }\n\t  return str.replace(UNESCAPE_MD_RE, '$1');\n\t}\n\t\n\tfunction unescapeAll(str) {\n\t  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) {\n\t    return str;\n\t  }\n\t\n\t  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n\t    if (escaped) {\n\t      return escaped;\n\t    }\n\t    return replaceEntityPattern(match, entity);\n\t  });\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\n\tvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\n\tvar HTML_REPLACEMENTS = {\n\t  '&': '&amp;',\n\t  '<': '&lt;',\n\t  '>': '&gt;',\n\t  '\"': '&quot;'\n\t};\n\t\n\tfunction replaceUnsafeChar(ch) {\n\t  return HTML_REPLACEMENTS[ch];\n\t}\n\t\n\tfunction escapeHtml(str) {\n\t  if (HTML_ESCAPE_TEST_RE.test(str)) {\n\t    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n\t  }\n\t  return str;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n\t\n\tfunction escapeRE(str) {\n\t  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&');\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tfunction isSpace(code) {\n\t  switch (code) {\n\t    case 0x09:\n\t    case 0x20:\n\t      return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t// Zs (unicode class) || [\\t\\f\\v\\r\\n]\n\tfunction isWhiteSpace(code) {\n\t  if (code >= 0x2000 && code <= 0x200A) {\n\t    return true;\n\t  }\n\t  switch (code) {\n\t    case 0x09: // \\t\n\t    case 0x0A: // \\n\n\t    case 0x0B: // \\v\n\t    case 0x0C: // \\f\n\t    case 0x0D: // \\r\n\t    case 0x20:\n\t    case 0xA0:\n\t    case 0x1680:\n\t    case 0x202F:\n\t    case 0x205F:\n\t    case 0x3000:\n\t      return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t/*eslint-disable max-len*/\n\tvar UNICODE_PUNCT_RE = __webpack_require__(258);\n\t\n\t// Currently without astral characters support.\n\tfunction isPunctChar(ch) {\n\t  return UNICODE_PUNCT_RE.test(ch);\n\t}\n\t\n\t// Markdown ASCII punctuation characters.\n\t//\n\t// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\t// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n\t//\n\t// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n\t//\n\tfunction isMdAsciiPunct(ch) {\n\t  switch (ch) {\n\t    case 0x21 /* ! */:\n\t    case 0x22 /* \" */:\n\t    case 0x23 /* # */:\n\t    case 0x24 /* $ */:\n\t    case 0x25 /* % */:\n\t    case 0x26 /* & */:\n\t    case 0x27 /* ' */:\n\t    case 0x28 /* ( */:\n\t    case 0x29 /* ) */:\n\t    case 0x2A /* * */:\n\t    case 0x2B /* + */:\n\t    case 0x2C /* , */:\n\t    case 0x2D /* - */:\n\t    case 0x2E /* . */:\n\t    case 0x2F /* / */:\n\t    case 0x3A /* : */:\n\t    case 0x3B /* ; */:\n\t    case 0x3C /* < */:\n\t    case 0x3D /* = */:\n\t    case 0x3E /* > */:\n\t    case 0x3F /* ? */:\n\t    case 0x40 /* @ */:\n\t    case 0x5B /* [ */:\n\t    case 0x5C /* \\ */:\n\t    case 0x5D /* ] */:\n\t    case 0x5E /* ^ */:\n\t    case 0x5F /* _ */:\n\t    case 0x60 /* ` */:\n\t    case 0x7B /* { */:\n\t    case 0x7C /* | */:\n\t    case 0x7D /* } */:\n\t    case 0x7E /* ~ */:\n\t      return true;\n\t    default:\n\t      return false;\n\t  }\n\t}\n\t\n\t// Hepler to unify [reference labels].\n\t//\n\tfunction normalizeReference(str) {\n\t  // use .toUpperCase() instead of .toLowerCase()\n\t  // here to avoid a conflict with Object.prototype\n\t  // members (most notably, `__proto__`)\n\t  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t// Re-export libraries commonly used in both markdown-it and its plugins,\n\t// so plugins won't have to depend on them explicitly, which reduces their\n\t// bundled size (e.g. a browser build).\n\t//\n\texports.lib = {};\n\texports.lib.mdurl = __webpack_require__(259);\n\texports.lib.ucmicro = __webpack_require__(264);\n\t\n\texports.assign = assign;\n\texports.isString = isString;\n\texports.has = has;\n\texports.unescapeMd = unescapeMd;\n\texports.unescapeAll = unescapeAll;\n\texports.isValidEntityCode = isValidEntityCode;\n\texports.fromCodePoint = fromCodePoint;\n\t// exports.replaceEntities     = replaceEntities;\n\texports.escapeHtml = escapeHtml;\n\texports.arrayReplaceAt = arrayReplaceAt;\n\texports.isSpace = isSpace;\n\texports.isWhiteSpace = isWhiteSpace;\n\texports.isMdAsciiPunct = isMdAsciiPunct;\n\texports.isPunctChar = isPunctChar;\n\texports.escapeRE = escapeRE;\n\texports.normalizeReference = normalizeReference;\n\n/***/ },\n/* 256 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// HTML5 entities map: { name -> utf16string }\n\t//\n\t'use strict';\n\t\n\t/*eslint quotes:0*/\n\tmodule.exports = __webpack_require__(257);\n\n/***/ },\n/* 257 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"Aacute\": \"\",\n\t\t\"aacute\": \"\",\n\t\t\"Abreve\": \"\",\n\t\t\"abreve\": \"\",\n\t\t\"ac\": \"\",\n\t\t\"acd\": \"\",\n\t\t\"acE\": \"\",\n\t\t\"Acirc\": \"\",\n\t\t\"acirc\": \"\",\n\t\t\"acute\": \"\",\n\t\t\"Acy\": \"\",\n\t\t\"acy\": \"\",\n\t\t\"AElig\": \"\",\n\t\t\"aelig\": \"\",\n\t\t\"af\": \"\",\n\t\t\"Afr\": \"\",\n\t\t\"afr\": \"\",\n\t\t\"Agrave\": \"\",\n\t\t\"agrave\": \"\",\n\t\t\"alefsym\": \"\",\n\t\t\"aleph\": \"\",\n\t\t\"Alpha\": \"\",\n\t\t\"alpha\": \"\",\n\t\t\"Amacr\": \"\",\n\t\t\"amacr\": \"\",\n\t\t\"amalg\": \"\",\n\t\t\"amp\": \"&\",\n\t\t\"AMP\": \"&\",\n\t\t\"andand\": \"\",\n\t\t\"And\": \"\",\n\t\t\"and\": \"\",\n\t\t\"andd\": \"\",\n\t\t\"andslope\": \"\",\n\t\t\"andv\": \"\",\n\t\t\"ang\": \"\",\n\t\t\"ange\": \"\",\n\t\t\"angle\": \"\",\n\t\t\"angmsdaa\": \"\",\n\t\t\"angmsdab\": \"\",\n\t\t\"angmsdac\": \"\",\n\t\t\"angmsdad\": \"\",\n\t\t\"angmsdae\": \"\",\n\t\t\"angmsdaf\": \"\",\n\t\t\"angmsdag\": \"\",\n\t\t\"angmsdah\": \"\",\n\t\t\"angmsd\": \"\",\n\t\t\"angrt\": \"\",\n\t\t\"angrtvb\": \"\",\n\t\t\"angrtvbd\": \"\",\n\t\t\"angsph\": \"\",\n\t\t\"angst\": \"\",\n\t\t\"angzarr\": \"\",\n\t\t\"Aogon\": \"\",\n\t\t\"aogon\": \"\",\n\t\t\"Aopf\": \"\",\n\t\t\"aopf\": \"\",\n\t\t\"apacir\": \"\",\n\t\t\"ap\": \"\",\n\t\t\"apE\": \"\",\n\t\t\"ape\": \"\",\n\t\t\"apid\": \"\",\n\t\t\"apos\": \"'\",\n\t\t\"ApplyFunction\": \"\",\n\t\t\"approx\": \"\",\n\t\t\"approxeq\": \"\",\n\t\t\"Aring\": \"\",\n\t\t\"aring\": \"\",\n\t\t\"Ascr\": \"\",\n\t\t\"ascr\": \"\",\n\t\t\"Assign\": \"\",\n\t\t\"ast\": \"*\",\n\t\t\"asymp\": \"\",\n\t\t\"asympeq\": \"\",\n\t\t\"Atilde\": \"\",\n\t\t\"atilde\": \"\",\n\t\t\"Auml\": \"\",\n\t\t\"auml\": \"\",\n\t\t\"awconint\": \"\",\n\t\t\"awint\": \"\",\n\t\t\"backcong\": \"\",\n\t\t\"backepsilon\": \"\",\n\t\t\"backprime\": \"\",\n\t\t\"backsim\": \"\",\n\t\t\"backsimeq\": \"\",\n\t\t\"Backslash\": \"\",\n\t\t\"Barv\": \"\",\n\t\t\"barvee\": \"\",\n\t\t\"barwed\": \"\",\n\t\t\"Barwed\": \"\",\n\t\t\"barwedge\": \"\",\n\t\t\"bbrk\": \"\",\n\t\t\"bbrktbrk\": \"\",\n\t\t\"bcong\": \"\",\n\t\t\"Bcy\": \"\",\n\t\t\"bcy\": \"\",\n\t\t\"bdquo\": \"\",\n\t\t\"becaus\": \"\",\n\t\t\"because\": \"\",\n\t\t\"Because\": \"\",\n\t\t\"bemptyv\": \"\",\n\t\t\"bepsi\": \"\",\n\t\t\"bernou\": \"\",\n\t\t\"Bernoullis\": \"\",\n\t\t\"Beta\": \"\",\n\t\t\"beta\": \"\",\n\t\t\"beth\": \"\",\n\t\t\"between\": \"\",\n\t\t\"Bfr\": \"\",\n\t\t\"bfr\": \"\",\n\t\t\"bigcap\": \"\",\n\t\t\"bigcirc\": \"\",\n\t\t\"bigcup\": \"\",\n\t\t\"bigodot\": \"\",\n\t\t\"bigoplus\": \"\",\n\t\t\"bigotimes\": \"\",\n\t\t\"bigsqcup\": \"\",\n\t\t\"bigstar\": \"\",\n\t\t\"bigtriangledown\": \"\",\n\t\t\"bigtriangleup\": \"\",\n\t\t\"biguplus\": \"\",\n\t\t\"bigvee\": \"\",\n\t\t\"bigwedge\": \"\",\n\t\t\"bkarow\": \"\",\n\t\t\"blacklozenge\": \"\",\n\t\t\"blacksquare\": \"\",\n\t\t\"blacktriangle\": \"\",\n\t\t\"blacktriangledown\": \"\",\n\t\t\"blacktriangleleft\": \"\",\n\t\t\"blacktriangleright\": \"\",\n\t\t\"blank\": \"\",\n\t\t\"blk12\": \"\",\n\t\t\"blk14\": \"\",\n\t\t\"blk34\": \"\",\n\t\t\"block\": \"\",\n\t\t\"bne\": \"=\",\n\t\t\"bnequiv\": \"\",\n\t\t\"bNot\": \"\",\n\t\t\"bnot\": \"\",\n\t\t\"Bopf\": \"\",\n\t\t\"bopf\": \"\",\n\t\t\"bot\": \"\",\n\t\t\"bottom\": \"\",\n\t\t\"bowtie\": \"\",\n\t\t\"boxbox\": \"\",\n\t\t\"boxdl\": \"\",\n\t\t\"boxdL\": \"\",\n\t\t\"boxDl\": \"\",\n\t\t\"boxDL\": \"\",\n\t\t\"boxdr\": \"\",\n\t\t\"boxdR\": \"\",\n\t\t\"boxDr\": \"\",\n\t\t\"boxDR\": \"\",\n\t\t\"boxh\": \"\",\n\t\t\"boxH\": \"\",\n\t\t\"boxhd\": \"\",\n\t\t\"boxHd\": \"\",\n\t\t\"boxhD\": \"\",\n\t\t\"boxHD\": \"\",\n\t\t\"boxhu\": \"\",\n\t\t\"boxHu\": \"\",\n\t\t\"boxhU\": \"\",\n\t\t\"boxHU\": \"\",\n\t\t\"boxminus\": \"\",\n\t\t\"boxplus\": \"\",\n\t\t\"boxtimes\": \"\",\n\t\t\"boxul\": \"\",\n\t\t\"boxuL\": \"\",\n\t\t\"boxUl\": \"\",\n\t\t\"boxUL\": \"\",\n\t\t\"boxur\": \"\",\n\t\t\"boxuR\": \"\",\n\t\t\"boxUr\": \"\",\n\t\t\"boxUR\": \"\",\n\t\t\"boxv\": \"\",\n\t\t\"boxV\": \"\",\n\t\t\"boxvh\": \"\",\n\t\t\"boxvH\": \"\",\n\t\t\"boxVh\": \"\",\n\t\t\"boxVH\": \"\",\n\t\t\"boxvl\": \"\",\n\t\t\"boxvL\": \"\",\n\t\t\"boxVl\": \"\",\n\t\t\"boxVL\": \"\",\n\t\t\"boxvr\": \"\",\n\t\t\"boxvR\": \"\",\n\t\t\"boxVr\": \"\",\n\t\t\"boxVR\": \"\",\n\t\t\"bprime\": \"\",\n\t\t\"breve\": \"\",\n\t\t\"Breve\": \"\",\n\t\t\"brvbar\": \"\",\n\t\t\"bscr\": \"\",\n\t\t\"Bscr\": \"\",\n\t\t\"bsemi\": \"\",\n\t\t\"bsim\": \"\",\n\t\t\"bsime\": \"\",\n\t\t\"bsolb\": \"\",\n\t\t\"bsol\": \"\\\\\",\n\t\t\"bsolhsub\": \"\",\n\t\t\"bull\": \"\",\n\t\t\"bullet\": \"\",\n\t\t\"bump\": \"\",\n\t\t\"bumpE\": \"\",\n\t\t\"bumpe\": \"\",\n\t\t\"Bumpeq\": \"\",\n\t\t\"bumpeq\": \"\",\n\t\t\"Cacute\": \"\",\n\t\t\"cacute\": \"\",\n\t\t\"capand\": \"\",\n\t\t\"capbrcup\": \"\",\n\t\t\"capcap\": \"\",\n\t\t\"cap\": \"\",\n\t\t\"Cap\": \"\",\n\t\t\"capcup\": \"\",\n\t\t\"capdot\": \"\",\n\t\t\"CapitalDifferentialD\": \"\",\n\t\t\"caps\": \"\",\n\t\t\"caret\": \"\",\n\t\t\"caron\": \"\",\n\t\t\"Cayleys\": \"\",\n\t\t\"ccaps\": \"\",\n\t\t\"Ccaron\": \"\",\n\t\t\"ccaron\": \"\",\n\t\t\"Ccedil\": \"\",\n\t\t\"ccedil\": \"\",\n\t\t\"Ccirc\": \"\",\n\t\t\"ccirc\": \"\",\n\t\t\"Cconint\": \"\",\n\t\t\"ccups\": \"\",\n\t\t\"ccupssm\": \"\",\n\t\t\"Cdot\": \"\",\n\t\t\"cdot\": \"\",\n\t\t\"cedil\": \"\",\n\t\t\"Cedilla\": \"\",\n\t\t\"cemptyv\": \"\",\n\t\t\"cent\": \"\",\n\t\t\"centerdot\": \"\",\n\t\t\"CenterDot\": \"\",\n\t\t\"cfr\": \"\",\n\t\t\"Cfr\": \"\",\n\t\t\"CHcy\": \"\",\n\t\t\"chcy\": \"\",\n\t\t\"check\": \"\",\n\t\t\"checkmark\": \"\",\n\t\t\"Chi\": \"\",\n\t\t\"chi\": \"\",\n\t\t\"circ\": \"\",\n\t\t\"circeq\": \"\",\n\t\t\"circlearrowleft\": \"\",\n\t\t\"circlearrowright\": \"\",\n\t\t\"circledast\": \"\",\n\t\t\"circledcirc\": \"\",\n\t\t\"circleddash\": \"\",\n\t\t\"CircleDot\": \"\",\n\t\t\"circledR\": \"\",\n\t\t\"circledS\": \"\",\n\t\t\"CircleMinus\": \"\",\n\t\t\"CirclePlus\": \"\",\n\t\t\"CircleTimes\": \"\",\n\t\t\"cir\": \"\",\n\t\t\"cirE\": \"\",\n\t\t\"cire\": \"\",\n\t\t\"cirfnint\": \"\",\n\t\t\"cirmid\": \"\",\n\t\t\"cirscir\": \"\",\n\t\t\"ClockwiseContourIntegral\": \"\",\n\t\t\"CloseCurlyDoubleQuote\": \"\",\n\t\t\"CloseCurlyQuote\": \"\",\n\t\t\"clubs\": \"\",\n\t\t\"clubsuit\": \"\",\n\t\t\"colon\": \":\",\n\t\t\"Colon\": \"\",\n\t\t\"Colone\": \"\",\n\t\t\"colone\": \"\",\n\t\t\"coloneq\": \"\",\n\t\t\"comma\": \",\",\n\t\t\"commat\": \"@\",\n\t\t\"comp\": \"\",\n\t\t\"compfn\": \"\",\n\t\t\"complement\": \"\",\n\t\t\"complexes\": \"\",\n\t\t\"cong\": \"\",\n\t\t\"congdot\": \"\",\n\t\t\"Congruent\": \"\",\n\t\t\"conint\": \"\",\n\t\t\"Conint\": \"\",\n\t\t\"ContourIntegral\": \"\",\n\t\t\"copf\": \"\",\n\t\t\"Copf\": \"\",\n\t\t\"coprod\": \"\",\n\t\t\"Coproduct\": \"\",\n\t\t\"copy\": \"\",\n\t\t\"COPY\": \"\",\n\t\t\"copysr\": \"\",\n\t\t\"CounterClockwiseContourIntegral\": \"\",\n\t\t\"crarr\": \"\",\n\t\t\"cross\": \"\",\n\t\t\"Cross\": \"\",\n\t\t\"Cscr\": \"\",\n\t\t\"cscr\": \"\",\n\t\t\"csub\": \"\",\n\t\t\"csube\": \"\",\n\t\t\"csup\": \"\",\n\t\t\"csupe\": \"\",\n\t\t\"ctdot\": \"\",\n\t\t\"cudarrl\": \"\",\n\t\t\"cudarrr\": \"\",\n\t\t\"cuepr\": \"\",\n\t\t\"cuesc\": \"\",\n\t\t\"cularr\": \"\",\n\t\t\"cularrp\": \"\",\n\t\t\"cupbrcap\": \"\",\n\t\t\"cupcap\": \"\",\n\t\t\"CupCap\": \"\",\n\t\t\"cup\": \"\",\n\t\t\"Cup\": \"\",\n\t\t\"cupcup\": \"\",\n\t\t\"cupdot\": \"\",\n\t\t\"cupor\": \"\",\n\t\t\"cups\": \"\",\n\t\t\"curarr\": \"\",\n\t\t\"curarrm\": \"\",\n\t\t\"curlyeqprec\": \"\",\n\t\t\"curlyeqsucc\": \"\",\n\t\t\"curlyvee\": \"\",\n\t\t\"curlywedge\": \"\",\n\t\t\"curren\": \"\",\n\t\t\"curvearrowleft\": \"\",\n\t\t\"curvearrowright\": \"\",\n\t\t\"cuvee\": \"\",\n\t\t\"cuwed\": \"\",\n\t\t\"cwconint\": \"\",\n\t\t\"cwint\": \"\",\n\t\t\"cylcty\": \"\",\n\t\t\"dagger\": \"\",\n\t\t\"Dagger\": \"\",\n\t\t\"daleth\": \"\",\n\t\t\"darr\": \"\",\n\t\t\"Darr\": \"\",\n\t\t\"dArr\": \"\",\n\t\t\"dash\": \"\",\n\t\t\"Dashv\": \"\",\n\t\t\"dashv\": \"\",\n\t\t\"dbkarow\": \"\",\n\t\t\"dblac\": \"\",\n\t\t\"Dcaron\": \"\",\n\t\t\"dcaron\": \"\",\n\t\t\"Dcy\": \"\",\n\t\t\"dcy\": \"\",\n\t\t\"ddagger\": \"\",\n\t\t\"ddarr\": \"\",\n\t\t\"DD\": \"\",\n\t\t\"dd\": \"\",\n\t\t\"DDotrahd\": \"\",\n\t\t\"ddotseq\": \"\",\n\t\t\"deg\": \"\",\n\t\t\"Del\": \"\",\n\t\t\"Delta\": \"\",\n\t\t\"delta\": \"\",\n\t\t\"demptyv\": \"\",\n\t\t\"dfisht\": \"\",\n\t\t\"Dfr\": \"\",\n\t\t\"dfr\": \"\",\n\t\t\"dHar\": \"\",\n\t\t\"dharl\": \"\",\n\t\t\"dharr\": \"\",\n\t\t\"DiacriticalAcute\": \"\",\n\t\t\"DiacriticalDot\": \"\",\n\t\t\"DiacriticalDoubleAcute\": \"\",\n\t\t\"DiacriticalGrave\": \"`\",\n\t\t\"DiacriticalTilde\": \"\",\n\t\t\"diam\": \"\",\n\t\t\"diamond\": \"\",\n\t\t\"Diamond\": \"\",\n\t\t\"diamondsuit\": \"\",\n\t\t\"diams\": \"\",\n\t\t\"die\": \"\",\n\t\t\"DifferentialD\": \"\",\n\t\t\"digamma\": \"\",\n\t\t\"disin\": \"\",\n\t\t\"div\": \"\",\n\t\t\"divide\": \"\",\n\t\t\"divideontimes\": \"\",\n\t\t\"divonx\": \"\",\n\t\t\"DJcy\": \"\",\n\t\t\"djcy\": \"\",\n\t\t\"dlcorn\": \"\",\n\t\t\"dlcrop\": \"\",\n\t\t\"dollar\": \"$\",\n\t\t\"Dopf\": \"\",\n\t\t\"dopf\": \"\",\n\t\t\"Dot\": \"\",\n\t\t\"dot\": \"\",\n\t\t\"DotDot\": \"\",\n\t\t\"doteq\": \"\",\n\t\t\"doteqdot\": \"\",\n\t\t\"DotEqual\": \"\",\n\t\t\"dotminus\": \"\",\n\t\t\"dotplus\": \"\",\n\t\t\"dotsquare\": \"\",\n\t\t\"doublebarwedge\": \"\",\n\t\t\"DoubleContourIntegral\": \"\",\n\t\t\"DoubleDot\": \"\",\n\t\t\"DoubleDownArrow\": \"\",\n\t\t\"DoubleLeftArrow\": \"\",\n\t\t\"DoubleLeftRightArrow\": \"\",\n\t\t\"DoubleLeftTee\": \"\",\n\t\t\"DoubleLongLeftArrow\": \"\",\n\t\t\"DoubleLongLeftRightArrow\": \"\",\n\t\t\"DoubleLongRightArrow\": \"\",\n\t\t\"DoubleRightArrow\": \"\",\n\t\t\"DoubleRightTee\": \"\",\n\t\t\"DoubleUpArrow\": \"\",\n\t\t\"DoubleUpDownArrow\": \"\",\n\t\t\"DoubleVerticalBar\": \"\",\n\t\t\"DownArrowBar\": \"\",\n\t\t\"downarrow\": \"\",\n\t\t\"DownArrow\": \"\",\n\t\t\"Downarrow\": \"\",\n\t\t\"DownArrowUpArrow\": \"\",\n\t\t\"DownBreve\": \"\",\n\t\t\"downdownarrows\": \"\",\n\t\t\"downharpoonleft\": \"\",\n\t\t\"downharpoonright\": \"\",\n\t\t\"DownLeftRightVector\": \"\",\n\t\t\"DownLeftTeeVector\": \"\",\n\t\t\"DownLeftVectorBar\": \"\",\n\t\t\"DownLeftVector\": \"\",\n\t\t\"DownRightTeeVector\": \"\",\n\t\t\"DownRightVectorBar\": \"\",\n\t\t\"DownRightVector\": \"\",\n\t\t\"DownTeeArrow\": \"\",\n\t\t\"DownTee\": \"\",\n\t\t\"drbkarow\": \"\",\n\t\t\"drcorn\": \"\",\n\t\t\"drcrop\": \"\",\n\t\t\"Dscr\": \"\",\n\t\t\"dscr\": \"\",\n\t\t\"DScy\": \"\",\n\t\t\"dscy\": \"\",\n\t\t\"dsol\": \"\",\n\t\t\"Dstrok\": \"\",\n\t\t\"dstrok\": \"\",\n\t\t\"dtdot\": \"\",\n\t\t\"dtri\": \"\",\n\t\t\"dtrif\": \"\",\n\t\t\"duarr\": \"\",\n\t\t\"duhar\": \"\",\n\t\t\"dwangle\": \"\",\n\t\t\"DZcy\": \"\",\n\t\t\"dzcy\": \"\",\n\t\t\"dzigrarr\": \"\",\n\t\t\"Eacute\": \"\",\n\t\t\"eacute\": \"\",\n\t\t\"easter\": \"\",\n\t\t\"Ecaron\": \"\",\n\t\t\"ecaron\": \"\",\n\t\t\"Ecirc\": \"\",\n\t\t\"ecirc\": \"\",\n\t\t\"ecir\": \"\",\n\t\t\"ecolon\": \"\",\n\t\t\"Ecy\": \"\",\n\t\t\"ecy\": \"\",\n\t\t\"eDDot\": \"\",\n\t\t\"Edot\": \"\",\n\t\t\"edot\": \"\",\n\t\t\"eDot\": \"\",\n\t\t\"ee\": \"\",\n\t\t\"efDot\": \"\",\n\t\t\"Efr\": \"\",\n\t\t\"efr\": \"\",\n\t\t\"eg\": \"\",\n\t\t\"Egrave\": \"\",\n\t\t\"egrave\": \"\",\n\t\t\"egs\": \"\",\n\t\t\"egsdot\": \"\",\n\t\t\"el\": \"\",\n\t\t\"Element\": \"\",\n\t\t\"elinters\": \"\",\n\t\t\"ell\": \"\",\n\t\t\"els\": \"\",\n\t\t\"elsdot\": \"\",\n\t\t\"Emacr\": \"\",\n\t\t\"emacr\": \"\",\n\t\t\"empty\": \"\",\n\t\t\"emptyset\": \"\",\n\t\t\"EmptySmallSquare\": \"\",\n\t\t\"emptyv\": \"\",\n\t\t\"EmptyVerySmallSquare\": \"\",\n\t\t\"emsp13\": \"\",\n\t\t\"emsp14\": \"\",\n\t\t\"emsp\": \"\",\n\t\t\"ENG\": \"\",\n\t\t\"eng\": \"\",\n\t\t\"ensp\": \"\",\n\t\t\"Eogon\": \"\",\n\t\t\"eogon\": \"\",\n\t\t\"Eopf\": \"\",\n\t\t\"eopf\": \"\",\n\t\t\"epar\": \"\",\n\t\t\"eparsl\": \"\",\n\t\t\"eplus\": \"\",\n\t\t\"epsi\": \"\",\n\t\t\"Epsilon\": \"\",\n\t\t\"epsilon\": \"\",\n\t\t\"epsiv\": \"\",\n\t\t\"eqcirc\": \"\",\n\t\t\"eqcolon\": \"\",\n\t\t\"eqsim\": \"\",\n\t\t\"eqslantgtr\": \"\",\n\t\t\"eqslantless\": \"\",\n\t\t\"Equal\": \"\",\n\t\t\"equals\": \"=\",\n\t\t\"EqualTilde\": \"\",\n\t\t\"equest\": \"\",\n\t\t\"Equilibrium\": \"\",\n\t\t\"equiv\": \"\",\n\t\t\"equivDD\": \"\",\n\t\t\"eqvparsl\": \"\",\n\t\t\"erarr\": \"\",\n\t\t\"erDot\": \"\",\n\t\t\"escr\": \"\",\n\t\t\"Escr\": \"\",\n\t\t\"esdot\": \"\",\n\t\t\"Esim\": \"\",\n\t\t\"esim\": \"\",\n\t\t\"Eta\": \"\",\n\t\t\"eta\": \"\",\n\t\t\"ETH\": \"\",\n\t\t\"eth\": \"\",\n\t\t\"Euml\": \"\",\n\t\t\"euml\": \"\",\n\t\t\"euro\": \"\",\n\t\t\"excl\": \"!\",\n\t\t\"exist\": \"\",\n\t\t\"Exists\": \"\",\n\t\t\"expectation\": \"\",\n\t\t\"exponentiale\": \"\",\n\t\t\"ExponentialE\": \"\",\n\t\t\"fallingdotseq\": \"\",\n\t\t\"Fcy\": \"\",\n\t\t\"fcy\": \"\",\n\t\t\"female\": \"\",\n\t\t\"ffilig\": \"\",\n\t\t\"fflig\": \"\",\n\t\t\"ffllig\": \"\",\n\t\t\"Ffr\": \"\",\n\t\t\"ffr\": \"\",\n\t\t\"filig\": \"\",\n\t\t\"FilledSmallSquare\": \"\",\n\t\t\"FilledVerySmallSquare\": \"\",\n\t\t\"fjlig\": \"fj\",\n\t\t\"flat\": \"\",\n\t\t\"fllig\": \"\",\n\t\t\"fltns\": \"\",\n\t\t\"fnof\": \"\",\n\t\t\"Fopf\": \"\",\n\t\t\"fopf\": \"\",\n\t\t\"forall\": \"\",\n\t\t\"ForAll\": \"\",\n\t\t\"fork\": \"\",\n\t\t\"forkv\": \"\",\n\t\t\"Fouriertrf\": \"\",\n\t\t\"fpartint\": \"\",\n\t\t\"frac12\": \"\",\n\t\t\"frac13\": \"\",\n\t\t\"frac14\": \"\",\n\t\t\"frac15\": \"\",\n\t\t\"frac16\": \"\",\n\t\t\"frac18\": \"\",\n\t\t\"frac23\": \"\",\n\t\t\"frac25\": \"\",\n\t\t\"frac34\": \"\",\n\t\t\"frac35\": \"\",\n\t\t\"frac38\": \"\",\n\t\t\"frac45\": \"\",\n\t\t\"frac56\": \"\",\n\t\t\"frac58\": \"\",\n\t\t\"frac78\": \"\",\n\t\t\"frasl\": \"\",\n\t\t\"frown\": \"\",\n\t\t\"fscr\": \"\",\n\t\t\"Fscr\": \"\",\n\t\t\"gacute\": \"\",\n\t\t\"Gamma\": \"\",\n\t\t\"gamma\": \"\",\n\t\t\"Gammad\": \"\",\n\t\t\"gammad\": \"\",\n\t\t\"gap\": \"\",\n\t\t\"Gbreve\": \"\",\n\t\t\"gbreve\": \"\",\n\t\t\"Gcedil\": \"\",\n\t\t\"Gcirc\": \"\",\n\t\t\"gcirc\": \"\",\n\t\t\"Gcy\": \"\",\n\t\t\"gcy\": \"\",\n\t\t\"Gdot\": \"\",\n\t\t\"gdot\": \"\",\n\t\t\"ge\": \"\",\n\t\t\"gE\": \"\",\n\t\t\"gEl\": \"\",\n\t\t\"gel\": \"\",\n\t\t\"geq\": \"\",\n\t\t\"geqq\": \"\",\n\t\t\"geqslant\": \"\",\n\t\t\"gescc\": \"\",\n\t\t\"ges\": \"\",\n\t\t\"gesdot\": \"\",\n\t\t\"gesdoto\": \"\",\n\t\t\"gesdotol\": \"\",\n\t\t\"gesl\": \"\",\n\t\t\"gesles\": \"\",\n\t\t\"Gfr\": \"\",\n\t\t\"gfr\": \"\",\n\t\t\"gg\": \"\",\n\t\t\"Gg\": \"\",\n\t\t\"ggg\": \"\",\n\t\t\"gimel\": \"\",\n\t\t\"GJcy\": \"\",\n\t\t\"gjcy\": \"\",\n\t\t\"gla\": \"\",\n\t\t\"gl\": \"\",\n\t\t\"glE\": \"\",\n\t\t\"glj\": \"\",\n\t\t\"gnap\": \"\",\n\t\t\"gnapprox\": \"\",\n\t\t\"gne\": \"\",\n\t\t\"gnE\": \"\",\n\t\t\"gneq\": \"\",\n\t\t\"gneqq\": \"\",\n\t\t\"gnsim\": \"\",\n\t\t\"Gopf\": \"\",\n\t\t\"gopf\": \"\",\n\t\t\"grave\": \"`\",\n\t\t\"GreaterEqual\": \"\",\n\t\t\"GreaterEqualLess\": \"\",\n\t\t\"GreaterFullEqual\": \"\",\n\t\t\"GreaterGreater\": \"\",\n\t\t\"GreaterLess\": \"\",\n\t\t\"GreaterSlantEqual\": \"\",\n\t\t\"GreaterTilde\": \"\",\n\t\t\"Gscr\": \"\",\n\t\t\"gscr\": \"\",\n\t\t\"gsim\": \"\",\n\t\t\"gsime\": \"\",\n\t\t\"gsiml\": \"\",\n\t\t\"gtcc\": \"\",\n\t\t\"gtcir\": \"\",\n\t\t\"gt\": \">\",\n\t\t\"GT\": \">\",\n\t\t\"Gt\": \"\",\n\t\t\"gtdot\": \"\",\n\t\t\"gtlPar\": \"\",\n\t\t\"gtquest\": \"\",\n\t\t\"gtrapprox\": \"\",\n\t\t\"gtrarr\": \"\",\n\t\t\"gtrdot\": \"\",\n\t\t\"gtreqless\": \"\",\n\t\t\"gtreqqless\": \"\",\n\t\t\"gtrless\": \"\",\n\t\t\"gtrsim\": \"\",\n\t\t\"gvertneqq\": \"\",\n\t\t\"gvnE\": \"\",\n\t\t\"Hacek\": \"\",\n\t\t\"hairsp\": \"\",\n\t\t\"half\": \"\",\n\t\t\"hamilt\": \"\",\n\t\t\"HARDcy\": \"\",\n\t\t\"hardcy\": \"\",\n\t\t\"harrcir\": \"\",\n\t\t\"harr\": \"\",\n\t\t\"hArr\": \"\",\n\t\t\"harrw\": \"\",\n\t\t\"Hat\": \"^\",\n\t\t\"hbar\": \"\",\n\t\t\"Hcirc\": \"\",\n\t\t\"hcirc\": \"\",\n\t\t\"hearts\": \"\",\n\t\t\"heartsuit\": \"\",\n\t\t\"hellip\": \"\",\n\t\t\"hercon\": \"\",\n\t\t\"hfr\": \"\",\n\t\t\"Hfr\": \"\",\n\t\t\"HilbertSpace\": \"\",\n\t\t\"hksearow\": \"\",\n\t\t\"hkswarow\": \"\",\n\t\t\"hoarr\": \"\",\n\t\t\"homtht\": \"\",\n\t\t\"hookleftarrow\": \"\",\n\t\t\"hookrightarrow\": \"\",\n\t\t\"hopf\": \"\",\n\t\t\"Hopf\": \"\",\n\t\t\"horbar\": \"\",\n\t\t\"HorizontalLine\": \"\",\n\t\t\"hscr\": \"\",\n\t\t\"Hscr\": \"\",\n\t\t\"hslash\": \"\",\n\t\t\"Hstrok\": \"\",\n\t\t\"hstrok\": \"\",\n\t\t\"HumpDownHump\": \"\",\n\t\t\"HumpEqual\": \"\",\n\t\t\"hybull\": \"\",\n\t\t\"hyphen\": \"\",\n\t\t\"Iacute\": \"\",\n\t\t\"iacute\": \"\",\n\t\t\"ic\": \"\",\n\t\t\"Icirc\": \"\",\n\t\t\"icirc\": \"\",\n\t\t\"Icy\": \"\",\n\t\t\"icy\": \"\",\n\t\t\"Idot\": \"\",\n\t\t\"IEcy\": \"\",\n\t\t\"iecy\": \"\",\n\t\t\"iexcl\": \"\",\n\t\t\"iff\": \"\",\n\t\t\"ifr\": \"\",\n\t\t\"Ifr\": \"\",\n\t\t\"Igrave\": \"\",\n\t\t\"igrave\": \"\",\n\t\t\"ii\": \"\",\n\t\t\"iiiint\": \"\",\n\t\t\"iiint\": \"\",\n\t\t\"iinfin\": \"\",\n\t\t\"iiota\": \"\",\n\t\t\"IJlig\": \"\",\n\t\t\"ijlig\": \"\",\n\t\t\"Imacr\": \"\",\n\t\t\"imacr\": \"\",\n\t\t\"image\": \"\",\n\t\t\"ImaginaryI\": \"\",\n\t\t\"imagline\": \"\",\n\t\t\"imagpart\": \"\",\n\t\t\"imath\": \"\",\n\t\t\"Im\": \"\",\n\t\t\"imof\": \"\",\n\t\t\"imped\": \"\",\n\t\t\"Implies\": \"\",\n\t\t\"incare\": \"\",\n\t\t\"in\": \"\",\n\t\t\"infin\": \"\",\n\t\t\"infintie\": \"\",\n\t\t\"inodot\": \"\",\n\t\t\"intcal\": \"\",\n\t\t\"int\": \"\",\n\t\t\"Int\": \"\",\n\t\t\"integers\": \"\",\n\t\t\"Integral\": \"\",\n\t\t\"intercal\": \"\",\n\t\t\"Intersection\": \"\",\n\t\t\"intlarhk\": \"\",\n\t\t\"intprod\": \"\",\n\t\t\"InvisibleComma\": \"\",\n\t\t\"InvisibleTimes\": \"\",\n\t\t\"IOcy\": \"\",\n\t\t\"iocy\": \"\",\n\t\t\"Iogon\": \"\",\n\t\t\"iogon\": \"\",\n\t\t\"Iopf\": \"\",\n\t\t\"iopf\": \"\",\n\t\t\"Iota\": \"\",\n\t\t\"iota\": \"\",\n\t\t\"iprod\": \"\",\n\t\t\"iquest\": \"\",\n\t\t\"iscr\": \"\",\n\t\t\"Iscr\": \"\",\n\t\t\"isin\": \"\",\n\t\t\"isindot\": \"\",\n\t\t\"isinE\": \"\",\n\t\t\"isins\": \"\",\n\t\t\"isinsv\": \"\",\n\t\t\"isinv\": \"\",\n\t\t\"it\": \"\",\n\t\t\"Itilde\": \"\",\n\t\t\"itilde\": \"\",\n\t\t\"Iukcy\": \"\",\n\t\t\"iukcy\": \"\",\n\t\t\"Iuml\": \"\",\n\t\t\"iuml\": \"\",\n\t\t\"Jcirc\": \"\",\n\t\t\"jcirc\": \"\",\n\t\t\"Jcy\": \"\",\n\t\t\"jcy\": \"\",\n\t\t\"Jfr\": \"\",\n\t\t\"jfr\": \"\",\n\t\t\"jmath\": \"\",\n\t\t\"Jopf\": \"\",\n\t\t\"jopf\": \"\",\n\t\t\"Jscr\": \"\",\n\t\t\"jscr\": \"\",\n\t\t\"Jsercy\": \"\",\n\t\t\"jsercy\": \"\",\n\t\t\"Jukcy\": \"\",\n\t\t\"jukcy\": \"\",\n\t\t\"Kappa\": \"\",\n\t\t\"kappa\": \"\",\n\t\t\"kappav\": \"\",\n\t\t\"Kcedil\": \"\",\n\t\t\"kcedil\": \"\",\n\t\t\"Kcy\": \"\",\n\t\t\"kcy\": \"\",\n\t\t\"Kfr\": \"\",\n\t\t\"kfr\": \"\",\n\t\t\"kgreen\": \"\",\n\t\t\"KHcy\": \"\",\n\t\t\"khcy\": \"\",\n\t\t\"KJcy\": \"\",\n\t\t\"kjcy\": \"\",\n\t\t\"Kopf\": \"\",\n\t\t\"kopf\": \"\",\n\t\t\"Kscr\": \"\",\n\t\t\"kscr\": \"\",\n\t\t\"lAarr\": \"\",\n\t\t\"Lacute\": \"\",\n\t\t\"lacute\": \"\",\n\t\t\"laemptyv\": \"\",\n\t\t\"lagran\": \"\",\n\t\t\"Lambda\": \"\",\n\t\t\"lambda\": \"\",\n\t\t\"lang\": \"\",\n\t\t\"Lang\": \"\",\n\t\t\"langd\": \"\",\n\t\t\"langle\": \"\",\n\t\t\"lap\": \"\",\n\t\t\"Laplacetrf\": \"\",\n\t\t\"laquo\": \"\",\n\t\t\"larrb\": \"\",\n\t\t\"larrbfs\": \"\",\n\t\t\"larr\": \"\",\n\t\t\"Larr\": \"\",\n\t\t\"lArr\": \"\",\n\t\t\"larrfs\": \"\",\n\t\t\"larrhk\": \"\",\n\t\t\"larrlp\": \"\",\n\t\t\"larrpl\": \"\",\n\t\t\"larrsim\": \"\",\n\t\t\"larrtl\": \"\",\n\t\t\"latail\": \"\",\n\t\t\"lAtail\": \"\",\n\t\t\"lat\": \"\",\n\t\t\"late\": \"\",\n\t\t\"lates\": \"\",\n\t\t\"lbarr\": \"\",\n\t\t\"lBarr\": \"\",\n\t\t\"lbbrk\": \"\",\n\t\t\"lbrace\": \"{\",\n\t\t\"lbrack\": \"[\",\n\t\t\"lbrke\": \"\",\n\t\t\"lbrksld\": \"\",\n\t\t\"lbrkslu\": \"\",\n\t\t\"Lcaron\": \"\",\n\t\t\"lcaron\": \"\",\n\t\t\"Lcedil\": \"\",\n\t\t\"lcedil\": \"\",\n\t\t\"lceil\": \"\",\n\t\t\"lcub\": \"{\",\n\t\t\"Lcy\": \"\",\n\t\t\"lcy\": \"\",\n\t\t\"ldca\": \"\",\n\t\t\"ldquo\": \"\",\n\t\t\"ldquor\": \"\",\n\t\t\"ldrdhar\": \"\",\n\t\t\"ldrushar\": \"\",\n\t\t\"ldsh\": \"\",\n\t\t\"le\": \"\",\n\t\t\"lE\": \"\",\n\t\t\"LeftAngleBracket\": \"\",\n\t\t\"LeftArrowBar\": \"\",\n\t\t\"leftarrow\": \"\",\n\t\t\"LeftArrow\": \"\",\n\t\t\"Leftarrow\": \"\",\n\t\t\"LeftArrowRightArrow\": \"\",\n\t\t\"leftarrowtail\": \"\",\n\t\t\"LeftCeiling\": \"\",\n\t\t\"LeftDoubleBracket\": \"\",\n\t\t\"LeftDownTeeVector\": \"\",\n\t\t\"LeftDownVectorBar\": \"\",\n\t\t\"LeftDownVector\": \"\",\n\t\t\"LeftFloor\": \"\",\n\t\t\"leftharpoondown\": \"\",\n\t\t\"leftharpoonup\": \"\",\n\t\t\"leftleftarrows\": \"\",\n\t\t\"leftrightarrow\": \"\",\n\t\t\"LeftRightArrow\": \"\",\n\t\t\"Leftrightarrow\": \"\",\n\t\t\"leftrightarrows\": \"\",\n\t\t\"leftrightharpoons\": \"\",\n\t\t\"leftrightsquigarrow\": \"\",\n\t\t\"LeftRightVector\": \"\",\n\t\t\"LeftTeeArrow\": \"\",\n\t\t\"LeftTee\": \"\",\n\t\t\"LeftTeeVector\": \"\",\n\t\t\"leftthreetimes\": \"\",\n\t\t\"LeftTriangleBar\": \"\",\n\t\t\"LeftTriangle\": \"\",\n\t\t\"LeftTriangleEqual\": \"\",\n\t\t\"LeftUpDownVector\": \"\",\n\t\t\"LeftUpTeeVector\": \"\",\n\t\t\"LeftUpVectorBar\": \"\",\n\t\t\"LeftUpVector\": \"\",\n\t\t\"LeftVectorBar\": \"\",\n\t\t\"LeftVector\": \"\",\n\t\t\"lEg\": \"\",\n\t\t\"leg\": \"\",\n\t\t\"leq\": \"\",\n\t\t\"leqq\": \"\",\n\t\t\"leqslant\": \"\",\n\t\t\"lescc\": \"\",\n\t\t\"les\": \"\",\n\t\t\"lesdot\": \"\",\n\t\t\"lesdoto\": \"\",\n\t\t\"lesdotor\": \"\",\n\t\t\"lesg\": \"\",\n\t\t\"lesges\": \"\",\n\t\t\"lessapprox\": \"\",\n\t\t\"lessdot\": \"\",\n\t\t\"lesseqgtr\": \"\",\n\t\t\"lesseqqgtr\": \"\",\n\t\t\"LessEqualGreater\": \"\",\n\t\t\"LessFullEqual\": \"\",\n\t\t\"LessGreater\": \"\",\n\t\t\"lessgtr\": \"\",\n\t\t\"LessLess\": \"\",\n\t\t\"lesssim\": \"\",\n\t\t\"LessSlantEqual\": \"\",\n\t\t\"LessTilde\": \"\",\n\t\t\"lfisht\": \"\",\n\t\t\"lfloor\": \"\",\n\t\t\"Lfr\": \"\",\n\t\t\"lfr\": \"\",\n\t\t\"lg\": \"\",\n\t\t\"lgE\": \"\",\n\t\t\"lHar\": \"\",\n\t\t\"lhard\": \"\",\n\t\t\"lharu\": \"\",\n\t\t\"lharul\": \"\",\n\t\t\"lhblk\": \"\",\n\t\t\"LJcy\": \"\",\n\t\t\"ljcy\": \"\",\n\t\t\"llarr\": \"\",\n\t\t\"ll\": \"\",\n\t\t\"Ll\": \"\",\n\t\t\"llcorner\": \"\",\n\t\t\"Lleftarrow\": \"\",\n\t\t\"llhard\": \"\",\n\t\t\"lltri\": \"\",\n\t\t\"Lmidot\": \"\",\n\t\t\"lmidot\": \"\",\n\t\t\"lmoustache\": \"\",\n\t\t\"lmoust\": \"\",\n\t\t\"lnap\": \"\",\n\t\t\"lnapprox\": \"\",\n\t\t\"lne\": \"\",\n\t\t\"lnE\": \"\",\n\t\t\"lneq\": \"\",\n\t\t\"lneqq\": \"\",\n\t\t\"lnsim\": \"\",\n\t\t\"loang\": \"\",\n\t\t\"loarr\": \"\",\n\t\t\"lobrk\": \"\",\n\t\t\"longleftarrow\": \"\",\n\t\t\"LongLeftArrow\": \"\",\n\t\t\"Longleftarrow\": \"\",\n\t\t\"longleftrightarrow\": \"\",\n\t\t\"LongLeftRightArrow\": \"\",\n\t\t\"Longleftrightarrow\": \"\",\n\t\t\"longmapsto\": \"\",\n\t\t\"longrightarrow\": \"\",\n\t\t\"LongRightArrow\": \"\",\n\t\t\"Longrightarrow\": \"\",\n\t\t\"looparrowleft\": \"\",\n\t\t\"looparrowright\": \"\",\n\t\t\"lopar\": \"\",\n\t\t\"Lopf\": \"\",\n\t\t\"lopf\": \"\",\n\t\t\"loplus\": \"\",\n\t\t\"lotimes\": \"\",\n\t\t\"lowast\": \"\",\n\t\t\"lowbar\": \"_\",\n\t\t\"LowerLeftArrow\": \"\",\n\t\t\"LowerRightArrow\": \"\",\n\t\t\"loz\": \"\",\n\t\t\"lozenge\": \"\",\n\t\t\"lozf\": \"\",\n\t\t\"lpar\": \"(\",\n\t\t\"lparlt\": \"\",\n\t\t\"lrarr\": \"\",\n\t\t\"lrcorner\": \"\",\n\t\t\"lrhar\": \"\",\n\t\t\"lrhard\": \"\",\n\t\t\"lrm\": \"\",\n\t\t\"lrtri\": \"\",\n\t\t\"lsaquo\": \"\",\n\t\t\"lscr\": \"\",\n\t\t\"Lscr\": \"\",\n\t\t\"lsh\": \"\",\n\t\t\"Lsh\": \"\",\n\t\t\"lsim\": \"\",\n\t\t\"lsime\": \"\",\n\t\t\"lsimg\": \"\",\n\t\t\"lsqb\": \"[\",\n\t\t\"lsquo\": \"\",\n\t\t\"lsquor\": \"\",\n\t\t\"Lstrok\": \"\",\n\t\t\"lstrok\": \"\",\n\t\t\"ltcc\": \"\",\n\t\t\"ltcir\": \"\",\n\t\t\"lt\": \"<\",\n\t\t\"LT\": \"<\",\n\t\t\"Lt\": \"\",\n\t\t\"ltdot\": \"\",\n\t\t\"lthree\": \"\",\n\t\t\"ltimes\": \"\",\n\t\t\"ltlarr\": \"\",\n\t\t\"ltquest\": \"\",\n\t\t\"ltri\": \"\",\n\t\t\"ltrie\": \"\",\n\t\t\"ltrif\": \"\",\n\t\t\"ltrPar\": \"\",\n\t\t\"lurdshar\": \"\",\n\t\t\"luruhar\": \"\",\n\t\t\"lvertneqq\": \"\",\n\t\t\"lvnE\": \"\",\n\t\t\"macr\": \"\",\n\t\t\"male\": \"\",\n\t\t\"malt\": \"\",\n\t\t\"maltese\": \"\",\n\t\t\"Map\": \"\",\n\t\t\"map\": \"\",\n\t\t\"mapsto\": \"\",\n\t\t\"mapstodown\": \"\",\n\t\t\"mapstoleft\": \"\",\n\t\t\"mapstoup\": \"\",\n\t\t\"marker\": \"\",\n\t\t\"mcomma\": \"\",\n\t\t\"Mcy\": \"\",\n\t\t\"mcy\": \"\",\n\t\t\"mdash\": \"\",\n\t\t\"mDDot\": \"\",\n\t\t\"measuredangle\": \"\",\n\t\t\"MediumSpace\": \"\",\n\t\t\"Mellintrf\": \"\",\n\t\t\"Mfr\": \"\",\n\t\t\"mfr\": \"\",\n\t\t\"mho\": \"\",\n\t\t\"micro\": \"\",\n\t\t\"midast\": \"*\",\n\t\t\"midcir\": \"\",\n\t\t\"mid\": \"\",\n\t\t\"middot\": \"\",\n\t\t\"minusb\": \"\",\n\t\t\"minus\": \"\",\n\t\t\"minusd\": \"\",\n\t\t\"minusdu\": \"\",\n\t\t\"MinusPlus\": \"\",\n\t\t\"mlcp\": \"\",\n\t\t\"mldr\": \"\",\n\t\t\"mnplus\": \"\",\n\t\t\"models\": \"\",\n\t\t\"Mopf\": \"\",\n\t\t\"mopf\": \"\",\n\t\t\"mp\": \"\",\n\t\t\"mscr\": \"\",\n\t\t\"Mscr\": \"\",\n\t\t\"mstpos\": \"\",\n\t\t\"Mu\": \"\",\n\t\t\"mu\": \"\",\n\t\t\"multimap\": \"\",\n\t\t\"mumap\": \"\",\n\t\t\"nabla\": \"\",\n\t\t\"Nacute\": \"\",\n\t\t\"nacute\": \"\",\n\t\t\"nang\": \"\",\n\t\t\"nap\": \"\",\n\t\t\"napE\": \"\",\n\t\t\"napid\": \"\",\n\t\t\"napos\": \"\",\n\t\t\"napprox\": \"\",\n\t\t\"natural\": \"\",\n\t\t\"naturals\": \"\",\n\t\t\"natur\": \"\",\n\t\t\"nbsp\": \"\",\n\t\t\"nbump\": \"\",\n\t\t\"nbumpe\": \"\",\n\t\t\"ncap\": \"\",\n\t\t\"Ncaron\": \"\",\n\t\t\"ncaron\": \"\",\n\t\t\"Ncedil\": \"\",\n\t\t\"ncedil\": \"\",\n\t\t\"ncong\": \"\",\n\t\t\"ncongdot\": \"\",\n\t\t\"ncup\": \"\",\n\t\t\"Ncy\": \"\",\n\t\t\"ncy\": \"\",\n\t\t\"ndash\": \"\",\n\t\t\"nearhk\": \"\",\n\t\t\"nearr\": \"\",\n\t\t\"neArr\": \"\",\n\t\t\"nearrow\": \"\",\n\t\t\"ne\": \"\",\n\t\t\"nedot\": \"\",\n\t\t\"NegativeMediumSpace\": \"\",\n\t\t\"NegativeThickSpace\": \"\",\n\t\t\"NegativeThinSpace\": \"\",\n\t\t\"NegativeVeryThinSpace\": \"\",\n\t\t\"nequiv\": \"\",\n\t\t\"nesear\": \"\",\n\t\t\"nesim\": \"\",\n\t\t\"NestedGreaterGreater\": \"\",\n\t\t\"NestedLessLess\": \"\",\n\t\t\"NewLine\": \"\\n\",\n\t\t\"nexist\": \"\",\n\t\t\"nexists\": \"\",\n\t\t\"Nfr\": \"\",\n\t\t\"nfr\": \"\",\n\t\t\"ngE\": \"\",\n\t\t\"nge\": \"\",\n\t\t\"ngeq\": \"\",\n\t\t\"ngeqq\": \"\",\n\t\t\"ngeqslant\": \"\",\n\t\t\"nges\": \"\",\n\t\t\"nGg\": \"\",\n\t\t\"ngsim\": \"\",\n\t\t\"nGt\": \"\",\n\t\t\"ngt\": \"\",\n\t\t\"ngtr\": \"\",\n\t\t\"nGtv\": \"\",\n\t\t\"nharr\": \"\",\n\t\t\"nhArr\": \"\",\n\t\t\"nhpar\": \"\",\n\t\t\"ni\": \"\",\n\t\t\"nis\": \"\",\n\t\t\"nisd\": \"\",\n\t\t\"niv\": \"\",\n\t\t\"NJcy\": \"\",\n\t\t\"njcy\": \"\",\n\t\t\"nlarr\": \"\",\n\t\t\"nlArr\": \"\",\n\t\t\"nldr\": \"\",\n\t\t\"nlE\": \"\",\n\t\t\"nle\": \"\",\n\t\t\"nleftarrow\": \"\",\n\t\t\"nLeftarrow\": \"\",\n\t\t\"nleftrightarrow\": \"\",\n\t\t\"nLeftrightarrow\": \"\",\n\t\t\"nleq\": \"\",\n\t\t\"nleqq\": \"\",\n\t\t\"nleqslant\": \"\",\n\t\t\"nles\": \"\",\n\t\t\"nless\": \"\",\n\t\t\"nLl\": \"\",\n\t\t\"nlsim\": \"\",\n\t\t\"nLt\": \"\",\n\t\t\"nlt\": \"\",\n\t\t\"nltri\": \"\",\n\t\t\"nltrie\": \"\",\n\t\t\"nLtv\": \"\",\n\t\t\"nmid\": \"\",\n\t\t\"NoBreak\": \"\",\n\t\t\"NonBreakingSpace\": \"\",\n\t\t\"nopf\": \"\",\n\t\t\"Nopf\": \"\",\n\t\t\"Not\": \"\",\n\t\t\"not\": \"\",\n\t\t\"NotCongruent\": \"\",\n\t\t\"NotCupCap\": \"\",\n\t\t\"NotDoubleVerticalBar\": \"\",\n\t\t\"NotElement\": \"\",\n\t\t\"NotEqual\": \"\",\n\t\t\"NotEqualTilde\": \"\",\n\t\t\"NotExists\": \"\",\n\t\t\"NotGreater\": \"\",\n\t\t\"NotGreaterEqual\": \"\",\n\t\t\"NotGreaterFullEqual\": \"\",\n\t\t\"NotGreaterGreater\": \"\",\n\t\t\"NotGreaterLess\": \"\",\n\t\t\"NotGreaterSlantEqual\": \"\",\n\t\t\"NotGreaterTilde\": \"\",\n\t\t\"NotHumpDownHump\": \"\",\n\t\t\"NotHumpEqual\": \"\",\n\t\t\"notin\": \"\",\n\t\t\"notindot\": \"\",\n\t\t\"notinE\": \"\",\n\t\t\"notinva\": \"\",\n\t\t\"notinvb\": \"\",\n\t\t\"notinvc\": \"\",\n\t\t\"NotLeftTriangleBar\": \"\",\n\t\t\"NotLeftTriangle\": \"\",\n\t\t\"NotLeftTriangleEqual\": \"\",\n\t\t\"NotLess\": \"\",\n\t\t\"NotLessEqual\": \"\",\n\t\t\"NotLessGreater\": \"\",\n\t\t\"NotLessLess\": \"\",\n\t\t\"NotLessSlantEqual\": \"\",\n\t\t\"NotLessTilde\": \"\",\n\t\t\"NotNestedGreaterGreater\": \"\",\n\t\t\"NotNestedLessLess\": \"\",\n\t\t\"notni\": \"\",\n\t\t\"notniva\": \"\",\n\t\t\"notnivb\": \"\",\n\t\t\"notnivc\": \"\",\n\t\t\"NotPrecedes\": \"\",\n\t\t\"NotPrecedesEqual\": \"\",\n\t\t\"NotPrecedesSlantEqual\": \"\",\n\t\t\"NotReverseElement\": \"\",\n\t\t\"NotRightTriangleBar\": \"\",\n\t\t\"NotRightTriangle\": \"\",\n\t\t\"NotRightTriangleEqual\": \"\",\n\t\t\"NotSquareSubset\": \"\",\n\t\t\"NotSquareSubsetEqual\": \"\",\n\t\t\"NotSquareSuperset\": \"\",\n\t\t\"NotSquareSupersetEqual\": \"\",\n\t\t\"NotSubset\": \"\",\n\t\t\"NotSubsetEqual\": \"\",\n\t\t\"NotSucceeds\": \"\",\n\t\t\"NotSucceedsEqual\": \"\",\n\t\t\"NotSucceedsSlantEqual\": \"\",\n\t\t\"NotSucceedsTilde\": \"\",\n\t\t\"NotSuperset\": \"\",\n\t\t\"NotSupersetEqual\": \"\",\n\t\t\"NotTilde\": \"\",\n\t\t\"NotTildeEqual\": \"\",\n\t\t\"NotTildeFullEqual\": \"\",\n\t\t\"NotTildeTilde\": \"\",\n\t\t\"NotVerticalBar\": \"\",\n\t\t\"nparallel\": \"\",\n\t\t\"npar\": \"\",\n\t\t\"nparsl\": \"\",\n\t\t\"npart\": \"\",\n\t\t\"npolint\": \"\",\n\t\t\"npr\": \"\",\n\t\t\"nprcue\": \"\",\n\t\t\"nprec\": \"\",\n\t\t\"npreceq\": \"\",\n\t\t\"npre\": \"\",\n\t\t\"nrarrc\": \"\",\n\t\t\"nrarr\": \"\",\n\t\t\"nrArr\": \"\",\n\t\t\"nrarrw\": \"\",\n\t\t\"nrightarrow\": \"\",\n\t\t\"nRightarrow\": \"\",\n\t\t\"nrtri\": \"\",\n\t\t\"nrtrie\": \"\",\n\t\t\"nsc\": \"\",\n\t\t\"nsccue\": \"\",\n\t\t\"nsce\": \"\",\n\t\t\"Nscr\": \"\",\n\t\t\"nscr\": \"\",\n\t\t\"nshortmid\": \"\",\n\t\t\"nshortparallel\": \"\",\n\t\t\"nsim\": \"\",\n\t\t\"nsime\": \"\",\n\t\t\"nsimeq\": \"\",\n\t\t\"nsmid\": \"\",\n\t\t\"nspar\": \"\",\n\t\t\"nsqsube\": \"\",\n\t\t\"nsqsupe\": \"\",\n\t\t\"nsub\": \"\",\n\t\t\"nsubE\": \"\",\n\t\t\"nsube\": \"\",\n\t\t\"nsubset\": \"\",\n\t\t\"nsubseteq\": \"\",\n\t\t\"nsubseteqq\": \"\",\n\t\t\"nsucc\": \"\",\n\t\t\"nsucceq\": \"\",\n\t\t\"nsup\": \"\",\n\t\t\"nsupE\": \"\",\n\t\t\"nsupe\": \"\",\n\t\t\"nsupset\": \"\",\n\t\t\"nsupseteq\": \"\",\n\t\t\"nsupseteqq\": \"\",\n\t\t\"ntgl\": \"\",\n\t\t\"Ntilde\": \"\",\n\t\t\"ntilde\": \"\",\n\t\t\"ntlg\": \"\",\n\t\t\"ntriangleleft\": \"\",\n\t\t\"ntrianglelefteq\": \"\",\n\t\t\"ntriangleright\": \"\",\n\t\t\"ntrianglerighteq\": \"\",\n\t\t\"Nu\": \"\",\n\t\t\"nu\": \"\",\n\t\t\"num\": \"#\",\n\t\t\"numero\": \"\",\n\t\t\"numsp\": \"\",\n\t\t\"nvap\": \"\",\n\t\t\"nvdash\": \"\",\n\t\t\"nvDash\": \"\",\n\t\t\"nVdash\": \"\",\n\t\t\"nVDash\": \"\",\n\t\t\"nvge\": \"\",\n\t\t\"nvgt\": \">\",\n\t\t\"nvHarr\": \"\",\n\t\t\"nvinfin\": \"\",\n\t\t\"nvlArr\": \"\",\n\t\t\"nvle\": \"\",\n\t\t\"nvlt\": \"<\",\n\t\t\"nvltrie\": \"\",\n\t\t\"nvrArr\": \"\",\n\t\t\"nvrtrie\": \"\",\n\t\t\"nvsim\": \"\",\n\t\t\"nwarhk\": \"\",\n\t\t\"nwarr\": \"\",\n\t\t\"nwArr\": \"\",\n\t\t\"nwarrow\": \"\",\n\t\t\"nwnear\": \"\",\n\t\t\"Oacute\": \"\",\n\t\t\"oacute\": \"\",\n\t\t\"oast\": \"\",\n\t\t\"Ocirc\": \"\",\n\t\t\"ocirc\": \"\",\n\t\t\"ocir\": \"\",\n\t\t\"Ocy\": \"\",\n\t\t\"ocy\": \"\",\n\t\t\"odash\": \"\",\n\t\t\"Odblac\": \"\",\n\t\t\"odblac\": \"\",\n\t\t\"odiv\": \"\",\n\t\t\"odot\": \"\",\n\t\t\"odsold\": \"\",\n\t\t\"OElig\": \"\",\n\t\t\"oelig\": \"\",\n\t\t\"ofcir\": \"\",\n\t\t\"Ofr\": \"\",\n\t\t\"ofr\": \"\",\n\t\t\"ogon\": \"\",\n\t\t\"Ograve\": \"\",\n\t\t\"ograve\": \"\",\n\t\t\"ogt\": \"\",\n\t\t\"ohbar\": \"\",\n\t\t\"ohm\": \"\",\n\t\t\"oint\": \"\",\n\t\t\"olarr\": \"\",\n\t\t\"olcir\": \"\",\n\t\t\"olcross\": \"\",\n\t\t\"oline\": \"\",\n\t\t\"olt\": \"\",\n\t\t\"Omacr\": \"\",\n\t\t\"omacr\": \"\",\n\t\t\"Omega\": \"\",\n\t\t\"omega\": \"\",\n\t\t\"Omicron\": \"\",\n\t\t\"omicron\": \"\",\n\t\t\"omid\": \"\",\n\t\t\"ominus\": \"\",\n\t\t\"Oopf\": \"\",\n\t\t\"oopf\": \"\",\n\t\t\"opar\": \"\",\n\t\t\"OpenCurlyDoubleQuote\": \"\",\n\t\t\"OpenCurlyQuote\": \"\",\n\t\t\"operp\": \"\",\n\t\t\"oplus\": \"\",\n\t\t\"orarr\": \"\",\n\t\t\"Or\": \"\",\n\t\t\"or\": \"\",\n\t\t\"ord\": \"\",\n\t\t\"order\": \"\",\n\t\t\"orderof\": \"\",\n\t\t\"ordf\": \"\",\n\t\t\"ordm\": \"\",\n\t\t\"origof\": \"\",\n\t\t\"oror\": \"\",\n\t\t\"orslope\": \"\",\n\t\t\"orv\": \"\",\n\t\t\"oS\": \"\",\n\t\t\"Oscr\": \"\",\n\t\t\"oscr\": \"\",\n\t\t\"Oslash\": \"\",\n\t\t\"oslash\": \"\",\n\t\t\"osol\": \"\",\n\t\t\"Otilde\": \"\",\n\t\t\"otilde\": \"\",\n\t\t\"otimesas\": \"\",\n\t\t\"Otimes\": \"\",\n\t\t\"otimes\": \"\",\n\t\t\"Ouml\": \"\",\n\t\t\"ouml\": \"\",\n\t\t\"ovbar\": \"\",\n\t\t\"OverBar\": \"\",\n\t\t\"OverBrace\": \"\",\n\t\t\"OverBracket\": \"\",\n\t\t\"OverParenthesis\": \"\",\n\t\t\"para\": \"\",\n\t\t\"parallel\": \"\",\n\t\t\"par\": \"\",\n\t\t\"parsim\": \"\",\n\t\t\"parsl\": \"\",\n\t\t\"part\": \"\",\n\t\t\"PartialD\": \"\",\n\t\t\"Pcy\": \"\",\n\t\t\"pcy\": \"\",\n\t\t\"percnt\": \"%\",\n\t\t\"period\": \".\",\n\t\t\"permil\": \"\",\n\t\t\"perp\": \"\",\n\t\t\"pertenk\": \"\",\n\t\t\"Pfr\": \"\",\n\t\t\"pfr\": \"\",\n\t\t\"Phi\": \"\",\n\t\t\"phi\": \"\",\n\t\t\"phiv\": \"\",\n\t\t\"phmmat\": \"\",\n\t\t\"phone\": \"\",\n\t\t\"Pi\": \"\",\n\t\t\"pi\": \"\",\n\t\t\"pitchfork\": \"\",\n\t\t\"piv\": \"\",\n\t\t\"planck\": \"\",\n\t\t\"planckh\": \"\",\n\t\t\"plankv\": \"\",\n\t\t\"plusacir\": \"\",\n\t\t\"plusb\": \"\",\n\t\t\"pluscir\": \"\",\n\t\t\"plus\": \"+\",\n\t\t\"plusdo\": \"\",\n\t\t\"plusdu\": \"\",\n\t\t\"pluse\": \"\",\n\t\t\"PlusMinus\": \"\",\n\t\t\"plusmn\": \"\",\n\t\t\"plussim\": \"\",\n\t\t\"plustwo\": \"\",\n\t\t\"pm\": \"\",\n\t\t\"Poincareplane\": \"\",\n\t\t\"pointint\": \"\",\n\t\t\"popf\": \"\",\n\t\t\"Popf\": \"\",\n\t\t\"pound\": \"\",\n\t\t\"prap\": \"\",\n\t\t\"Pr\": \"\",\n\t\t\"pr\": \"\",\n\t\t\"prcue\": \"\",\n\t\t\"precapprox\": \"\",\n\t\t\"prec\": \"\",\n\t\t\"preccurlyeq\": \"\",\n\t\t\"Precedes\": \"\",\n\t\t\"PrecedesEqual\": \"\",\n\t\t\"PrecedesSlantEqual\": \"\",\n\t\t\"PrecedesTilde\": \"\",\n\t\t\"preceq\": \"\",\n\t\t\"precnapprox\": \"\",\n\t\t\"precneqq\": \"\",\n\t\t\"precnsim\": \"\",\n\t\t\"pre\": \"\",\n\t\t\"prE\": \"\",\n\t\t\"precsim\": \"\",\n\t\t\"prime\": \"\",\n\t\t\"Prime\": \"\",\n\t\t\"primes\": \"\",\n\t\t\"prnap\": \"\",\n\t\t\"prnE\": \"\",\n\t\t\"prnsim\": \"\",\n\t\t\"prod\": \"\",\n\t\t\"Product\": \"\",\n\t\t\"profalar\": \"\",\n\t\t\"profline\": \"\",\n\t\t\"profsurf\": \"\",\n\t\t\"prop\": \"\",\n\t\t\"Proportional\": \"\",\n\t\t\"Proportion\": \"\",\n\t\t\"propto\": \"\",\n\t\t\"prsim\": \"\",\n\t\t\"prurel\": \"\",\n\t\t\"Pscr\": \"\",\n\t\t\"pscr\": \"\",\n\t\t\"Psi\": \"\",\n\t\t\"psi\": \"\",\n\t\t\"puncsp\": \"\",\n\t\t\"Qfr\": \"\",\n\t\t\"qfr\": \"\",\n\t\t\"qint\": \"\",\n\t\t\"qopf\": \"\",\n\t\t\"Qopf\": \"\",\n\t\t\"qprime\": \"\",\n\t\t\"Qscr\": \"\",\n\t\t\"qscr\": \"\",\n\t\t\"quaternions\": \"\",\n\t\t\"quatint\": \"\",\n\t\t\"quest\": \"?\",\n\t\t\"questeq\": \"\",\n\t\t\"quot\": \"\\\"\",\n\t\t\"QUOT\": \"\\\"\",\n\t\t\"rAarr\": \"\",\n\t\t\"race\": \"\",\n\t\t\"Racute\": \"\",\n\t\t\"racute\": \"\",\n\t\t\"radic\": \"\",\n\t\t\"raemptyv\": \"\",\n\t\t\"rang\": \"\",\n\t\t\"Rang\": \"\",\n\t\t\"rangd\": \"\",\n\t\t\"range\": \"\",\n\t\t\"rangle\": \"\",\n\t\t\"raquo\": \"\",\n\t\t\"rarrap\": \"\",\n\t\t\"rarrb\": \"\",\n\t\t\"rarrbfs\": \"\",\n\t\t\"rarrc\": \"\",\n\t\t\"rarr\": \"\",\n\t\t\"Rarr\": \"\",\n\t\t\"rArr\": \"\",\n\t\t\"rarrfs\": \"\",\n\t\t\"rarrhk\": \"\",\n\t\t\"rarrlp\": \"\",\n\t\t\"rarrpl\": \"\",\n\t\t\"rarrsim\": \"\",\n\t\t\"Rarrtl\": \"\",\n\t\t\"rarrtl\": \"\",\n\t\t\"rarrw\": \"\",\n\t\t\"ratail\": \"\",\n\t\t\"rAtail\": \"\",\n\t\t\"ratio\": \"\",\n\t\t\"rationals\": \"\",\n\t\t\"rbarr\": \"\",\n\t\t\"rBarr\": \"\",\n\t\t\"RBarr\": \"\",\n\t\t\"rbbrk\": \"\",\n\t\t\"rbrace\": \"}\",\n\t\t\"rbrack\": \"]\",\n\t\t\"rbrke\": \"\",\n\t\t\"rbrksld\": \"\",\n\t\t\"rbrkslu\": \"\",\n\t\t\"Rcaron\": \"\",\n\t\t\"rcaron\": \"\",\n\t\t\"Rcedil\": \"\",\n\t\t\"rcedil\": \"\",\n\t\t\"rceil\": \"\",\n\t\t\"rcub\": \"}\",\n\t\t\"Rcy\": \"\",\n\t\t\"rcy\": \"\",\n\t\t\"rdca\": \"\",\n\t\t\"rdldhar\": \"\",\n\t\t\"rdquo\": \"\",\n\t\t\"rdquor\": \"\",\n\t\t\"rdsh\": \"\",\n\t\t\"real\": \"\",\n\t\t\"realine\": \"\",\n\t\t\"realpart\": \"\",\n\t\t\"reals\": \"\",\n\t\t\"Re\": \"\",\n\t\t\"rect\": \"\",\n\t\t\"reg\": \"\",\n\t\t\"REG\": \"\",\n\t\t\"ReverseElement\": \"\",\n\t\t\"ReverseEquilibrium\": \"\",\n\t\t\"ReverseUpEquilibrium\": \"\",\n\t\t\"rfisht\": \"\",\n\t\t\"rfloor\": \"\",\n\t\t\"rfr\": \"\",\n\t\t\"Rfr\": \"\",\n\t\t\"rHar\": \"\",\n\t\t\"rhard\": \"\",\n\t\t\"rharu\": \"\",\n\t\t\"rharul\": \"\",\n\t\t\"Rho\": \"\",\n\t\t\"rho\": \"\",\n\t\t\"rhov\": \"\",\n\t\t\"RightAngleBracket\": \"\",\n\t\t\"RightArrowBar\": \"\",\n\t\t\"rightarrow\": \"\",\n\t\t\"RightArrow\": \"\",\n\t\t\"Rightarrow\": \"\",\n\t\t\"RightArrowLeftArrow\": \"\",\n\t\t\"rightarrowtail\": \"\",\n\t\t\"RightCeiling\": \"\",\n\t\t\"RightDoubleBracket\": \"\",\n\t\t\"RightDownTeeVector\": \"\",\n\t\t\"RightDownVectorBar\": \"\",\n\t\t\"RightDownVector\": \"\",\n\t\t\"RightFloor\": \"\",\n\t\t\"rightharpoondown\": \"\",\n\t\t\"rightharpoonup\": \"\",\n\t\t\"rightleftarrows\": \"\",\n\t\t\"rightleftharpoons\": \"\",\n\t\t\"rightrightarrows\": \"\",\n\t\t\"rightsquigarrow\": \"\",\n\t\t\"RightTeeArrow\": \"\",\n\t\t\"RightTee\": \"\",\n\t\t\"RightTeeVector\": \"\",\n\t\t\"rightthreetimes\": \"\",\n\t\t\"RightTriangleBar\": \"\",\n\t\t\"RightTriangle\": \"\",\n\t\t\"RightTriangleEqual\": \"\",\n\t\t\"RightUpDownVector\": \"\",\n\t\t\"RightUpTeeVector\": \"\",\n\t\t\"RightUpVectorBar\": \"\",\n\t\t\"RightUpVector\": \"\",\n\t\t\"RightVectorBar\": \"\",\n\t\t\"RightVector\": \"\",\n\t\t\"ring\": \"\",\n\t\t\"risingdotseq\": \"\",\n\t\t\"rlarr\": \"\",\n\t\t\"rlhar\": \"\",\n\t\t\"rlm\": \"\",\n\t\t\"rmoustache\": \"\",\n\t\t\"rmoust\": \"\",\n\t\t\"rnmid\": \"\",\n\t\t\"roang\": \"\",\n\t\t\"roarr\": \"\",\n\t\t\"robrk\": \"\",\n\t\t\"ropar\": \"\",\n\t\t\"ropf\": \"\",\n\t\t\"Ropf\": \"\",\n\t\t\"roplus\": \"\",\n\t\t\"rotimes\": \"\",\n\t\t\"RoundImplies\": \"\",\n\t\t\"rpar\": \")\",\n\t\t\"rpargt\": \"\",\n\t\t\"rppolint\": \"\",\n\t\t\"rrarr\": \"\",\n\t\t\"Rrightarrow\": \"\",\n\t\t\"rsaquo\": \"\",\n\t\t\"rscr\": \"\",\n\t\t\"Rscr\": \"\",\n\t\t\"rsh\": \"\",\n\t\t\"Rsh\": \"\",\n\t\t\"rsqb\": \"]\",\n\t\t\"rsquo\": \"\",\n\t\t\"rsquor\": \"\",\n\t\t\"rthree\": \"\",\n\t\t\"rtimes\": \"\",\n\t\t\"rtri\": \"\",\n\t\t\"rtrie\": \"\",\n\t\t\"rtrif\": \"\",\n\t\t\"rtriltri\": \"\",\n\t\t\"RuleDelayed\": \"\",\n\t\t\"ruluhar\": \"\",\n\t\t\"rx\": \"\",\n\t\t\"Sacute\": \"\",\n\t\t\"sacute\": \"\",\n\t\t\"sbquo\": \"\",\n\t\t\"scap\": \"\",\n\t\t\"Scaron\": \"\",\n\t\t\"scaron\": \"\",\n\t\t\"Sc\": \"\",\n\t\t\"sc\": \"\",\n\t\t\"sccue\": \"\",\n\t\t\"sce\": \"\",\n\t\t\"scE\": \"\",\n\t\t\"Scedil\": \"\",\n\t\t\"scedil\": \"\",\n\t\t\"Scirc\": \"\",\n\t\t\"scirc\": \"\",\n\t\t\"scnap\": \"\",\n\t\t\"scnE\": \"\",\n\t\t\"scnsim\": \"\",\n\t\t\"scpolint\": \"\",\n\t\t\"scsim\": \"\",\n\t\t\"Scy\": \"\",\n\t\t\"scy\": \"\",\n\t\t\"sdotb\": \"\",\n\t\t\"sdot\": \"\",\n\t\t\"sdote\": \"\",\n\t\t\"searhk\": \"\",\n\t\t\"searr\": \"\",\n\t\t\"seArr\": \"\",\n\t\t\"searrow\": \"\",\n\t\t\"sect\": \"\",\n\t\t\"semi\": \";\",\n\t\t\"seswar\": \"\",\n\t\t\"setminus\": \"\",\n\t\t\"setmn\": \"\",\n\t\t\"sext\": \"\",\n\t\t\"Sfr\": \"\",\n\t\t\"sfr\": \"\",\n\t\t\"sfrown\": \"\",\n\t\t\"sharp\": \"\",\n\t\t\"SHCHcy\": \"\",\n\t\t\"shchcy\": \"\",\n\t\t\"SHcy\": \"\",\n\t\t\"shcy\": \"\",\n\t\t\"ShortDownArrow\": \"\",\n\t\t\"ShortLeftArrow\": \"\",\n\t\t\"shortmid\": \"\",\n\t\t\"shortparallel\": \"\",\n\t\t\"ShortRightArrow\": \"\",\n\t\t\"ShortUpArrow\": \"\",\n\t\t\"shy\": \"\",\n\t\t\"Sigma\": \"\",\n\t\t\"sigma\": \"\",\n\t\t\"sigmaf\": \"\",\n\t\t\"sigmav\": \"\",\n\t\t\"sim\": \"\",\n\t\t\"simdot\": \"\",\n\t\t\"sime\": \"\",\n\t\t\"simeq\": \"\",\n\t\t\"simg\": \"\",\n\t\t\"simgE\": \"\",\n\t\t\"siml\": \"\",\n\t\t\"simlE\": \"\",\n\t\t\"simne\": \"\",\n\t\t\"simplus\": \"\",\n\t\t\"simrarr\": \"\",\n\t\t\"slarr\": \"\",\n\t\t\"SmallCircle\": \"\",\n\t\t\"smallsetminus\": \"\",\n\t\t\"smashp\": \"\",\n\t\t\"smeparsl\": \"\",\n\t\t\"smid\": \"\",\n\t\t\"smile\": \"\",\n\t\t\"smt\": \"\",\n\t\t\"smte\": \"\",\n\t\t\"smtes\": \"\",\n\t\t\"SOFTcy\": \"\",\n\t\t\"softcy\": \"\",\n\t\t\"solbar\": \"\",\n\t\t\"solb\": \"\",\n\t\t\"sol\": \"/\",\n\t\t\"Sopf\": \"\",\n\t\t\"sopf\": \"\",\n\t\t\"spades\": \"\",\n\t\t\"spadesuit\": \"\",\n\t\t\"spar\": \"\",\n\t\t\"sqcap\": \"\",\n\t\t\"sqcaps\": \"\",\n\t\t\"sqcup\": \"\",\n\t\t\"sqcups\": \"\",\n\t\t\"Sqrt\": \"\",\n\t\t\"sqsub\": \"\",\n\t\t\"sqsube\": \"\",\n\t\t\"sqsubset\": \"\",\n\t\t\"sqsubseteq\": \"\",\n\t\t\"sqsup\": \"\",\n\t\t\"sqsupe\": \"\",\n\t\t\"sqsupset\": \"\",\n\t\t\"sqsupseteq\": \"\",\n\t\t\"square\": \"\",\n\t\t\"Square\": \"\",\n\t\t\"SquareIntersection\": \"\",\n\t\t\"SquareSubset\": \"\",\n\t\t\"SquareSubsetEqual\": \"\",\n\t\t\"SquareSuperset\": \"\",\n\t\t\"SquareSupersetEqual\": \"\",\n\t\t\"SquareUnion\": \"\",\n\t\t\"squarf\": \"\",\n\t\t\"squ\": \"\",\n\t\t\"squf\": \"\",\n\t\t\"srarr\": \"\",\n\t\t\"Sscr\": \"\",\n\t\t\"sscr\": \"\",\n\t\t\"ssetmn\": \"\",\n\t\t\"ssmile\": \"\",\n\t\t\"sstarf\": \"\",\n\t\t\"Star\": \"\",\n\t\t\"star\": \"\",\n\t\t\"starf\": \"\",\n\t\t\"straightepsilon\": \"\",\n\t\t\"straightphi\": \"\",\n\t\t\"strns\": \"\",\n\t\t\"sub\": \"\",\n\t\t\"Sub\": \"\",\n\t\t\"subdot\": \"\",\n\t\t\"subE\": \"\",\n\t\t\"sube\": \"\",\n\t\t\"subedot\": \"\",\n\t\t\"submult\": \"\",\n\t\t\"subnE\": \"\",\n\t\t\"subne\": \"\",\n\t\t\"subplus\": \"\",\n\t\t\"subrarr\": \"\",\n\t\t\"subset\": \"\",\n\t\t\"Subset\": \"\",\n\t\t\"subseteq\": \"\",\n\t\t\"subseteqq\": \"\",\n\t\t\"SubsetEqual\": \"\",\n\t\t\"subsetneq\": \"\",\n\t\t\"subsetneqq\": \"\",\n\t\t\"subsim\": \"\",\n\t\t\"subsub\": \"\",\n\t\t\"subsup\": \"\",\n\t\t\"succapprox\": \"\",\n\t\t\"succ\": \"\",\n\t\t\"succcurlyeq\": \"\",\n\t\t\"Succeeds\": \"\",\n\t\t\"SucceedsEqual\": \"\",\n\t\t\"SucceedsSlantEqual\": \"\",\n\t\t\"SucceedsTilde\": \"\",\n\t\t\"succeq\": \"\",\n\t\t\"succnapprox\": \"\",\n\t\t\"succneqq\": \"\",\n\t\t\"succnsim\": \"\",\n\t\t\"succsim\": \"\",\n\t\t\"SuchThat\": \"\",\n\t\t\"sum\": \"\",\n\t\t\"Sum\": \"\",\n\t\t\"sung\": \"\",\n\t\t\"sup1\": \"\",\n\t\t\"sup2\": \"\",\n\t\t\"sup3\": \"\",\n\t\t\"sup\": \"\",\n\t\t\"Sup\": \"\",\n\t\t\"supdot\": \"\",\n\t\t\"supdsub\": \"\",\n\t\t\"supE\": \"\",\n\t\t\"supe\": \"\",\n\t\t\"supedot\": \"\",\n\t\t\"Superset\": \"\",\n\t\t\"SupersetEqual\": \"\",\n\t\t\"suphsol\": \"\",\n\t\t\"suphsub\": \"\",\n\t\t\"suplarr\": \"\",\n\t\t\"supmult\": \"\",\n\t\t\"supnE\": \"\",\n\t\t\"supne\": \"\",\n\t\t\"supplus\": \"\",\n\t\t\"supset\": \"\",\n\t\t\"Supset\": \"\",\n\t\t\"supseteq\": \"\",\n\t\t\"supseteqq\": \"\",\n\t\t\"supsetneq\": \"\",\n\t\t\"supsetneqq\": \"\",\n\t\t\"supsim\": \"\",\n\t\t\"supsub\": \"\",\n\t\t\"supsup\": \"\",\n\t\t\"swarhk\": \"\",\n\t\t\"swarr\": \"\",\n\t\t\"swArr\": \"\",\n\t\t\"swarrow\": \"\",\n\t\t\"swnwar\": \"\",\n\t\t\"szlig\": \"\",\n\t\t\"Tab\": \"\\t\",\n\t\t\"target\": \"\",\n\t\t\"Tau\": \"\",\n\t\t\"tau\": \"\",\n\t\t\"tbrk\": \"\",\n\t\t\"Tcaron\": \"\",\n\t\t\"tcaron\": \"\",\n\t\t\"Tcedil\": \"\",\n\t\t\"tcedil\": \"\",\n\t\t\"Tcy\": \"\",\n\t\t\"tcy\": \"\",\n\t\t\"tdot\": \"\",\n\t\t\"telrec\": \"\",\n\t\t\"Tfr\": \"\",\n\t\t\"tfr\": \"\",\n\t\t\"there4\": \"\",\n\t\t\"therefore\": \"\",\n\t\t\"Therefore\": \"\",\n\t\t\"Theta\": \"\",\n\t\t\"theta\": \"\",\n\t\t\"thetasym\": \"\",\n\t\t\"thetav\": \"\",\n\t\t\"thickapprox\": \"\",\n\t\t\"thicksim\": \"\",\n\t\t\"ThickSpace\": \"\",\n\t\t\"ThinSpace\": \"\",\n\t\t\"thinsp\": \"\",\n\t\t\"thkap\": \"\",\n\t\t\"thksim\": \"\",\n\t\t\"THORN\": \"\",\n\t\t\"thorn\": \"\",\n\t\t\"tilde\": \"\",\n\t\t\"Tilde\": \"\",\n\t\t\"TildeEqual\": \"\",\n\t\t\"TildeFullEqual\": \"\",\n\t\t\"TildeTilde\": \"\",\n\t\t\"timesbar\": \"\",\n\t\t\"timesb\": \"\",\n\t\t\"times\": \"\",\n\t\t\"timesd\": \"\",\n\t\t\"tint\": \"\",\n\t\t\"toea\": \"\",\n\t\t\"topbot\": \"\",\n\t\t\"topcir\": \"\",\n\t\t\"top\": \"\",\n\t\t\"Topf\": \"\",\n\t\t\"topf\": \"\",\n\t\t\"topfork\": \"\",\n\t\t\"tosa\": \"\",\n\t\t\"tprime\": \"\",\n\t\t\"trade\": \"\",\n\t\t\"TRADE\": \"\",\n\t\t\"triangle\": \"\",\n\t\t\"triangledown\": \"\",\n\t\t\"triangleleft\": \"\",\n\t\t\"trianglelefteq\": \"\",\n\t\t\"triangleq\": \"\",\n\t\t\"triangleright\": \"\",\n\t\t\"trianglerighteq\": \"\",\n\t\t\"tridot\": \"\",\n\t\t\"trie\": \"\",\n\t\t\"triminus\": \"\",\n\t\t\"TripleDot\": \"\",\n\t\t\"triplus\": \"\",\n\t\t\"trisb\": \"\",\n\t\t\"tritime\": \"\",\n\t\t\"trpezium\": \"\",\n\t\t\"Tscr\": \"\",\n\t\t\"tscr\": \"\",\n\t\t\"TScy\": \"\",\n\t\t\"tscy\": \"\",\n\t\t\"TSHcy\": \"\",\n\t\t\"tshcy\": \"\",\n\t\t\"Tstrok\": \"\",\n\t\t\"tstrok\": \"\",\n\t\t\"twixt\": \"\",\n\t\t\"twoheadleftarrow\": \"\",\n\t\t\"twoheadrightarrow\": \"\",\n\t\t\"Uacute\": \"\",\n\t\t\"uacute\": \"\",\n\t\t\"uarr\": \"\",\n\t\t\"Uarr\": \"\",\n\t\t\"uArr\": \"\",\n\t\t\"Uarrocir\": \"\",\n\t\t\"Ubrcy\": \"\",\n\t\t\"ubrcy\": \"\",\n\t\t\"Ubreve\": \"\",\n\t\t\"ubreve\": \"\",\n\t\t\"Ucirc\": \"\",\n\t\t\"ucirc\": \"\",\n\t\t\"Ucy\": \"\",\n\t\t\"ucy\": \"\",\n\t\t\"udarr\": \"\",\n\t\t\"Udblac\": \"\",\n\t\t\"udblac\": \"\",\n\t\t\"udhar\": \"\",\n\t\t\"ufisht\": \"\",\n\t\t\"Ufr\": \"\",\n\t\t\"ufr\": \"\",\n\t\t\"Ugrave\": \"\",\n\t\t\"ugrave\": \"\",\n\t\t\"uHar\": \"\",\n\t\t\"uharl\": \"\",\n\t\t\"uharr\": \"\",\n\t\t\"uhblk\": \"\",\n\t\t\"ulcorn\": \"\",\n\t\t\"ulcorner\": \"\",\n\t\t\"ulcrop\": \"\",\n\t\t\"ultri\": \"\",\n\t\t\"Umacr\": \"\",\n\t\t\"umacr\": \"\",\n\t\t\"uml\": \"\",\n\t\t\"UnderBar\": \"_\",\n\t\t\"UnderBrace\": \"\",\n\t\t\"UnderBracket\": \"\",\n\t\t\"UnderParenthesis\": \"\",\n\t\t\"Union\": \"\",\n\t\t\"UnionPlus\": \"\",\n\t\t\"Uogon\": \"\",\n\t\t\"uogon\": \"\",\n\t\t\"Uopf\": \"\",\n\t\t\"uopf\": \"\",\n\t\t\"UpArrowBar\": \"\",\n\t\t\"uparrow\": \"\",\n\t\t\"UpArrow\": \"\",\n\t\t\"Uparrow\": \"\",\n\t\t\"UpArrowDownArrow\": \"\",\n\t\t\"updownarrow\": \"\",\n\t\t\"UpDownArrow\": \"\",\n\t\t\"Updownarrow\": \"\",\n\t\t\"UpEquilibrium\": \"\",\n\t\t\"upharpoonleft\": \"\",\n\t\t\"upharpoonright\": \"\",\n\t\t\"uplus\": \"\",\n\t\t\"UpperLeftArrow\": \"\",\n\t\t\"UpperRightArrow\": \"\",\n\t\t\"upsi\": \"\",\n\t\t\"Upsi\": \"\",\n\t\t\"upsih\": \"\",\n\t\t\"Upsilon\": \"\",\n\t\t\"upsilon\": \"\",\n\t\t\"UpTeeArrow\": \"\",\n\t\t\"UpTee\": \"\",\n\t\t\"upuparrows\": \"\",\n\t\t\"urcorn\": \"\",\n\t\t\"urcorner\": \"\",\n\t\t\"urcrop\": \"\",\n\t\t\"Uring\": \"\",\n\t\t\"uring\": \"\",\n\t\t\"urtri\": \"\",\n\t\t\"Uscr\": \"\",\n\t\t\"uscr\": \"\",\n\t\t\"utdot\": \"\",\n\t\t\"Utilde\": \"\",\n\t\t\"utilde\": \"\",\n\t\t\"utri\": \"\",\n\t\t\"utrif\": \"\",\n\t\t\"uuarr\": \"\",\n\t\t\"Uuml\": \"\",\n\t\t\"uuml\": \"\",\n\t\t\"uwangle\": \"\",\n\t\t\"vangrt\": \"\",\n\t\t\"varepsilon\": \"\",\n\t\t\"varkappa\": \"\",\n\t\t\"varnothing\": \"\",\n\t\t\"varphi\": \"\",\n\t\t\"varpi\": \"\",\n\t\t\"varpropto\": \"\",\n\t\t\"varr\": \"\",\n\t\t\"vArr\": \"\",\n\t\t\"varrho\": \"\",\n\t\t\"varsigma\": \"\",\n\t\t\"varsubsetneq\": \"\",\n\t\t\"varsubsetneqq\": \"\",\n\t\t\"varsupsetneq\": \"\",\n\t\t\"varsupsetneqq\": \"\",\n\t\t\"vartheta\": \"\",\n\t\t\"vartriangleleft\": \"\",\n\t\t\"vartriangleright\": \"\",\n\t\t\"vBar\": \"\",\n\t\t\"Vbar\": \"\",\n\t\t\"vBarv\": \"\",\n\t\t\"Vcy\": \"\",\n\t\t\"vcy\": \"\",\n\t\t\"vdash\": \"\",\n\t\t\"vDash\": \"\",\n\t\t\"Vdash\": \"\",\n\t\t\"VDash\": \"\",\n\t\t\"Vdashl\": \"\",\n\t\t\"veebar\": \"\",\n\t\t\"vee\": \"\",\n\t\t\"Vee\": \"\",\n\t\t\"veeeq\": \"\",\n\t\t\"vellip\": \"\",\n\t\t\"verbar\": \"|\",\n\t\t\"Verbar\": \"\",\n\t\t\"vert\": \"|\",\n\t\t\"Vert\": \"\",\n\t\t\"VerticalBar\": \"\",\n\t\t\"VerticalLine\": \"|\",\n\t\t\"VerticalSeparator\": \"\",\n\t\t\"VerticalTilde\": \"\",\n\t\t\"VeryThinSpace\": \"\",\n\t\t\"Vfr\": \"\",\n\t\t\"vfr\": \"\",\n\t\t\"vltri\": \"\",\n\t\t\"vnsub\": \"\",\n\t\t\"vnsup\": \"\",\n\t\t\"Vopf\": \"\",\n\t\t\"vopf\": \"\",\n\t\t\"vprop\": \"\",\n\t\t\"vrtri\": \"\",\n\t\t\"Vscr\": \"\",\n\t\t\"vscr\": \"\",\n\t\t\"vsubnE\": \"\",\n\t\t\"vsubne\": \"\",\n\t\t\"vsupnE\": \"\",\n\t\t\"vsupne\": \"\",\n\t\t\"Vvdash\": \"\",\n\t\t\"vzigzag\": \"\",\n\t\t\"Wcirc\": \"\",\n\t\t\"wcirc\": \"\",\n\t\t\"wedbar\": \"\",\n\t\t\"wedge\": \"\",\n\t\t\"Wedge\": \"\",\n\t\t\"wedgeq\": \"\",\n\t\t\"weierp\": \"\",\n\t\t\"Wfr\": \"\",\n\t\t\"wfr\": \"\",\n\t\t\"Wopf\": \"\",\n\t\t\"wopf\": \"\",\n\t\t\"wp\": \"\",\n\t\t\"wr\": \"\",\n\t\t\"wreath\": \"\",\n\t\t\"Wscr\": \"\",\n\t\t\"wscr\": \"\",\n\t\t\"xcap\": \"\",\n\t\t\"xcirc\": \"\",\n\t\t\"xcup\": \"\",\n\t\t\"xdtri\": \"\",\n\t\t\"Xfr\": \"\",\n\t\t\"xfr\": \"\",\n\t\t\"xharr\": \"\",\n\t\t\"xhArr\": \"\",\n\t\t\"Xi\": \"\",\n\t\t\"xi\": \"\",\n\t\t\"xlarr\": \"\",\n\t\t\"xlArr\": \"\",\n\t\t\"xmap\": \"\",\n\t\t\"xnis\": \"\",\n\t\t\"xodot\": \"\",\n\t\t\"Xopf\": \"\",\n\t\t\"xopf\": \"\",\n\t\t\"xoplus\": \"\",\n\t\t\"xotime\": \"\",\n\t\t\"xrarr\": \"\",\n\t\t\"xrArr\": \"\",\n\t\t\"Xscr\": \"\",\n\t\t\"xscr\": \"\",\n\t\t\"xsqcup\": \"\",\n\t\t\"xuplus\": \"\",\n\t\t\"xutri\": \"\",\n\t\t\"xvee\": \"\",\n\t\t\"xwedge\": \"\",\n\t\t\"Yacute\": \"\",\n\t\t\"yacute\": \"\",\n\t\t\"YAcy\": \"\",\n\t\t\"yacy\": \"\",\n\t\t\"Ycirc\": \"\",\n\t\t\"ycirc\": \"\",\n\t\t\"Ycy\": \"\",\n\t\t\"ycy\": \"\",\n\t\t\"yen\": \"\",\n\t\t\"Yfr\": \"\",\n\t\t\"yfr\": \"\",\n\t\t\"YIcy\": \"\",\n\t\t\"yicy\": \"\",\n\t\t\"Yopf\": \"\",\n\t\t\"yopf\": \"\",\n\t\t\"Yscr\": \"\",\n\t\t\"yscr\": \"\",\n\t\t\"YUcy\": \"\",\n\t\t\"yucy\": \"\",\n\t\t\"yuml\": \"\",\n\t\t\"Yuml\": \"\",\n\t\t\"Zacute\": \"\",\n\t\t\"zacute\": \"\",\n\t\t\"Zcaron\": \"\",\n\t\t\"zcaron\": \"\",\n\t\t\"Zcy\": \"\",\n\t\t\"zcy\": \"\",\n\t\t\"Zdot\": \"\",\n\t\t\"zdot\": \"\",\n\t\t\"zeetrf\": \"\",\n\t\t\"ZeroWidthSpace\": \"\",\n\t\t\"Zeta\": \"\",\n\t\t\"zeta\": \"\",\n\t\t\"zfr\": \"\",\n\t\t\"Zfr\": \"\",\n\t\t\"ZHcy\": \"\",\n\t\t\"zhcy\": \"\",\n\t\t\"zigrarr\": \"\",\n\t\t\"zopf\": \"\",\n\t\t\"Zopf\": \"\",\n\t\t\"Zscr\": \"\",\n\t\t\"zscr\": \"\",\n\t\t\"zwj\": \"\",\n\t\t\"zwnj\": \"\"\n\t};\n\n/***/ },\n/* 258 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = /[!-#%-\\*,-/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDE38-\\uDE3D]|\\uD805[\\uDCC6\\uDDC1-\\uDDC9\\uDE41-\\uDE43]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F/;\n\n/***/ },\n/* 259 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports.encode = __webpack_require__(260);\n\tmodule.exports.decode = __webpack_require__(261);\n\tmodule.exports.format = __webpack_require__(262);\n\tmodule.exports.parse = __webpack_require__(263);\n\n/***/ },\n/* 260 */\n/***/ function(module, exports) {\n\n\t\n\t'use strict';\n\t\n\tvar encodeCache = {};\n\t\n\t// Create a lookup array where anything but characters in `chars` string\n\t// and alphanumeric chars is percent-encoded.\n\t//\n\tfunction getEncodeCache(exclude) {\n\t  var i,\n\t      ch,\n\t      cache = encodeCache[exclude];\n\t  if (cache) {\n\t    return cache;\n\t  }\n\t\n\t  cache = encodeCache[exclude] = [];\n\t\n\t  for (i = 0; i < 128; i++) {\n\t    ch = String.fromCharCode(i);\n\t\n\t    if (/^[0-9a-z]$/i.test(ch)) {\n\t      // always allow unencoded alphanumeric characters\n\t      cache.push(ch);\n\t    } else {\n\t      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n\t    }\n\t  }\n\t\n\t  for (i = 0; i < exclude.length; i++) {\n\t    cache[exclude.charCodeAt(i)] = exclude[i];\n\t  }\n\t\n\t  return cache;\n\t}\n\t\n\t// Encode unsafe characters with percent-encoding, skipping already\n\t// encoded sequences.\n\t//\n\t//  - string       - string to encode\n\t//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n\t//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n\t//\n\tfunction encode(string, exclude, keepEscaped) {\n\t  var i,\n\t      l,\n\t      code,\n\t      nextCode,\n\t      cache,\n\t      result = '';\n\t\n\t  if (typeof exclude !== 'string') {\n\t    // encode(string, keepEscaped)\n\t    keepEscaped = exclude;\n\t    exclude = encode.defaultChars;\n\t  }\n\t\n\t  if (typeof keepEscaped === 'undefined') {\n\t    keepEscaped = true;\n\t  }\n\t\n\t  cache = getEncodeCache(exclude);\n\t\n\t  for (i = 0, l = string.length; i < l; i++) {\n\t    code = string.charCodeAt(i);\n\t\n\t    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n\t      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n\t        result += string.slice(i, i + 3);\n\t        i += 2;\n\t        continue;\n\t      }\n\t    }\n\t\n\t    if (code < 128) {\n\t      result += cache[code];\n\t      continue;\n\t    }\n\t\n\t    if (code >= 0xD800 && code <= 0xDFFF) {\n\t      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n\t        nextCode = string.charCodeAt(i + 1);\n\t        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n\t          result += encodeURIComponent(string[i] + string[i + 1]);\n\t          i++;\n\t          continue;\n\t        }\n\t      }\n\t      result += '%EF%BF%BD';\n\t      continue;\n\t    }\n\t\n\t    result += encodeURIComponent(string[i]);\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tencode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\n\tencode.componentChars = \"-_.!~*'()\";\n\t\n\tmodule.exports = encode;\n\n/***/ },\n/* 261 */\n/***/ function(module, exports) {\n\n\t\n\t'use strict';\n\t\n\t/* eslint-disable no-bitwise */\n\t\n\tvar decodeCache = {};\n\t\n\tfunction getDecodeCache(exclude) {\n\t  var i,\n\t      ch,\n\t      cache = decodeCache[exclude];\n\t  if (cache) {\n\t    return cache;\n\t  }\n\t\n\t  cache = decodeCache[exclude] = [];\n\t\n\t  for (i = 0; i < 128; i++) {\n\t    ch = String.fromCharCode(i);\n\t    cache.push(ch);\n\t  }\n\t\n\t  for (i = 0; i < exclude.length; i++) {\n\t    ch = exclude.charCodeAt(i);\n\t    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n\t  }\n\t\n\t  return cache;\n\t}\n\t\n\t// Decode percent-encoded string.\n\t//\n\tfunction decode(string, exclude) {\n\t  var cache;\n\t\n\t  if (typeof exclude !== 'string') {\n\t    exclude = decode.defaultChars;\n\t  }\n\t\n\t  cache = getDecodeCache(exclude);\n\t\n\t  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {\n\t    var i,\n\t        l,\n\t        b1,\n\t        b2,\n\t        b3,\n\t        b4,\n\t        chr,\n\t        result = '';\n\t\n\t    for (i = 0, l = seq.length; i < l; i += 3) {\n\t      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\t\n\t      if (b1 < 0x80) {\n\t        result += cache[b1];\n\t        continue;\n\t      }\n\t\n\t      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {\n\t        // 110xxxxx 10xxxxxx\n\t        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\t\n\t        if ((b2 & 0xC0) === 0x80) {\n\t          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;\n\t\n\t          if (chr < 0x80) {\n\t            result += '';\n\t          } else {\n\t            result += String.fromCharCode(chr);\n\t          }\n\t\n\t          i += 3;\n\t          continue;\n\t        }\n\t      }\n\t\n\t      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {\n\t        // 1110xxxx 10xxxxxx 10xxxxxx\n\t        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\t        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\t\n\t        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n\t          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;\n\t\n\t          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {\n\t            result += '';\n\t          } else {\n\t            result += String.fromCharCode(chr);\n\t          }\n\t\n\t          i += 6;\n\t          continue;\n\t        }\n\t      }\n\t\n\t      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {\n\t        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n\t        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\t        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\t        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\t\n\t        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n\t          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;\n\t\n\t          if (chr < 0x10000 || chr > 0x10FFFF) {\n\t            result += '';\n\t          } else {\n\t            chr -= 0x10000;\n\t            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n\t          }\n\t\n\t          i += 9;\n\t          continue;\n\t        }\n\t      }\n\t\n\t      result += '';\n\t    }\n\t\n\t    return result;\n\t  });\n\t}\n\t\n\tdecode.defaultChars = ';/?:@&=+$,#';\n\tdecode.componentChars = '';\n\t\n\tmodule.exports = decode;\n\n/***/ },\n/* 262 */\n/***/ function(module, exports) {\n\n\t\n\t'use strict';\n\t\n\tmodule.exports = function format(url) {\n\t  var result = '';\n\t\n\t  result += url.protocol || '';\n\t  result += url.slashes ? '//' : '';\n\t  result += url.auth ? url.auth + '@' : '';\n\t\n\t  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n\t    // ipv6 address\n\t    result += '[' + url.hostname + ']';\n\t  } else {\n\t    result += url.hostname || '';\n\t  }\n\t\n\t  result += url.port ? ':' + url.port : '';\n\t  result += url.pathname || '';\n\t  result += url.search || '';\n\t  result += url.hash || '';\n\t\n\t  return result;\n\t};\n\n/***/ },\n/* 263 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t'use strict';\n\t\n\t//\n\t// Changes from joyent/node:\n\t//\n\t// 1. No leading slash in paths,\n\t//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n\t//\n\t// 2. Backslashes are not replaced with slashes,\n\t//    so `http:\\\\example.org\\` is treated like a relative path\n\t//\n\t// 3. Trailing colon is treated like a part of the path,\n\t//    i.e. in `http://example.org:foo` pathname is `:foo`\n\t//\n\t// 4. Nothing is URL-encoded in the resulting object,\n\t//    (in joyent/node some chars in auth and paths are encoded)\n\t//\n\t// 5. `url.parse()` does not have `parseQueryString` argument\n\t//\n\t// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n\t//    which can be constructed using other parts of the url.\n\t//\n\t\n\tfunction Url() {\n\t  this.protocol = null;\n\t  this.slashes = null;\n\t  this.auth = null;\n\t  this.port = null;\n\t  this.hostname = null;\n\t  this.hash = null;\n\t  this.search = null;\n\t  this.pathname = null;\n\t}\n\t\n\t// Reference: RFC 3986, RFC 1808, RFC 2396\n\t\n\t// define these here so at least they only have to be\n\t// compiled once on the first module load.\n\tvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n\t    portPattern = /:[0-9]*$/,\n\t\n\t// Special case for a simple path URL\n\tsimplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\t\n\t// RFC 2396: characters reserved for delimiting URLs.\n\t// We actually just auto-escape these.\n\tdelims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\t\n\t// RFC 2396: characters not allowed for various reasons.\n\tunwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\t\n\t// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n\tautoEscape = ['\\''].concat(unwise),\n\t\n\t// Characters that are never ever allowed in a hostname.\n\t// Note that any invalid chars are also handled, but these\n\t// are the ones that are *expected* to be seen, so we fast-path\n\t// them.\n\tnonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n\t    hostEndingChars = ['/', '?', '#'],\n\t    hostnameMaxLen = 255,\n\t    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n\t    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n\t\n\t// protocols that can allow \"unsafe\" and \"unwise\" chars.\n\t/* eslint-disable no-script-url */\n\t// protocols that never have a hostname.\n\thostlessProtocol = {\n\t  'javascript': true,\n\t  'javascript:': true\n\t},\n\t\n\t// protocols that always contain a // bit.\n\tslashedProtocol = {\n\t  'http': true,\n\t  'https': true,\n\t  'ftp': true,\n\t  'gopher': true,\n\t  'file': true,\n\t  'http:': true,\n\t  'https:': true,\n\t  'ftp:': true,\n\t  'gopher:': true,\n\t  'file:': true\n\t};\n\t/* eslint-enable no-script-url */\n\t\n\tfunction urlParse(url, slashesDenoteHost) {\n\t  if (url && url instanceof Url) {\n\t    return url;\n\t  }\n\t\n\t  var u = new Url();\n\t  u.parse(url, slashesDenoteHost);\n\t  return u;\n\t}\n\t\n\tUrl.prototype.parse = function (url, slashesDenoteHost) {\n\t  var i,\n\t      l,\n\t      lowerProto,\n\t      hec,\n\t      slashes,\n\t      rest = url;\n\t\n\t  // trim before proceeding.\n\t  // This is to support parse stuff like \"  http://foo.com  \\n\"\n\t  rest = rest.trim();\n\t\n\t  if (!slashesDenoteHost && url.split('#').length === 1) {\n\t    // Try fast path regexp\n\t    var simplePath = simplePathPattern.exec(rest);\n\t    if (simplePath) {\n\t      this.pathname = simplePath[1];\n\t      if (simplePath[2]) {\n\t        this.search = simplePath[2];\n\t      }\n\t      return this;\n\t    }\n\t  }\n\t\n\t  var proto = protocolPattern.exec(rest);\n\t  if (proto) {\n\t    proto = proto[0];\n\t    lowerProto = proto.toLowerCase();\n\t    this.protocol = proto;\n\t    rest = rest.substr(proto.length);\n\t  }\n\t\n\t  // figure out if it's got a host\n\t  // user@server is *always* interpreted as a hostname, and url\n\t  // resolution will treat //foo/bar as host=foo,path=bar because that's\n\t  // how the browser resolves relative URLs.\n\t  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n\t    slashes = rest.substr(0, 2) === '//';\n\t    if (slashes && !(proto && hostlessProtocol[proto])) {\n\t      rest = rest.substr(2);\n\t      this.slashes = true;\n\t    }\n\t  }\n\t\n\t  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n\t\n\t    // there's a hostname.\n\t    // the first instance of /, ?, ;, or # ends the host.\n\t    //\n\t    // If there is an @ in the hostname, then non-host chars *are* allowed\n\t    // to the left of the last @ sign, unless some host-ending character\n\t    // comes *before* the @-sign.\n\t    // URLs are obnoxious.\n\t    //\n\t    // ex:\n\t    // http://a@b@c/ => user:a@b host:c\n\t    // http://a@b?@c => user:a host:c path:/?@c\n\t\n\t    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n\t    // Review our test case against browsers more comprehensively.\n\t\n\t    // find the first instance of any hostEndingChars\n\t    var hostEnd = -1;\n\t    for (i = 0; i < hostEndingChars.length; i++) {\n\t      hec = rest.indexOf(hostEndingChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n\t        hostEnd = hec;\n\t      }\n\t    }\n\t\n\t    // at this point, either we have an explicit point where the\n\t    // auth portion cannot go past, or the last @ char is the decider.\n\t    var auth, atSign;\n\t    if (hostEnd === -1) {\n\t      // atSign can be anywhere.\n\t      atSign = rest.lastIndexOf('@');\n\t    } else {\n\t      // atSign must be in auth portion.\n\t      // http://a@b/c@d => host:b auth:a path:/c@d\n\t      atSign = rest.lastIndexOf('@', hostEnd);\n\t    }\n\t\n\t    // Now we have a portion which is definitely the auth.\n\t    // Pull that off.\n\t    if (atSign !== -1) {\n\t      auth = rest.slice(0, atSign);\n\t      rest = rest.slice(atSign + 1);\n\t      this.auth = auth;\n\t    }\n\t\n\t    // the host is the remaining to the left of the first non-host char\n\t    hostEnd = -1;\n\t    for (i = 0; i < nonHostChars.length; i++) {\n\t      hec = rest.indexOf(nonHostChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n\t        hostEnd = hec;\n\t      }\n\t    }\n\t    // if we still have not hit it, then the entire thing is a host.\n\t    if (hostEnd === -1) {\n\t      hostEnd = rest.length;\n\t    }\n\t\n\t    if (rest[hostEnd - 1] === ':') {\n\t      hostEnd--;\n\t    }\n\t    var host = rest.slice(0, hostEnd);\n\t    rest = rest.slice(hostEnd);\n\t\n\t    // pull out port.\n\t    this.parseHost(host);\n\t\n\t    // we've indicated that there is a hostname,\n\t    // so even if it's empty, it has to be present.\n\t    this.hostname = this.hostname || '';\n\t\n\t    // if hostname begins with [ and ends with ]\n\t    // assume that it's an IPv6 address.\n\t    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\t\n\t    // validate a little.\n\t    if (!ipv6Hostname) {\n\t      var hostparts = this.hostname.split(/\\./);\n\t      for (i = 0, l = hostparts.length; i < l; i++) {\n\t        var part = hostparts[i];\n\t        if (!part) {\n\t          continue;\n\t        }\n\t        if (!part.match(hostnamePartPattern)) {\n\t          var newpart = '';\n\t          for (var j = 0, k = part.length; j < k; j++) {\n\t            if (part.charCodeAt(j) > 127) {\n\t              // we replace non-ASCII char with a temporary placeholder\n\t              // we need this to make sure size of hostname is not\n\t              // broken by replacing non-ASCII by nothing\n\t              newpart += 'x';\n\t            } else {\n\t              newpart += part[j];\n\t            }\n\t          }\n\t          // we test again with ASCII char only\n\t          if (!newpart.match(hostnamePartPattern)) {\n\t            var validParts = hostparts.slice(0, i);\n\t            var notHost = hostparts.slice(i + 1);\n\t            var bit = part.match(hostnamePartStart);\n\t            if (bit) {\n\t              validParts.push(bit[1]);\n\t              notHost.unshift(bit[2]);\n\t            }\n\t            if (notHost.length) {\n\t              rest = notHost.join('.') + rest;\n\t            }\n\t            this.hostname = validParts.join('.');\n\t            break;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (this.hostname.length > hostnameMaxLen) {\n\t      this.hostname = '';\n\t    }\n\t\n\t    // strip [ and ] from the hostname\n\t    // the host field still retains them, though\n\t    if (ipv6Hostname) {\n\t      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\t    }\n\t  }\n\t\n\t  // chop off from the tail first.\n\t  var hash = rest.indexOf('#');\n\t  if (hash !== -1) {\n\t    // got a fragment string.\n\t    this.hash = rest.substr(hash);\n\t    rest = rest.slice(0, hash);\n\t  }\n\t  var qm = rest.indexOf('?');\n\t  if (qm !== -1) {\n\t    this.search = rest.substr(qm);\n\t    rest = rest.slice(0, qm);\n\t  }\n\t  if (rest) {\n\t    this.pathname = rest;\n\t  }\n\t  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n\t    this.pathname = '';\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tUrl.prototype.parseHost = function (host) {\n\t  var port = portPattern.exec(host);\n\t  if (port) {\n\t    port = port[0];\n\t    if (port !== ':') {\n\t      this.port = port.substr(1);\n\t    }\n\t    host = host.substr(0, host.length - port.length);\n\t  }\n\t  if (host) {\n\t    this.hostname = host;\n\t  }\n\t};\n\t\n\tmodule.exports = urlParse;\n\n/***/ },\n/* 264 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports.Any = __webpack_require__(265);\n\tmodule.exports.Cc = __webpack_require__(266);\n\tmodule.exports.Cf = __webpack_require__(267);\n\tmodule.exports.P = __webpack_require__(258);\n\tmodule.exports.Z = __webpack_require__(268);\n\n/***/ },\n/* 265 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = /[\\0-\\uD7FF\\uDC00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]/;\n\n/***/ },\n/* 266 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = /[\\0-\\x1F\\x7F-\\x9F]/;\n\n/***/ },\n/* 267 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/;\n\n/***/ },\n/* 268 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = /[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n\n/***/ },\n/* 269 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Just a shortcut for bulk export\n\t'use strict';\n\t\n\texports.parseLinkLabel = __webpack_require__(270);\n\texports.parseLinkDestination = __webpack_require__(271);\n\texports.parseLinkTitle = __webpack_require__(272);\n\n/***/ },\n/* 270 */\n/***/ function(module, exports) {\n\n\t// Parse link label\n\t//\n\t// this function assumes that first character (\"[\") already matches;\n\t// returns the end of the label\n\t//\n\t'use strict';\n\t\n\tmodule.exports = function parseLinkLabel(state, start, disableNested) {\n\t  var level,\n\t      found,\n\t      marker,\n\t      prevPos,\n\t      labelEnd = -1,\n\t      max = state.posMax,\n\t      oldPos = state.pos;\n\t\n\t  state.pos = start + 1;\n\t  level = 1;\n\t\n\t  while (state.pos < max) {\n\t    marker = state.src.charCodeAt(state.pos);\n\t    if (marker === 0x5D /* ] */) {\n\t        level--;\n\t        if (level === 0) {\n\t          found = true;\n\t          break;\n\t        }\n\t      }\n\t\n\t    prevPos = state.pos;\n\t    state.md.inline.skipToken(state);\n\t    if (marker === 0x5B /* [ */) {\n\t        if (prevPos === state.pos - 1) {\n\t          // increase level if we find text `[`, which is not a part of any token\n\t          level++;\n\t        } else if (disableNested) {\n\t          state.pos = oldPos;\n\t          return -1;\n\t        }\n\t      }\n\t  }\n\t\n\t  if (found) {\n\t    labelEnd = state.pos;\n\t  }\n\t\n\t  // restore old state\n\t  state.pos = oldPos;\n\t\n\t  return labelEnd;\n\t};\n\n/***/ },\n/* 271 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Parse link destination\n\t//\n\t'use strict';\n\t\n\tvar isSpace = __webpack_require__(255).isSpace;\n\tvar unescapeAll = __webpack_require__(255).unescapeAll;\n\t\n\tmodule.exports = function parseLinkDestination(str, pos, max) {\n\t  var code,\n\t      level,\n\t      lines = 0,\n\t      start = pos,\n\t      result = {\n\t    ok: false,\n\t    pos: 0,\n\t    lines: 0,\n\t    str: ''\n\t  };\n\t\n\t  if (str.charCodeAt(pos) === 0x3C /* < */) {\n\t      pos++;\n\t      while (pos < max) {\n\t        code = str.charCodeAt(pos);\n\t        if (code === 0x0A /* \\n */ || isSpace(code)) {\n\t          return result;\n\t        }\n\t        if (code === 0x3E /* > */) {\n\t            result.pos = pos + 1;\n\t            result.str = unescapeAll(str.slice(start + 1, pos));\n\t            result.ok = true;\n\t            return result;\n\t          }\n\t        if (code === 0x5C /* \\ */ && pos + 1 < max) {\n\t          pos += 2;\n\t          continue;\n\t        }\n\t\n\t        pos++;\n\t      }\n\t\n\t      // no closing '>'\n\t      return result;\n\t    }\n\t\n\t  // this should be ... } else { ... branch\n\t\n\t  level = 0;\n\t  while (pos < max) {\n\t    code = str.charCodeAt(pos);\n\t\n\t    if (code === 0x20) {\n\t      break;\n\t    }\n\t\n\t    // ascii control characters\n\t    if (code < 0x20 || code === 0x7F) {\n\t      break;\n\t    }\n\t\n\t    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n\t      pos += 2;\n\t      continue;\n\t    }\n\t\n\t    if (code === 0x28 /* ( */) {\n\t        level++;\n\t        if (level > 1) {\n\t          break;\n\t        }\n\t      }\n\t\n\t    if (code === 0x29 /* ) */) {\n\t        level--;\n\t        if (level < 0) {\n\t          break;\n\t        }\n\t      }\n\t\n\t    pos++;\n\t  }\n\t\n\t  if (start === pos) {\n\t    return result;\n\t  }\n\t\n\t  result.str = unescapeAll(str.slice(start, pos));\n\t  result.lines = lines;\n\t  result.pos = pos;\n\t  result.ok = true;\n\t  return result;\n\t};\n\n/***/ },\n/* 272 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Parse link title\n\t//\n\t'use strict';\n\t\n\tvar unescapeAll = __webpack_require__(255).unescapeAll;\n\t\n\tmodule.exports = function parseLinkTitle(str, pos, max) {\n\t  var code,\n\t      marker,\n\t      lines = 0,\n\t      start = pos,\n\t      result = {\n\t    ok: false,\n\t    pos: 0,\n\t    lines: 0,\n\t    str: ''\n\t  };\n\t\n\t  if (pos >= max) {\n\t    return result;\n\t  }\n\t\n\t  marker = str.charCodeAt(pos);\n\t\n\t  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {\n\t      return result;\n\t    }\n\t\n\t  pos++;\n\t\n\t  // if opening marker is \"(\", switch it to closing marker \")\"\n\t  if (marker === 0x28) {\n\t    marker = 0x29;\n\t  }\n\t\n\t  while (pos < max) {\n\t    code = str.charCodeAt(pos);\n\t    if (code === marker) {\n\t      result.pos = pos + 1;\n\t      result.lines = lines;\n\t      result.str = unescapeAll(str.slice(start + 1, pos));\n\t      result.ok = true;\n\t      return result;\n\t    } else if (code === 0x0A) {\n\t      lines++;\n\t    } else if (code === 0x5C /* \\ */ && pos + 1 < max) {\n\t      pos++;\n\t      if (str.charCodeAt(pos) === 0x0A) {\n\t        lines++;\n\t      }\n\t    }\n\t\n\t    pos++;\n\t  }\n\t\n\t  return result;\n\t};\n\n/***/ },\n/* 273 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * class Renderer\n\t *\n\t * Generates HTML from parsed token stream. Each instance has independent\n\t * copy of rules. Those can be rewritten with ease. Also, you can add new\n\t * rules if you create plugin and adds new token types.\n\t **/\n\t'use strict';\n\t\n\tvar assign = __webpack_require__(255).assign;\n\tvar unescapeAll = __webpack_require__(255).unescapeAll;\n\tvar escapeHtml = __webpack_require__(255).escapeHtml;\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar default_rules = {};\n\t\n\tdefault_rules.code_inline = function (tokens, idx /*, options, env */) {\n\t  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n\t};\n\t\n\tdefault_rules.code_block = function (tokens, idx /*, options, env */) {\n\t  return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\n\t};\n\t\n\tdefault_rules.fence = function (tokens, idx, options, env, slf) {\n\t  var token = tokens[idx],\n\t      info = token.info ? unescapeAll(token.info).trim() : '',\n\t      langName = '',\n\t      highlighted;\n\t\n\t  if (info) {\n\t    langName = info.split(/\\s+/g)[0];\n\t    token.attrJoin('class', options.langPrefix + langName);\n\t  }\n\t\n\t  if (options.highlight) {\n\t    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n\t  } else {\n\t    highlighted = escapeHtml(token.content);\n\t  }\n\t\n\t  if (highlighted.indexOf('<pre') === 0) {\n\t    return highlighted + '\\n';\n\t  }\n\t\n\t  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\\n';\n\t};\n\t\n\tdefault_rules.image = function (tokens, idx, options, env, slf) {\n\t  var token = tokens[idx];\n\t\n\t  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n\t  // should be placed on proper position for tests.\n\t  //\n\t  // Replace content with actual value\n\t\n\t  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);\n\t\n\t  return slf.renderToken(tokens, idx, options);\n\t};\n\t\n\tdefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n\t  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n\t};\n\tdefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n\t  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n\t};\n\t\n\tdefault_rules.text = function (tokens, idx /*, options, env */) {\n\t  return escapeHtml(tokens[idx].content);\n\t};\n\t\n\tdefault_rules.html_block = function (tokens, idx /*, options, env */) {\n\t  return tokens[idx].content;\n\t};\n\tdefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n\t  return tokens[idx].content;\n\t};\n\t\n\t/**\n\t * new Renderer()\n\t *\n\t * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n\t **/\n\tfunction Renderer() {\n\t\n\t  /**\n\t   * Renderer#rules -> Object\n\t   *\n\t   * Contains render rules for tokens. Can be updated and extended.\n\t   *\n\t   * ##### Example\n\t   *\n\t   * ```javascript\n\t   * var md = require('markdown-it')();\n\t   *\n\t   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n\t   * md.renderer.rules.strong_close = function () { return '</b>'; };\n\t   *\n\t   * var result = md.renderInline(...);\n\t   * ```\n\t   *\n\t   * Each rule is called as independed static function with fixed signature:\n\t   *\n\t   * ```javascript\n\t   * function my_token_render(tokens, idx, options, env, renderer) {\n\t   *   // ...\n\t   *   return renderedHTML;\n\t   * }\n\t   * ```\n\t   *\n\t   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n\t   * for more details and examples.\n\t   **/\n\t  this.rules = assign({}, default_rules);\n\t}\n\t\n\t/**\n\t * Renderer.renderAttrs(token) -> String\n\t *\n\t * Render token attributes to string.\n\t **/\n\tRenderer.prototype.renderAttrs = function renderAttrs(token) {\n\t  var i, l, result;\n\t\n\t  if (!token.attrs) {\n\t    return '';\n\t  }\n\t\n\t  result = '';\n\t\n\t  for (i = 0, l = token.attrs.length; i < l; i++) {\n\t    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * Renderer.renderToken(tokens, idx, options) -> String\n\t * - tokens (Array): list of tokens\n\t * - idx (Numbed): token index to render\n\t * - options (Object): params of parser instance\n\t *\n\t * Default token renderer. Can be overriden by custom function\n\t * in [[Renderer#rules]].\n\t **/\n\tRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n\t  var nextToken,\n\t      result = '',\n\t      needLf = false,\n\t      token = tokens[idx];\n\t\n\t  // Tight list paragraphs\n\t  if (token.hidden) {\n\t    return '';\n\t  }\n\t\n\t  // Insert a newline between hidden paragraph and subsequent opening\n\t  // block-level tag.\n\t  //\n\t  // For example, here we should insert a newline before blockquote:\n\t  //  - a\n\t  //    >\n\t  //\n\t  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n\t    result += '\\n';\n\t  }\n\t\n\t  // Add token name, e.g. `<img`\n\t  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\t\n\t  // Encode attributes, e.g. `<img src=\"foo\"`\n\t  result += this.renderAttrs(token);\n\t\n\t  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n\t  if (token.nesting === 0 && options.xhtmlOut) {\n\t    result += ' /';\n\t  }\n\t\n\t  // Check if we need to add a newline after this tag\n\t  if (token.block) {\n\t    needLf = true;\n\t\n\t    if (token.nesting === 1) {\n\t      if (idx + 1 < tokens.length) {\n\t        nextToken = tokens[idx + 1];\n\t\n\t        if (nextToken.type === 'inline' || nextToken.hidden) {\n\t          // Block-level tag containing an inline tag.\n\t          //\n\t          needLf = false;\n\t        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n\t          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n\t          //\n\t          needLf = false;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  result += needLf ? '>\\n' : '>';\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * Renderer.renderInline(tokens, options, env) -> String\n\t * - tokens (Array): list on block tokens to renter\n\t * - options (Object): params of parser instance\n\t * - env (Object): additional data from parsed input (references, for example)\n\t *\n\t * The same as [[Renderer.render]], but for single token of `inline` type.\n\t **/\n\tRenderer.prototype.renderInline = function (tokens, options, env) {\n\t  var type,\n\t      result = '',\n\t      rules = this.rules;\n\t\n\t  for (var i = 0, len = tokens.length; i < len; i++) {\n\t    type = tokens[i].type;\n\t\n\t    if (typeof rules[type] !== 'undefined') {\n\t      result += rules[type](tokens, i, options, env, this);\n\t    } else {\n\t      result += this.renderToken(tokens, i, options);\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/** internal\n\t * Renderer.renderInlineAsText(tokens, options, env) -> String\n\t * - tokens (Array): list on block tokens to renter\n\t * - options (Object): params of parser instance\n\t * - env (Object): additional data from parsed input (references, for example)\n\t *\n\t * Special kludge for image `alt` attributes to conform CommonMark spec.\n\t * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n\t * instead of simple escaping.\n\t **/\n\tRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n\t  var result = '',\n\t      rules = this.rules;\n\t\n\t  for (var i = 0, len = tokens.length; i < len; i++) {\n\t    if (tokens[i].type === 'text') {\n\t      result += rules.text(tokens, i, options, env, this);\n\t    } else if (tokens[i].type === 'image') {\n\t      result += this.renderInlineAsText(tokens[i].children, options, env);\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * Renderer.render(tokens, options, env) -> String\n\t * - tokens (Array): list on block tokens to renter\n\t * - options (Object): params of parser instance\n\t * - env (Object): additional data from parsed input (references, for example)\n\t *\n\t * Takes token stream and generates HTML. Probably, you will never need to call\n\t * this method directly.\n\t **/\n\tRenderer.prototype.render = function (tokens, options, env) {\n\t  var i,\n\t      len,\n\t      type,\n\t      result = '',\n\t      rules = this.rules;\n\t\n\t  for (i = 0, len = tokens.length; i < len; i++) {\n\t    type = tokens[i].type;\n\t\n\t    if (type === 'inline') {\n\t      result += this.renderInline(tokens[i].children, options, env);\n\t    } else if (typeof rules[type] !== 'undefined') {\n\t      result += rules[tokens[i].type](tokens, i, options, env, this);\n\t    } else {\n\t      result += this.renderToken(tokens, i, options, env);\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\tmodule.exports = Renderer;\n\n/***/ },\n/* 274 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** internal\n\t * class Core\n\t *\n\t * Top-level rules executor. Glues block/inline parsers and does intermediate\n\t * transformations.\n\t **/\n\t'use strict';\n\t\n\tvar Ruler = __webpack_require__(275);\n\t\n\tvar _rules = [['normalize', __webpack_require__(276)], ['block', __webpack_require__(277)], ['inline', __webpack_require__(278)], ['linkify', __webpack_require__(279)], ['replacements', __webpack_require__(280)], ['smartquotes', __webpack_require__(281)]];\n\t\n\t/**\n\t * new Core()\n\t **/\n\tfunction Core() {\n\t  /**\n\t   * Core#ruler -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Keep configuration of core rules.\n\t   **/\n\t  this.ruler = new Ruler();\n\t\n\t  for (var i = 0; i < _rules.length; i++) {\n\t    this.ruler.push(_rules[i][0], _rules[i][1]);\n\t  }\n\t}\n\t\n\t/**\n\t * Core.process(state)\n\t *\n\t * Executes core chain rules.\n\t **/\n\tCore.prototype.process = function (state) {\n\t  var i, l, rules;\n\t\n\t  rules = this.ruler.getRules('');\n\t\n\t  for (i = 0, l = rules.length; i < l; i++) {\n\t    rules[i](state);\n\t  }\n\t};\n\t\n\tCore.prototype.State = __webpack_require__(282);\n\t\n\tmodule.exports = Core;\n\n/***/ },\n/* 275 */\n/***/ function(module, exports) {\n\n\t/**\n\t * class Ruler\n\t *\n\t * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n\t * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n\t *\n\t * - keep rules in defined order\n\t * - assign the name to each rule\n\t * - enable/disable rules\n\t * - add/replace rules\n\t * - allow assign rules to additional named chains (in the same)\n\t * - cacheing lists of active rules\n\t *\n\t * You will not need use this class directly until write plugins. For simple\n\t * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n\t * [[MarkdownIt.use]].\n\t **/\n\t'use strict';\n\t\n\t/**\n\t * new Ruler()\n\t **/\n\tfunction Ruler() {\n\t  // List of added rules. Each element is:\n\t  //\n\t  // {\n\t  //   name: XXX,\n\t  //   enabled: Boolean,\n\t  //   fn: Function(),\n\t  //   alt: [ name2, name3 ]\n\t  // }\n\t  //\n\t  this.__rules__ = [];\n\t\n\t  // Cached rule chains.\n\t  //\n\t  // First level - chain name, '' for default.\n\t  // Second level - diginal anchor for fast filtering by charcodes.\n\t  //\n\t  this.__cache__ = null;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t// Helper methods, should not be used directly\n\t\n\t// Find rule index by name\n\t//\n\tRuler.prototype.__find__ = function (name) {\n\t  for (var i = 0; i < this.__rules__.length; i++) {\n\t    if (this.__rules__[i].name === name) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t};\n\t\n\t// Build rules lookup cache\n\t//\n\tRuler.prototype.__compile__ = function () {\n\t  var self = this;\n\t  var chains = [''];\n\t\n\t  // collect unique names\n\t  self.__rules__.forEach(function (rule) {\n\t    if (!rule.enabled) {\n\t      return;\n\t    }\n\t\n\t    rule.alt.forEach(function (altName) {\n\t      if (chains.indexOf(altName) < 0) {\n\t        chains.push(altName);\n\t      }\n\t    });\n\t  });\n\t\n\t  self.__cache__ = {};\n\t\n\t  chains.forEach(function (chain) {\n\t    self.__cache__[chain] = [];\n\t    self.__rules__.forEach(function (rule) {\n\t      if (!rule.enabled) {\n\t        return;\n\t      }\n\t\n\t      if (chain && rule.alt.indexOf(chain) < 0) {\n\t        return;\n\t      }\n\t\n\t      self.__cache__[chain].push(rule.fn);\n\t    });\n\t  });\n\t};\n\t\n\t/**\n\t * Ruler.at(name, fn [, options])\n\t * - name (String): rule name to replace.\n\t * - fn (Function): new rule function.\n\t * - options (Object): new rule options (not mandatory).\n\t *\n\t * Replace rule by name with new function & options. Throws error if name not\n\t * found.\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * Replace existing typorgapher replacement rule with new one:\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.core.ruler.at('replacements', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/\n\tRuler.prototype.at = function (name, fn, options) {\n\t  var index = this.__find__(name);\n\t  var opt = options || {};\n\t\n\t  if (index === -1) {\n\t    throw new Error('Parser rule not found: ' + name);\n\t  }\n\t\n\t  this.__rules__[index].fn = fn;\n\t  this.__rules__[index].alt = opt.alt || [];\n\t  this.__cache__ = null;\n\t};\n\t\n\t/**\n\t * Ruler.before(beforeName, ruleName, fn [, options])\n\t * - beforeName (String): new rule will be added before this one.\n\t * - ruleName (String): name of added rule.\n\t * - fn (Function): rule function.\n\t * - options (Object): rule options (not mandatory).\n\t *\n\t * Add new rule to chain before one with given name. See also\n\t * [[Ruler.after]], [[Ruler.push]].\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/\n\tRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n\t  var index = this.__find__(beforeName);\n\t  var opt = options || {};\n\t\n\t  if (index === -1) {\n\t    throw new Error('Parser rule not found: ' + beforeName);\n\t  }\n\t\n\t  this.__rules__.splice(index, 0, {\n\t    name: ruleName,\n\t    enabled: true,\n\t    fn: fn,\n\t    alt: opt.alt || []\n\t  });\n\t\n\t  this.__cache__ = null;\n\t};\n\t\n\t/**\n\t * Ruler.after(afterName, ruleName, fn [, options])\n\t * - afterName (String): new rule will be added after this one.\n\t * - ruleName (String): name of added rule.\n\t * - fn (Function): rule function.\n\t * - options (Object): rule options (not mandatory).\n\t *\n\t * Add new rule to chain after one with given name. See also\n\t * [[Ruler.before]], [[Ruler.push]].\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/\n\tRuler.prototype.after = function (afterName, ruleName, fn, options) {\n\t  var index = this.__find__(afterName);\n\t  var opt = options || {};\n\t\n\t  if (index === -1) {\n\t    throw new Error('Parser rule not found: ' + afterName);\n\t  }\n\t\n\t  this.__rules__.splice(index + 1, 0, {\n\t    name: ruleName,\n\t    enabled: true,\n\t    fn: fn,\n\t    alt: opt.alt || []\n\t  });\n\t\n\t  this.__cache__ = null;\n\t};\n\t\n\t/**\n\t * Ruler.push(ruleName, fn [, options])\n\t * - ruleName (String): name of added rule.\n\t * - fn (Function): rule function.\n\t * - options (Object): rule options (not mandatory).\n\t *\n\t * Push new rule to the end of chain. See also\n\t * [[Ruler.before]], [[Ruler.after]].\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.core.ruler.push('my_rule', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/\n\tRuler.prototype.push = function (ruleName, fn, options) {\n\t  var opt = options || {};\n\t\n\t  this.__rules__.push({\n\t    name: ruleName,\n\t    enabled: true,\n\t    fn: fn,\n\t    alt: opt.alt || []\n\t  });\n\t\n\t  this.__cache__ = null;\n\t};\n\t\n\t/**\n\t * Ruler.enable(list [, ignoreInvalid]) -> Array\n\t * - list (String|Array): list of rule names to enable.\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Enable rules with given names. If any rule name not found - throw Error.\n\t * Errors can be disabled by second param.\n\t *\n\t * Returns list of found rule names (if no exception happened).\n\t *\n\t * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n\t **/\n\tRuler.prototype.enable = function (list, ignoreInvalid) {\n\t  if (!Array.isArray(list)) {\n\t    list = [list];\n\t  }\n\t\n\t  var result = [];\n\t\n\t  // Search by name and enable\n\t  list.forEach(function (name) {\n\t    var idx = this.__find__(name);\n\t\n\t    if (idx < 0) {\n\t      if (ignoreInvalid) {\n\t        return;\n\t      }\n\t      throw new Error('Rules manager: invalid rule name ' + name);\n\t    }\n\t    this.__rules__[idx].enabled = true;\n\t    result.push(name);\n\t  }, this);\n\t\n\t  this.__cache__ = null;\n\t  return result;\n\t};\n\t\n\t/**\n\t * Ruler.enableOnly(list [, ignoreInvalid])\n\t * - list (String|Array): list of rule names to enable (whitelist).\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Enable rules with given names, and disable everything else. If any rule name\n\t * not found - throw Error. Errors can be disabled by second param.\n\t *\n\t * See also [[Ruler.disable]], [[Ruler.enable]].\n\t **/\n\tRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n\t  if (!Array.isArray(list)) {\n\t    list = [list];\n\t  }\n\t\n\t  this.__rules__.forEach(function (rule) {\n\t    rule.enabled = false;\n\t  });\n\t\n\t  this.enable(list, ignoreInvalid);\n\t};\n\t\n\t/**\n\t * Ruler.disable(list [, ignoreInvalid]) -> Array\n\t * - list (String|Array): list of rule names to disable.\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Disable rules with given names. If any rule name not found - throw Error.\n\t * Errors can be disabled by second param.\n\t *\n\t * Returns list of found rule names (if no exception happened).\n\t *\n\t * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n\t **/\n\tRuler.prototype.disable = function (list, ignoreInvalid) {\n\t  if (!Array.isArray(list)) {\n\t    list = [list];\n\t  }\n\t\n\t  var result = [];\n\t\n\t  // Search by name and disable\n\t  list.forEach(function (name) {\n\t    var idx = this.__find__(name);\n\t\n\t    if (idx < 0) {\n\t      if (ignoreInvalid) {\n\t        return;\n\t      }\n\t      throw new Error('Rules manager: invalid rule name ' + name);\n\t    }\n\t    this.__rules__[idx].enabled = false;\n\t    result.push(name);\n\t  }, this);\n\t\n\t  this.__cache__ = null;\n\t  return result;\n\t};\n\t\n\t/**\n\t * Ruler.getRules(chainName) -> Array\n\t *\n\t * Return array of active functions (rules) for given chain name. It analyzes\n\t * rules configuration, compiles caches if not exists and returns result.\n\t *\n\t * Default chain name is `''` (empty string). It can't be skipped. That's\n\t * done intentionally, to keep signature monomorphic for high speed.\n\t **/\n\tRuler.prototype.getRules = function (chainName) {\n\t  if (this.__cache__ === null) {\n\t    this.__compile__();\n\t  }\n\t\n\t  // Chain can be empty, if rules disabled. But we still have to return Array.\n\t  return this.__cache__[chainName] || [];\n\t};\n\t\n\tmodule.exports = Ruler;\n\n/***/ },\n/* 276 */\n/***/ function(module, exports) {\n\n\t// Normalize input string\n\t\n\t'use strict';\n\t\n\tvar NEWLINES_RE = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\n\tvar NULL_RE = /\\u0000/g;\n\t\n\tmodule.exports = function inline(state) {\n\t  var str;\n\t\n\t  // Normalize newlines\n\t  str = state.src.replace(NEWLINES_RE, '\\n');\n\t\n\t  // Replace NULL characters\n\t  str = str.replace(NULL_RE, '');\n\t\n\t  state.src = str;\n\t};\n\n/***/ },\n/* 277 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function block(state) {\n\t  var token;\n\t\n\t  if (state.inlineMode) {\n\t    token = new state.Token('inline', '', 0);\n\t    token.content = state.src;\n\t    token.map = [0, 1];\n\t    token.children = [];\n\t    state.tokens.push(token);\n\t  } else {\n\t    state.md.block.parse(state.src, state.md, state.env, state.tokens);\n\t  }\n\t};\n\n/***/ },\n/* 278 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function inline(state) {\n\t  var tokens = state.tokens,\n\t      tok,\n\t      i,\n\t      l;\n\t\n\t  // Parse inlines\n\t  for (i = 0, l = tokens.length; i < l; i++) {\n\t    tok = tokens[i];\n\t    if (tok.type === 'inline') {\n\t      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 279 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Replace link-like texts with link nodes.\n\t//\n\t// Currently restricted by `md.validateLink()` to http/https/ftp\n\t//\n\t'use strict';\n\t\n\tvar arrayReplaceAt = __webpack_require__(255).arrayReplaceAt;\n\t\n\tfunction isLinkOpen(str) {\n\t  return (/^<a[>\\s]/i.test(str)\n\t  );\n\t}\n\tfunction isLinkClose(str) {\n\t  return (/^<\\/a\\s*>/i.test(str)\n\t  );\n\t}\n\t\n\tmodule.exports = function linkify(state) {\n\t  var i,\n\t      j,\n\t      l,\n\t      tokens,\n\t      token,\n\t      currentToken,\n\t      nodes,\n\t      ln,\n\t      text,\n\t      pos,\n\t      lastPos,\n\t      level,\n\t      htmlLinkLevel,\n\t      url,\n\t      fullUrl,\n\t      urlText,\n\t      blockTokens = state.tokens,\n\t      links;\n\t\n\t  if (!state.md.options.linkify) {\n\t    return;\n\t  }\n\t\n\t  for (j = 0, l = blockTokens.length; j < l; j++) {\n\t    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {\n\t      continue;\n\t    }\n\t\n\t    tokens = blockTokens[j].children;\n\t\n\t    htmlLinkLevel = 0;\n\t\n\t    // We scan from the end, to keep position when new tags added.\n\t    // Use reversed logic in links start/end match\n\t    for (i = tokens.length - 1; i >= 0; i--) {\n\t      currentToken = tokens[i];\n\t\n\t      // Skip content of markdown links\n\t      if (currentToken.type === 'link_close') {\n\t        i--;\n\t        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n\t          i--;\n\t        }\n\t        continue;\n\t      }\n\t\n\t      // Skip content of html tag links\n\t      if (currentToken.type === 'html_inline') {\n\t        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n\t          htmlLinkLevel--;\n\t        }\n\t        if (isLinkClose(currentToken.content)) {\n\t          htmlLinkLevel++;\n\t        }\n\t      }\n\t      if (htmlLinkLevel > 0) {\n\t        continue;\n\t      }\n\t\n\t      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\t\n\t        text = currentToken.content;\n\t        links = state.md.linkify.match(text);\n\t\n\t        // Now split string to nodes\n\t        nodes = [];\n\t        level = currentToken.level;\n\t        lastPos = 0;\n\t\n\t        for (ln = 0; ln < links.length; ln++) {\n\t\n\t          url = links[ln].url;\n\t          fullUrl = state.md.normalizeLink(url);\n\t          if (!state.md.validateLink(fullUrl)) {\n\t            continue;\n\t          }\n\t\n\t          urlText = links[ln].text;\n\t\n\t          // Linkifier might send raw hostnames like \"example.com\", where url\n\t          // starts with domain name. So we prepend http:// in those cases,\n\t          // and remove it afterwards.\n\t          //\n\t          if (!links[ln].schema) {\n\t            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n\t          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n\t            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n\t          } else {\n\t            urlText = state.md.normalizeLinkText(urlText);\n\t          }\n\t\n\t          pos = links[ln].index;\n\t\n\t          if (pos > lastPos) {\n\t            token = new state.Token('text', '', 0);\n\t            token.content = text.slice(lastPos, pos);\n\t            token.level = level;\n\t            nodes.push(token);\n\t          }\n\t\n\t          token = new state.Token('link_open', 'a', 1);\n\t          token.attrs = [['href', fullUrl]];\n\t          token.level = level++;\n\t          token.markup = 'linkify';\n\t          token.info = 'auto';\n\t          nodes.push(token);\n\t\n\t          token = new state.Token('text', '', 0);\n\t          token.content = urlText;\n\t          token.level = level;\n\t          nodes.push(token);\n\t\n\t          token = new state.Token('link_close', 'a', -1);\n\t          token.level = --level;\n\t          token.markup = 'linkify';\n\t          token.info = 'auto';\n\t          nodes.push(token);\n\t\n\t          lastPos = links[ln].lastIndex;\n\t        }\n\t        if (lastPos < text.length) {\n\t          token = new state.Token('text', '', 0);\n\t          token.content = text.slice(lastPos);\n\t          token.level = level;\n\t          nodes.push(token);\n\t        }\n\t\n\t        // replace current node\n\t        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n\t      }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 280 */\n/***/ function(module, exports) {\n\n\t// Simple typographyc replacements\n\t//\n\t// (c) (C)  \n\t// (tm) (TM)  \n\t// (r) (R)  \n\t// +-  \n\t// (p) (P) -> \n\t// ...   (also ?....  ?.., !....  !..)\n\t// ????????  ???, !!!!!  !!!, `,,`  `,`\n\t// --  &ndash;, ---  &mdash;\n\t//\n\t'use strict';\n\t\n\t// TODO:\n\t// - fractionals 1/2, 1/4, 3/4 -> , , \n\t// - miltiplication 2 x 4 -> 2  4\n\t\n\tvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\t\n\t// Workaround for phantomjs - need regex without /g flag,\n\t// or root check will fail every second time\n\tvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\n\t\n\tvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\n\tvar SCOPED_ABBR = {\n\t  'c': '',\n\t  'r': '',\n\t  'p': '',\n\t  'tm': ''\n\t};\n\t\n\tfunction replaceFn(match, name) {\n\t  return SCOPED_ABBR[name.toLowerCase()];\n\t}\n\t\n\tfunction replace_scoped(inlineTokens) {\n\t  var i, token;\n\t\n\t  for (i = inlineTokens.length - 1; i >= 0; i--) {\n\t    token = inlineTokens[i];\n\t    if (token.type === 'text') {\n\t      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n\t    }\n\t  }\n\t}\n\t\n\tfunction replace_rare(inlineTokens) {\n\t  var i, token;\n\t\n\t  for (i = inlineTokens.length - 1; i >= 0; i--) {\n\t    token = inlineTokens[i];\n\t    if (token.type === 'text') {\n\t      if (RARE_RE.test(token.content)) {\n\t        token.content = token.content.replace(/\\+-/g, '')\n\t        // .., ..., ....... -> \n\t        // but ?..... & !..... -> ?.. & !..\n\t        .replace(/\\.{2,}/g, '').replace(/([?!])/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n\t        // em-dash\n\t        .replace(/(^|[^-])---([^-]|$)/mg, '$1$2')\n\t        // en-dash\n\t        .replace(/(^|\\s)--(\\s|$)/mg, '$1$2').replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1$2');\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function replace(state) {\n\t  var blkIdx;\n\t\n\t  if (!state.md.options.typographer) {\n\t    return;\n\t  }\n\t\n\t  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\t\n\t    if (state.tokens[blkIdx].type !== 'inline') {\n\t      continue;\n\t    }\n\t\n\t    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n\t      replace_scoped(state.tokens[blkIdx].children);\n\t    }\n\t\n\t    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n\t      replace_rare(state.tokens[blkIdx].children);\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 281 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Convert straight quotation marks to typographic ones\n\t//\n\t'use strict';\n\t\n\tvar isWhiteSpace = __webpack_require__(255).isWhiteSpace;\n\tvar isPunctChar = __webpack_require__(255).isPunctChar;\n\tvar isMdAsciiPunct = __webpack_require__(255).isMdAsciiPunct;\n\t\n\tvar QUOTE_TEST_RE = /['\"]/;\n\tvar QUOTE_RE = /['\"]/g;\n\tvar APOSTROPHE = ''; /*  */\n\t\n\tfunction replaceAt(str, index, ch) {\n\t  return str.substr(0, index) + ch + str.substr(index + 1);\n\t}\n\t\n\tfunction process_inlines(tokens, state) {\n\t  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\t\n\t  stack = [];\n\t\n\t  for (i = 0; i < tokens.length; i++) {\n\t    token = tokens[i];\n\t\n\t    thisLevel = tokens[i].level;\n\t\n\t    for (j = stack.length - 1; j >= 0; j--) {\n\t      if (stack[j].level <= thisLevel) {\n\t        break;\n\t      }\n\t    }\n\t    stack.length = j + 1;\n\t\n\t    if (token.type !== 'text') {\n\t      continue;\n\t    }\n\t\n\t    text = token.content;\n\t    pos = 0;\n\t    max = text.length;\n\t\n\t    /*eslint no-labels:0,block-scoped-var:0*/\n\t    OUTER: while (pos < max) {\n\t      QUOTE_RE.lastIndex = pos;\n\t      t = QUOTE_RE.exec(text);\n\t      if (!t) {\n\t        break;\n\t      }\n\t\n\t      canOpen = canClose = true;\n\t      pos = t.index + 1;\n\t      isSingle = t[0] === \"'\";\n\t\n\t      // Find previous character,\n\t      // default to space if it's the beginning of the line\n\t      //\n\t      lastChar = 0x20;\n\t\n\t      if (t.index - 1 >= 0) {\n\t        lastChar = text.charCodeAt(t.index - 1);\n\t      } else {\n\t        for (j = i - 1; j >= 0; j--) {\n\t          if (tokens[j].type !== 'text') {\n\t            continue;\n\t          }\n\t\n\t          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n\t          break;\n\t        }\n\t      }\n\t\n\t      // Find next character,\n\t      // default to space if it's the end of the line\n\t      //\n\t      nextChar = 0x20;\n\t\n\t      if (pos < max) {\n\t        nextChar = text.charCodeAt(pos);\n\t      } else {\n\t        for (j = i + 1; j < tokens.length; j++) {\n\t          if (tokens[j].type !== 'text') {\n\t            continue;\n\t          }\n\t\n\t          nextChar = tokens[j].content.charCodeAt(0);\n\t          break;\n\t        }\n\t      }\n\t\n\t      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n\t      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\t\n\t      isLastWhiteSpace = isWhiteSpace(lastChar);\n\t      isNextWhiteSpace = isWhiteSpace(nextChar);\n\t\n\t      if (isNextWhiteSpace) {\n\t        canOpen = false;\n\t      } else if (isNextPunctChar) {\n\t        if (!(isLastWhiteSpace || isLastPunctChar)) {\n\t          canOpen = false;\n\t        }\n\t      }\n\t\n\t      if (isLastWhiteSpace) {\n\t        canClose = false;\n\t      } else if (isLastPunctChar) {\n\t        if (!(isNextWhiteSpace || isNextPunctChar)) {\n\t          canClose = false;\n\t        }\n\t      }\n\t\n\t      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n\t        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n\t            // special case: 1\"\" - count first quote as an inch\n\t            canClose = canOpen = false;\n\t          }\n\t      }\n\t\n\t      if (canOpen && canClose) {\n\t        // treat this as the middle of the word\n\t        canOpen = false;\n\t        canClose = isNextPunctChar;\n\t      }\n\t\n\t      if (!canOpen && !canClose) {\n\t        // middle of word\n\t        if (isSingle) {\n\t          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n\t        }\n\t        continue;\n\t      }\n\t\n\t      if (canClose) {\n\t        // this could be a closing quote, rewind the stack to get a match\n\t        for (j = stack.length - 1; j >= 0; j--) {\n\t          item = stack[j];\n\t          if (stack[j].level < thisLevel) {\n\t            break;\n\t          }\n\t          if (item.single === isSingle && stack[j].level === thisLevel) {\n\t            item = stack[j];\n\t\n\t            if (isSingle) {\n\t              openQuote = state.md.options.quotes[2];\n\t              closeQuote = state.md.options.quotes[3];\n\t            } else {\n\t              openQuote = state.md.options.quotes[0];\n\t              closeQuote = state.md.options.quotes[1];\n\t            }\n\t\n\t            // replace token.content *before* tokens[item.token].content,\n\t            // because, if they are pointing at the same token, replaceAt\n\t            // could mess up indices when quote length != 1\n\t            token.content = replaceAt(token.content, t.index, closeQuote);\n\t            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);\n\t\n\t            pos += closeQuote.length - 1;\n\t            if (item.token === i) {\n\t              pos += openQuote.length - 1;\n\t            }\n\t\n\t            text = token.content;\n\t            max = text.length;\n\t\n\t            stack.length = j;\n\t            continue OUTER;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (canOpen) {\n\t        stack.push({\n\t          token: i,\n\t          pos: t.index,\n\t          single: isSingle,\n\t          level: thisLevel\n\t        });\n\t      } else if (canClose && isSingle) {\n\t        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function smartquotes(state) {\n\t  /*eslint max-depth:0*/\n\t  var blkIdx;\n\t\n\t  if (!state.md.options.typographer) {\n\t    return;\n\t  }\n\t\n\t  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\t\n\t    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n\t      continue;\n\t    }\n\t\n\t    process_inlines(state.tokens[blkIdx].children, state);\n\t  }\n\t};\n\n/***/ },\n/* 282 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Core state object\n\t//\n\t'use strict';\n\t\n\tvar Token = __webpack_require__(283);\n\t\n\tfunction StateCore(src, md, env) {\n\t  this.src = src;\n\t  this.env = env;\n\t  this.tokens = [];\n\t  this.inlineMode = false;\n\t  this.md = md; // link to parser instance\n\t}\n\t\n\t// re-export Token class to use in core rules\n\tStateCore.prototype.Token = Token;\n\t\n\tmodule.exports = StateCore;\n\n/***/ },\n/* 283 */\n/***/ function(module, exports) {\n\n\t// Token class\n\t\n\t'use strict';\n\t\n\t/**\n\t * class Token\n\t **/\n\t\n\t/**\n\t * new Token(type, tag, nesting)\n\t *\n\t * Create new token and fill passed properties.\n\t **/\n\tfunction Token(type, tag, nesting) {\n\t  /**\n\t   * Token#type -> String\n\t   *\n\t   * Type of the token (string, e.g. \"paragraph_open\")\n\t   **/\n\t  this.type = type;\n\t\n\t  /**\n\t   * Token#tag -> String\n\t   *\n\t   * html tag name, e.g. \"p\"\n\t   **/\n\t  this.tag = tag;\n\t\n\t  /**\n\t   * Token#attrs -> Array\n\t   *\n\t   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n\t   **/\n\t  this.attrs = null;\n\t\n\t  /**\n\t   * Token#map -> Array\n\t   *\n\t   * Source map info. Format: `[ line_begin, line_end ]`\n\t   **/\n\t  this.map = null;\n\t\n\t  /**\n\t   * Token#nesting -> Number\n\t   *\n\t   * Level change (number in {-1, 0, 1} set), where:\n\t   *\n\t   * -  `1` means the tag is opening\n\t   * -  `0` means the tag is self-closing\n\t   * - `-1` means the tag is closing\n\t   **/\n\t  this.nesting = nesting;\n\t\n\t  /**\n\t   * Token#level -> Number\n\t   *\n\t   * nesting level, the same as `state.level`\n\t   **/\n\t  this.level = 0;\n\t\n\t  /**\n\t   * Token#children -> Array\n\t   *\n\t   * An array of child nodes (inline and img tokens)\n\t   **/\n\t  this.children = null;\n\t\n\t  /**\n\t   * Token#content -> String\n\t   *\n\t   * In a case of self-closing tag (code, html, fence, etc.),\n\t   * it has contents of this tag.\n\t   **/\n\t  this.content = '';\n\t\n\t  /**\n\t   * Token#markup -> String\n\t   *\n\t   * '*' or '_' for emphasis, fence string for fence, etc.\n\t   **/\n\t  this.markup = '';\n\t\n\t  /**\n\t   * Token#info -> String\n\t   *\n\t   * fence infostring\n\t   **/\n\t  this.info = '';\n\t\n\t  /**\n\t   * Token#meta -> Object\n\t   *\n\t   * A place for plugins to store an arbitrary data\n\t   **/\n\t  this.meta = null;\n\t\n\t  /**\n\t   * Token#block -> Boolean\n\t   *\n\t   * True for block-level tokens, false for inline tokens.\n\t   * Used in renderer to calculate line breaks\n\t   **/\n\t  this.block = false;\n\t\n\t  /**\n\t   * Token#hidden -> Boolean\n\t   *\n\t   * If it's true, ignore this element when rendering. Used for tight lists\n\t   * to hide paragraphs.\n\t   **/\n\t  this.hidden = false;\n\t}\n\t\n\t/**\n\t * Token.attrIndex(name) -> Number\n\t *\n\t * Search attribute index by name.\n\t **/\n\tToken.prototype.attrIndex = function attrIndex(name) {\n\t  var attrs, i, len;\n\t\n\t  if (!this.attrs) {\n\t    return -1;\n\t  }\n\t\n\t  attrs = this.attrs;\n\t\n\t  for (i = 0, len = attrs.length; i < len; i++) {\n\t    if (attrs[i][0] === name) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t};\n\t\n\t/**\n\t * Token.attrPush(attrData)\n\t *\n\t * Add `[ name, value ]` attribute to list. Init attrs if necessary\n\t **/\n\tToken.prototype.attrPush = function attrPush(attrData) {\n\t  if (this.attrs) {\n\t    this.attrs.push(attrData);\n\t  } else {\n\t    this.attrs = [attrData];\n\t  }\n\t};\n\t\n\t/**\n\t * Token.attrSet(name, value)\n\t *\n\t * Set `name` attribute to `value`. Override old value if exists.\n\t **/\n\tToken.prototype.attrSet = function attrSet(name, value) {\n\t  var idx = this.attrIndex(name),\n\t      attrData = [name, value];\n\t\n\t  if (idx < 0) {\n\t    this.attrPush(attrData);\n\t  } else {\n\t    this.attrs[idx] = attrData;\n\t  }\n\t};\n\t\n\t/**\n\t * Token.attrJoin(name, value)\n\t *\n\t * Join value to existing attribute via space. Or create new attribute if not\n\t * exists. Useful to operate with token classes.\n\t **/\n\tToken.prototype.attrJoin = function attrJoin(name, value) {\n\t  var idx = this.attrIndex(name);\n\t\n\t  if (idx < 0) {\n\t    this.attrPush([name, value]);\n\t  } else {\n\t    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\n\t  }\n\t};\n\t\n\tmodule.exports = Token;\n\n/***/ },\n/* 284 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** internal\n\t * class ParserBlock\n\t *\n\t * Block-level tokenizer.\n\t **/\n\t'use strict';\n\t\n\tvar Ruler = __webpack_require__(275);\n\t\n\tvar _rules = [\n\t// First 2 params - rule name & source. Secondary array - list of rules,\n\t// which can be terminated by this one.\n\t['table', __webpack_require__(285), ['paragraph', 'reference']], ['code', __webpack_require__(286)], ['fence', __webpack_require__(287), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(288), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(289), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(290), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(291)], ['heading', __webpack_require__(292), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(293)], ['html_block', __webpack_require__(294), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(297)]];\n\t\n\t/**\n\t * new ParserBlock()\n\t **/\n\tfunction ParserBlock() {\n\t  /**\n\t   * ParserBlock#ruler -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Keep configuration of block rules.\n\t   **/\n\t  this.ruler = new Ruler();\n\t\n\t  for (var i = 0; i < _rules.length; i++) {\n\t    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n\t  }\n\t}\n\t\n\t// Generate tokens for input range\n\t//\n\tParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n\t  var ok,\n\t      i,\n\t      rules = this.ruler.getRules(''),\n\t      len = rules.length,\n\t      line = startLine,\n\t      hasEmptyLines = false,\n\t      maxNesting = state.md.options.maxNesting;\n\t\n\t  while (line < endLine) {\n\t    state.line = line = state.skipEmptyLines(line);\n\t    if (line >= endLine) {\n\t      break;\n\t    }\n\t\n\t    // Termination condition for nested calls.\n\t    // Nested calls currently used for blockquotes & lists\n\t    if (state.sCount[line] < state.blkIndent) {\n\t      break;\n\t    }\n\t\n\t    // If nesting level exceeded - skip tail to the end. That's not ordinary\n\t    // situation and we should not care about content.\n\t    if (state.level >= maxNesting) {\n\t      state.line = endLine;\n\t      break;\n\t    }\n\t\n\t    // Try all possible rules.\n\t    // On success, rule should:\n\t    //\n\t    // - update `state.line`\n\t    // - update `state.tokens`\n\t    // - return true\n\t\n\t    for (i = 0; i < len; i++) {\n\t      ok = rules[i](state, line, endLine, false);\n\t      if (ok) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    // set state.tight iff we had an empty line before current tag\n\t    // i.e. latest empty line should not count\n\t    state.tight = !hasEmptyLines;\n\t\n\t    // paragraph might \"eat\" one newline after it in nested lists\n\t    if (state.isEmpty(state.line - 1)) {\n\t      hasEmptyLines = true;\n\t    }\n\t\n\t    line = state.line;\n\t\n\t    if (line < endLine && state.isEmpty(line)) {\n\t      hasEmptyLines = true;\n\t      line++;\n\t\n\t      // two empty lines should stop the parser in list mode\n\t      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {\n\t        break;\n\t      }\n\t      state.line = line;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * ParserBlock.parse(str, md, env, outTokens)\n\t *\n\t * Process input string and push block tokens into `outTokens`\n\t **/\n\tParserBlock.prototype.parse = function (src, md, env, outTokens) {\n\t  var state;\n\t\n\t  if (!src) {\n\t    return [];\n\t  }\n\t\n\t  state = new this.State(src, md, env, outTokens);\n\t\n\t  this.tokenize(state, state.line, state.lineMax);\n\t};\n\t\n\tParserBlock.prototype.State = __webpack_require__(298);\n\t\n\tmodule.exports = ParserBlock;\n\n/***/ },\n/* 285 */\n/***/ function(module, exports) {\n\n\t// GFM table, non-standard\n\t\n\t'use strict';\n\t\n\tfunction getLine(state, line) {\n\t  var pos = state.bMarks[line] + state.blkIndent,\n\t      max = state.eMarks[line];\n\t\n\t  return state.src.substr(pos, max - pos);\n\t}\n\t\n\tfunction escapedSplit(str) {\n\t  var result = [],\n\t      pos = 0,\n\t      max = str.length,\n\t      ch,\n\t      escapes = 0,\n\t      lastPos = 0,\n\t      backTicked = false,\n\t      lastBackTick = 0;\n\t\n\t  ch = str.charCodeAt(pos);\n\t\n\t  while (pos < max) {\n\t    if (ch === 0x60 /* ` */ && escapes % 2 === 0) {\n\t      backTicked = !backTicked;\n\t      lastBackTick = pos;\n\t    } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {\n\t      result.push(str.substring(lastPos, pos));\n\t      lastPos = pos + 1;\n\t    } else if (ch === 0x5c /* \\ */) {\n\t        escapes++;\n\t      } else {\n\t      escapes = 0;\n\t    }\n\t\n\t    pos++;\n\t\n\t    // If there was an un-closed backtick, go back to just after\n\t    // the last backtick, but as if it was a normal character\n\t    if (pos === max && backTicked) {\n\t      backTicked = false;\n\t      pos = lastBackTick + 1;\n\t    }\n\t\n\t    ch = str.charCodeAt(pos);\n\t  }\n\t\n\t  result.push(str.substring(lastPos));\n\t\n\t  return result;\n\t}\n\t\n\tmodule.exports = function table(state, startLine, endLine, silent) {\n\t  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;\n\t\n\t  // should have at least three lines\n\t  if (startLine + 2 > endLine) {\n\t    return false;\n\t  }\n\t\n\t  nextLine = startLine + 1;\n\t\n\t  if (state.sCount[nextLine] < state.blkIndent) {\n\t    return false;\n\t  }\n\t\n\t  // first character of the second line should be '|' or '-'\n\t\n\t  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\t  if (pos >= state.eMarks[nextLine]) {\n\t    return false;\n\t  }\n\t\n\t  ch = state.src.charCodeAt(pos);\n\t  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {\n\t      return false;\n\t    }\n\t\n\t  lineText = getLine(state, startLine + 1);\n\t  if (!/^[-:| ]+$/.test(lineText)) {\n\t    return false;\n\t  }\n\t\n\t  columns = lineText.split('|');\n\t  aligns = [];\n\t  for (i = 0; i < columns.length; i++) {\n\t    t = columns[i].trim();\n\t    if (!t) {\n\t      // allow empty columns before and after table, but not in between columns;\n\t      // e.g. allow ` |---| `, disallow ` ---||--- `\n\t      if (i === 0 || i === columns.length - 1) {\n\t        continue;\n\t      } else {\n\t        return false;\n\t      }\n\t    }\n\t\n\t    if (!/^:?-+:?$/.test(t)) {\n\t      return false;\n\t    }\n\t    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {\n\t        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');\n\t      } else if (t.charCodeAt(0) === 0x3A /* : */) {\n\t        aligns.push('left');\n\t      } else {\n\t      aligns.push('');\n\t    }\n\t  }\n\t\n\t  lineText = getLine(state, startLine).trim();\n\t  if (lineText.indexOf('|') === -1) {\n\t    return false;\n\t  }\n\t  columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\t\n\t  // header row will define an amount of columns in the entire table,\n\t  // and align row shouldn't be smaller than that (the rest of the rows can)\n\t  columnCount = columns.length;\n\t  if (columnCount > aligns.length) {\n\t    return false;\n\t  }\n\t\n\t  if (silent) {\n\t    return true;\n\t  }\n\t\n\t  token = state.push('table_open', 'table', 1);\n\t  token.map = tableLines = [startLine, 0];\n\t\n\t  token = state.push('thead_open', 'thead', 1);\n\t  token.map = [startLine, startLine + 1];\n\t\n\t  token = state.push('tr_open', 'tr', 1);\n\t  token.map = [startLine, startLine + 1];\n\t\n\t  for (i = 0; i < columns.length; i++) {\n\t    token = state.push('th_open', 'th', 1);\n\t    token.map = [startLine, startLine + 1];\n\t    if (aligns[i]) {\n\t      token.attrs = [['style', 'text-align:' + aligns[i]]];\n\t    }\n\t\n\t    token = state.push('inline', '', 0);\n\t    token.content = columns[i].trim();\n\t    token.map = [startLine, startLine + 1];\n\t    token.children = [];\n\t\n\t    token = state.push('th_close', 'th', -1);\n\t  }\n\t\n\t  token = state.push('tr_close', 'tr', -1);\n\t  token = state.push('thead_close', 'thead', -1);\n\t\n\t  token = state.push('tbody_open', 'tbody', 1);\n\t  token.map = tbodyLines = [startLine + 2, 0];\n\t\n\t  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n\t    if (state.sCount[nextLine] < state.blkIndent) {\n\t      break;\n\t    }\n\t\n\t    lineText = getLine(state, nextLine).trim();\n\t    if (lineText.indexOf('|') === -1) {\n\t      break;\n\t    }\n\t    columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\t\n\t    token = state.push('tr_open', 'tr', 1);\n\t    for (i = 0; i < columnCount; i++) {\n\t      token = state.push('td_open', 'td', 1);\n\t      if (aligns[i]) {\n\t        token.attrs = [['style', 'text-align:' + aligns[i]]];\n\t      }\n\t\n\t      token = state.push('inline', '', 0);\n\t      token.content = columns[i] ? columns[i].trim() : '';\n\t      token.children = [];\n\t\n\t      token = state.push('td_close', 'td', -1);\n\t    }\n\t    token = state.push('tr_close', 'tr', -1);\n\t  }\n\t  token = state.push('tbody_close', 'tbody', -1);\n\t  token = state.push('table_close', 'table', -1);\n\t\n\t  tableLines[1] = tbodyLines[1] = nextLine;\n\t  state.line = nextLine;\n\t  return true;\n\t};\n\n/***/ },\n/* 286 */\n/***/ function(module, exports) {\n\n\t// Code block (4 spaces padded)\n\t\n\t'use strict';\n\t\n\tmodule.exports = function code(state, startLine, endLine /*, silent*/) {\n\t  var nextLine,\n\t      last,\n\t      token,\n\t      emptyLines = 0;\n\t\n\t  if (state.sCount[startLine] - state.blkIndent < 4) {\n\t    return false;\n\t  }\n\t\n\t  last = nextLine = startLine + 1;\n\t\n\t  while (nextLine < endLine) {\n\t    if (state.isEmpty(nextLine)) {\n\t      emptyLines++;\n\t\n\t      // workaround for lists: 2 blank lines should terminate indented\n\t      // code block, but not fenced code block\n\t      if (emptyLines >= 2 && state.parentType === 'list') {\n\t        break;\n\t      }\n\t\n\t      nextLine++;\n\t      continue;\n\t    }\n\t\n\t    emptyLines = 0;\n\t\n\t    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n\t      nextLine++;\n\t      last = nextLine;\n\t      continue;\n\t    }\n\t    break;\n\t  }\n\t\n\t  state.line = last;\n\t\n\t  token = state.push('code_block', 'code', 0);\n\t  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);\n\t  token.map = [startLine, state.line];\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 287 */\n/***/ function(module, exports) {\n\n\t// fences (``` lang, ~~~ lang)\n\t\n\t'use strict';\n\t\n\tmodule.exports = function fence(state, startLine, endLine, silent) {\n\t  var marker,\n\t      len,\n\t      params,\n\t      nextLine,\n\t      mem,\n\t      token,\n\t      markup,\n\t      haveEndMarker = false,\n\t      pos = state.bMarks[startLine] + state.tShift[startLine],\n\t      max = state.eMarks[startLine];\n\t\n\t  if (pos + 3 > max) {\n\t    return false;\n\t  }\n\t\n\t  marker = state.src.charCodeAt(pos);\n\t\n\t  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {\n\t      return false;\n\t    }\n\t\n\t  // scan marker length\n\t  mem = pos;\n\t  pos = state.skipChars(pos, marker);\n\t\n\t  len = pos - mem;\n\t\n\t  if (len < 3) {\n\t    return false;\n\t  }\n\t\n\t  markup = state.src.slice(mem, pos);\n\t  params = state.src.slice(pos, max);\n\t\n\t  if (params.indexOf('`') >= 0) {\n\t    return false;\n\t  }\n\t\n\t  // Since start is found, we can report success here in validation mode\n\t  if (silent) {\n\t    return true;\n\t  }\n\t\n\t  // search end of block\n\t  nextLine = startLine;\n\t\n\t  for (;;) {\n\t    nextLine++;\n\t    if (nextLine >= endLine) {\n\t      // unclosed block should be autoclosed by end of document.\n\t      // also block seems to be autoclosed by end of parent\n\t      break;\n\t    }\n\t\n\t    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n\t    max = state.eMarks[nextLine];\n\t\n\t    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n\t      // non-empty line with negative indent should stop the list:\n\t      // - ```\n\t      //  test\n\t      break;\n\t    }\n\t\n\t    if (state.src.charCodeAt(pos) !== marker) {\n\t      continue;\n\t    }\n\t\n\t    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n\t      // closing fence should be indented less than 4 spaces\n\t      continue;\n\t    }\n\t\n\t    pos = state.skipChars(pos, marker);\n\t\n\t    // closing code fence must be at least as long as the opening one\n\t    if (pos - mem < len) {\n\t      continue;\n\t    }\n\t\n\t    // make sure tail has spaces only\n\t    pos = state.skipSpaces(pos);\n\t\n\t    if (pos < max) {\n\t      continue;\n\t    }\n\t\n\t    haveEndMarker = true;\n\t    // found!\n\t    break;\n\t  }\n\t\n\t  // If a fence has heading spaces, they should be removed from its inner block\n\t  len = state.sCount[startLine];\n\t\n\t  state.line = nextLine + (haveEndMarker ? 1 : 0);\n\t\n\t  token = state.push('fence', 'code', 0);\n\t  token.info = params;\n\t  token.content = state.getLines(startLine + 1, nextLine, len, true);\n\t  token.markup = markup;\n\t  token.map = [startLine, state.line];\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 288 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Block quotes\n\t\n\t'use strict';\n\t\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tmodule.exports = function blockquote(state, startLine, endLine, silent) {\n\t  var nextLine,\n\t      lastLineEmpty,\n\t      oldTShift,\n\t      oldSCount,\n\t      oldBMarks,\n\t      oldIndent,\n\t      oldParentType,\n\t      lines,\n\t      initial,\n\t      offset,\n\t      ch,\n\t      terminatorRules,\n\t      token,\n\t      i,\n\t      l,\n\t      terminate,\n\t      pos = state.bMarks[startLine] + state.tShift[startLine],\n\t      max = state.eMarks[startLine];\n\t\n\t  // check the block quote marker\n\t  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {\n\t      return false;\n\t    }\n\t\n\t  // we know that it's going to be a valid blockquote,\n\t  // so no point trying to find the end of it in silent mode\n\t  if (silent) {\n\t    return true;\n\t  }\n\t\n\t  // skip one optional space (but not tab, check cmark impl) after '>'\n\t  if (state.src.charCodeAt(pos) === 0x20) {\n\t    pos++;\n\t  }\n\t\n\t  oldIndent = state.blkIndent;\n\t  state.blkIndent = 0;\n\t\n\t  // skip spaces after \">\" and re-calculate offset\n\t  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\t\n\t  oldBMarks = [state.bMarks[startLine]];\n\t  state.bMarks[startLine] = pos;\n\t\n\t  while (pos < max) {\n\t    ch = state.src.charCodeAt(pos);\n\t\n\t    if (isSpace(ch)) {\n\t      if (ch === 0x09) {\n\t        offset += 4 - offset % 4;\n\t      } else {\n\t        offset++;\n\t      }\n\t    } else {\n\t      break;\n\t    }\n\t\n\t    pos++;\n\t  }\n\t\n\t  lastLineEmpty = pos >= max;\n\t\n\t  oldSCount = [state.sCount[startLine]];\n\t  state.sCount[startLine] = offset - initial;\n\t\n\t  oldTShift = [state.tShift[startLine]];\n\t  state.tShift[startLine] = pos - state.bMarks[startLine];\n\t\n\t  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\t\n\t  // Search the end of the block\n\t  //\n\t  // Block ends with either:\n\t  //  1. an empty line outside:\n\t  //     ```\n\t  //     > test\n\t  //\n\t  //     ```\n\t  //  2. an empty line inside:\n\t  //     ```\n\t  //     >\n\t  //     test\n\t  //     ```\n\t  //  3. another tag\n\t  //     ```\n\t  //     > test\n\t  //      - - -\n\t  //     ```\n\t  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n\t    if (state.sCount[nextLine] < oldIndent) {\n\t      break;\n\t    }\n\t\n\t    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\t    max = state.eMarks[nextLine];\n\t\n\t    if (pos >= max) {\n\t      // Case 1: line is not inside the blockquote, and this line is empty.\n\t      break;\n\t    }\n\t\n\t    if (state.src.charCodeAt(pos++) === 0x3E /* > */) {\n\t        // This line is inside the blockquote.\n\t\n\t        // skip one optional space (but not tab, check cmark impl) after '>'\n\t        if (state.src.charCodeAt(pos) === 0x20) {\n\t          pos++;\n\t        }\n\t\n\t        // skip spaces after \">\" and re-calculate offset\n\t        initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);\n\t\n\t        oldBMarks.push(state.bMarks[nextLine]);\n\t        state.bMarks[nextLine] = pos;\n\t\n\t        while (pos < max) {\n\t          ch = state.src.charCodeAt(pos);\n\t\n\t          if (isSpace(ch)) {\n\t            if (ch === 0x09) {\n\t              offset += 4 - offset % 4;\n\t            } else {\n\t              offset++;\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t\n\t          pos++;\n\t        }\n\t\n\t        lastLineEmpty = pos >= max;\n\t\n\t        oldSCount.push(state.sCount[nextLine]);\n\t        state.sCount[nextLine] = offset - initial;\n\t\n\t        oldTShift.push(state.tShift[nextLine]);\n\t        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n\t        continue;\n\t      }\n\t\n\t    // Case 2: line is not inside the blockquote, and the last line was empty.\n\t    if (lastLineEmpty) {\n\t      break;\n\t    }\n\t\n\t    // Case 3: another tag found.\n\t    terminate = false;\n\t    for (i = 0, l = terminatorRules.length; i < l; i++) {\n\t      if (terminatorRules[i](state, nextLine, endLine, true)) {\n\t        terminate = true;\n\t        break;\n\t      }\n\t    }\n\t    if (terminate) {\n\t      break;\n\t    }\n\t\n\t    oldBMarks.push(state.bMarks[nextLine]);\n\t    oldTShift.push(state.tShift[nextLine]);\n\t    oldSCount.push(state.sCount[nextLine]);\n\t\n\t    // A negative indentation means that this is a paragraph continuation\n\t    //\n\t    state.sCount[nextLine] = -1;\n\t  }\n\t\n\t  oldParentType = state.parentType;\n\t  state.parentType = 'blockquote';\n\t\n\t  token = state.push('blockquote_open', 'blockquote', 1);\n\t  token.markup = '>';\n\t  token.map = lines = [startLine, 0];\n\t\n\t  state.md.block.tokenize(state, startLine, nextLine);\n\t\n\t  token = state.push('blockquote_close', 'blockquote', -1);\n\t  token.markup = '>';\n\t\n\t  state.parentType = oldParentType;\n\t  lines[1] = state.line;\n\t\n\t  // Restore original tShift; this might not be necessary since the parser\n\t  // has already been here, but just to make sure we can do that.\n\t  for (i = 0; i < oldTShift.length; i++) {\n\t    state.bMarks[i + startLine] = oldBMarks[i];\n\t    state.tShift[i + startLine] = oldTShift[i];\n\t    state.sCount[i + startLine] = oldSCount[i];\n\t  }\n\t  state.blkIndent = oldIndent;\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 289 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Horizontal rule\n\t\n\t'use strict';\n\t\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tmodule.exports = function hr(state, startLine, endLine, silent) {\n\t  var marker,\n\t      cnt,\n\t      ch,\n\t      token,\n\t      pos = state.bMarks[startLine] + state.tShift[startLine],\n\t      max = state.eMarks[startLine];\n\t\n\t  marker = state.src.charCodeAt(pos++);\n\t\n\t  // Check hr marker\n\t  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {\n\t      return false;\n\t    }\n\t\n\t  // markers can be mixed with spaces, but there should be at least 3 of them\n\t\n\t  cnt = 1;\n\t  while (pos < max) {\n\t    ch = state.src.charCodeAt(pos++);\n\t    if (ch !== marker && !isSpace(ch)) {\n\t      return false;\n\t    }\n\t    if (ch === marker) {\n\t      cnt++;\n\t    }\n\t  }\n\t\n\t  if (cnt < 3) {\n\t    return false;\n\t  }\n\t\n\t  if (silent) {\n\t    return true;\n\t  }\n\t\n\t  state.line = startLine + 1;\n\t\n\t  token = state.push('hr', 'hr', 0);\n\t  token.map = [startLine, state.line];\n\t  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 290 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Lists\n\t\n\t'use strict';\n\t\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\t// Search `[-+*][\\n ]`, returns next pos arter marker on success\n\t// or -1 on fail.\n\tfunction skipBulletListMarker(state, startLine) {\n\t  var marker, pos, max, ch;\n\t\n\t  pos = state.bMarks[startLine] + state.tShift[startLine];\n\t  max = state.eMarks[startLine];\n\t\n\t  marker = state.src.charCodeAt(pos++);\n\t  // Check bullet\n\t  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {\n\t      return -1;\n\t    }\n\t\n\t  if (pos < max) {\n\t    ch = state.src.charCodeAt(pos);\n\t\n\t    if (!isSpace(ch)) {\n\t      // \" -test \" - is not a list item\n\t      return -1;\n\t    }\n\t  }\n\t\n\t  return pos;\n\t}\n\t\n\t// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n\t// or -1 on fail.\n\tfunction skipOrderedListMarker(state, startLine) {\n\t  var ch,\n\t      start = state.bMarks[startLine] + state.tShift[startLine],\n\t      pos = start,\n\t      max = state.eMarks[startLine];\n\t\n\t  // List marker should have at least 2 chars (digit + dot)\n\t  if (pos + 1 >= max) {\n\t    return -1;\n\t  }\n\t\n\t  ch = state.src.charCodeAt(pos++);\n\t\n\t  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {\n\t      return -1;\n\t    }\n\t\n\t  for (;;) {\n\t    // EOL -> fail\n\t    if (pos >= max) {\n\t      return -1;\n\t    }\n\t\n\t    ch = state.src.charCodeAt(pos++);\n\t\n\t    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {\n\t\n\t        // List marker should have no more than 9 digits\n\t        // (prevents integer overflow in browsers)\n\t        if (pos - start >= 10) {\n\t          return -1;\n\t        }\n\t\n\t        continue;\n\t      }\n\t\n\t    // found valid marker\n\t    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {\n\t        break;\n\t      }\n\t\n\t    return -1;\n\t  }\n\t\n\t  if (pos < max) {\n\t    ch = state.src.charCodeAt(pos);\n\t\n\t    if (!isSpace(ch)) {\n\t      // \" 1.test \" - is not a list item\n\t      return -1;\n\t    }\n\t  }\n\t  return pos;\n\t}\n\t\n\tfunction markTightParagraphs(state, idx) {\n\t  var i,\n\t      l,\n\t      level = state.level + 2;\n\t\n\t  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n\t    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n\t      state.tokens[i + 2].hidden = true;\n\t      state.tokens[i].hidden = true;\n\t      i += 2;\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function list(state, startLine, endLine, silent) {\n\t  var nextLine,\n\t      initial,\n\t      offset,\n\t      indent,\n\t      oldTShift,\n\t      oldIndent,\n\t      oldLIndent,\n\t      oldTight,\n\t      oldParentType,\n\t      start,\n\t      posAfterMarker,\n\t      ch,\n\t      pos,\n\t      max,\n\t      indentAfterMarker,\n\t      markerValue,\n\t      markerCharCode,\n\t      isOrdered,\n\t      contentStart,\n\t      listTokIdx,\n\t      prevEmptyEnd,\n\t      listLines,\n\t      itemLines,\n\t      tight = true,\n\t      terminatorRules,\n\t      token,\n\t      i,\n\t      l,\n\t      terminate;\n\t\n\t  // Detect list type and position after marker\n\t  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n\t    isOrdered = true;\n\t  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n\t    isOrdered = false;\n\t  } else {\n\t    return false;\n\t  }\n\t\n\t  // We should terminate list on style change. Remember first one to compare.\n\t  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\t\n\t  // For validation mode we can terminate immediately\n\t  if (silent) {\n\t    return true;\n\t  }\n\t\n\t  // Start list\n\t  listTokIdx = state.tokens.length;\n\t\n\t  if (isOrdered) {\n\t    start = state.bMarks[startLine] + state.tShift[startLine];\n\t    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\t\n\t    token = state.push('ordered_list_open', 'ol', 1);\n\t    if (markerValue !== 1) {\n\t      token.attrs = [['start', markerValue]];\n\t    }\n\t  } else {\n\t    token = state.push('bullet_list_open', 'ul', 1);\n\t  }\n\t\n\t  token.map = listLines = [startLine, 0];\n\t  token.markup = String.fromCharCode(markerCharCode);\n\t\n\t  //\n\t  // Iterate list items\n\t  //\n\t\n\t  nextLine = startLine;\n\t  prevEmptyEnd = false;\n\t  terminatorRules = state.md.block.ruler.getRules('list');\n\t\n\t  while (nextLine < endLine) {\n\t    pos = posAfterMarker;\n\t    max = state.eMarks[nextLine];\n\t\n\t    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\t\n\t    while (pos < max) {\n\t      ch = state.src.charCodeAt(pos);\n\t\n\t      if (isSpace(ch)) {\n\t        if (ch === 0x09) {\n\t          offset += 4 - offset % 4;\n\t        } else {\n\t          offset++;\n\t        }\n\t      } else {\n\t        break;\n\t      }\n\t\n\t      pos++;\n\t    }\n\t\n\t    contentStart = pos;\n\t\n\t    if (contentStart >= max) {\n\t      // trimming space in \"-    \\n  3\" case, indent is 1 here\n\t      indentAfterMarker = 1;\n\t    } else {\n\t      indentAfterMarker = offset - initial;\n\t    }\n\t\n\t    // If we have more than 4 spaces, the indent is 1\n\t    // (the rest is just indented code block)\n\t    if (indentAfterMarker > 4) {\n\t      indentAfterMarker = 1;\n\t    }\n\t\n\t    // \"  -  test\"\n\t    //  ^^^^^ - calculating total length of this thing\n\t    indent = initial + indentAfterMarker;\n\t\n\t    // Run subparser & write tokens\n\t    token = state.push('list_item_open', 'li', 1);\n\t    token.markup = String.fromCharCode(markerCharCode);\n\t    token.map = itemLines = [startLine, 0];\n\t\n\t    oldIndent = state.blkIndent;\n\t    oldTight = state.tight;\n\t    oldTShift = state.tShift[startLine];\n\t    oldLIndent = state.sCount[startLine];\n\t    oldParentType = state.parentType;\n\t    state.blkIndent = indent;\n\t    state.tight = true;\n\t    state.parentType = 'list';\n\t    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n\t    state.sCount[startLine] = offset;\n\t\n\t    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n\t      // workaround for this case\n\t      // (list item is empty, list terminates before \"foo\"):\n\t      // ~~~~~~~~\n\t      //   -\n\t      //\n\t      //     foo\n\t      // ~~~~~~~~\n\t      state.line = Math.min(state.line + 2, endLine);\n\t    } else {\n\t      state.md.block.tokenize(state, startLine, endLine, true);\n\t    }\n\t\n\t    // If any of list item is tight, mark list as tight\n\t    if (!state.tight || prevEmptyEnd) {\n\t      tight = false;\n\t    }\n\t    // Item become loose if finish with empty line,\n\t    // but we should filter last element, because it means list finish\n\t    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n\t\n\t    state.blkIndent = oldIndent;\n\t    state.tShift[startLine] = oldTShift;\n\t    state.sCount[startLine] = oldLIndent;\n\t    state.tight = oldTight;\n\t    state.parentType = oldParentType;\n\t\n\t    token = state.push('list_item_close', 'li', -1);\n\t    token.markup = String.fromCharCode(markerCharCode);\n\t\n\t    nextLine = startLine = state.line;\n\t    itemLines[1] = nextLine;\n\t    contentStart = state.bMarks[startLine];\n\t\n\t    if (nextLine >= endLine) {\n\t      break;\n\t    }\n\t\n\t    if (state.isEmpty(nextLine)) {\n\t      break;\n\t    }\n\t\n\t    //\n\t    // Try to check if list is terminated or continued.\n\t    //\n\t    if (state.sCount[nextLine] < state.blkIndent) {\n\t      break;\n\t    }\n\t\n\t    // fail if terminating block found\n\t    terminate = false;\n\t    for (i = 0, l = terminatorRules.length; i < l; i++) {\n\t      if (terminatorRules[i](state, nextLine, endLine, true)) {\n\t        terminate = true;\n\t        break;\n\t      }\n\t    }\n\t    if (terminate) {\n\t      break;\n\t    }\n\t\n\t    // fail if list has another type\n\t    if (isOrdered) {\n\t      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\t      if (posAfterMarker < 0) {\n\t        break;\n\t      }\n\t    } else {\n\t      posAfterMarker = skipBulletListMarker(state, nextLine);\n\t      if (posAfterMarker < 0) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n\t      break;\n\t    }\n\t  }\n\t\n\t  // Finilize list\n\t  if (isOrdered) {\n\t    token = state.push('ordered_list_close', 'ol', -1);\n\t  } else {\n\t    token = state.push('bullet_list_close', 'ul', -1);\n\t  }\n\t  token.markup = String.fromCharCode(markerCharCode);\n\t\n\t  listLines[1] = nextLine;\n\t  state.line = nextLine;\n\t\n\t  // mark paragraphs tight if needed\n\t  if (tight) {\n\t    markTightParagraphs(state, listTokIdx);\n\t  }\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 291 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseLinkDestination = __webpack_require__(271);\n\tvar parseLinkTitle = __webpack_require__(272);\n\tvar normalizeReference = __webpack_require__(255).normalizeReference;\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tmodule.exports = function reference(state, startLine, _endLine, silent) {\n\t  var ch,\n\t      destEndPos,\n\t      destEndLineNo,\n\t      endLine,\n\t      href,\n\t      i,\n\t      l,\n\t      label,\n\t      labelEnd,\n\t      res,\n\t      start,\n\t      str,\n\t      terminate,\n\t      terminatorRules,\n\t      title,\n\t      lines = 0,\n\t      pos = state.bMarks[startLine] + state.tShift[startLine],\n\t      max = state.eMarks[startLine],\n\t      nextLine = startLine + 1;\n\t\n\t  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {\n\t      return false;\n\t    }\n\t\n\t  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n\t  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n\t  while (++pos < max) {\n\t    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \\ */) {\n\t        if (pos + 1 === max) {\n\t          return false;\n\t        }\n\t        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {\n\t            return false;\n\t          }\n\t        break;\n\t      }\n\t  }\n\t\n\t  endLine = state.lineMax;\n\t\n\t  // jump line-by-line until empty one or EOF\n\t  terminatorRules = state.md.block.ruler.getRules('reference');\n\t\n\t  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n\t    // this would be a code block normally, but after paragraph\n\t    // it's considered a lazy continuation regardless of what's there\n\t    if (state.sCount[nextLine] - state.blkIndent > 3) {\n\t      continue;\n\t    }\n\t\n\t    // quirk for blockquotes, this line should already be checked by that rule\n\t    if (state.sCount[nextLine] < 0) {\n\t      continue;\n\t    }\n\t\n\t    // Some tags can terminate paragraph without empty line.\n\t    terminate = false;\n\t    for (i = 0, l = terminatorRules.length; i < l; i++) {\n\t      if (terminatorRules[i](state, nextLine, endLine, true)) {\n\t        terminate = true;\n\t        break;\n\t      }\n\t    }\n\t    if (terminate) {\n\t      break;\n\t    }\n\t  }\n\t\n\t  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\t  max = str.length;\n\t\n\t  for (pos = 1; pos < max; pos++) {\n\t    ch = str.charCodeAt(pos);\n\t    if (ch === 0x5B /* [ */) {\n\t        return false;\n\t      } else if (ch === 0x5D /* ] */) {\n\t        labelEnd = pos;\n\t        break;\n\t      } else if (ch === 0x0A /* \\n */) {\n\t        lines++;\n\t      } else if (ch === 0x5C /* \\ */) {\n\t        pos++;\n\t        if (pos < max && str.charCodeAt(pos) === 0x0A) {\n\t          lines++;\n\t        }\n\t      }\n\t  }\n\t\n\t  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {\n\t      return false;\n\t    }\n\t\n\t  // [label]:   destination   'title'\n\t  //         ^^^ skip optional whitespace here\n\t  for (pos = labelEnd + 2; pos < max; pos++) {\n\t    ch = str.charCodeAt(pos);\n\t    if (ch === 0x0A) {\n\t      lines++;\n\t    } else if (isSpace(ch)) {\n\t      /*eslint no-empty:0*/\n\t    } else {\n\t        break;\n\t      }\n\t  }\n\t\n\t  // [label]:   destination   'title'\n\t  //            ^^^^^^^^^^^ parse this\n\t  res = parseLinkDestination(str, pos, max);\n\t  if (!res.ok) {\n\t    return false;\n\t  }\n\t\n\t  href = state.md.normalizeLink(res.str);\n\t  if (!state.md.validateLink(href)) {\n\t    return false;\n\t  }\n\t\n\t  pos = res.pos;\n\t  lines += res.lines;\n\t\n\t  // save cursor state, we could require to rollback later\n\t  destEndPos = pos;\n\t  destEndLineNo = lines;\n\t\n\t  // [label]:   destination   'title'\n\t  //                       ^^^ skipping those spaces\n\t  start = pos;\n\t  for (; pos < max; pos++) {\n\t    ch = str.charCodeAt(pos);\n\t    if (ch === 0x0A) {\n\t      lines++;\n\t    } else if (isSpace(ch)) {\n\t      /*eslint no-empty:0*/\n\t    } else {\n\t        break;\n\t      }\n\t  }\n\t\n\t  // [label]:   destination   'title'\n\t  //                          ^^^^^^^ parse this\n\t  res = parseLinkTitle(str, pos, max);\n\t  if (pos < max && start !== pos && res.ok) {\n\t    title = res.str;\n\t    pos = res.pos;\n\t    lines += res.lines;\n\t  } else {\n\t    title = '';\n\t    pos = destEndPos;\n\t    lines = destEndLineNo;\n\t  }\n\t\n\t  // skip trailing spaces until the rest of the line\n\t  while (pos < max) {\n\t    ch = str.charCodeAt(pos);\n\t    if (!isSpace(ch)) {\n\t      break;\n\t    }\n\t    pos++;\n\t  }\n\t\n\t  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n\t    if (title) {\n\t      // garbage at the end of the line after title,\n\t      // but it could still be a valid reference if we roll back\n\t      title = '';\n\t      pos = destEndPos;\n\t      lines = destEndLineNo;\n\t      while (pos < max) {\n\t        ch = str.charCodeAt(pos);\n\t        if (!isSpace(ch)) {\n\t          break;\n\t        }\n\t        pos++;\n\t      }\n\t    }\n\t  }\n\t\n\t  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n\t    // garbage at the end of the line\n\t    return false;\n\t  }\n\t\n\t  label = normalizeReference(str.slice(1, labelEnd));\n\t  if (!label) {\n\t    // CommonMark 0.20 disallows empty labels\n\t    return false;\n\t  }\n\t\n\t  // Reference can not terminate anything. This check is for safety only.\n\t  /*istanbul ignore if*/\n\t  if (silent) {\n\t    return true;\n\t  }\n\t\n\t  if (typeof state.env.references === 'undefined') {\n\t    state.env.references = {};\n\t  }\n\t  if (typeof state.env.references[label] === 'undefined') {\n\t    state.env.references[label] = { title: title, href: href };\n\t  }\n\t\n\t  state.line = startLine + lines + 1;\n\t  return true;\n\t};\n\n/***/ },\n/* 292 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// heading (#, ##, ...)\n\t\n\t'use strict';\n\t\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tmodule.exports = function heading(state, startLine, endLine, silent) {\n\t  var ch,\n\t      level,\n\t      tmp,\n\t      token,\n\t      pos = state.bMarks[startLine] + state.tShift[startLine],\n\t      max = state.eMarks[startLine];\n\t\n\t  ch = state.src.charCodeAt(pos);\n\t\n\t  if (ch !== 0x23 /* # */ || pos >= max) {\n\t    return false;\n\t  }\n\t\n\t  // count heading level\n\t  level = 1;\n\t  ch = state.src.charCodeAt(++pos);\n\t  while (ch === 0x23 /* # */ && pos < max && level <= 6) {\n\t    level++;\n\t    ch = state.src.charCodeAt(++pos);\n\t  }\n\t\n\t  if (level > 6 || pos < max && ch !== 0x20 /* space */) {\n\t      return false;\n\t    }\n\t\n\t  if (silent) {\n\t    return true;\n\t  }\n\t\n\t  // Let's cut tails like '    ###  ' from the end of string\n\t\n\t  max = state.skipSpacesBack(max, pos);\n\t  tmp = state.skipCharsBack(max, 0x23, pos); // #\n\t  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n\t    max = tmp;\n\t  }\n\t\n\t  state.line = startLine + 1;\n\t\n\t  token = state.push('heading_open', 'h' + String(level), 1);\n\t  token.markup = '########'.slice(0, level);\n\t  token.map = [startLine, state.line];\n\t\n\t  token = state.push('inline', '', 0);\n\t  token.content = state.src.slice(pos, max).trim();\n\t  token.map = [startLine, state.line];\n\t  token.children = [];\n\t\n\t  token = state.push('heading_close', 'h' + String(level), -1);\n\t  token.markup = '########'.slice(0, level);\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 293 */\n/***/ function(module, exports) {\n\n\t// lheading (---, ===)\n\t\n\t'use strict';\n\t\n\tmodule.exports = function lheading(state, startLine, endLine /*, silent*/) {\n\t  var content,\n\t      terminate,\n\t      i,\n\t      l,\n\t      token,\n\t      pos,\n\t      max,\n\t      level,\n\t      marker,\n\t      nextLine = startLine + 1,\n\t      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\t\n\t  // jump line-by-line until empty one or EOF\n\t  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n\t    // this would be a code block normally, but after paragraph\n\t    // it's considered a lazy continuation regardless of what's there\n\t    if (state.sCount[nextLine] - state.blkIndent > 3) {\n\t      continue;\n\t    }\n\t\n\t    //\n\t    // Check for underline in setext header\n\t    //\n\t    if (state.sCount[nextLine] >= state.blkIndent) {\n\t      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\t      max = state.eMarks[nextLine];\n\t\n\t      if (pos < max) {\n\t        marker = state.src.charCodeAt(pos);\n\t\n\t        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {\n\t            pos = state.skipChars(pos, marker);\n\t            pos = state.skipSpaces(pos);\n\t\n\t            if (pos >= max) {\n\t              level = marker === 0x3D /* = */ ? 1 : 2;\n\t              break;\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    // quirk for blockquotes, this line should already be checked by that rule\n\t    if (state.sCount[nextLine] < 0) {\n\t      continue;\n\t    }\n\t\n\t    // Some tags can terminate paragraph without empty line.\n\t    terminate = false;\n\t    for (i = 0, l = terminatorRules.length; i < l; i++) {\n\t      if (terminatorRules[i](state, nextLine, endLine, true)) {\n\t        terminate = true;\n\t        break;\n\t      }\n\t    }\n\t    if (terminate) {\n\t      break;\n\t    }\n\t  }\n\t\n\t  if (!level) {\n\t    // Didn't find valid underline\n\t    return false;\n\t  }\n\t\n\t  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\t\n\t  state.line = nextLine + 1;\n\t\n\t  token = state.push('heading_open', 'h' + String(level), 1);\n\t  token.markup = String.fromCharCode(marker);\n\t  token.map = [startLine, state.line];\n\t\n\t  token = state.push('inline', '', 0);\n\t  token.content = content;\n\t  token.map = [startLine, state.line - 1];\n\t  token.children = [];\n\t\n\t  token = state.push('heading_close', 'h' + String(level), -1);\n\t  token.markup = String.fromCharCode(marker);\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 294 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// HTML block\n\t\n\t'use strict';\n\t\n\tvar block_names = __webpack_require__(295);\n\tvar HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(296).HTML_OPEN_CLOSE_TAG_RE;\n\t\n\t// An array of opening and corresponding closing sequences for html tags,\n\t// last argument defines whether it can terminate a paragraph or not\n\t//\n\tvar HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\\?/, /\\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\\[CDATA\\[/, /\\]\\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'), /^$/, false]];\n\t\n\tmodule.exports = function html_block(state, startLine, endLine, silent) {\n\t  var i,\n\t      nextLine,\n\t      token,\n\t      lineText,\n\t      pos = state.bMarks[startLine] + state.tShift[startLine],\n\t      max = state.eMarks[startLine];\n\t\n\t  if (!state.md.options.html) {\n\t    return false;\n\t  }\n\t\n\t  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {\n\t      return false;\n\t    }\n\t\n\t  lineText = state.src.slice(pos, max);\n\t\n\t  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n\t    if (HTML_SEQUENCES[i][0].test(lineText)) {\n\t      break;\n\t    }\n\t  }\n\t\n\t  if (i === HTML_SEQUENCES.length) {\n\t    return false;\n\t  }\n\t\n\t  if (silent) {\n\t    // true if this sequence can be a terminator, false otherwise\n\t    return HTML_SEQUENCES[i][2];\n\t  }\n\t\n\t  nextLine = startLine + 1;\n\t\n\t  // If we are here - we detected HTML block.\n\t  // Let's roll down till block end.\n\t  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n\t    for (; nextLine < endLine; nextLine++) {\n\t      if (state.sCount[nextLine] < state.blkIndent) {\n\t        break;\n\t      }\n\t\n\t      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\t      max = state.eMarks[nextLine];\n\t      lineText = state.src.slice(pos, max);\n\t\n\t      if (HTML_SEQUENCES[i][1].test(lineText)) {\n\t        if (lineText.length !== 0) {\n\t          nextLine++;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  state.line = nextLine;\n\t\n\t  token = state.push('html_block', '', 0);\n\t  token.map = [startLine, nextLine];\n\t  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 295 */\n/***/ function(module, exports) {\n\n\t// List of valid html blocks names, accorting to commonmark spec\n\t// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\t\n\t'use strict';\n\t\n\tmodule.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];\n\n/***/ },\n/* 296 */\n/***/ function(module, exports) {\n\n\t// Regexps to match html elements\n\t\n\t'use strict';\n\t\n\tvar attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\n\t\n\tvar unquoted = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\n\tvar single_quoted = \"'[^']*'\";\n\tvar double_quoted = '\"[^\"]*\"';\n\t\n\tvar attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';\n\t\n\tvar attribute = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)';\n\t\n\tvar open_tag = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\n\t\n\tvar close_tag = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\n\tvar comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\n\tvar processing = '<[?].*?[?]>';\n\tvar declaration = '<![A-Z]+\\\\s+[^>]*>';\n\tvar cdata = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\n\t\n\tvar HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');\n\tvar HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');\n\t\n\tmodule.exports.HTML_TAG_RE = HTML_TAG_RE;\n\tmodule.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n\n/***/ },\n/* 297 */\n/***/ function(module, exports) {\n\n\t// Paragraph\n\t\n\t'use strict';\n\t\n\tmodule.exports = function paragraph(state, startLine /*, endLine*/) {\n\t  var content,\n\t      terminate,\n\t      i,\n\t      l,\n\t      token,\n\t      nextLine = startLine + 1,\n\t      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n\t      endLine = state.lineMax;\n\t\n\t  // jump line-by-line until empty one or EOF\n\t  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n\t    // this would be a code block normally, but after paragraph\n\t    // it's considered a lazy continuation regardless of what's there\n\t    if (state.sCount[nextLine] - state.blkIndent > 3) {\n\t      continue;\n\t    }\n\t\n\t    // quirk for blockquotes, this line should already be checked by that rule\n\t    if (state.sCount[nextLine] < 0) {\n\t      continue;\n\t    }\n\t\n\t    // Some tags can terminate paragraph without empty line.\n\t    terminate = false;\n\t    for (i = 0, l = terminatorRules.length; i < l; i++) {\n\t      if (terminatorRules[i](state, nextLine, endLine, true)) {\n\t        terminate = true;\n\t        break;\n\t      }\n\t    }\n\t    if (terminate) {\n\t      break;\n\t    }\n\t  }\n\t\n\t  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\t\n\t  state.line = nextLine;\n\t\n\t  token = state.push('paragraph_open', 'p', 1);\n\t  token.map = [startLine, state.line];\n\t\n\t  token = state.push('inline', '', 0);\n\t  token.content = content;\n\t  token.map = [startLine, state.line];\n\t  token.children = [];\n\t\n\t  token = state.push('paragraph_close', 'p', -1);\n\t\n\t  return true;\n\t};\n\n/***/ },\n/* 298 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Parser state class\n\t\n\t'use strict';\n\t\n\tvar Token = __webpack_require__(283);\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tfunction StateBlock(src, md, env, tokens) {\n\t  var ch, s, start, pos, len, indent, offset, indent_found;\n\t\n\t  this.src = src;\n\t\n\t  // link to parser instance\n\t  this.md = md;\n\t\n\t  this.env = env;\n\t\n\t  //\n\t  // Internal state vartiables\n\t  //\n\t\n\t  this.tokens = tokens;\n\t\n\t  this.bMarks = []; // line begin offsets for fast jumps\n\t  this.eMarks = []; // line end offsets for fast jumps\n\t  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)\n\t  this.sCount = []; // indents for each line (tabs expanded)\n\t\n\t  // block parser variables\n\t  this.blkIndent = 0; // required block content indent\n\t  // (for example, if we are in list)\n\t  this.line = 0; // line index in src\n\t  this.lineMax = 0; // lines count\n\t  this.tight = false; // loose/tight mode for lists\n\t  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n\t  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\t\n\t  this.level = 0;\n\t\n\t  // renderer\n\t  this.result = '';\n\t\n\t  // Create caches\n\t  // Generate markers.\n\t  s = this.src;\n\t  indent_found = false;\n\t\n\t  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n\t    ch = s.charCodeAt(pos);\n\t\n\t    if (!indent_found) {\n\t      if (isSpace(ch)) {\n\t        indent++;\n\t\n\t        if (ch === 0x09) {\n\t          offset += 4 - offset % 4;\n\t        } else {\n\t          offset++;\n\t        }\n\t        continue;\n\t      } else {\n\t        indent_found = true;\n\t      }\n\t    }\n\t\n\t    if (ch === 0x0A || pos === len - 1) {\n\t      if (ch !== 0x0A) {\n\t        pos++;\n\t      }\n\t      this.bMarks.push(start);\n\t      this.eMarks.push(pos);\n\t      this.tShift.push(indent);\n\t      this.sCount.push(offset);\n\t\n\t      indent_found = false;\n\t      indent = 0;\n\t      offset = 0;\n\t      start = pos + 1;\n\t    }\n\t  }\n\t\n\t  // Push fake entry to simplify cache bounds checks\n\t  this.bMarks.push(s.length);\n\t  this.eMarks.push(s.length);\n\t  this.tShift.push(0);\n\t  this.sCount.push(0);\n\t\n\t  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n\t}\n\t\n\t// Push new token to \"stream\".\n\t//\n\tStateBlock.prototype.push = function (type, tag, nesting) {\n\t  var token = new Token(type, tag, nesting);\n\t  token.block = true;\n\t\n\t  if (nesting < 0) {\n\t    this.level--;\n\t  }\n\t  token.level = this.level;\n\t  if (nesting > 0) {\n\t    this.level++;\n\t  }\n\t\n\t  this.tokens.push(token);\n\t  return token;\n\t};\n\t\n\tStateBlock.prototype.isEmpty = function isEmpty(line) {\n\t  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n\t};\n\t\n\tStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n\t  for (var max = this.lineMax; from < max; from++) {\n\t    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n\t      break;\n\t    }\n\t  }\n\t  return from;\n\t};\n\t\n\t// Skip spaces from given position.\n\tStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n\t  var ch;\n\t\n\t  for (var max = this.src.length; pos < max; pos++) {\n\t    ch = this.src.charCodeAt(pos);\n\t    if (!isSpace(ch)) {\n\t      break;\n\t    }\n\t  }\n\t  return pos;\n\t};\n\t\n\t// Skip spaces from given position in reverse.\n\tStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n\t  if (pos <= min) {\n\t    return pos;\n\t  }\n\t\n\t  while (pos > min) {\n\t    if (!isSpace(this.src.charCodeAt(--pos))) {\n\t      return pos + 1;\n\t    }\n\t  }\n\t  return pos;\n\t};\n\t\n\t// Skip char codes from given position\n\tStateBlock.prototype.skipChars = function skipChars(pos, code) {\n\t  for (var max = this.src.length; pos < max; pos++) {\n\t    if (this.src.charCodeAt(pos) !== code) {\n\t      break;\n\t    }\n\t  }\n\t  return pos;\n\t};\n\t\n\t// Skip char codes reverse from given position - 1\n\tStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n\t  if (pos <= min) {\n\t    return pos;\n\t  }\n\t\n\t  while (pos > min) {\n\t    if (code !== this.src.charCodeAt(--pos)) {\n\t      return pos + 1;\n\t    }\n\t  }\n\t  return pos;\n\t};\n\t\n\t// cut lines range from source.\n\tStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n\t  var i,\n\t      lineIndent,\n\t      ch,\n\t      first,\n\t      last,\n\t      queue,\n\t      lineStart,\n\t      line = begin;\n\t\n\t  if (begin >= end) {\n\t    return '';\n\t  }\n\t\n\t  queue = new Array(end - begin);\n\t\n\t  for (i = 0; line < end; line++, i++) {\n\t    lineIndent = 0;\n\t    lineStart = first = this.bMarks[line];\n\t\n\t    if (line + 1 < end || keepLastLF) {\n\t      // No need for bounds check because we have fake entry on tail.\n\t      last = this.eMarks[line] + 1;\n\t    } else {\n\t      last = this.eMarks[line];\n\t    }\n\t\n\t    while (first < last && lineIndent < indent) {\n\t      ch = this.src.charCodeAt(first);\n\t\n\t      if (isSpace(ch)) {\n\t        if (ch === 0x09) {\n\t          lineIndent += 4 - lineIndent % 4;\n\t        } else {\n\t          lineIndent++;\n\t        }\n\t      } else if (first - lineStart < this.tShift[line]) {\n\t        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n\t        lineIndent++;\n\t      } else {\n\t        break;\n\t      }\n\t\n\t      first++;\n\t    }\n\t\n\t    queue[i] = this.src.slice(first, last);\n\t  }\n\t\n\t  return queue.join('');\n\t};\n\t\n\t// re-export Token class to use in block rules\n\tStateBlock.prototype.Token = Token;\n\t\n\tmodule.exports = StateBlock;\n\n/***/ },\n/* 299 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** internal\n\t * class ParserInline\n\t *\n\t * Tokenizes paragraph content.\n\t **/\n\t'use strict';\n\t\n\tvar Ruler = __webpack_require__(275);\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t// Parser rules\n\t\n\tvar _rules = [['text', __webpack_require__(300)], ['newline', __webpack_require__(301)], ['escape', __webpack_require__(302)], ['backticks', __webpack_require__(303)], ['strikethrough', __webpack_require__(304).tokenize], ['emphasis', __webpack_require__(305).tokenize], ['link', __webpack_require__(306)], ['image', __webpack_require__(307)], ['autolink', __webpack_require__(308)], ['html_inline', __webpack_require__(310)], ['entity', __webpack_require__(311)]];\n\t\n\tvar _rules2 = [['balance_pairs', __webpack_require__(312)], ['strikethrough', __webpack_require__(304).postProcess], ['emphasis', __webpack_require__(305).postProcess], ['text_collapse', __webpack_require__(313)]];\n\t\n\t/**\n\t * new ParserInline()\n\t **/\n\tfunction ParserInline() {\n\t  var i;\n\t\n\t  /**\n\t   * ParserInline#ruler -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Keep configuration of inline rules.\n\t   **/\n\t  this.ruler = new Ruler();\n\t\n\t  for (i = 0; i < _rules.length; i++) {\n\t    this.ruler.push(_rules[i][0], _rules[i][1]);\n\t  }\n\t\n\t  /**\n\t   * ParserInline#ruler2 -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Second ruler used for post-processing\n\t   * (e.g. in emphasis-like rules).\n\t   **/\n\t  this.ruler2 = new Ruler();\n\t\n\t  for (i = 0; i < _rules2.length; i++) {\n\t    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n\t  }\n\t}\n\t\n\t// Skip single token by running all rules in validation mode;\n\t// returns `true` if any rule reported success\n\t//\n\tParserInline.prototype.skipToken = function (state) {\n\t  var ok,\n\t      i,\n\t      pos = state.pos,\n\t      rules = this.ruler.getRules(''),\n\t      len = rules.length,\n\t      maxNesting = state.md.options.maxNesting,\n\t      cache = state.cache;\n\t\n\t  if (typeof cache[pos] !== 'undefined') {\n\t    state.pos = cache[pos];\n\t    return;\n\t  }\n\t\n\t  if (state.level < maxNesting) {\n\t    for (i = 0; i < len; i++) {\n\t      // Increment state.level and decrement it later to limit recursion.\n\t      // It's harmless to do here, because no tokens are created. But ideally,\n\t      // we'd need a separate private state variable for this purpose.\n\t      //\n\t      state.level++;\n\t      ok = rules[i](state, true);\n\t      state.level--;\n\t\n\t      if (ok) {\n\t        break;\n\t      }\n\t    }\n\t  } else {\n\t    // Too much nesting, just skip until the end of the paragraph.\n\t    //\n\t    // NOTE: this will cause links to behave incorrectly in the following case,\n\t    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n\t    //\n\t    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n\t    //\n\t    // TODO: remove this workaround when CM standard will allow nested links\n\t    //       (we can replace it by preventing links from being parsed in\n\t    //       validation mode)\n\t    //\n\t    state.pos = state.posMax;\n\t  }\n\t\n\t  if (!ok) {\n\t    state.pos++;\n\t  }\n\t  cache[pos] = state.pos;\n\t};\n\t\n\t// Generate tokens for input range\n\t//\n\tParserInline.prototype.tokenize = function (state) {\n\t  var ok,\n\t      i,\n\t      rules = this.ruler.getRules(''),\n\t      len = rules.length,\n\t      end = state.posMax,\n\t      maxNesting = state.md.options.maxNesting;\n\t\n\t  while (state.pos < end) {\n\t    // Try all possible rules.\n\t    // On success, rule should:\n\t    //\n\t    // - update `state.pos`\n\t    // - update `state.tokens`\n\t    // - return true\n\t\n\t    if (state.level < maxNesting) {\n\t      for (i = 0; i < len; i++) {\n\t        ok = rules[i](state, false);\n\t        if (ok) {\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    if (ok) {\n\t      if (state.pos >= end) {\n\t        break;\n\t      }\n\t      continue;\n\t    }\n\t\n\t    state.pending += state.src[state.pos++];\n\t  }\n\t\n\t  if (state.pending) {\n\t    state.pushPending();\n\t  }\n\t};\n\t\n\t/**\n\t * ParserInline.parse(str, md, env, outTokens)\n\t *\n\t * Process input string and push inline tokens into `outTokens`\n\t **/\n\tParserInline.prototype.parse = function (str, md, env, outTokens) {\n\t  var i, rules, len;\n\t  var state = new this.State(str, md, env, outTokens);\n\t\n\t  this.tokenize(state);\n\t\n\t  rules = this.ruler2.getRules('');\n\t  len = rules.length;\n\t\n\t  for (i = 0; i < len; i++) {\n\t    rules[i](state);\n\t  }\n\t};\n\t\n\tParserInline.prototype.State = __webpack_require__(314);\n\t\n\tmodule.exports = ParserInline;\n\n/***/ },\n/* 300 */\n/***/ function(module, exports) {\n\n\t// Skip text characters for text token, place those to pending buffer\n\t// and increment current pos\n\t\n\t'use strict';\n\t\n\t// Rule to skip pure text\n\t// '{}$%@~+=:' reserved for extentions\n\t\n\t// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\t\n\t// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n\t// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n\tfunction isTerminatorChar(ch) {\n\t  switch (ch) {\n\t    case 0x0A /* \\n */:\n\t    case 0x21 /* ! */:\n\t    case 0x23 /* # */:\n\t    case 0x24 /* $ */:\n\t    case 0x25 /* % */:\n\t    case 0x26 /* & */:\n\t    case 0x2A /* * */:\n\t    case 0x2B /* + */:\n\t    case 0x2D /* - */:\n\t    case 0x3A /* : */:\n\t    case 0x3C /* < */:\n\t    case 0x3D /* = */:\n\t    case 0x3E /* > */:\n\t    case 0x40 /* @ */:\n\t    case 0x5B /* [ */:\n\t    case 0x5C /* \\ */:\n\t    case 0x5D /* ] */:\n\t    case 0x5E /* ^ */:\n\t    case 0x5F /* _ */:\n\t    case 0x60 /* ` */:\n\t    case 0x7B /* { */:\n\t    case 0x7D /* } */:\n\t    case 0x7E /* ~ */:\n\t      return true;\n\t    default:\n\t      return false;\n\t  }\n\t}\n\t\n\tmodule.exports = function text(state, silent) {\n\t  var pos = state.pos;\n\t\n\t  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n\t    pos++;\n\t  }\n\t\n\t  if (pos === state.pos) {\n\t    return false;\n\t  }\n\t\n\t  if (!silent) {\n\t    state.pending += state.src.slice(state.pos, pos);\n\t  }\n\t\n\t  state.pos = pos;\n\t\n\t  return true;\n\t};\n\t\n\t// Alternative implementation, for memory.\n\t//\n\t// It costs 10% of performance, but allows extend terminators list, if place it\n\t// to `ParcerInline` property. Probably, will switch to it sometime, such\n\t// flexibility required.\n\t\n\t/*\n\tvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\t\n\tmodule.exports = function text(state, silent) {\n\t  var pos = state.pos,\n\t      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\t\n\t  // first char is terminator -> empty text\n\t  if (idx === 0) { return false; }\n\t\n\t  // no terminator -> text till end of string\n\t  if (idx < 0) {\n\t    if (!silent) { state.pending += state.src.slice(pos); }\n\t    state.pos = state.src.length;\n\t    return true;\n\t  }\n\t\n\t  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\t\n\t  state.pos += idx;\n\t\n\t  return true;\n\t};*/\n\n/***/ },\n/* 301 */\n/***/ function(module, exports) {\n\n\t// Proceess '\\n'\n\t\n\t'use strict';\n\t\n\tmodule.exports = function newline(state, silent) {\n\t  var pmax,\n\t      max,\n\t      pos = state.pos;\n\t\n\t  if (state.src.charCodeAt(pos) !== 0x0A /* \\n */) {\n\t      return false;\n\t    }\n\t\n\t  pmax = state.pending.length - 1;\n\t  max = state.posMax;\n\t\n\t  // '  \\n' -> hardbreak\n\t  // Lookup in pending chars is bad practice! Don't copy to other rules!\n\t  // Pending string is stored in concat mode, indexed lookups will cause\n\t  // convertion to flat mode.\n\t  if (!silent) {\n\t    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n\t      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n\t        state.pending = state.pending.replace(/ +$/, '');\n\t        state.push('hardbreak', 'br', 0);\n\t      } else {\n\t        state.pending = state.pending.slice(0, -1);\n\t        state.push('softbreak', 'br', 0);\n\t      }\n\t    } else {\n\t      state.push('softbreak', 'br', 0);\n\t    }\n\t  }\n\t\n\t  pos++;\n\t\n\t  // skip heading spaces for next line\n\t  while (pos < max && state.src.charCodeAt(pos) === 0x20) {\n\t    pos++;\n\t  }\n\t\n\t  state.pos = pos;\n\t  return true;\n\t};\n\n/***/ },\n/* 302 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Proceess escaped chars and hardbreaks\n\t\n\t'use strict';\n\t\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tvar ESCAPED = [];\n\t\n\tfor (var i = 0; i < 256; i++) {\n\t  ESCAPED.push(0);\n\t}\n\t\n\t'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {\n\t  ESCAPED[ch.charCodeAt(0)] = 1;\n\t});\n\t\n\tmodule.exports = function escape(state, silent) {\n\t  var ch,\n\t      pos = state.pos,\n\t      max = state.posMax;\n\t\n\t  if (state.src.charCodeAt(pos) !== 0x5C /* \\ */) {\n\t      return false;\n\t    }\n\t\n\t  pos++;\n\t\n\t  if (pos < max) {\n\t    ch = state.src.charCodeAt(pos);\n\t\n\t    if (ch < 256 && ESCAPED[ch] !== 0) {\n\t      if (!silent) {\n\t        state.pending += state.src[pos];\n\t      }\n\t      state.pos += 2;\n\t      return true;\n\t    }\n\t\n\t    if (ch === 0x0A) {\n\t      if (!silent) {\n\t        state.push('hardbreak', 'br', 0);\n\t      }\n\t\n\t      pos++;\n\t      // skip leading whitespaces from next line\n\t      while (pos < max) {\n\t        ch = state.src.charCodeAt(pos);\n\t        if (!isSpace(ch)) {\n\t          break;\n\t        }\n\t        pos++;\n\t      }\n\t\n\t      state.pos = pos;\n\t      return true;\n\t    }\n\t  }\n\t\n\t  if (!silent) {\n\t    state.pending += '\\\\';\n\t  }\n\t  state.pos++;\n\t  return true;\n\t};\n\n/***/ },\n/* 303 */\n/***/ function(module, exports) {\n\n\t// Parse backticks\n\t\n\t'use strict';\n\t\n\tmodule.exports = function backtick(state, silent) {\n\t  var start,\n\t      max,\n\t      marker,\n\t      matchStart,\n\t      matchEnd,\n\t      token,\n\t      pos = state.pos,\n\t      ch = state.src.charCodeAt(pos);\n\t\n\t  if (ch !== 0x60 /* ` */) {\n\t      return false;\n\t    }\n\t\n\t  start = pos;\n\t  pos++;\n\t  max = state.posMax;\n\t\n\t  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {\n\t    pos++;\n\t  }\n\t\n\t  marker = state.src.slice(start, pos);\n\t\n\t  matchStart = matchEnd = pos;\n\t\n\t  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n\t    matchEnd = matchStart + 1;\n\t\n\t    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {\n\t      matchEnd++;\n\t    }\n\t\n\t    if (matchEnd - matchStart === marker.length) {\n\t      if (!silent) {\n\t        token = state.push('code_inline', 'code', 0);\n\t        token.markup = marker;\n\t        token.content = state.src.slice(pos, matchStart).replace(/[ \\n]+/g, ' ').trim();\n\t      }\n\t      state.pos = matchEnd;\n\t      return true;\n\t    }\n\t  }\n\t\n\t  if (!silent) {\n\t    state.pending += marker;\n\t  }\n\t  state.pos += marker.length;\n\t  return true;\n\t};\n\n/***/ },\n/* 304 */\n/***/ function(module, exports) {\n\n\t// ~~strike through~~\n\t//\n\t'use strict';\n\t\n\t// Insert each marker as a separate text token, and add it to delimiter list\n\t//\n\tmodule.exports.tokenize = function strikethrough(state, silent) {\n\t  var i,\n\t      scanned,\n\t      token,\n\t      len,\n\t      ch,\n\t      start = state.pos,\n\t      marker = state.src.charCodeAt(start);\n\t\n\t  if (silent) {\n\t    return false;\n\t  }\n\t\n\t  if (marker !== 0x7E /* ~ */) {\n\t      return false;\n\t    }\n\t\n\t  scanned = state.scanDelims(state.pos, true);\n\t  len = scanned.length;\n\t  ch = String.fromCharCode(marker);\n\t\n\t  if (len < 2) {\n\t    return false;\n\t  }\n\t\n\t  if (len % 2) {\n\t    token = state.push('text', '', 0);\n\t    token.content = ch;\n\t    len--;\n\t  }\n\t\n\t  for (i = 0; i < len; i += 2) {\n\t    token = state.push('text', '', 0);\n\t    token.content = ch + ch;\n\t\n\t    state.delimiters.push({\n\t      marker: marker,\n\t      jump: i,\n\t      token: state.tokens.length - 1,\n\t      level: state.level,\n\t      end: -1,\n\t      open: scanned.can_open,\n\t      close: scanned.can_close\n\t    });\n\t  }\n\t\n\t  state.pos += scanned.length;\n\t\n\t  return true;\n\t};\n\t\n\t// Walk through delimiter list and replace text tokens with tags\n\t//\n\tmodule.exports.postProcess = function strikethrough(state) {\n\t  var i,\n\t      j,\n\t      startDelim,\n\t      endDelim,\n\t      token,\n\t      loneMarkers = [],\n\t      delimiters = state.delimiters,\n\t      max = state.delimiters.length;\n\t\n\t  for (i = 0; i < max; i++) {\n\t    startDelim = delimiters[i];\n\t\n\t    if (startDelim.marker !== 0x7E /* ~ */) {\n\t        continue;\n\t      }\n\t\n\t    if (startDelim.end === -1) {\n\t      continue;\n\t    }\n\t\n\t    endDelim = delimiters[startDelim.end];\n\t\n\t    token = state.tokens[startDelim.token];\n\t    token.type = 's_open';\n\t    token.tag = 's';\n\t    token.nesting = 1;\n\t    token.markup = '~~';\n\t    token.content = '';\n\t\n\t    token = state.tokens[endDelim.token];\n\t    token.type = 's_close';\n\t    token.tag = 's';\n\t    token.nesting = -1;\n\t    token.markup = '~~';\n\t    token.content = '';\n\t\n\t    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {\n\t\n\t      loneMarkers.push(endDelim.token - 1);\n\t    }\n\t  }\n\t\n\t  // If a marker sequence has an odd number of characters, it's splitted\n\t  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n\t  // start of the sequence.\n\t  //\n\t  // So, we have to move all those markers after subsequent s_close tags.\n\t  //\n\t  while (loneMarkers.length) {\n\t    i = loneMarkers.pop();\n\t    j = i + 1;\n\t\n\t    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n\t      j++;\n\t    }\n\t\n\t    j--;\n\t\n\t    if (i !== j) {\n\t      token = state.tokens[j];\n\t      state.tokens[j] = state.tokens[i];\n\t      state.tokens[i] = token;\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 305 */\n/***/ function(module, exports) {\n\n\t// Process *this* and _that_\n\t//\n\t'use strict';\n\t\n\t// Insert each marker as a separate text token, and add it to delimiter list\n\t//\n\tmodule.exports.tokenize = function emphasis(state, silent) {\n\t  var i,\n\t      scanned,\n\t      token,\n\t      start = state.pos,\n\t      marker = state.src.charCodeAt(start);\n\t\n\t  if (silent) {\n\t    return false;\n\t  }\n\t\n\t  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {\n\t      return false;\n\t    }\n\t\n\t  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\t\n\t  for (i = 0; i < scanned.length; i++) {\n\t    token = state.push('text', '', 0);\n\t    token.content = String.fromCharCode(marker);\n\t\n\t    state.delimiters.push({\n\t      // Char code of the starting marker (number).\n\t      //\n\t      marker: marker,\n\t\n\t      // An amount of characters before this one that's equivalent to\n\t      // current one. In plain English: if this delimiter does not open\n\t      // an emphasis, neither do previous `jump` characters.\n\t      //\n\t      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n\t      // value will be 0, for 2nd it's 1 and so on.\n\t      //\n\t      jump: i,\n\t\n\t      // A position of the token this delimiter corresponds to.\n\t      //\n\t      token: state.tokens.length - 1,\n\t\n\t      // Token level.\n\t      //\n\t      level: state.level,\n\t\n\t      // If this delimiter is matched as a valid opener, `end` will be\n\t      // equal to its position, otherwise it's `-1`.\n\t      //\n\t      end: -1,\n\t\n\t      // Boolean flags that determine if this delimiter could open or close\n\t      // an emphasis.\n\t      //\n\t      open: scanned.can_open,\n\t      close: scanned.can_close\n\t    });\n\t  }\n\t\n\t  state.pos += scanned.length;\n\t\n\t  return true;\n\t};\n\t\n\t// Walk through delimiter list and replace text tokens with tags\n\t//\n\tmodule.exports.postProcess = function emphasis(state) {\n\t  var i,\n\t      startDelim,\n\t      endDelim,\n\t      token,\n\t      ch,\n\t      isStrong,\n\t      delimiters = state.delimiters,\n\t      max = state.delimiters.length;\n\t\n\t  for (i = 0; i < max; i++) {\n\t    startDelim = delimiters[i];\n\t\n\t    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {\n\t        continue;\n\t      }\n\t\n\t    // Process only opening markers\n\t    if (startDelim.end === -1) {\n\t      continue;\n\t    }\n\t\n\t    endDelim = delimiters[startDelim.end];\n\t\n\t    // If the next delimiter has the same marker and is adjacent to this one,\n\t    // merge those into one strong delimiter.\n\t    //\n\t    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n\t    //\n\t    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;\n\t\n\t    ch = String.fromCharCode(startDelim.marker);\n\t\n\t    token = state.tokens[startDelim.token];\n\t    token.type = isStrong ? 'strong_open' : 'em_open';\n\t    token.tag = isStrong ? 'strong' : 'em';\n\t    token.nesting = 1;\n\t    token.markup = isStrong ? ch + ch : ch;\n\t    token.content = '';\n\t\n\t    token = state.tokens[endDelim.token];\n\t    token.type = isStrong ? 'strong_close' : 'em_close';\n\t    token.tag = isStrong ? 'strong' : 'em';\n\t    token.nesting = -1;\n\t    token.markup = isStrong ? ch + ch : ch;\n\t    token.content = '';\n\t\n\t    if (isStrong) {\n\t      state.tokens[delimiters[i + 1].token].content = '';\n\t      state.tokens[delimiters[startDelim.end - 1].token].content = '';\n\t      i++;\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 306 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Process [link](<to> \"stuff\")\n\t\n\t'use strict';\n\t\n\tvar parseLinkLabel = __webpack_require__(270);\n\tvar parseLinkDestination = __webpack_require__(271);\n\tvar parseLinkTitle = __webpack_require__(272);\n\tvar normalizeReference = __webpack_require__(255).normalizeReference;\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tmodule.exports = function link(state, silent) {\n\t  var attrs,\n\t      code,\n\t      label,\n\t      labelEnd,\n\t      labelStart,\n\t      pos,\n\t      res,\n\t      ref,\n\t      title,\n\t      token,\n\t      href = '',\n\t      oldPos = state.pos,\n\t      max = state.posMax,\n\t      start = state.pos;\n\t\n\t  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {\n\t      return false;\n\t    }\n\t\n\t  labelStart = state.pos + 1;\n\t  labelEnd = parseLinkLabel(state, state.pos, true);\n\t\n\t  // parser failed to find ']', so it's not a valid link\n\t  if (labelEnd < 0) {\n\t    return false;\n\t  }\n\t\n\t  pos = labelEnd + 1;\n\t  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {\n\t      //\n\t      // Inline link\n\t      //\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //        ^^ skipping these spaces\n\t      pos++;\n\t      for (; pos < max; pos++) {\n\t        code = state.src.charCodeAt(pos);\n\t        if (!isSpace(code) && code !== 0x0A) {\n\t          break;\n\t        }\n\t      }\n\t      if (pos >= max) {\n\t        return false;\n\t      }\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //          ^^^^^^ parsing link destination\n\t      start = pos;\n\t      res = parseLinkDestination(state.src, pos, state.posMax);\n\t      if (res.ok) {\n\t        href = state.md.normalizeLink(res.str);\n\t        if (state.md.validateLink(href)) {\n\t          pos = res.pos;\n\t        } else {\n\t          href = '';\n\t        }\n\t      }\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //                ^^ skipping these spaces\n\t      start = pos;\n\t      for (; pos < max; pos++) {\n\t        code = state.src.charCodeAt(pos);\n\t        if (!isSpace(code) && code !== 0x0A) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //                  ^^^^^^^ parsing link title\n\t      res = parseLinkTitle(state.src, pos, state.posMax);\n\t      if (pos < max && start !== pos && res.ok) {\n\t        title = res.str;\n\t        pos = res.pos;\n\t\n\t        // [link](  <href>  \"title\"  )\n\t        //                         ^^ skipping these spaces\n\t        for (; pos < max; pos++) {\n\t          code = state.src.charCodeAt(pos);\n\t          if (!isSpace(code) && code !== 0x0A) {\n\t            break;\n\t          }\n\t        }\n\t      } else {\n\t        title = '';\n\t      }\n\t\n\t      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {\n\t          state.pos = oldPos;\n\t          return false;\n\t        }\n\t      pos++;\n\t    } else {\n\t    //\n\t    // Link reference\n\t    //\n\t    if (typeof state.env.references === 'undefined') {\n\t      return false;\n\t    }\n\t\n\t    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {\n\t        start = pos + 1;\n\t        pos = parseLinkLabel(state, pos);\n\t        if (pos >= 0) {\n\t          label = state.src.slice(start, pos++);\n\t        } else {\n\t          pos = labelEnd + 1;\n\t        }\n\t      } else {\n\t      pos = labelEnd + 1;\n\t    }\n\t\n\t    // covers label === '' and label === undefined\n\t    // (collapsed reference link and shortcut reference link respectively)\n\t    if (!label) {\n\t      label = state.src.slice(labelStart, labelEnd);\n\t    }\n\t\n\t    ref = state.env.references[normalizeReference(label)];\n\t    if (!ref) {\n\t      state.pos = oldPos;\n\t      return false;\n\t    }\n\t    href = ref.href;\n\t    title = ref.title;\n\t  }\n\t\n\t  //\n\t  // We found the end of the link, and know for a fact it's a valid link;\n\t  // so all that's left to do is to call tokenizer.\n\t  //\n\t  if (!silent) {\n\t    state.pos = labelStart;\n\t    state.posMax = labelEnd;\n\t\n\t    token = state.push('link_open', 'a', 1);\n\t    token.attrs = attrs = [['href', href]];\n\t    if (title) {\n\t      attrs.push(['title', title]);\n\t    }\n\t\n\t    state.md.inline.tokenize(state);\n\t\n\t    token = state.push('link_close', 'a', -1);\n\t  }\n\t\n\t  state.pos = pos;\n\t  state.posMax = max;\n\t  return true;\n\t};\n\n/***/ },\n/* 307 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Process ![image](<src> \"title\")\n\t\n\t'use strict';\n\t\n\tvar parseLinkLabel = __webpack_require__(270);\n\tvar parseLinkDestination = __webpack_require__(271);\n\tvar parseLinkTitle = __webpack_require__(272);\n\tvar normalizeReference = __webpack_require__(255).normalizeReference;\n\tvar isSpace = __webpack_require__(255).isSpace;\n\t\n\tmodule.exports = function image(state, silent) {\n\t  var attrs,\n\t      code,\n\t      content,\n\t      label,\n\t      labelEnd,\n\t      labelStart,\n\t      pos,\n\t      ref,\n\t      res,\n\t      title,\n\t      token,\n\t      tokens,\n\t      start,\n\t      href = '',\n\t      oldPos = state.pos,\n\t      max = state.posMax;\n\t\n\t  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {\n\t      return false;\n\t    }\n\t  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {\n\t      return false;\n\t    }\n\t\n\t  labelStart = state.pos + 2;\n\t  labelEnd = parseLinkLabel(state, state.pos + 1, false);\n\t\n\t  // parser failed to find ']', so it's not a valid link\n\t  if (labelEnd < 0) {\n\t    return false;\n\t  }\n\t\n\t  pos = labelEnd + 1;\n\t  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {\n\t      //\n\t      // Inline link\n\t      //\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //        ^^ skipping these spaces\n\t      pos++;\n\t      for (; pos < max; pos++) {\n\t        code = state.src.charCodeAt(pos);\n\t        if (!isSpace(code) && code !== 0x0A) {\n\t          break;\n\t        }\n\t      }\n\t      if (pos >= max) {\n\t        return false;\n\t      }\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //          ^^^^^^ parsing link destination\n\t      start = pos;\n\t      res = parseLinkDestination(state.src, pos, state.posMax);\n\t      if (res.ok) {\n\t        href = state.md.normalizeLink(res.str);\n\t        if (state.md.validateLink(href)) {\n\t          pos = res.pos;\n\t        } else {\n\t          href = '';\n\t        }\n\t      }\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //                ^^ skipping these spaces\n\t      start = pos;\n\t      for (; pos < max; pos++) {\n\t        code = state.src.charCodeAt(pos);\n\t        if (!isSpace(code) && code !== 0x0A) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      // [link](  <href>  \"title\"  )\n\t      //                  ^^^^^^^ parsing link title\n\t      res = parseLinkTitle(state.src, pos, state.posMax);\n\t      if (pos < max && start !== pos && res.ok) {\n\t        title = res.str;\n\t        pos = res.pos;\n\t\n\t        // [link](  <href>  \"title\"  )\n\t        //                         ^^ skipping these spaces\n\t        for (; pos < max; pos++) {\n\t          code = state.src.charCodeAt(pos);\n\t          if (!isSpace(code) && code !== 0x0A) {\n\t            break;\n\t          }\n\t        }\n\t      } else {\n\t        title = '';\n\t      }\n\t\n\t      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {\n\t          state.pos = oldPos;\n\t          return false;\n\t        }\n\t      pos++;\n\t    } else {\n\t    //\n\t    // Link reference\n\t    //\n\t    if (typeof state.env.references === 'undefined') {\n\t      return false;\n\t    }\n\t\n\t    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {\n\t        start = pos + 1;\n\t        pos = parseLinkLabel(state, pos);\n\t        if (pos >= 0) {\n\t          label = state.src.slice(start, pos++);\n\t        } else {\n\t          pos = labelEnd + 1;\n\t        }\n\t      } else {\n\t      pos = labelEnd + 1;\n\t    }\n\t\n\t    // covers label === '' and label === undefined\n\t    // (collapsed reference link and shortcut reference link respectively)\n\t    if (!label) {\n\t      label = state.src.slice(labelStart, labelEnd);\n\t    }\n\t\n\t    ref = state.env.references[normalizeReference(label)];\n\t    if (!ref) {\n\t      state.pos = oldPos;\n\t      return false;\n\t    }\n\t    href = ref.href;\n\t    title = ref.title;\n\t  }\n\t\n\t  //\n\t  // We found the end of the link, and know for a fact it's a valid link;\n\t  // so all that's left to do is to call tokenizer.\n\t  //\n\t  if (!silent) {\n\t    content = state.src.slice(labelStart, labelEnd);\n\t\n\t    state.md.inline.parse(content, state.md, state.env, tokens = []);\n\t\n\t    token = state.push('image', 'img', 0);\n\t    token.attrs = attrs = [['src', href], ['alt', '']];\n\t    token.children = tokens;\n\t    token.content = content;\n\t\n\t    if (title) {\n\t      attrs.push(['title', title]);\n\t    }\n\t  }\n\t\n\t  state.pos = pos;\n\t  state.posMax = max;\n\t  return true;\n\t};\n\n/***/ },\n/* 308 */\n/***/ function(module, exports) {\n\n\t// Process autolinks '<protocol:...>'\n\t\n\t'use strict';\n\t\n\t/*eslint max-len:0*/\n\tvar EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\n\tvar AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)>/;\n\t\n\tmodule.exports = function autolink(state, silent) {\n\t  var tail,\n\t      linkMatch,\n\t      emailMatch,\n\t      url,\n\t      fullUrl,\n\t      token,\n\t      pos = state.pos;\n\t\n\t  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {\n\t      return false;\n\t    }\n\t\n\t  tail = state.src.slice(pos);\n\t\n\t  if (tail.indexOf('>') < 0) {\n\t    return false;\n\t  }\n\t\n\t  if (AUTOLINK_RE.test(tail)) {\n\t    linkMatch = tail.match(AUTOLINK_RE);\n\t\n\t    url = linkMatch[0].slice(1, -1);\n\t    fullUrl = state.md.normalizeLink(url);\n\t    if (!state.md.validateLink(fullUrl)) {\n\t      return false;\n\t    }\n\t\n\t    if (!silent) {\n\t      token = state.push('link_open', 'a', 1);\n\t      token.attrs = [['href', fullUrl]];\n\t      token.markup = 'autolink';\n\t      token.info = 'auto';\n\t\n\t      token = state.push('text', '', 0);\n\t      token.content = state.md.normalizeLinkText(url);\n\t\n\t      token = state.push('link_close', 'a', -1);\n\t      token.markup = 'autolink';\n\t      token.info = 'auto';\n\t    }\n\t\n\t    state.pos += linkMatch[0].length;\n\t    return true;\n\t  }\n\t\n\t  if (EMAIL_RE.test(tail)) {\n\t    emailMatch = tail.match(EMAIL_RE);\n\t\n\t    url = emailMatch[0].slice(1, -1);\n\t    fullUrl = state.md.normalizeLink('mailto:' + url);\n\t    if (!state.md.validateLink(fullUrl)) {\n\t      return false;\n\t    }\n\t\n\t    if (!silent) {\n\t      token = state.push('link_open', 'a', 1);\n\t      token.attrs = [['href', fullUrl]];\n\t      token.markup = 'autolink';\n\t      token.info = 'auto';\n\t\n\t      token = state.push('text', '', 0);\n\t      token.content = state.md.normalizeLinkText(url);\n\t\n\t      token = state.push('link_close', 'a', -1);\n\t      token.markup = 'autolink';\n\t      token.info = 'auto';\n\t    }\n\t\n\t    state.pos += emailMatch[0].length;\n\t    return true;\n\t  }\n\t\n\t  return false;\n\t};\n\n/***/ },\n/* 309 */,\n/* 310 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Process html tags\n\t\n\t'use strict';\n\t\n\tvar HTML_TAG_RE = __webpack_require__(296).HTML_TAG_RE;\n\t\n\tfunction isLetter(ch) {\n\t  /*eslint no-bitwise:0*/\n\t  var lc = ch | 0x20; // to lower case\n\t  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;\n\t}\n\t\n\tmodule.exports = function html_inline(state, silent) {\n\t  var ch,\n\t      match,\n\t      max,\n\t      token,\n\t      pos = state.pos;\n\t\n\t  if (!state.md.options.html) {\n\t    return false;\n\t  }\n\t\n\t  // Check start\n\t  max = state.posMax;\n\t  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {\n\t    return false;\n\t  }\n\t\n\t  // Quick fail on second char\n\t  ch = state.src.charCodeAt(pos + 1);\n\t  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {\n\t    return false;\n\t  }\n\t\n\t  match = state.src.slice(pos).match(HTML_TAG_RE);\n\t  if (!match) {\n\t    return false;\n\t  }\n\t\n\t  if (!silent) {\n\t    token = state.push('html_inline', '', 0);\n\t    token.content = state.src.slice(pos, pos + match[0].length);\n\t  }\n\t  state.pos += match[0].length;\n\t  return true;\n\t};\n\n/***/ },\n/* 311 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Process html entity - &#123;, &#xAF;, &quot;, ...\n\t\n\t'use strict';\n\t\n\tvar entities = __webpack_require__(256);\n\tvar has = __webpack_require__(255).has;\n\tvar isValidEntityCode = __webpack_require__(255).isValidEntityCode;\n\tvar fromCodePoint = __webpack_require__(255).fromCodePoint;\n\t\n\tvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\n\tvar NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\n\t\n\tmodule.exports = function entity(state, silent) {\n\t  var ch,\n\t      code,\n\t      match,\n\t      pos = state.pos,\n\t      max = state.posMax;\n\t\n\t  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {\n\t      return false;\n\t    }\n\t\n\t  if (pos + 1 < max) {\n\t    ch = state.src.charCodeAt(pos + 1);\n\t\n\t    if (ch === 0x23 /* # */) {\n\t        match = state.src.slice(pos).match(DIGITAL_RE);\n\t        if (match) {\n\t          if (!silent) {\n\t            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n\t            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n\t          }\n\t          state.pos += match[0].length;\n\t          return true;\n\t        }\n\t      } else {\n\t      match = state.src.slice(pos).match(NAMED_RE);\n\t      if (match) {\n\t        if (has(entities, match[1])) {\n\t          if (!silent) {\n\t            state.pending += entities[match[1]];\n\t          }\n\t          state.pos += match[0].length;\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (!silent) {\n\t    state.pending += '&';\n\t  }\n\t  state.pos++;\n\t  return true;\n\t};\n\n/***/ },\n/* 312 */\n/***/ function(module, exports) {\n\n\t// For each opening emphasis-like marker find a matching closing one\n\t//\n\t'use strict';\n\t\n\tmodule.exports = function link_pairs(state) {\n\t  var i,\n\t      j,\n\t      lastDelim,\n\t      currDelim,\n\t      delimiters = state.delimiters,\n\t      max = state.delimiters.length;\n\t\n\t  for (i = 0; i < max; i++) {\n\t    lastDelim = delimiters[i];\n\t\n\t    if (!lastDelim.close) {\n\t      continue;\n\t    }\n\t\n\t    j = i - lastDelim.jump - 1;\n\t\n\t    while (j >= 0) {\n\t      currDelim = delimiters[j];\n\t\n\t      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {\n\t\n\t        lastDelim.jump = i - j;\n\t        lastDelim.open = false;\n\t        currDelim.end = i;\n\t        currDelim.jump = 0;\n\t        break;\n\t      }\n\t\n\t      j -= currDelim.jump + 1;\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 313 */\n/***/ function(module, exports) {\n\n\t// Merge adjacent text nodes into one, and re-calculate all token levels\n\t//\n\t'use strict';\n\t\n\tmodule.exports = function text_collapse(state) {\n\t  var curr,\n\t      last,\n\t      level = 0,\n\t      tokens = state.tokens,\n\t      max = state.tokens.length;\n\t\n\t  for (curr = last = 0; curr < max; curr++) {\n\t    // re-calculate levels\n\t    level += tokens[curr].nesting;\n\t    tokens[curr].level = level;\n\t\n\t    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {\n\t\n\t      // collapse two adjacent text nodes\n\t      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n\t    } else {\n\t      if (curr !== last) {\n\t        tokens[last] = tokens[curr];\n\t      }\n\t\n\t      last++;\n\t    }\n\t  }\n\t\n\t  if (curr !== last) {\n\t    tokens.length = last;\n\t  }\n\t};\n\n/***/ },\n/* 314 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Inline parser state\n\t\n\t'use strict';\n\t\n\tvar Token = __webpack_require__(283);\n\tvar isWhiteSpace = __webpack_require__(255).isWhiteSpace;\n\tvar isPunctChar = __webpack_require__(255).isPunctChar;\n\tvar isMdAsciiPunct = __webpack_require__(255).isMdAsciiPunct;\n\t\n\tfunction StateInline(src, md, env, outTokens) {\n\t  this.src = src;\n\t  this.env = env;\n\t  this.md = md;\n\t  this.tokens = outTokens;\n\t\n\t  this.pos = 0;\n\t  this.posMax = this.src.length;\n\t  this.level = 0;\n\t  this.pending = '';\n\t  this.pendingLevel = 0;\n\t\n\t  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack\n\t  // optimization of pairs parse (emphasis, strikes).\n\t\n\t  this.delimiters = []; // Emphasis-like delimiters\n\t}\n\t\n\t// Flush pending text\n\t//\n\tStateInline.prototype.pushPending = function () {\n\t  var token = new Token('text', '', 0);\n\t  token.content = this.pending;\n\t  token.level = this.pendingLevel;\n\t  this.tokens.push(token);\n\t  this.pending = '';\n\t  return token;\n\t};\n\t\n\t// Push new token to \"stream\".\n\t// If pending text exists - flush it as text token\n\t//\n\tStateInline.prototype.push = function (type, tag, nesting) {\n\t  if (this.pending) {\n\t    this.pushPending();\n\t  }\n\t\n\t  var token = new Token(type, tag, nesting);\n\t\n\t  if (nesting < 0) {\n\t    this.level--;\n\t  }\n\t  token.level = this.level;\n\t  if (nesting > 0) {\n\t    this.level++;\n\t  }\n\t\n\t  this.pendingLevel = this.level;\n\t  this.tokens.push(token);\n\t  return token;\n\t};\n\t\n\t// Scan a sequence of emphasis-like markers, and determine whether\n\t// it can start an emphasis sequence or end an emphasis sequence.\n\t//\n\t//  - start - position to scan from (it should point at a valid marker);\n\t//  - canSplitWord - determine if these markers can be found inside a word\n\t//\n\tStateInline.prototype.scanDelims = function (start, canSplitWord) {\n\t  var pos = start,\n\t      lastChar,\n\t      nextChar,\n\t      count,\n\t      can_open,\n\t      can_close,\n\t      isLastWhiteSpace,\n\t      isLastPunctChar,\n\t      isNextWhiteSpace,\n\t      isNextPunctChar,\n\t      left_flanking = true,\n\t      right_flanking = true,\n\t      max = this.posMax,\n\t      marker = this.src.charCodeAt(start);\n\t\n\t  // treat beginning of the line as a whitespace\n\t  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\t\n\t  while (pos < max && this.src.charCodeAt(pos) === marker) {\n\t    pos++;\n\t  }\n\t\n\t  count = pos - start;\n\t\n\t  // treat end of the line as a whitespace\n\t  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\t\n\t  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n\t  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\t\n\t  isLastWhiteSpace = isWhiteSpace(lastChar);\n\t  isNextWhiteSpace = isWhiteSpace(nextChar);\n\t\n\t  if (isNextWhiteSpace) {\n\t    left_flanking = false;\n\t  } else if (isNextPunctChar) {\n\t    if (!(isLastWhiteSpace || isLastPunctChar)) {\n\t      left_flanking = false;\n\t    }\n\t  }\n\t\n\t  if (isLastWhiteSpace) {\n\t    right_flanking = false;\n\t  } else if (isLastPunctChar) {\n\t    if (!(isNextWhiteSpace || isNextPunctChar)) {\n\t      right_flanking = false;\n\t    }\n\t  }\n\t\n\t  if (!canSplitWord) {\n\t    can_open = left_flanking && (!right_flanking || isLastPunctChar);\n\t    can_close = right_flanking && (!left_flanking || isNextPunctChar);\n\t  } else {\n\t    can_open = left_flanking;\n\t    can_close = right_flanking;\n\t  }\n\t\n\t  return {\n\t    can_open: can_open,\n\t    can_close: can_close,\n\t    length: count\n\t  };\n\t};\n\t\n\t// re-export Token class to use in block rules\n\tStateInline.prototype.Token = Token;\n\t\n\tmodule.exports = StateInline;\n\n/***/ },\n/* 315 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t// Helpers\n\t\n\t// Merge objects\n\t//\n\tfunction assign(obj /*from1, from2, from3, ...*/) {\n\t  var sources = Array.prototype.slice.call(arguments, 1);\n\t\n\t  sources.forEach(function (source) {\n\t    if (!source) {\n\t      return;\n\t    }\n\t\n\t    Object.keys(source).forEach(function (key) {\n\t      obj[key] = source[key];\n\t    });\n\t  });\n\t\n\t  return obj;\n\t}\n\t\n\tfunction _class(obj) {\n\t  return Object.prototype.toString.call(obj);\n\t}\n\tfunction isString(obj) {\n\t  return _class(obj) === '[object String]';\n\t}\n\tfunction isObject(obj) {\n\t  return _class(obj) === '[object Object]';\n\t}\n\tfunction isRegExp(obj) {\n\t  return _class(obj) === '[object RegExp]';\n\t}\n\tfunction isFunction(obj) {\n\t  return _class(obj) === '[object Function]';\n\t}\n\t\n\tfunction escapeRE(str) {\n\t  return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&');\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar defaultOptions = {\n\t  fuzzyLink: true,\n\t  fuzzyEmail: true,\n\t  fuzzyIP: false\n\t};\n\t\n\tfunction isOptionsObj(obj) {\n\t  return Object.keys(obj || {}).reduce(function (acc, k) {\n\t    return acc || defaultOptions.hasOwnProperty(k);\n\t  }, false);\n\t}\n\t\n\tvar defaultSchemas = {\n\t  'http:': {\n\t    validate: function validate(text, pos, self) {\n\t      var tail = text.slice(pos);\n\t\n\t      if (!self.re.http) {\n\t        // compile lazily, because \"host\"-containing variables can change on tlds update.\n\t        self.re.http = new RegExp('^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');\n\t      }\n\t      if (self.re.http.test(tail)) {\n\t        return tail.match(self.re.http)[0].length;\n\t      }\n\t      return 0;\n\t    }\n\t  },\n\t  'https:': 'http:',\n\t  'ftp:': 'http:',\n\t  '//': {\n\t    validate: function validate(text, pos, self) {\n\t      var tail = text.slice(pos);\n\t\n\t      if (!self.re.no_http) {\n\t        // compile lazily, becayse \"host\"-containing variables can change on tlds update.\n\t        self.re.no_http = new RegExp('^' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');\n\t      }\n\t\n\t      if (self.re.no_http.test(tail)) {\n\t        // should not be `://`, that protects from errors in protocol name\n\t        if (pos >= 3 && text[pos - 3] === ':') {\n\t          return 0;\n\t        }\n\t        return tail.match(self.re.no_http)[0].length;\n\t      }\n\t      return 0;\n\t    }\n\t  },\n\t  'mailto:': {\n\t    validate: function validate(text, pos, self) {\n\t      var tail = text.slice(pos);\n\t\n\t      if (!self.re.mailto) {\n\t        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');\n\t      }\n\t      if (self.re.mailto.test(tail)) {\n\t        return tail.match(self.re.mailto)[0].length;\n\t      }\n\t      return 0;\n\t    }\n\t  }\n\t};\n\t\n\t/*eslint-disable max-len*/\n\t\n\t// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\n\tvar tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';\n\t\n\t// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\n\tvar tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|'.split('|');\n\t\n\t/*eslint-enable max-len*/\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tfunction resetScanCache(self) {\n\t  self.__index__ = -1;\n\t  self.__text_cache__ = '';\n\t}\n\t\n\tfunction createValidator(re) {\n\t  return function (text, pos) {\n\t    var tail = text.slice(pos);\n\t\n\t    if (re.test(tail)) {\n\t      return tail.match(re)[0].length;\n\t    }\n\t    return 0;\n\t  };\n\t}\n\t\n\tfunction createNormalizer() {\n\t  return function (match, self) {\n\t    self.normalize(match);\n\t  };\n\t}\n\t\n\t// Schemas compiler. Build regexps.\n\t//\n\tfunction compile(self) {\n\t\n\t  // Load & clone RE patterns.\n\t  var re = self.re = assign({}, __webpack_require__(316));\n\t\n\t  // Define dynamic patterns\n\t  var tlds = self.__tlds__.slice();\n\t\n\t  if (!self.__tlds_replaced__) {\n\t    tlds.push(tlds_2ch_src_re);\n\t  }\n\t  tlds.push(re.src_xn);\n\t\n\t  re.src_tlds = tlds.join('|');\n\t\n\t  function untpl(tpl) {\n\t    return tpl.replace('%TLDS%', re.src_tlds);\n\t  }\n\t\n\t  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');\n\t  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');\n\t  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');\n\t  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');\n\t\n\t  //\n\t  // Compile each schema\n\t  //\n\t\n\t  var aliases = [];\n\t\n\t  self.__compiled__ = {}; // Reset compiled data\n\t\n\t  function schemaError(name, val) {\n\t    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n\t  }\n\t\n\t  Object.keys(self.__schemas__).forEach(function (name) {\n\t    var val = self.__schemas__[name];\n\t\n\t    // skip disabled methods\n\t    if (val === null) {\n\t      return;\n\t    }\n\t\n\t    var compiled = { validate: null, link: null };\n\t\n\t    self.__compiled__[name] = compiled;\n\t\n\t    if (isObject(val)) {\n\t      if (isRegExp(val.validate)) {\n\t        compiled.validate = createValidator(val.validate);\n\t      } else if (isFunction(val.validate)) {\n\t        compiled.validate = val.validate;\n\t      } else {\n\t        schemaError(name, val);\n\t      }\n\t\n\t      if (isFunction(val.normalize)) {\n\t        compiled.normalize = val.normalize;\n\t      } else if (!val.normalize) {\n\t        compiled.normalize = createNormalizer();\n\t      } else {\n\t        schemaError(name, val);\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (isString(val)) {\n\t      aliases.push(name);\n\t      return;\n\t    }\n\t\n\t    schemaError(name, val);\n\t  });\n\t\n\t  //\n\t  // Compile postponed aliases\n\t  //\n\t\n\t  aliases.forEach(function (alias) {\n\t    if (!self.__compiled__[self.__schemas__[alias]]) {\n\t      // Silently fail on missed schemas to avoid errons on disable.\n\t      // schemaError(alias, self.__schemas__[alias]);\n\t      return;\n\t    }\n\t\n\t    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;\n\t    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;\n\t  });\n\t\n\t  //\n\t  // Fake record for guessed links\n\t  //\n\t  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };\n\t\n\t  //\n\t  // Build schema condition\n\t  //\n\t  var slist = Object.keys(self.__compiled__).filter(function (name) {\n\t    // Filter disabled & fake schemas\n\t    return name.length > 0 && self.__compiled__[name];\n\t  }).map(escapeRE).join('|');\n\t  // (?!_) cause 1.5x slowdown\n\t  self.re.schema_test = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'i');\n\t  self.re.schema_search = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'ig');\n\t\n\t  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');\n\t\n\t  //\n\t  // Cleanup\n\t  //\n\t\n\t  resetScanCache(self);\n\t}\n\t\n\t/**\n\t * class Match\n\t *\n\t * Match result. Single element of array, returned by [[LinkifyIt#match]]\n\t **/\n\tfunction Match(self, shift) {\n\t  var start = self.__index__,\n\t      end = self.__last_index__,\n\t      text = self.__text_cache__.slice(start, end);\n\t\n\t  /**\n\t   * Match#schema -> String\n\t   *\n\t   * Prefix (protocol) for matched string.\n\t   **/\n\t  this.schema = self.__schema__.toLowerCase();\n\t  /**\n\t   * Match#index -> Number\n\t   *\n\t   * First position of matched string.\n\t   **/\n\t  this.index = start + shift;\n\t  /**\n\t   * Match#lastIndex -> Number\n\t   *\n\t   * Next position after matched string.\n\t   **/\n\t  this.lastIndex = end + shift;\n\t  /**\n\t   * Match#raw -> String\n\t   *\n\t   * Matched string.\n\t   **/\n\t  this.raw = text;\n\t  /**\n\t   * Match#text -> String\n\t   *\n\t   * Notmalized text of matched string.\n\t   **/\n\t  this.text = text;\n\t  /**\n\t   * Match#url -> String\n\t   *\n\t   * Normalized url of matched string.\n\t   **/\n\t  this.url = text;\n\t}\n\t\n\tfunction createMatch(self, shift) {\n\t  var match = new Match(self, shift);\n\t\n\t  self.__compiled__[match.schema].normalize(match, self);\n\t\n\t  return match;\n\t}\n\t\n\t/**\n\t * class LinkifyIt\n\t **/\n\t\n\t/**\n\t * new LinkifyIt(schemas, options)\n\t * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n\t * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n\t *\n\t * Creates new linkifier instance with optional additional schemas.\n\t * Can be called without `new` keyword for convenience.\n\t *\n\t * By default understands:\n\t *\n\t * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n\t * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n\t *\n\t * `schemas` is an object, where each key/value describes protocol/rule:\n\t *\n\t * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n\t *   for example). `linkify-it` makes shure that prefix is not preceeded with\n\t *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n\t * - __value__ - rule to check tail after link prefix\n\t *   - _String_ - just alias to existing rule\n\t *   - _Object_\n\t *     - _validate_ - validator function (should return matched length on success),\n\t *       or `RegExp`.\n\t *     - _normalize_ - optional function to normalize text & url of matched result\n\t *       (for example, for @twitter mentions).\n\t *\n\t * `options`:\n\t *\n\t * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n\t * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n\t *   like version numbers. Default `false`.\n\t * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n\t *\n\t **/\n\tfunction LinkifyIt(schemas, options) {\n\t  if (!(this instanceof LinkifyIt)) {\n\t    return new LinkifyIt(schemas, options);\n\t  }\n\t\n\t  if (!options) {\n\t    if (isOptionsObj(schemas)) {\n\t      options = schemas;\n\t      schemas = {};\n\t    }\n\t  }\n\t\n\t  this.__opts__ = assign({}, defaultOptions, options);\n\t\n\t  // Cache last tested result. Used to skip repeating steps on next `match` call.\n\t  this.__index__ = -1;\n\t  this.__last_index__ = -1; // Next scan position\n\t  this.__schema__ = '';\n\t  this.__text_cache__ = '';\n\t\n\t  this.__schemas__ = assign({}, defaultSchemas, schemas);\n\t  this.__compiled__ = {};\n\t\n\t  this.__tlds__ = tlds_default;\n\t  this.__tlds_replaced__ = false;\n\t\n\t  this.re = {};\n\t\n\t  compile(this);\n\t}\n\t\n\t/** chainable\n\t * LinkifyIt#add(schema, definition)\n\t * - schema (String): rule name (fixed pattern prefix)\n\t * - definition (String|RegExp|Object): schema definition\n\t *\n\t * Add new rule definition. See constructor description for details.\n\t **/\n\tLinkifyIt.prototype.add = function add(schema, definition) {\n\t  this.__schemas__[schema] = definition;\n\t  compile(this);\n\t  return this;\n\t};\n\t\n\t/** chainable\n\t * LinkifyIt#set(options)\n\t * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n\t *\n\t * Set recognition options for links without schema.\n\t **/\n\tLinkifyIt.prototype.set = function set(options) {\n\t  this.__opts__ = assign(this.__opts__, options);\n\t  return this;\n\t};\n\t\n\t/**\n\t * LinkifyIt#test(text) -> Boolean\n\t *\n\t * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n\t **/\n\tLinkifyIt.prototype.test = function test(text) {\n\t  // Reset scan cache\n\t  this.__text_cache__ = text;\n\t  this.__index__ = -1;\n\t\n\t  if (!text.length) {\n\t    return false;\n\t  }\n\t\n\t  var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n\t\n\t  // try to scan for link with schema - that's the most simple rule\n\t  if (this.re.schema_test.test(text)) {\n\t    re = this.re.schema_search;\n\t    re.lastIndex = 0;\n\t    while ((m = re.exec(text)) !== null) {\n\t      len = this.testSchemaAt(text, m[2], re.lastIndex);\n\t      if (len) {\n\t        this.__schema__ = m[2];\n\t        this.__index__ = m.index + m[1].length;\n\t        this.__last_index__ = m.index + m[0].length + len;\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {\n\t    // guess schemaless links\n\t    tld_pos = text.search(this.re.host_fuzzy_test);\n\t    if (tld_pos >= 0) {\n\t      // if tld is located after found link - no need to check fuzzy pattern\n\t      if (this.__index__ < 0 || tld_pos < this.__index__) {\n\t        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n\t\n\t          shift = ml.index + ml[1].length;\n\t\n\t          if (this.__index__ < 0 || shift < this.__index__) {\n\t            this.__schema__ = '';\n\t            this.__index__ = shift;\n\t            this.__last_index__ = ml.index + ml[0].length;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {\n\t    // guess schemaless emails\n\t    at_pos = text.indexOf('@');\n\t    if (at_pos >= 0) {\n\t      // We can't skip this check, because this cases are possible:\n\t      // 192.168.1.1@gmail.com, my.in@example.com\n\t      if ((me = text.match(this.re.email_fuzzy)) !== null) {\n\t\n\t        shift = me.index + me[1].length;\n\t        next = me.index + me[0].length;\n\t\n\t        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {\n\t          this.__schema__ = 'mailto:';\n\t          this.__index__ = shift;\n\t          this.__last_index__ = next;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return this.__index__ >= 0;\n\t};\n\t\n\t/**\n\t * LinkifyIt#pretest(text) -> Boolean\n\t *\n\t * Very quick check, that can give false positives. Returns true if link MAY BE\n\t * can exists. Can be used for speed optimization, when you need to check that\n\t * link NOT exists.\n\t **/\n\tLinkifyIt.prototype.pretest = function pretest(text) {\n\t  return this.re.pretest.test(text);\n\t};\n\t\n\t/**\n\t * LinkifyIt#testSchemaAt(text, name, position) -> Number\n\t * - text (String): text to scan\n\t * - name (String): rule (schema) name\n\t * - position (Number): text offset to check from\n\t *\n\t * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n\t * at given position. Returns length of found pattern (0 on fail).\n\t **/\n\tLinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n\t  // If not supported schema check requested - terminate\n\t  if (!this.__compiled__[schema.toLowerCase()]) {\n\t    return 0;\n\t  }\n\t  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n\t};\n\t\n\t/**\n\t * LinkifyIt#match(text) -> Array|null\n\t *\n\t * Returns array of found link descriptions or `null` on fail. We strongly\n\t * to use [[LinkifyIt#test]] first, for best speed.\n\t *\n\t * ##### Result match description\n\t *\n\t * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n\t *   protocol-neutral  links.\n\t * - __index__ - offset of matched text\n\t * - __lastIndex__ - index of next char after mathch end\n\t * - __raw__ - matched text\n\t * - __text__ - normalized text\n\t * - __url__ - link, generated from matched text\n\t **/\n\tLinkifyIt.prototype.match = function match(text) {\n\t  var shift = 0,\n\t      result = [];\n\t\n\t  // Try to take previous element from cache, if .test() called before\n\t  if (this.__index__ >= 0 && this.__text_cache__ === text) {\n\t    result.push(createMatch(this, shift));\n\t    shift = this.__last_index__;\n\t  }\n\t\n\t  // Cut head if cache was used\n\t  var tail = shift ? text.slice(shift) : text;\n\t\n\t  // Scan string until end reached\n\t  while (this.test(tail)) {\n\t    result.push(createMatch(this, shift));\n\t\n\t    tail = tail.slice(this.__last_index__);\n\t    shift += this.__last_index__;\n\t  }\n\t\n\t  if (result.length) {\n\t    return result;\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\t/** chainable\n\t * LinkifyIt#tlds(list [, keepOld]) -> this\n\t * - list (Array): list of tlds\n\t * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n\t *\n\t * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n\t * to avoid false positives. By default this algorythm used:\n\t *\n\t * - hostname with any 2-letter root zones are ok.\n\t * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\n\t *   are ok.\n\t * - encoded (`xn--...`) root zones are ok.\n\t *\n\t * If list is replaced, then exact match for 2-chars root zones will be checked.\n\t **/\n\tLinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n\t  list = Array.isArray(list) ? list : [list];\n\t\n\t  if (!keepOld) {\n\t    this.__tlds__ = list.slice();\n\t    this.__tlds_replaced__ = true;\n\t    compile(this);\n\t    return this;\n\t  }\n\t\n\t  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {\n\t    return el !== arr[idx - 1];\n\t  }).reverse();\n\t\n\t  compile(this);\n\t  return this;\n\t};\n\t\n\t/**\n\t * LinkifyIt#normalize(match)\n\t *\n\t * Default normalizer (if schema does not define it's own).\n\t **/\n\tLinkifyIt.prototype.normalize = function normalize(match) {\n\t\n\t  // Do minimal possible changes by default. Need to collect feedback prior\n\t  // to move forward https://github.com/markdown-it/linkify-it/issues/1\n\t\n\t  if (!match.schema) {\n\t    match.url = 'http://' + match.url;\n\t  }\n\t\n\t  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\n\t    match.url = 'mailto:' + match.url;\n\t  }\n\t};\n\t\n\tmodule.exports = LinkifyIt;\n\n/***/ },\n/* 316 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Use direct extract instead of `regenerate` to reduse browserified size\n\tvar src_Any = exports.src_Any = __webpack_require__(265).source;\n\tvar src_Cc = exports.src_Cc = __webpack_require__(266).source;\n\tvar src_Z = exports.src_Z = __webpack_require__(268).source;\n\tvar src_P = exports.src_P = __webpack_require__(258).source;\n\t\n\t// \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n\tvar src_ZPCc = exports.src_ZPCc = [src_Z, src_P, src_Cc].join('|');\n\t\n\t// \\p{\\Z\\Cc} (white spaces + control)\n\tvar src_ZCc = exports.src_ZCc = [src_Z, src_Cc].join('|');\n\t\n\t// All possible word characters (everything without punctuation, spaces & controls)\n\t// Defined via punctuation & spaces to save space\n\t// Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n\tvar src_pseudo_letter = '(?:(?!' + src_ZPCc + ')' + src_Any + ')';\n\t// The same as abothe but without [0-9]\n\tvar src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar src_ip4 = exports.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';\n\t\n\texports.src_auth = '(?:(?:(?!' + src_ZCc + ').)+@)?';\n\t\n\tvar src_port = exports.src_port = '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?';\n\t\n\tvar src_host_terminator = exports.src_host_terminator = '(?=$|' + src_ZPCc + ')(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|' + src_ZPCc + '))';\n\t\n\tvar src_path = exports.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + src_ZCc + '|[()[\\\\]{}.,\"\\'?!\\\\-]).|' + '\\\\[(?:(?!' + src_ZCc + '|\\\\]).)*\\\\]|' + '\\\\((?:(?!' + src_ZCc + '|[)]).)*\\\\)|' + '\\\\{(?:(?!' + src_ZCc + '|[}]).)*\\\\}|' + '\\\\\"(?:(?!' + src_ZCc + '|[\"]).)+\\\\\"|' + \"\\\\'(?:(?!\" + src_ZCc + \"|[']).)+\\\\'|\" + \"\\\\'(?=\" + src_pseudo_letter + ').|' + // allow `I'm_king` if no pair found\n\t'\\\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to\n\t// - english\n\t// - percent-encoded\n\t// - parts of file path\n\t// until more examples found.\n\t'\\\\.(?!' + src_ZCc + '|[.]).|' + '\\\\-(?!--(?:[^-]|$))(?:-*)|' + // `---` => long dash, terminate\n\t'\\\\,(?!' + src_ZCc + ').|' + // allow `,,,` in paths\n\t'\\\\!(?!' + src_ZCc + '|[!]).|' + '\\\\?(?!' + src_ZCc + '|[?]).' + ')+' + '|\\\\/' + ')?';\n\t\n\tvar src_email_name = exports.src_email_name = '[\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]+';\n\t\n\tvar src_xn = exports.src_xn = 'xn--[a-z0-9\\\\-]{1,59}';\n\t\n\t// More to read about domain names\n\t// http://serverfault.com/questions/638260/\n\t\n\tvar src_domain_root = exports.src_domain_root =\n\t\n\t// Can't have digits and dashes\n\t'(?:' + src_xn + '|' + src_pseudo_letter_non_d + '{1,63}' + ')';\n\t\n\tvar src_domain = exports.src_domain = '(?:' + src_xn + '|' + '(?:' + src_pseudo_letter + ')' + '|' +\n\t// don't allow `--` in domain names, because:\n\t// - that can conflict with markdown &mdash; / &ndash;\n\t// - nobody use those anyway\n\t'(?:' + src_pseudo_letter + '(?:-(?!-)|' + src_pseudo_letter + '){0,61}' + src_pseudo_letter + ')' + ')';\n\t\n\tvar src_host = exports.src_host = '(?:' + src_ip4 + '|' + '(?:(?:(?:' + src_domain + ')\\\\.)*' + src_domain_root + ')' + ')';\n\t\n\tvar tpl_host_fuzzy = exports.tpl_host_fuzzy = '(?:' + src_ip4 + '|' + '(?:(?:(?:' + src_domain + ')\\\\.)+(?:%TLDS%))' + ')';\n\t\n\tvar tpl_host_no_ip_fuzzy = exports.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + src_domain + ')\\\\.)+(?:%TLDS%))';\n\t\n\texports.src_host_strict = src_host + src_host_terminator;\n\t\n\tvar tpl_host_fuzzy_strict = exports.tpl_host_fuzzy_strict = tpl_host_fuzzy + src_host_terminator;\n\t\n\texports.src_host_port_strict = src_host + src_port + src_host_terminator;\n\t\n\tvar tpl_host_port_fuzzy_strict = exports.tpl_host_port_fuzzy_strict = tpl_host_fuzzy + src_port + src_host_terminator;\n\t\n\tvar tpl_host_port_no_ip_fuzzy_strict = exports.tpl_host_port_no_ip_fuzzy_strict = tpl_host_no_ip_fuzzy + src_port + src_host_terminator;\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t// Main rules\n\t\n\t// Rude test fuzzy links by host, for quick deny\n\texports.tpl_host_fuzzy_test = 'localhost|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + src_ZPCc + '|$))';\n\t\n\texports.tpl_email_fuzzy = '(^|>|' + src_ZCc + ')(' + src_email_name + '@' + tpl_host_fuzzy_strict + ')';\n\t\n\texports.tpl_link_fuzzy =\n\t// Fuzzy link can't be prepended with .:/\\- and non punctuation.\n\t// but can start with > (markdown blockquote)\n\t'(^|(?![.:/\\\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' + '((?![$+<=>^`|])' + tpl_host_port_fuzzy_strict + src_path + ')';\n\t\n\texports.tpl_link_no_ip_fuzzy =\n\t// Fuzzy link can't be prepended with .:/\\- and non punctuation.\n\t// but can start with > (markdown blockquote)\n\t'(^|(?![.:/\\\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' + '((?![$+<=>^`|])' + tpl_host_port_no_ip_fuzzy_strict + src_path + ')';\n\n/***/ },\n/* 317 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.4.0 by @mathias */\n\t'use strict';\n\t\n\t;(function (root) {\n\t\n\t\t/** Detect free variables */\n\t\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\t\tvar freeModule = typeof module == 'object' && module && !module.nodeType && module;\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/**\n\t  * The `punycode` object.\n\t  * @name punycode\n\t  * @type Object\n\t  */\n\t\tvar punycode,\n\t\t   \n\t\n\t\t/** Highest positive signed 32-bit float value */\n\t\tmaxInt = 2147483647,\n\t\t    // aka. 0x7FFFFFFF or 2^31-1\n\t\n\t\t/** Bootstring parameters */\n\t\tbase = 36,\n\t\t    tMin = 1,\n\t\t    tMax = 26,\n\t\t    skew = 38,\n\t\t    damp = 700,\n\t\t    initialBias = 72,\n\t\t    initialN = 128,\n\t\t    // 0x80\n\t\tdelimiter = '-',\n\t\t    // '\\x2D'\n\t\n\t\t/** Regular expressions */\n\t\tregexPunycode = /^xn--/,\n\t\t    regexNonASCII = /[^\\x20-\\x7E]/,\n\t\t    // unprintable ASCII chars + non-ASCII chars\n\t\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n\t\t    // RFC 3490 separators\n\t\n\t\t/** Error messages */\n\t\terrors = {\n\t\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t\t'invalid-input': 'Invalid input'\n\t\t},\n\t\t   \n\t\n\t\t/** Convenience shortcuts */\n\t\tbaseMinusTMin = base - tMin,\n\t\t    floor = Math.floor,\n\t\t    stringFromCharCode = String.fromCharCode,\n\t\t   \n\t\n\t\t/** Temporary variable */\n\t\tkey;\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\t/**\n\t  * A generic error utility function.\n\t  * @private\n\t  * @param {String} type The error type.\n\t  * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t  */\n\t\tfunction error(type) {\n\t\t\tthrow new RangeError(errors[type]);\n\t\t}\n\t\n\t\t/**\n\t  * A generic `Array#map` utility function.\n\t  * @private\n\t  * @param {Array} array The array to iterate over.\n\t  * @param {Function} callback The function that gets called for every array\n\t  * item.\n\t  * @returns {Array} A new array of values returned by the callback function.\n\t  */\n\t\tfunction map(array, fn) {\n\t\t\tvar length = array.length;\n\t\t\tvar result = [];\n\t\t\twhile (length--) {\n\t\t\t\tresult[length] = fn(array[length]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t  * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t  * addresses.\n\t  * @private\n\t  * @param {String} domain The domain name or email address.\n\t  * @param {Function} callback The function that gets called for every\n\t  * character.\n\t  * @returns {Array} A new string of characters returned by the callback\n\t  * function.\n\t  */\n\t\tfunction mapDomain(string, fn) {\n\t\t\tvar parts = string.split('@');\n\t\t\tvar result = '';\n\t\t\tif (parts.length > 1) {\n\t\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\t\tresult = parts[0] + '@';\n\t\t\t\tstring = parts[1];\n\t\t\t}\n\t\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\t\tvar labels = string.split('.');\n\t\t\tvar encoded = map(labels, fn).join('.');\n\t\t\treturn result + encoded;\n\t\t}\n\t\n\t\t/**\n\t  * Creates an array containing the numeric code points of each Unicode\n\t  * character in the string. While JavaScript uses UCS-2 internally,\n\t  * this function will convert a pair of surrogate halves (each of which\n\t  * UCS-2 exposes as separate characters) into a single code point,\n\t  * matching UTF-16.\n\t  * @see `punycode.ucs2.encode`\n\t  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t  * @memberOf punycode.ucs2\n\t  * @name decode\n\t  * @param {String} string The Unicode input string (UCS-2).\n\t  * @returns {Array} The new array of code points.\n\t  */\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [],\n\t\t\t    counter = 0,\n\t\t\t    length = string.length,\n\t\t\t    value,\n\t\t\t    extra;\n\t\t\twhile (counter < length) {\n\t\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t\t// low surrogate\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t/**\n\t  * Creates a string based on an array of numeric code points.\n\t  * @see `punycode.ucs2.decode`\n\t  * @memberOf punycode.ucs2\n\t  * @name encode\n\t  * @param {Array} codePoints The array of numeric code points.\n\t  * @returns {String} The new Unicode string (UCS-2).\n\t  */\n\t\tfunction ucs2encode(array) {\n\t\t\treturn map(array, function (value) {\n\t\t\t\tvar output = '';\n\t\t\t\tif (value > 0xFFFF) {\n\t\t\t\t\tvalue -= 0x10000;\n\t\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t\t}\n\t\t\t\toutput += stringFromCharCode(value);\n\t\t\t\treturn output;\n\t\t\t}).join('');\n\t\t}\n\t\n\t\t/**\n\t  * Converts a basic code point into a digit/integer.\n\t  * @see `digitToBasic()`\n\t  * @private\n\t  * @param {Number} codePoint The basic numeric code point value.\n\t  * @returns {Number} The numeric value of a basic code point (for use in\n\t  * representing integers) in the range `0` to `base - 1`, or `base` if\n\t  * the code point does not represent a value.\n\t  */\n\t\tfunction basicToDigit(codePoint) {\n\t\t\tif (codePoint - 48 < 10) {\n\t\t\t\treturn codePoint - 22;\n\t\t\t}\n\t\t\tif (codePoint - 65 < 26) {\n\t\t\t\treturn codePoint - 65;\n\t\t\t}\n\t\t\tif (codePoint - 97 < 26) {\n\t\t\t\treturn codePoint - 97;\n\t\t\t}\n\t\t\treturn base;\n\t\t}\n\t\n\t\t/**\n\t  * Converts a digit/integer into a basic code point.\n\t  * @see `basicToDigit()`\n\t  * @private\n\t  * @param {Number} digit The numeric value of a basic code point.\n\t  * @returns {Number} The basic code point whose value (when used for\n\t  * representing integers) is `digit`, which needs to be in the range\n\t  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t  * used; else, the lowercase form is used. The behavior is undefined\n\t  * if `flag` is non-zero and `digit` has no uppercase form.\n\t  */\n\t\tfunction digitToBasic(digit, flag) {\n\t\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t\t// 26..35 map to ASCII 0..9\n\t\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t\t}\n\t\n\t\t/**\n\t  * Bias adaptation function as per section 3.4 of RFC 3492.\n\t  * https://tools.ietf.org/html/rfc3492#section-3.4\n\t  * @private\n\t  */\n\t\tfunction adapt(delta, numPoints, firstTime) {\n\t\t\tvar k = 0;\n\t\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\t\tdelta += floor(delta / numPoints);\n\t\t\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t\t}\n\t\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t\t}\n\t\n\t\t/**\n\t  * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t  * symbols.\n\t  * @memberOf punycode\n\t  * @param {String} input The Punycode string of ASCII-only symbols.\n\t  * @returns {String} The resulting string of Unicode symbols.\n\t  */\n\t\tfunction decode(input) {\n\t\t\t// Don't use UCS-2\n\t\t\tvar output = [],\n\t\t\t    inputLength = input.length,\n\t\t\t    out,\n\t\t\t    i = 0,\n\t\t\t    n = initialN,\n\t\t\t    bias = initialBias,\n\t\t\t    basic,\n\t\t\t    j,\n\t\t\t    index,\n\t\t\t    oldi,\n\t\t\t    w,\n\t\t\t    k,\n\t\t\t    digit,\n\t\t\t    t,\n\t\t\t   \n\t\t\t/** Cached calculation results */\n\t\t\tbaseMinusT;\n\t\n\t\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t\t// the first basic code points to the output.\n\t\n\t\t\tbasic = input.lastIndexOf(delimiter);\n\t\t\tif (basic < 0) {\n\t\t\t\tbasic = 0;\n\t\t\t}\n\t\n\t\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t\t// if it's not a basic code point\n\t\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\t\terror('not-basic');\n\t\t\t\t}\n\t\t\t\toutput.push(input.charCodeAt(j));\n\t\t\t}\n\t\n\t\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t\t// points were copied; start at the beginning otherwise.\n\t\n\t\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\t\n\t\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t\t// value at the end to obtain `delta`.\n\t\t\t\tfor (oldi = i, w = 1, k = base;; /* no condition */k += base) {\n\t\n\t\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\t\terror('invalid-input');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\t\n\t\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\ti += digit * w;\n\t\t\t\t\tt = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\n\t\t\t\t\tif (digit < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tw *= baseMinusT;\n\t\t\t\t}\n\t\n\t\t\t\tout = output.length + 1;\n\t\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\t\n\t\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\t\n\t\t\t\tn += floor(i / out);\n\t\t\t\ti %= out;\n\t\n\t\t\t\t// Insert `n` at position `i` of the output\n\t\t\t\toutput.splice(i++, 0, n);\n\t\t\t}\n\t\n\t\t\treturn ucs2encode(output);\n\t\t}\n\t\n\t\t/**\n\t  * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t  * Punycode string of ASCII-only symbols.\n\t  * @memberOf punycode\n\t  * @param {String} input The string of Unicode symbols.\n\t  * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t  */\n\t\tfunction encode(input) {\n\t\t\tvar n,\n\t\t\t    delta,\n\t\t\t    handledCPCount,\n\t\t\t    basicLength,\n\t\t\t    bias,\n\t\t\t    j,\n\t\t\t    m,\n\t\t\t    q,\n\t\t\t    k,\n\t\t\t    t,\n\t\t\t    currentValue,\n\t\t\t    output = [],\n\t\t\t   \n\t\t\t/** `inputLength` will hold the number of code points in `input`. */\n\t\t\tinputLength,\n\t\t\t   \n\t\t\t/** Cached calculation results */\n\t\t\thandledCPCountPlusOne,\n\t\t\t    baseMinusT,\n\t\t\t    qMinusT;\n\t\n\t\t\t// Convert the input in UCS-2 to Unicode\n\t\t\tinput = ucs2decode(input);\n\t\n\t\t\t// Cache the length\n\t\t\tinputLength = input.length;\n\t\n\t\t\t// Initialize the state\n\t\t\tn = initialN;\n\t\t\tdelta = 0;\n\t\t\tbias = initialBias;\n\t\n\t\t\t// Handle the basic code points\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue < 0x80) {\n\t\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\thandledCPCount = basicLength = output.length;\n\t\n\t\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t\t// `basicLength` is the number of basic code points.\n\t\n\t\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\t\tif (basicLength) {\n\t\t\t\toutput.push(delimiter);\n\t\t\t}\n\t\n\t\t\t// Main encoding loop:\n\t\t\twhile (handledCPCount < inputLength) {\n\t\n\t\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t\t// larger one:\n\t\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\t\tcurrentValue = input[j];\n\t\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\t\tm = currentValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t\t// but guard against overflow\n\t\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\t\n\t\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\t\tn = m;\n\t\n\t\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\t\tcurrentValue = input[j];\n\t\n\t\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\t\tfor (q = delta, k = base;; /* no condition */k += base) {\n\t\t\t\t\t\t\tt = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\t\tdelta = 0;\n\t\t\t\t\t\t++handledCPCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t++delta;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\treturn output.join('');\n\t\t}\n\t\n\t\t/**\n\t  * Converts a Punycode string representing a domain name or an email address\n\t  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t  * it doesn't matter if you call it on a string that has already been\n\t  * converted to Unicode.\n\t  * @memberOf punycode\n\t  * @param {String} input The Punycoded domain name or email address to\n\t  * convert to Unicode.\n\t  * @returns {String} The Unicode representation of the given Punycode\n\t  * string.\n\t  */\n\t\tfunction toUnicode(input) {\n\t\t\treturn mapDomain(input, function (string) {\n\t\t\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * Converts a Unicode string representing a domain name or an email address to\n\t  * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t  * i.e. it doesn't matter if you call it with a domain that's already in\n\t  * ASCII.\n\t  * @memberOf punycode\n\t  * @param {String} input The domain name or email address to convert, as a\n\t  * Unicode string.\n\t  * @returns {String} The Punycode representation of the given domain name or\n\t  * email address.\n\t  */\n\t\tfunction toASCII(input) {\n\t\t\treturn mapDomain(input, function (string) {\n\t\t\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t\t\t});\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\t/** Define the public API */\n\t\tpunycode = {\n\t\t\t/**\n\t   * A string representing the current Punycode.js version number.\n\t   * @memberOf punycode\n\t   * @type String\n\t   */\n\t\t\t'version': '1.3.2',\n\t\t\t/**\n\t   * An object of methods to convert from JavaScript's internal character\n\t   * representation (UCS-2) to Unicode code points, and back.\n\t   * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t   * @memberOf punycode\n\t   * @type Object\n\t   */\n\t\t\t'ucs2': {\n\t\t\t\t'decode': ucs2decode,\n\t\t\t\t'encode': ucs2encode\n\t\t\t},\n\t\t\t'decode': decode,\n\t\t\t'encode': encode,\n\t\t\t'toASCII': toASCII,\n\t\t\t'toUnicode': toUnicode\n\t\t};\n\t\n\t\t/** Expose `punycode` */\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (true) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\t\treturn punycode;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else if (freeExports && freeModule) {\n\t\t\tif (module.exports == freeExports) {\n\t\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = punycode;\n\t\t\t} else {\n\t\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\t\tfor (key in punycode) {\n\t\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// in Rhino or a web browser\n\t\t\troot.punycode = punycode;\n\t\t}\n\t})(undefined);\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(211)(module), (function() { return this; }())))\n\n/***/ },\n/* 318 */\n/***/ function(module, exports) {\n\n\t// markdown-it default options\n\t\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  options: {\n\t    html: false, // Enable HTML tags in source\n\t    xhtmlOut: false, // Use '/' to close single tags (<br />)\n\t    breaks: false, // Convert '\\n' in paragraphs into <br>\n\t    langPrefix: 'language-', // CSS language prefix for fenced blocks\n\t    linkify: false, // autoconvert URL-like texts to links\n\t\n\t    // Enable some language-neutral replacements + quotes beautification\n\t    typographer: false,\n\t\n\t    // Double + single quotes replacement pairs, when typographer enabled,\n\t    // and smartquotes on. Could be either a String or an Array.\n\t    //\n\t    // For example, you can use '' for Russian, '' for German,\n\t    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n\t    quotes: '', /*  */\n\t\n\t    // Highlighter function. Should return escaped HTML,\n\t    // or '' if the source string is not changed and should be escaped externaly.\n\t    // If result starts with <pre... internal wrapper is skipped.\n\t    //\n\t    // function (/*str, lang*/) { return ''; }\n\t    //\n\t    highlight: null,\n\t\n\t    maxNesting: 100 // Internal protection, recursion limit\n\t  },\n\t\n\t  components: {\n\t\n\t    core: {},\n\t    block: {},\n\t    inline: {}\n\t  }\n\t};\n\n/***/ },\n/* 319 */\n/***/ function(module, exports) {\n\n\t// \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\n\t// modes. For example, to parse bold/italic only.\n\t\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  options: {\n\t    html: false, // Enable HTML tags in source\n\t    xhtmlOut: false, // Use '/' to close single tags (<br />)\n\t    breaks: false, // Convert '\\n' in paragraphs into <br>\n\t    langPrefix: 'language-', // CSS language prefix for fenced blocks\n\t    linkify: false, // autoconvert URL-like texts to links\n\t\n\t    // Enable some language-neutral replacements + quotes beautification\n\t    typographer: false,\n\t\n\t    // Double + single quotes replacement pairs, when typographer enabled,\n\t    // and smartquotes on. Could be either a String or an Array.\n\t    //\n\t    // For example, you can use '' for Russian, '' for German,\n\t    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n\t    quotes: '', /*  */\n\t\n\t    // Highlighter function. Should return escaped HTML,\n\t    // or '' if the source string is not changed and should be escaped externaly.\n\t    // If result starts with <pre... internal wrapper is skipped.\n\t    //\n\t    // function (/*str, lang*/) { return ''; }\n\t    //\n\t    highlight: null,\n\t\n\t    maxNesting: 20 // Internal protection, recursion limit\n\t  },\n\t\n\t  components: {\n\t\n\t    core: {\n\t      rules: ['normalize', 'block', 'inline']\n\t    },\n\t\n\t    block: {\n\t      rules: ['paragraph']\n\t    },\n\t\n\t    inline: {\n\t      rules: ['text'],\n\t      rules2: ['balance_pairs', 'text_collapse']\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 320 */\n/***/ function(module, exports) {\n\n\t// Commonmark default options\n\t\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  options: {\n\t    html: true, // Enable HTML tags in source\n\t    xhtmlOut: true, // Use '/' to close single tags (<br />)\n\t    breaks: false, // Convert '\\n' in paragraphs into <br>\n\t    langPrefix: 'language-', // CSS language prefix for fenced blocks\n\t    linkify: false, // autoconvert URL-like texts to links\n\t\n\t    // Enable some language-neutral replacements + quotes beautification\n\t    typographer: false,\n\t\n\t    // Double + single quotes replacement pairs, when typographer enabled,\n\t    // and smartquotes on. Could be either a String or an Array.\n\t    //\n\t    // For example, you can use '' for Russian, '' for German,\n\t    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n\t    quotes: '', /*  */\n\t\n\t    // Highlighter function. Should return escaped HTML,\n\t    // or '' if the source string is not changed and should be escaped externaly.\n\t    // If result starts with <pre... internal wrapper is skipped.\n\t    //\n\t    // function (/*str, lang*/) { return ''; }\n\t    //\n\t    highlight: null,\n\t\n\t    maxNesting: 20 // Internal protection, recursion limit\n\t  },\n\t\n\t  components: {\n\t\n\t    core: {\n\t      rules: ['normalize', 'block', 'inline']\n\t    },\n\t\n\t    block: {\n\t      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']\n\t    },\n\t\n\t    inline: {\n\t      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],\n\t      rules2: ['balance_pairs', 'emphasis', 'text_collapse']\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 321 */,\n/* 322 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Adds `key:Ctrl+B` support to code_inline\n\t * @param md\n\t */\n\t\n\tmodule.exports = function (md) {\n\t\n\t  md.renderer.rules.code_inline = function (tokens, idx, options, env, slf) {\n\t\n\t    var token = tokens[idx];\n\t    var content = token.content.trim();\n\t\n\t    if (content.indexOf('key:') == 0) {\n\t      return renderKey(content.slice(4));\n\t    } else {\n\t      var codePrefixes = ['pattern', 'match', 'subject'];\n\t      for (var i = 0; i < codePrefixes.length; i++) {\n\t        var prefix = codePrefixes[i];\n\t        if (content.startsWith(prefix + ':')) {\n\t          return '<code class=\"' + prefix + '\">' + md.utils.escapeHtml(content.slice(prefix.length + 1)) + '</code>';\n\t        }\n\t      }\n\t    }\n\t\n\t    return '<code>' + md.utils.escapeHtml(content) + '</code>';\n\t  };\n\t\n\t  function renderKey(keys) {\n\t\n\t    var results = [];\n\t\n\t    if (keys === '+') {\n\t      return '<kbd class=\"shortcut\">+</kbd>';\n\t    }\n\t\n\t    var plusLabel = Math.random();\n\t    keys = keys.replace(/\\+\\+/g, '+' + plusLabel);\n\t    keys = keys.split('+');\n\t\n\t    for (var i = 0; i < keys.length; i++) {\n\t      var key = keys[i];\n\t      results.push(key == plusLabel ? '+' : md.utils.escapeHtml(key));\n\t      if (i < keys.length - 1) {\n\t        results.push('<span class=\"shortcut__plus\">+</span>');\n\t      }\n\t    }\n\t\n\t    return '<kbd class=\"shortcut\">' + results.join('') + '</kbd>';\n\t  }\n\t};\n\n/***/ },\n/* 323 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Client/server plugin\n\t */\n\t\n\tvar markdownItContainer = __webpack_require__(324);\n\tvar parseAttrs = __webpack_require__(325);\n\tvar t = __webpack_require__(326);\n\t\n\tvar LANG = __webpack_require__(252).lang;\n\t\n\tt.requirePhrase('markit.outlined', __webpack_require__(331)(\"./\" + LANG + '.yml'));\n\t\n\tmodule.exports = function (md) {\n\t\n\t  ['warn', 'smart', 'ponder'].forEach(function (name) {\n\t    md.use(markdownItContainer, name, {\n\t      marker: '`',\n\t      render: function render(tokens, idx, options, env, slf) {\n\t\n\t        if (tokens[idx].nesting === 1) {\n\t          var attrs = parseAttrs(tokens[idx].info, true);\n\t          var header = attrs.header;\n\t          if (header) {\n\t            //header = header.replace(/`(.*?)`/g, '<code>$1</code>');\n\t            header = md.renderInline(header);\n\t          } else {\n\t            header = t('markit.outlined.' + name);\n\t          }\n\t          return '<div class=\"important important_' + name + '\">\\n            <div class=\"important__header\"><span class=\"important__type\">' + header + '</span></div>\\n            <div class=\"important__content\">';\n\t        } else {\n\t          // closing tag\n\t          return '</div></div>\\n';\n\t        }\n\t      }\n\t    });\n\t  });\n\t};\n\n/***/ },\n/* 324 */\n/***/ function(module, exports) {\n\n\t// Process block-level custom containers\n\t//\n\t'use strict';\n\t\n\tmodule.exports = function container_plugin(md, name, options) {\n\t\n\t  function validateDefault(params) {\n\t    return params.trim().split(' ', 2)[0] === name;\n\t  }\n\t\n\t  function renderDefault(tokens, idx, _options, env, self) {\n\t\n\t    // add a class to the opening tag\n\t    if (tokens[idx].nesting === 1) {\n\t      tokens[idx].attrPush(['class', name]);\n\t    }\n\t\n\t    return self.renderToken(tokens, idx, _options, env, self);\n\t  }\n\t\n\t  options = options || {};\n\t\n\t  var min_markers = 3,\n\t      marker_str = options.marker || ':',\n\t      marker_char = marker_str.charCodeAt(0),\n\t      marker_len = marker_str.length,\n\t      validate = options.validate || validateDefault,\n\t      render = options.render || renderDefault;\n\t\n\t  function container(state, startLine, endLine, silent) {\n\t    var pos,\n\t        nextLine,\n\t        marker_count,\n\t        markup,\n\t        params,\n\t        token,\n\t        old_parent,\n\t        old_line_max,\n\t        auto_closed = false,\n\t        start = state.bMarks[startLine] + state.tShift[startLine],\n\t        max = state.eMarks[startLine];\n\t\n\t    // Check out the first character quickly,\n\t    // this should filter out most of non-containers\n\t    //\n\t    if (marker_char !== state.src.charCodeAt(start)) {\n\t      return false;\n\t    }\n\t\n\t    // Check out the rest of the marker string\n\t    //\n\t    for (pos = start + 1; pos <= max; pos++) {\n\t      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    marker_count = Math.floor((pos - start) / marker_len);\n\t    if (marker_count < min_markers) {\n\t      return false;\n\t    }\n\t    pos -= (pos - start) % marker_len;\n\t\n\t    markup = state.src.slice(start, pos);\n\t    params = state.src.slice(pos, max);\n\t    if (!validate(params)) {\n\t      return false;\n\t    }\n\t\n\t    // Since start is found, we can report success here in validation mode\n\t    //\n\t    if (silent) {\n\t      return true;\n\t    }\n\t\n\t    // Search for the end of the block\n\t    //\n\t    nextLine = startLine;\n\t\n\t    for (;;) {\n\t      nextLine++;\n\t      if (nextLine >= endLine) {\n\t        // unclosed block should be autoclosed by end of document.\n\t        // also block seems to be autoclosed by end of parent\n\t        break;\n\t      }\n\t\n\t      start = state.bMarks[nextLine] + state.tShift[nextLine];\n\t      max = state.eMarks[nextLine];\n\t\n\t      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n\t        // non-empty line with negative indent should stop the list:\n\t        // - ```\n\t        //  test\n\t        break;\n\t      }\n\t\n\t      if (marker_char !== state.src.charCodeAt(start)) {\n\t        continue;\n\t      }\n\t\n\t      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n\t        // closing fence should be indented less than 4 spaces\n\t        continue;\n\t      }\n\t\n\t      for (pos = start + 1; pos <= max; pos++) {\n\t        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      // closing code fence must be at least as long as the opening one\n\t      if (Math.floor((pos - start) / marker_len) < marker_count) {\n\t        continue;\n\t      }\n\t\n\t      // make sure tail has spaces only\n\t      pos -= (pos - start) % marker_len;\n\t      pos = state.skipSpaces(pos);\n\t\n\t      if (pos < max) {\n\t        continue;\n\t      }\n\t\n\t      // found!\n\t      auto_closed = true;\n\t      break;\n\t    }\n\t\n\t    old_parent = state.parentType;\n\t    old_line_max = state.lineMax;\n\t    state.parentType = 'container';\n\t\n\t    // this will prevent lazy continuations from ever going past our end marker\n\t    state.lineMax = nextLine;\n\t\n\t    token = state.push('container_' + name + '_open', 'div', 1);\n\t    token.markup = markup;\n\t    token.block = true;\n\t    token.info = params;\n\t    token.map = [startLine, nextLine];\n\t\n\t    state.md.block.tokenize(state, startLine + 1, nextLine);\n\t\n\t    token = state.push('container_' + name + '_close', 'div', -1);\n\t    token.markup = state.src.slice(start, pos);\n\t    token.block = true;\n\t\n\t    state.parentType = old_parent;\n\t    state.lineMax = old_line_max;\n\t    state.line = nextLine + (auto_closed ? 1 : 0);\n\t\n\t    return true;\n\t  }\n\t\n\t  md.block.ruler.before('fence', 'container_' + name, container, {\n\t    alt: ['paragraph', 'reference', 'blockquote', 'list']\n\t  });\n\t  md.renderer.rules['container_' + name + '_open'] = render;\n\t  md.renderer.rules['container_' + name + '_close'] = render;\n\t};\n\n/***/ },\n/* 325 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// 'my=5 test=3 bla=\"my \"test\"'  -> my=5 test=3 bla=\"my \"  (test is not matched)\n\tvar attrsReg = /([\\w-]+)(?:=(?:'((?:\\\\'|[^'])*)'|\"((?:\\\\\"|[^\"])*)\"|(\\S+))|(?:\\s|$))/g;\n\t\n\tmodule.exports = function (attrs, withBlockName) {\n\t  var attrsObject = {};\n\t\n\t  if (!attrs) {\n\t    return attrsObject;\n\t  }\n\t\n\t  var blockName = undefined;\n\t  if (withBlockName) {\n\t    blockName = attrs.match(/^\\w+/);\n\t    blockName = blockName && blockName[0];\n\t    attrs = attrs.replace(/^\\w+\\s+/, '');\n\t  }\n\t\n\t  var match = undefined,\n\t      name = undefined,\n\t      value = undefined;\n\t  while ((match = attrsReg.exec(attrs)) !== null) {\n\t    name = match[1];\n\t    value = match[2] !== undefined ? match[2].replace(/\\\\'/g, \"'\") : match[3] !== undefined ? match[3].replace(/\\\\\"/g, '\"') : match[4];\n\t\n\t    attrsObject[name.toLowerCase()] = value === undefined ? true : value;\n\t  }\n\t\n\t  if (blockName) {\n\t    attrsObject.blockName = blockName;\n\t  }\n\t\n\t  return attrsObject;\n\t};\n\n/***/ },\n/* 326 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar BabelFish = __webpack_require__(327);\n\t\n\tvar i18n = new BabelFish('en');\n\t\n\tvar LANG = __webpack_require__(252).lang;\n\t\n\tfunction t() {\n\t  var args = [LANG];\n\t  for (var i = 0; i < arguments.length; i++) {\n\t    args.push(arguments[i]);\n\t  }\n\t  return i18n.t.apply(i18n, args);\n\t}\n\t\n\tvar docs = {};\n\t\n\tt.i18n = i18n;\n\t\n\tt.requirePhrase = function (packageName, doc) {\n\t  // if same phrase with same doc was processed - don't redo it\n\t  if (docs[packageName] && docs[packageName].indexOf(doc) != -1) return;\n\t\n\t  if (!docs[packageName]) docs[packageName] = [];\n\t  docs[packageName].push(doc);\n\t\n\t  i18n.addPhrase(LANG, packageName, doc);\n\t};\n\t\n\tmodule.exports = t;\n\n/***/ },\n/* 327 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(328);\n\n/***/ },\n/* 328 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  class BabelFish\n\t *\n\t *  Internalization and localization library that makes i18n and l10n fun again.\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  var BabelFish = require('babelfish'),\n\t *      i18n = new BabelFish();\n\t *  ```\n\t *\n\t *  or\n\t *\n\t *  ```javascript\n\t *  var babelfish = require('babelfish'),\n\t *      i18n = babelfish();\n\t *  ```\n\t **/\n\t\n\t'use strict';\n\t\n\tvar parser = __webpack_require__(329);\n\tvar plural = __webpack_require__(330);\n\t\n\tfunction _class(obj) {\n\t  return Object.prototype.toString.call(obj);\n\t}\n\t\n\tfunction isString(obj) {\n\t  return _class(obj) === '[object String]';\n\t}\n\tfunction isNumber(obj) {\n\t  return !isNaN(obj) && isFinite(obj);\n\t}\n\tfunction isBoolean(obj) {\n\t  return obj === true || obj === false;\n\t}\n\tfunction isFunction(obj) {\n\t  return _class(obj) === '[object Function]';\n\t}\n\tfunction isObject(obj) {\n\t  return _class(obj) === '[object Object]';\n\t}\n\t\n\t/*istanbul ignore next*/\n\tvar isArray = Array.isArray || function _isArray(obj) {\n\t  return _class(obj) === '[object Array]';\n\t};\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t// The following two utilities (forEach and extend) are modified from Underscore\n\t//\n\t// http://underscorejs.org\n\t//\n\t// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n\t//\n\t// Underscore may be freely distributed under the MIT license\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar nativeForEach = Array.prototype.forEach;\n\t\n\t// The cornerstone, an `each` implementation, aka `forEach`.\n\t// Handles objects with the built-in `forEach`, arrays, and raw objects.\n\t// Delegates to **ECMAScript 5**'s native `forEach` if available.\n\t/*istanbul ignore next*/\n\tfunction forEach(obj, iterator, context) {\n\t  if (obj === null) {\n\t    return;\n\t  }\n\t  if (nativeForEach && obj.forEach === nativeForEach) {\n\t    obj.forEach(iterator, context);\n\t  } else if (obj.length === +obj.length) {\n\t    for (var i = 0, l = obj.length; i < l; i += 1) {\n\t      iterator.call(context, obj[i], i, obj);\n\t    }\n\t  } else {\n\t    for (var key in obj) {\n\t      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t        iterator.call(context, obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar formatRegExp = /%[sdj%]/g;\n\t\n\t/*istanbul ignore next*/\n\tfunction format(f) {\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function (x) {\n\t    if (x === '%%') {\n\t      return '%';\n\t    }\n\t    if (i >= len) {\n\t      return x;\n\t    }\n\t    switch (x) {\n\t      case '%s':\n\t        return String(args[i++]);\n\t      case '%d':\n\t        return Number(args[i++]);\n\t      case '%j':\n\t        return JSON.stringify(args[i++]);\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  return str;\n\t}\n\t\n\t// helpers\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t// Last resort locale, that exists for sure\n\tvar GENERIC_LOCALE = 'en';\n\t\n\t// flatten(obj) -> Object\n\t//\n\t// Flattens object into one-level dictionary.\n\t//\n\t// ##### Example\n\t//\n\t//     var obj = {\n\t//       abc: { def: 'foo' },\n\t//       hij: 'bar'\n\t//     };\n\t//\n\t//     flatten(obj);\n\t//     // -> { 'abc.def': 'foo', 'hij': 'bar' };\n\t//\n\tfunction flatten(obj) {\n\t  var params = {};\n\t\n\t  forEach(obj || {}, function (val, key) {\n\t    if (val && typeof val === 'object') {\n\t      forEach(flatten(val), function (sub_val, sub_key) {\n\t        params[key + '.' + sub_key] = sub_val;\n\t      });\n\t      return;\n\t    }\n\t\n\t    params[key] = val;\n\t  });\n\t\n\t  return params;\n\t}\n\t\n\tvar keySeparator = '#@$';\n\t\n\tfunction makePhraseKey(locale, phrase) {\n\t  return locale + keySeparator + phrase;\n\t}\n\t\n\tfunction searchPhraseKey(self, locale, phrase) {\n\t  var key = makePhraseKey(locale, phrase);\n\t  var storage = self._storage;\n\t\n\t  // direct search first\n\t  if (storage.hasOwnProperty(key)) {\n\t    return key;\n\t  }\n\t\n\t  // don't try follbacks for default locale\n\t  if (locale === self._defaultLocale) {\n\t    return null;\n\t  }\n\t\n\t  // search via fallback map cache\n\t  var fb_cache = self._fallbacks_cache;\n\t  if (fb_cache.hasOwnProperty(key)) {\n\t    return fb_cache[key];\n\t  }\n\t\n\t  // scan fallbacks & cache result\n\t  var fb = self._fallbacks[locale] || [self._defaultLocale];\n\t  var fb_key;\n\t\n\t  for (var i = 0, l = fb.length; i < l; i++) {\n\t    fb_key = makePhraseKey(fb[i], phrase);\n\t    if (storage.hasOwnProperty(fb_key)) {\n\t      // found - update cache and return result\n\t      fb_cache[key] = fb_key;\n\t      return fb_cache[key];\n\t    }\n\t  }\n\t\n\t  // mark fb_cache entry empty for fast lookup on next request\n\t  fb_cache[key] = null;\n\t  return null;\n\t}\n\t\n\tfunction pluralizer(lang, val, forms) {\n\t  var idx = plural.indexOf(lang, val);\n\t\n\t  if (idx === -1) {\n\t    return format('[pluralizer for \"%s\" locale not found]', lang);\n\t  }\n\t\n\t  if (typeof forms[idx] === 'undefined') {\n\t    return format('[plural form %d (\"%s\") not found in translation]', idx, plural.forms(lang)[idx]);\n\t  }\n\t\n\t  return forms[idx];\n\t}\n\t\n\t// public api (module)\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t/**\n\t *  new BabelFish([defaultLocale = 'en'])\n\t *\n\t *  Initiates new instance of BabelFish.\n\t *\n\t *  __Note!__ you can omit `new` for convenience, direct call will return\n\t * new instance too.\n\t **/\n\tfunction BabelFish(defaultLocale) {\n\t  if (!(this instanceof BabelFish)) {\n\t    return new BabelFish(defaultLocale);\n\t  }\n\t\n\t  this._defaultLocale = defaultLocale ? String(defaultLocale) : GENERIC_LOCALE;\n\t\n\t  // hash of locale => [ fallback1, fallback2, ... ] pairs\n\t  this._fallbacks = {};\n\t\n\t  // fallback cache for each phrase\n\t  //\n\t  // {\n\t  //   locale_key: fallback_key\n\t  // }\n\t  //\n\t  // fallback_key can be null if search failed\n\t  //\n\t  this._fallbacks_cache = {};\n\t\n\t  // storage of compiled translations\n\t  //\n\t  // {\n\t  //   locale + @#$ + phrase_key: {\n\t  //     locale:      locale name - can be different for fallbacks\n\t  //     translation: original translation phrase or data variable/object\n\t  //     raw:         true/false - does translation contain plain data or\n\t  //                  string to compile\n\t  //     compiled:    copiled translation fn or plain string\n\t  //   }\n\t  //   ...\n\t  // }\n\t  //\n\t  this._storage = {};\n\t\n\t  // cache for complex plural parts (with params)\n\t  //\n\t  // {\n\t  //   language: new BabelFish(language)\n\t  // }\n\t  //\n\t  this._plurals_cache = {};\n\t}\n\t\n\t// public api (instance)\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\t/**\n\t *  BabelFish#addPhrase(locale, phrase, translation [, flattenLevel]) -> BabelFish\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String|Null): Phrase ID, e.g. `apps.forum`\n\t *  - translation (String|Object|Array|Number|Boolean): Translation or an object\n\t *    with nested phrases, or a pure object.\n\t *  - flattenLevel (Number|Boolean): Optional, 0..infinity. `Infinity` by default.\n\t *    Define \"flatten\" deepness for loaded object.  You can also use\n\t *    `true` as `0` or `false` as `Infinity`.\n\t *\n\t *\n\t *  ##### Flatten & using JS objects\n\t *\n\t *  By default all nested properties are normalized to strings like \"foo.bar.baz\",\n\t *  and if value is string, it will be compiled with babelfish notation.\n\t *  If deepness is above `flattenLevel` OR value is not object and not string,\n\t *  it will be used \"as is\". Note, only JSON stringifiable data should be used.\n\t *\n\t *  In short: you can safely pass `Array`, `Number` or `Boolean`. For objects you\n\t *  should define flatten level or disable it compleetely, to work with pure data.\n\t *\n\t *  Pure objects can be useful to prepare bulk data for external libraries, like\n\t *  calendars, time/date generators and so on.\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  i18n.addPhrase('ru-RU',\n\t *    'apps.forums.replies_count',\n\t *    '#{count} %{||}:count  ');\n\t *\n\t *  // equals to:\n\t *  i18n.addPhrase('ru-RU',\n\t *    'apps.forums',\n\t *    { replies_count: '#{count} %{||}:count  ' });\n\t *  ```\n\t **/\n\tBabelFish.prototype.addPhrase = function _addPhrase(locale, phrase, translation, flattenLevel) {\n\t  var self = this,\n\t      fl;\n\t\n\t  // Calculate flatten level. Infinity by default\n\t  if (isBoolean(flattenLevel)) {\n\t    fl = flattenLevel ? Infinity : 0;\n\t  } else if (isNumber(flattenLevel)) {\n\t    fl = Math.floor(flattenLevel);\n\t    if (fl < 0) {\n\t      throw new TypeError('Invalid flatten level (should be >= 0).');\n\t    }\n\t  } else {\n\t    fl = Infinity;\n\t  }\n\t\n\t  if (isObject(translation) && fl > 0) {\n\t    // recursive object walk, until flattenLevel allows\n\t    forEach(translation, function (val, key) {\n\t      self.addPhrase(locale, (phrase ? phrase + '.' : '') + key, val, fl - 1);\n\t    });\n\t    return this;\n\t  }\n\t\n\t  if (isString(translation)) {\n\t    this._storage[makePhraseKey(locale, phrase)] = {\n\t      translation: translation,\n\t      locale: locale,\n\t      raw: false\n\t    };\n\t  } else if (isArray(translation) || isNumber(translation) || isBoolean(translation) || fl === 0 && isObject(translation)) {\n\t    // Pure objects are stored without compilation\n\t    // Limit allowed types.\n\t    this._storage[makePhraseKey(locale, phrase)] = {\n\t      translation: translation,\n\t      locale: locale,\n\t      raw: true\n\t    };\n\t  } else {\n\t    // `Regex`, `Date`, `Uint8Array` and others types will\n\t    //  fuckup `stringify()`. Don't allow here.\n\t    // `undefined` also means wrong param in real life.\n\t    // `null` can be allowed when examples from real life available.\n\t    throw new TypeError('Invalid translation - [String|Object|Array|Number|Boolean] expected.');\n\t  }\n\t\n\t  self._fallbacks_cache = {};\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t *  BabelFish#setFallback(locale, fallbacks) -> BabelFish\n\t *  - locale (String): Target locale\n\t *  - fallbacks (Array): List of fallback locales\n\t *\n\t *  Set fallbacks for given locale.\n\t *\n\t *  When `locale` has no translation for the phrase, `fallbacks[0]` will be\n\t *  tried, if translation still not found, then `fallbacks[1]` will be tried\n\t *  and so on. If none of fallbacks have translation,\n\t *  default locale will be tried as last resort.\n\t *\n\t *  ##### Errors\n\t *\n\t *  - throws `Error`, when `locale` equals default locale\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  i18n.setFallback('ua-UK', ['ua', 'ru']);\n\t *  ```\n\t **/\n\tBabelFish.prototype.setFallback = function _setFallback(locale, fallbacks) {\n\t  var def = this._defaultLocale;\n\t\n\t  if (def === locale) {\n\t    throw new Error(\"Default locale can't have fallbacks\");\n\t  }\n\t\n\t  var fb = isArray(fallbacks) ? fallbacks.slice() : [fallbacks];\n\t  if (fb[fb.length - 1] !== def) {\n\t    fb.push(def);\n\t  }\n\t\n\t  this._fallbacks[locale] = fb;\n\t  this._fallbacks_cache = {};\n\t\n\t  return this;\n\t};\n\t\n\tvar CAN_HAVE_DIRECTIVES_RE = /#\\{|\\(\\(|\\\\\\\\/;\n\t\n\t// Compiles given string into function. Used to compile phrases,\n\t// which contains `plurals`, `variables`, etc.\n\tfunction compile(self, str, locale) {\n\t  var nodes, buf, key, strict_exec, forms_exec, plurals_cache;\n\t\n\t  // Quick check to avoid parse in most cases :)\n\t  if (!CAN_HAVE_DIRECTIVES_RE.test(str)) {\n\t    return str;\n\t  }\n\t\n\t  nodes = parser.parse(str);\n\t\n\t  if (nodes.length === 1 && nodes[0].type === 'literal') {\n\t    return nodes[0].text;\n\t  }\n\t\n\t  // init cache instance for plural parts, if not exists yet.\n\t  if (!self._plurals_cache[locale]) {\n\t    self._plurals_cache[locale] = new BabelFish(locale);\n\t  }\n\t  plurals_cache = self._plurals_cache[locale];\n\t\n\t  buf = [];\n\t  buf.push(['var str = \"\", strict, strict_exec, forms, forms_exec, plrl, cache, loc, loc_plzr, anchor;']);\n\t  buf.push('params = flatten(params);');\n\t\n\t  forEach(nodes, function (node) {\n\t    if (node.type === 'literal') {\n\t      buf.push(format('str += %j;', node.text));\n\t      return;\n\t    }\n\t\n\t    if (node.type === 'variable') {\n\t      key = node.anchor;\n\t      buf.push(format('str += (\"undefined\" === typeof (params[%j])) ? \"[missed variable: %s]\" : params[%j];', key, key, key));\n\t      return;\n\t    }\n\t\n\t    // should never happen\n\t    /*istanbul ignore next*/\n\t    if (node.type !== 'plural') {\n\t      throw new Error('Unknown node type');\n\t    }\n\t\n\t    //\n\t    // Compile plural\n\t    //\n\t\n\t    key = node.anchor;\n\t    // check if plural parts are plain strings or executable,\n\t    // and add executable to \"cache\" instance of babelfish\n\t    // plural part text will be used as translation key\n\t    strict_exec = {};\n\t    forEach(node.strict, function (text, k) {\n\t      var parsed = parser.parse(text);\n\t      if (parsed.length === 1 && parsed[0].type === 'literal') {\n\t        strict_exec[k] = false;\n\t        // patch with unescaped value for direct extract\n\t        node.strict[k] = parsed[0].text;\n\t        return;\n\t      }\n\t\n\t      strict_exec[k] = true;\n\t      if (!plurals_cache.hasPhrase(locale, text, true)) {\n\t        plurals_cache.addPhrase(locale, text, text);\n\t      }\n\t    });\n\t\n\t    forms_exec = {};\n\t    forEach(node.forms, function (text, idx) {\n\t      var parsed = parser.parse(text),\n\t          unescaped;\n\t      if (parsed.length === 1 && parsed[0].type === 'literal') {\n\t        // patch with unescaped value for direct extract\n\t        unescaped = parsed[0].text;\n\t        node.forms[idx] = unescaped;\n\t        forms_exec[unescaped] = false;\n\t        return;\n\t      }\n\t\n\t      forms_exec[text] = true;\n\t      if (!plurals_cache.hasPhrase(locale, text, true)) {\n\t        plurals_cache.addPhrase(locale, text, text);\n\t      }\n\t    });\n\t    /*eslint-disable space-in-parens*/\n\t    buf.push(format('loc = %j;', locale));\n\t    buf.push(format('loc_plzr = %j;', locale.split(/[-_]/)[0]));\n\t    buf.push(format('anchor = params[%j];', key));\n\t    buf.push(format('cache = this._plurals_cache[loc];'));\n\t    buf.push(format('strict = %j;', node.strict));\n\t    buf.push(format('strict_exec = %j;', strict_exec));\n\t    buf.push(format('forms = %j;', node.forms));\n\t    buf.push(format('forms_exec = %j;', forms_exec));\n\t    buf.push('if (+(anchor) != anchor) {');\n\t    buf.push(format('  str += \"[invalid plurals amount: %s(\" + anchor + \")]\";', key));\n\t    buf.push('} else {');\n\t    buf.push('  if (strict[anchor] !== undefined) {');\n\t    buf.push('    plrl = strict[anchor];');\n\t    buf.push('    str += strict_exec[anchor] ? cache.t(loc, plrl, params) : plrl;');\n\t    buf.push('  } else {');\n\t    buf.push('    plrl = pluralizer(loc_plzr, +anchor, forms);');\n\t    buf.push('    str += forms_exec[plrl] ? cache.t(loc, plrl, params) : plrl;');\n\t    buf.push('  }');\n\t    buf.push('}');\n\t    return;\n\t  });\n\t\n\t  buf.push('return str;');\n\t\n\t  /*eslint-disable no-new-func*/\n\t  return new Function('params', 'flatten', 'pluralizer', buf.join('\\n'));\n\t}\n\t\n\t/**\n\t *  BabelFish#translate(locale, phrase[, params]) -> String\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n\t *  - params (Object|Number|String): Params for translation. `Number` & `String`\n\t *    will be  coerced to `{ count: X, value: X }`\n\t *\n\t *  ##### Example\n\t *\n\t *  ```javascript\n\t *  i18n.addPhrase('ru-RU',\n\t *     'apps.forums.replies_count',\n\t *     '#{count} ((||))  ');\n\t *\n\t *  // ...\n\t *\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 1 });\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', 1});\n\t *  // -> '1 '\n\t *\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 2 });\n\t *  i18n.translate('ru-RU', 'app.forums.replies_count', 2);\n\t *  // -> '2 a'\n\t *  ```\n\t **/\n\tBabelFish.prototype.translate = function _translate(locale, phrase, params) {\n\t  var key = searchPhraseKey(this, locale, phrase);\n\t  var data;\n\t\n\t  if (!key) {\n\t    return locale + ': No translation for [' + phrase + ']';\n\t  }\n\t\n\t  data = this._storage[key];\n\t\n\t  // simple string or other pure object\n\t  if (data.raw) {\n\t    return data.translation;\n\t  }\n\t\n\t  // compile data if not done yet\n\t  if (!data.hasOwnProperty('compiled')) {\n\t    // We should use locale from phrase, because of possible fallback,\n\t    // to keep plural locales in sync.\n\t    data.compiled = compile(this, data.translation, data.locale);\n\t  }\n\t\n\t  // return simple string immediately\n\t  if (!isFunction(data.compiled)) {\n\t    return data.compiled;\n\t  }\n\t\n\t  //\n\t  // Generate \"complex\" phrase\n\t  //\n\t\n\t  // Sugar: coerce numbers & strings to { count: X, value: X }\n\t  if (isNumber(params) || isString(params)) {\n\t    params = { count: params, value: params };\n\t  }\n\t\n\t  return data.compiled.call(this, params, flatten, pluralizer);\n\t};\n\t\n\t/**\n\t *  BabelFish#hasPhrase(locale, phrase) -> Boolean\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n\t *  - noFallback (Boolean): Disable search in fallbacks\n\t *\n\t *  Returns whenever or not there's a translation of a `phrase`.\n\t **/\n\tBabelFish.prototype.hasPhrase = function _hasPhrase(locale, phrase, noFallback) {\n\t  return noFallback ? this._storage.hasOwnProperty(makePhraseKey(locale, phrase)) : searchPhraseKey(this, locale, phrase) ? true : false;\n\t};\n\t\n\t/**\n\t *  BabelFish#getLocale(locale, phrase) -> String|null\n\t *  - locale (String): Locale of translation\n\t *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n\t *  - noFallback (Boolean): Disable search in fallbacks\n\t *\n\t *  Similar to [[BabelFish#hasPhrase]], but returns real locale of requested\n\t *  phrase, or `null` if nothing found. Can be useful for dynamic dependencies\n\t *  init. For example, when you fetch i10n config as single object and create\n\t *  phrases from it's content.\n\t **/\n\tBabelFish.prototype.getLocale = function _getLocale(locale, phrase, noFallback) {\n\t  if (noFallback) {\n\t    return this._storage.hasOwnProperty(makePhraseKey(locale, phrase)) ? locale : null;\n\t  }\n\t\n\t  var key = searchPhraseKey(this, locale, phrase);\n\t\n\t  return key ? key.split(keySeparator, 2)[0] : null;\n\t};\n\t\n\t/** alias of: BabelFish#translate\n\t *  BabelFish#t(locale, phrase[, params]) -> String\n\t **/\n\tBabelFish.prototype.t = BabelFish.prototype.translate;\n\t\n\t/**\n\t *  BabelFish#stringify(locale) -> String\n\t *  - locale (String): Locale of translation\n\t *\n\t *  Returns serialized locale data, uncluding fallbacks.\n\t *  It can be loaded back via `load()` method.\n\t **/\n\tBabelFish.prototype.stringify = function _stringify(locale) {\n\t  var self = this;\n\t\n\t  // Collect unique keys\n\t  var unique = {};\n\t\n\t  forEach(this._storage, function (val, key) {\n\t    unique[key.split(keySeparator)[1]] = true;\n\t  });\n\t\n\t  // Collect phrases (with fallbacks)\n\t  var result = {};\n\t\n\t  forEach(unique, function (val, key) {\n\t    var k = searchPhraseKey(self, locale, key);\n\t    // if key was just a garbage from another\n\t    // and doesn't fit into fallback chain for current locale - skip it\n\t    if (!k) {\n\t      return;\n\t    }\n\t    // create namespace if not exists\n\t    var l = self._storage[k].locale;\n\t    if (!result[l]) {\n\t      result[l] = {};\n\t    }\n\t    result[l][key] = self._storage[k].translation;\n\t  });\n\t\n\t  var out = {\n\t    fallback: {},\n\t    locales: result\n\t  };\n\t\n\t  // Get fallback rule. Cut auto-added fallback to default locale\n\t  var fallback = (self._fallbacks[locale] || []).slice(0, -1);\n\t  if (fallback.length) {\n\t    out.fallback[locale] = fallback;\n\t  }\n\t\n\t  return JSON.stringify(out);\n\t};\n\t\n\t/**\n\t *  BabelFish#load(data) -> BabelFish\n\t *  - data (Object|String): data from `stringify()` method, as object or string.\n\t *\n\t *  Batch load phrases data, prepared with `stringify()` method.\n\t *  Useful at browser side.\n\t **/\n\tBabelFish.prototype.load = function _load(data) {\n\t  var self = this;\n\t\n\t  if (isString(data)) {\n\t    data = JSON.parse(data);\n\t  }\n\t\n\t  forEach(data.locales, function (phrases, locale) {\n\t    forEach(phrases, function (translation, key) {\n\t      self.addPhrase(locale, key, translation, 0);\n\t    });\n\t  });\n\t\n\t  forEach(data.fallback, function (rule, locale) {\n\t    self.setFallback(locale, rule);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t// export module\n\tmodule.exports = BabelFish;\n\n/***/ },\n/* 329 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = (function () {\n\t  /*\n\t   * Generated by PEG.js 0.8.0.\n\t   *\n\t   * http://pegjs.majda.cz/\n\t   */\n\t\n\t  function peg$subclass(child, parent) {\n\t    function ctor() {\n\t      this.constructor = child;\n\t    }\n\t    ctor.prototype = parent.prototype;\n\t    child.prototype = new ctor();\n\t  }\n\t\n\t  function SyntaxError(message, expected, found, offset, line, column) {\n\t    this.message = message;\n\t    this.expected = expected;\n\t    this.found = found;\n\t    this.offset = offset;\n\t    this.line = line;\n\t    this.column = column;\n\t\n\t    this.name = \"SyntaxError\";\n\t  }\n\t\n\t  peg$subclass(SyntaxError, Error);\n\t\n\t  function parse(input) {\n\t    var options = arguments.length > 1 ? arguments[1] : {},\n\t        peg$FAILED = {},\n\t        peg$startRuleFunctions = { start: peg$parsestart },\n\t        peg$startRuleFunction = peg$parsestart,\n\t        peg$c0 = [],\n\t        peg$c1 = peg$FAILED,\n\t        peg$c2 = \"((\",\n\t        peg$c3 = { type: \"literal\", value: \"((\", description: \"\\\"((\\\"\" },\n\t        peg$c4 = \"))\",\n\t        peg$c5 = { type: \"literal\", value: \"))\", description: \"\\\"))\\\"\" },\n\t        peg$c6 = null,\n\t        peg$c7 = function peg$c7(forms, anchor) {\n\t      return {\n\t        type: 'plural',\n\t        forms: regularForms(forms),\n\t        strict: strictForms(forms),\n\t        anchor: anchor || 'count'\n\t      };\n\t    },\n\t        peg$c8 = \"|\",\n\t        peg$c9 = { type: \"literal\", value: \"|\", description: \"\\\"|\\\"\" },\n\t        peg$c10 = function peg$c10(part, more) {\n\t      return [part].concat(more);\n\t    },\n\t        peg$c11 = function peg$c11(part) {\n\t      return [part];\n\t    },\n\t        peg$c12 = \"=\",\n\t        peg$c13 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n\t        peg$c14 = /^[0-9]/,\n\t        peg$c15 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n\t        peg$c16 = \" \",\n\t        peg$c17 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n\t        peg$c18 = function peg$c18(strict, form) {\n\t      return {\n\t        strict: strict.join(''),\n\t        text: form.join('')\n\t      };\n\t    },\n\t        peg$c19 = function peg$c19() {\n\t      return {\n\t        text: text()\n\t      };\n\t    },\n\t        peg$c20 = \"\\\\\",\n\t        peg$c21 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n\t        peg$c22 = /^[\\\\|)(]/,\n\t        peg$c23 = { type: \"class\", value: \"[\\\\\\\\|)(]\", description: \"[\\\\\\\\|)(]\" },\n\t        peg$c24 = function peg$c24(char) {\n\t      return char;\n\t    },\n\t        peg$c25 = void 0,\n\t        peg$c26 = { type: \"any\", description: \"any character\" },\n\t        peg$c27 = function peg$c27() {\n\t      return text();\n\t    },\n\t        peg$c28 = \":\",\n\t        peg$c29 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n\t        peg$c30 = function peg$c30(name) {\n\t      return name;\n\t    },\n\t        peg$c31 = \"#{\",\n\t        peg$c32 = { type: \"literal\", value: \"#{\", description: \"\\\"#{\\\"\" },\n\t        peg$c33 = \"}\",\n\t        peg$c34 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n\t        peg$c35 = function peg$c35(anchor) {\n\t      return {\n\t        type: 'variable',\n\t        anchor: anchor\n\t      };\n\t    },\n\t        peg$c36 = \".\",\n\t        peg$c37 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n\t        peg$c38 = function peg$c38() {\n\t      return text();\n\t    },\n\t        peg$c39 = /^[a-zA-Z_$]/,\n\t        peg$c40 = { type: \"class\", value: \"[a-zA-Z_$]\", description: \"[a-zA-Z_$]\" },\n\t        peg$c41 = /^[a-zA-Z0-9_$]/,\n\t        peg$c42 = { type: \"class\", value: \"[a-zA-Z0-9_$]\", description: \"[a-zA-Z0-9_$]\" },\n\t        peg$c43 = function peg$c43(lc) {\n\t      return lc;\n\t    },\n\t        peg$c44 = function peg$c44(literal_chars) {\n\t      return {\n\t        type: 'literal',\n\t        text: literal_chars.join('')\n\t      };\n\t    },\n\t        peg$c45 = /^[\\\\#()|]/,\n\t        peg$c46 = { type: \"class\", value: \"[\\\\\\\\#()|]\", description: \"[\\\\\\\\#()|]\" },\n\t        peg$currPos = 0,\n\t        peg$reportedPos = 0,\n\t        peg$cachedPos = 0,\n\t        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n\t        peg$maxFailPos = 0,\n\t        peg$maxFailExpected = [],\n\t        peg$silentFails = 0,\n\t        peg$result;\n\t\n\t    if (\"startRule\" in options) {\n\t      if (!(options.startRule in peg$startRuleFunctions)) {\n\t        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n\t      }\n\t\n\t      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n\t    }\n\t\n\t    function text() {\n\t      return input.substring(peg$reportedPos, peg$currPos);\n\t    }\n\t\n\t    function offset() {\n\t      return peg$reportedPos;\n\t    }\n\t\n\t    function line() {\n\t      return peg$computePosDetails(peg$reportedPos).line;\n\t    }\n\t\n\t    function column() {\n\t      return peg$computePosDetails(peg$reportedPos).column;\n\t    }\n\t\n\t    function expected(description) {\n\t      throw peg$buildException(null, [{ type: \"other\", description: description }], peg$reportedPos);\n\t    }\n\t\n\t    function error(message) {\n\t      throw peg$buildException(message, null, peg$reportedPos);\n\t    }\n\t\n\t    function peg$computePosDetails(pos) {\n\t      function advance(details, startPos, endPos) {\n\t        var p, ch;\n\t\n\t        for (p = startPos; p < endPos; p++) {\n\t          ch = input.charAt(p);\n\t          if (ch === \"\\n\") {\n\t            if (!details.seenCR) {\n\t              details.line++;\n\t            }\n\t            details.column = 1;\n\t            details.seenCR = false;\n\t          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n\t            details.line++;\n\t            details.column = 1;\n\t            details.seenCR = true;\n\t          } else {\n\t            details.column++;\n\t            details.seenCR = false;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (peg$cachedPos !== pos) {\n\t        if (peg$cachedPos > pos) {\n\t          peg$cachedPos = 0;\n\t          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n\t        }\n\t        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n\t        peg$cachedPos = pos;\n\t      }\n\t\n\t      return peg$cachedPosDetails;\n\t    }\n\t\n\t    function peg$fail(expected) {\n\t      if (peg$currPos < peg$maxFailPos) {\n\t        return;\n\t      }\n\t\n\t      if (peg$currPos > peg$maxFailPos) {\n\t        peg$maxFailPos = peg$currPos;\n\t        peg$maxFailExpected = [];\n\t      }\n\t\n\t      peg$maxFailExpected.push(expected);\n\t    }\n\t\n\t    function peg$buildException(message, expected, pos) {\n\t      function cleanupExpected(expected) {\n\t        var i = 1;\n\t\n\t        expected.sort(function (a, b) {\n\t          if (a.description < b.description) {\n\t            return -1;\n\t          } else if (a.description > b.description) {\n\t            return 1;\n\t          } else {\n\t            return 0;\n\t          }\n\t        });\n\t\n\t        while (i < expected.length) {\n\t          if (expected[i - 1] === expected[i]) {\n\t            expected.splice(i, 1);\n\t          } else {\n\t            i++;\n\t          }\n\t        }\n\t      }\n\t\n\t      function buildMessage(expected, found) {\n\t        function stringEscape(s) {\n\t          function hex(ch) {\n\t            return ch.charCodeAt(0).toString(16).toUpperCase();\n\t          }\n\t\n\t          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch) {\n\t            return '\\\\x0' + hex(ch);\n\t          }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch) {\n\t            return '\\\\x' + hex(ch);\n\t          }).replace(/[\\u0180-\\u0FFF]/g, function (ch) {\n\t            return \"\\\\u0\" + hex(ch);\n\t          }).replace(/[\\u1080-\\uFFFF]/g, function (ch) {\n\t            return \"\\\\u\" + hex(ch);\n\t          });\n\t        }\n\t\n\t        var expectedDescs = new Array(expected.length),\n\t            expectedDesc,\n\t            foundDesc,\n\t            i;\n\t\n\t        for (i = 0; i < expected.length; i++) {\n\t          expectedDescs[i] = expected[i].description;\n\t        }\n\t\n\t        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(\", \") + \" or \" + expectedDescs[expected.length - 1] : expectedDescs[0];\n\t\n\t        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\t\n\t        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n\t      }\n\t\n\t      var posDetails = peg$computePosDetails(pos),\n\t          found = pos < input.length ? input.charAt(pos) : null;\n\t\n\t      if (expected !== null) {\n\t        cleanupExpected(expected);\n\t      }\n\t\n\t      return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);\n\t    }\n\t\n\t    function peg$parsestart() {\n\t      var s0, s1;\n\t\n\t      s0 = [];\n\t      s1 = peg$parseliteral();\n\t      if (s1 === peg$FAILED) {\n\t        s1 = peg$parseplural();\n\t        if (s1 === peg$FAILED) {\n\t          s1 = peg$parsevariable();\n\t        }\n\t      }\n\t      while (s1 !== peg$FAILED) {\n\t        s0.push(s1);\n\t        s1 = peg$parseliteral();\n\t        if (s1 === peg$FAILED) {\n\t          s1 = peg$parseplural();\n\t          if (s1 === peg$FAILED) {\n\t            s1 = peg$parsevariable();\n\t          }\n\t        }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural() {\n\t      var s0, s1, s2, s3, s4;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.substr(peg$currPos, 2) === peg$c2) {\n\t        s1 = peg$c2;\n\t        peg$currPos += 2;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c3);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = peg$parseplural_forms();\n\t        if (s2 !== peg$FAILED) {\n\t          if (input.substr(peg$currPos, 2) === peg$c4) {\n\t            s3 = peg$c4;\n\t            peg$currPos += 2;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c5);\n\t            }\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            s4 = peg$parseplural_anchor();\n\t            if (s4 === peg$FAILED) {\n\t              s4 = peg$c6;\n\t            }\n\t            if (s4 !== peg$FAILED) {\n\t              peg$reportedPos = s0;\n\t              s1 = peg$c7(s2, s4);\n\t              s0 = s1;\n\t            } else {\n\t              peg$currPos = s0;\n\t              s0 = peg$c1;\n\t            }\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_forms() {\n\t      var s0, s1, s2, s3;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = peg$parseplural_part();\n\t      if (s1 !== peg$FAILED) {\n\t        if (input.charCodeAt(peg$currPos) === 124) {\n\t          s2 = peg$c8;\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c9);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          s3 = peg$parseplural_forms();\n\t          if (s3 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c10(s1, s3);\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$currPos;\n\t        s1 = peg$parseplural_part();\n\t        if (s1 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c11(s1);\n\t        }\n\t        s0 = s1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_part() {\n\t      var s0, s1, s2, s3, s4, s5;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 61) {\n\t        s1 = peg$c12;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c13);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = [];\n\t        if (peg$c14.test(input.charAt(peg$currPos))) {\n\t          s3 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s3 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c15);\n\t          }\n\t        }\n\t        if (s3 !== peg$FAILED) {\n\t          while (s3 !== peg$FAILED) {\n\t            s2.push(s3);\n\t            if (peg$c14.test(input.charAt(peg$currPos))) {\n\t              s3 = input.charAt(peg$currPos);\n\t              peg$currPos++;\n\t            } else {\n\t              s3 = peg$FAILED;\n\t              if (peg$silentFails === 0) {\n\t                peg$fail(peg$c15);\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          s2 = peg$c1;\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          if (input.charCodeAt(peg$currPos) === 32) {\n\t            s3 = peg$c16;\n\t            peg$currPos++;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c17);\n\t            }\n\t          }\n\t          if (s3 === peg$FAILED) {\n\t            s3 = peg$c6;\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            s4 = [];\n\t            s5 = peg$parseplural_char();\n\t            if (s5 !== peg$FAILED) {\n\t              while (s5 !== peg$FAILED) {\n\t                s4.push(s5);\n\t                s5 = peg$parseplural_char();\n\t              }\n\t            } else {\n\t              s4 = peg$c1;\n\t            }\n\t            if (s4 !== peg$FAILED) {\n\t              peg$reportedPos = s0;\n\t              s1 = peg$c18(s2, s4);\n\t              s0 = s1;\n\t            } else {\n\t              peg$currPos = s0;\n\t              s0 = peg$c1;\n\t            }\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$currPos;\n\t        s1 = [];\n\t        s2 = peg$parseplural_char();\n\t        if (s2 !== peg$FAILED) {\n\t          while (s2 !== peg$FAILED) {\n\t            s1.push(s2);\n\t            s2 = peg$parseplural_char();\n\t          }\n\t        } else {\n\t          s1 = peg$c1;\n\t        }\n\t        if (s1 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c19();\n\t        }\n\t        s0 = s1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_char() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 92) {\n\t        s1 = peg$c20;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c21);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        if (peg$c22.test(input.charAt(peg$currPos))) {\n\t          s2 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c23);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c24(s2);\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$currPos;\n\t        s1 = peg$currPos;\n\t        peg$silentFails++;\n\t        if (input.charCodeAt(peg$currPos) === 124) {\n\t          s2 = peg$c8;\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c9);\n\t          }\n\t        }\n\t        if (s2 === peg$FAILED) {\n\t          if (input.substr(peg$currPos, 2) === peg$c4) {\n\t            s2 = peg$c4;\n\t            peg$currPos += 2;\n\t          } else {\n\t            s2 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c5);\n\t            }\n\t          }\n\t        }\n\t        peg$silentFails--;\n\t        if (s2 === peg$FAILED) {\n\t          s1 = peg$c25;\n\t        } else {\n\t          peg$currPos = s1;\n\t          s1 = peg$c1;\n\t        }\n\t        if (s1 !== peg$FAILED) {\n\t          if (input.length > peg$currPos) {\n\t            s2 = input.charAt(peg$currPos);\n\t            peg$currPos++;\n\t          } else {\n\t            s2 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c26);\n\t            }\n\t          }\n\t          if (s2 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c27();\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseplural_anchor() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 58) {\n\t        s1 = peg$c28;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c29);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = peg$parseidentifier();\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c30(s2);\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parsevariable() {\n\t      var s0, s1, s2, s3;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.substr(peg$currPos, 2) === peg$c31) {\n\t        s1 = peg$c31;\n\t        peg$currPos += 2;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c32);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = peg$parseidentifier();\n\t        if (s2 !== peg$FAILED) {\n\t          if (input.charCodeAt(peg$currPos) === 125) {\n\t            s3 = peg$c33;\n\t            peg$currPos++;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c34);\n\t            }\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c35(s2);\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseidentifier() {\n\t      var s0, s1, s2, s3, s4;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = peg$parseidentifier_part();\n\t      if (s1 !== peg$FAILED) {\n\t        if (input.charCodeAt(peg$currPos) === 46) {\n\t          s2 = peg$c36;\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c37);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          s3 = [];\n\t          s4 = peg$parseidentifier();\n\t          if (s4 !== peg$FAILED) {\n\t            while (s4 !== peg$FAILED) {\n\t              s3.push(s4);\n\t              s4 = peg$parseidentifier();\n\t            }\n\t          } else {\n\t            s3 = peg$c1;\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            peg$reportedPos = s0;\n\t            s1 = peg$c38();\n\t            s0 = s1;\n\t          } else {\n\t            peg$currPos = s0;\n\t            s0 = peg$c1;\n\t          }\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        s0 = peg$parseidentifier_part();\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseidentifier_part() {\n\t      var s0, s1, s2, s3;\n\t\n\t      s0 = peg$currPos;\n\t      if (peg$c39.test(input.charAt(peg$currPos))) {\n\t        s1 = input.charAt(peg$currPos);\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c40);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        s2 = [];\n\t        if (peg$c41.test(input.charAt(peg$currPos))) {\n\t          s3 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s3 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c42);\n\t          }\n\t        }\n\t        while (s3 !== peg$FAILED) {\n\t          s2.push(s3);\n\t          if (peg$c41.test(input.charAt(peg$currPos))) {\n\t            s3 = input.charAt(peg$currPos);\n\t            peg$currPos++;\n\t          } else {\n\t            s3 = peg$FAILED;\n\t            if (peg$silentFails === 0) {\n\t              peg$fail(peg$c42);\n\t            }\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c27();\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseliteral() {\n\t      var s0, s1, s2, s3, s4;\n\t\n\t      s0 = peg$currPos;\n\t      s1 = [];\n\t      s2 = peg$currPos;\n\t      s3 = peg$currPos;\n\t      peg$silentFails++;\n\t      s4 = peg$parseplural();\n\t      if (s4 === peg$FAILED) {\n\t        s4 = peg$parsevariable();\n\t      }\n\t      peg$silentFails--;\n\t      if (s4 === peg$FAILED) {\n\t        s3 = peg$c25;\n\t      } else {\n\t        peg$currPos = s3;\n\t        s3 = peg$c1;\n\t      }\n\t      if (s3 !== peg$FAILED) {\n\t        s4 = peg$parseliteral_char();\n\t        if (s4 !== peg$FAILED) {\n\t          peg$reportedPos = s2;\n\t          s3 = peg$c43(s4);\n\t          s2 = s3;\n\t        } else {\n\t          peg$currPos = s2;\n\t          s2 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s2;\n\t        s2 = peg$c1;\n\t      }\n\t      if (s2 !== peg$FAILED) {\n\t        while (s2 !== peg$FAILED) {\n\t          s1.push(s2);\n\t          s2 = peg$currPos;\n\t          s3 = peg$currPos;\n\t          peg$silentFails++;\n\t          s4 = peg$parseplural();\n\t          if (s4 === peg$FAILED) {\n\t            s4 = peg$parsevariable();\n\t          }\n\t          peg$silentFails--;\n\t          if (s4 === peg$FAILED) {\n\t            s3 = peg$c25;\n\t          } else {\n\t            peg$currPos = s3;\n\t            s3 = peg$c1;\n\t          }\n\t          if (s3 !== peg$FAILED) {\n\t            s4 = peg$parseliteral_char();\n\t            if (s4 !== peg$FAILED) {\n\t              peg$reportedPos = s2;\n\t              s3 = peg$c43(s4);\n\t              s2 = s3;\n\t            } else {\n\t              peg$currPos = s2;\n\t              s2 = peg$c1;\n\t            }\n\t          } else {\n\t            peg$currPos = s2;\n\t            s2 = peg$c1;\n\t          }\n\t        }\n\t      } else {\n\t        s1 = peg$c1;\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        peg$reportedPos = s0;\n\t        s1 = peg$c44(s1);\n\t      }\n\t      s0 = s1;\n\t\n\t      return s0;\n\t    }\n\t\n\t    function peg$parseliteral_char() {\n\t      var s0, s1, s2;\n\t\n\t      s0 = peg$currPos;\n\t      if (input.charCodeAt(peg$currPos) === 92) {\n\t        s1 = peg$c20;\n\t        peg$currPos++;\n\t      } else {\n\t        s1 = peg$FAILED;\n\t        if (peg$silentFails === 0) {\n\t          peg$fail(peg$c21);\n\t        }\n\t      }\n\t      if (s1 !== peg$FAILED) {\n\t        if (peg$c45.test(input.charAt(peg$currPos))) {\n\t          s2 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s2 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c46);\n\t          }\n\t        }\n\t        if (s2 !== peg$FAILED) {\n\t          peg$reportedPos = s0;\n\t          s1 = peg$c24(s2);\n\t          s0 = s1;\n\t        } else {\n\t          peg$currPos = s0;\n\t          s0 = peg$c1;\n\t        }\n\t      } else {\n\t        peg$currPos = s0;\n\t        s0 = peg$c1;\n\t      }\n\t      if (s0 === peg$FAILED) {\n\t        if (input.length > peg$currPos) {\n\t          s0 = input.charAt(peg$currPos);\n\t          peg$currPos++;\n\t        } else {\n\t          s0 = peg$FAILED;\n\t          if (peg$silentFails === 0) {\n\t            peg$fail(peg$c26);\n\t          }\n\t        }\n\t      }\n\t\n\t      return s0;\n\t    }\n\t\n\t    function regularForms(forms) {\n\t      var result = [];\n\t      for (var i = 0; i < forms.length; i++) {\n\t        if (forms[i].strict === undefined) {\n\t          result.push(forms[i].text);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t    function strictForms(forms) {\n\t      var result = {};\n\t      for (var i = 0; i < forms.length; i++) {\n\t        if (forms[i].strict !== undefined) {\n\t          result[forms[i].strict] = forms[i].text;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    peg$result = peg$startRuleFunction();\n\t\n\t    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n\t      return peg$result;\n\t    } else {\n\t      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n\t        peg$fail({ type: \"end\", description: \"end of input\" });\n\t      }\n\t\n\t      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n\t    }\n\t  }\n\t\n\t  return {\n\t    SyntaxError: SyntaxError,\n\t    parse: parse\n\t  };\n\t})();\n\n/***/ },\n/* 330 */\n/***/ function(module, exports) {\n\n\t/*\n\t * Plural functions support (cardinal & ordinal forms)\n\t *\n\t * Autogenerated from CLDR:\n\t *\n\t *   Version:   28\n\t *   $Revision: 12002 $\n\t */\n\t\n\t'use strict';\n\t\n\t// pluralizers cache\n\tvar s = {};\n\t\n\tfunction normalize(loc) {\n\t  var l;\n\t  if (s[loc]) {\n\t    return loc;\n\t  }\n\t  l = loc.toLowerCase().replace('_', '-');\n\t  if (s[l]) {\n\t    return l;\n\t  }\n\t  l = l.split('-')[0];\n\t  if (s[l]) {\n\t    return l;\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction forms(loc) {\n\t  var l = normalize(loc);\n\t  return s[l] ? s[l].c : null;\n\t}\n\t\n\tfunction indexOf(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!l) {\n\t    return -1;\n\t  }\n\t\n\t  if (!s[l].cFn) {\n\t    return 0;\n\t  }\n\t\n\t  var sval = String(value),\n\t      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n\t      v = f.length,\n\t      n = +value,\n\t      i = +sval.split('.')[0],\n\t      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\t\n\t  return s[l].cFn(n, i, v, +f, t);\n\t}\n\t\n\tfunction plural(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!l) {\n\t    return null;\n\t  }\n\t  return s[l].c[indexOf(l, value)];\n\t}\n\t\n\tfunction o_forms(loc) {\n\t  var l = normalize(loc);\n\t  return s[l] ? s[l].o : null;\n\t}\n\t\n\tfunction o_indexOf(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!l) {\n\t    return -1;\n\t  }\n\t\n\t  if (!s[l].oFn) {\n\t    return 0;\n\t  }\n\t\n\t  var sval = String(value),\n\t      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n\t      v = f.length,\n\t      n = +value,\n\t      i = +sval.split('.')[0],\n\t      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\t\n\t  return s[l].oFn(n, i, v, +f, t);\n\t}\n\t\n\tfunction ordinal(loc, value) {\n\t  var l = normalize(loc);\n\t  if (!s[l]) {\n\t    return null;\n\t  }\n\t  return s[l].o[o_indexOf(l, value)];\n\t}\n\t\n\tmodule.exports = plural;\n\tmodule.exports.indexOf = indexOf;\n\tmodule.exports.forms = forms;\n\tmodule.exports.ordinal = ordinal;\n\tmodule.exports.ordinal.indexOf = o_indexOf;\n\tmodule.exports.ordinal.forms = o_forms;\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar FORMS = ['zero', 'one', 'two', 'few', 'many', 'other'];\n\t\n\tfunction unpack(i) {\n\t  return FORMS[i];\n\t}\n\t\n\t// adds given `rule` pluralizer for given `locales` into `storage`\n\tfunction add(locales, rule) {\n\t  var i;\n\t\n\t  rule.c = rule.c ? rule.c.map(unpack) : ['other'];\n\t  rule.o = rule.o ? rule.o.map(unpack) : ['other'];\n\t\n\t  for (i = 0; i < locales.length; i++) {\n\t    s[locales[i]] = rule;\n\t  }\n\t}\n\t\n\tfunction B(x, y, val) {\n\t  return x <= val && val <= y && val % 1 === 0;\n\t}\n\tfunction IN(set, val) {\n\t  return set.indexOf(val) >= 0;\n\t}\n\t\n\tadd(['af', 'asa', 'bem', 'bez', 'bg', 'brx', 'ce', 'cgg', 'chr', 'ckb', 'dv', 'ee', 'el', 'eo', 'es', 'eu', 'fo', 'fur', 'gsw', 'ha', 'haw', 'jgo', 'jmc', 'kaj', 'kcg', 'kkj', 'kl', 'ks', 'ksb', 'ku', 'ky', 'lb', 'lg', 'mas', 'mgo', 'ml', 'mn', 'nah', 'nb', 'nd', 'nn', 'nnh', 'no', 'nr', 'ny', 'nyn', 'om', 'or', 'os', 'pap', 'ps', 'rm', 'rof', 'rwk', 'saq', 'sdh', 'seh', 'sn', 'so', 'ss', 'ssy', 'st', 'syr', 'ta', 'te', 'teo', 'tig', 'tk', 'tn', 'tr', 'ts', 'ug', 'uz', 've', 'vo', 'vun', 'wae', 'xh', 'xog'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ak', 'bh', 'guw', 'ln', 'mg', 'nso', 'pa', 'ti', 'wa'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return B(0, 1, n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['am', 'fa', 'kn', 'zu'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ar'], {\n\t  c: [0, 1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n100 = n % 100;\n\t    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : B(3, 10, n100) ? 3 : B(11, 99, n100) ? 4 : 5;\n\t  }\n\t});\n\t\n\tadd(['as', 'bn'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 4, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([1, 5, 7, 8, 9, 10], n) ? 0 : IN([2, 3], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['ast', 'de', 'et', 'fi', 'fy', 'gl', 'ji', 'nl', 'sw', 'ur', 'yi'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['az'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 3, 4, 5],\n\t  oFn: function oFn(n, i) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100,\n\t        i1000 = i % 1000;\n\t    return IN([1, 2, 5, 7, 8], i10) || IN([20, 50, 70, 80], i100) ? 0 : IN([3, 4], i10) || IN([100, 200, 300, 400, 500, 600, 700, 800, 900], i1000) ? 1 : i === 0 || i10 === 6 || IN([40, 60, 90], i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['be'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 1 && n100 !== 11 ? 0 : B(2, 4, n10) && !B(12, 14, n100) ? 1 : n10 === 0 || B(5, 9, n10) || B(11, 14, n100) ? 2 : 3;\n\t  },\n\t  o: [3, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return IN([2, 3], n10) && !IN([12, 13], n100) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['bm', 'bo', 'dz', 'id', 'ig', 'ii', 'in', 'ja', 'jbo', 'jv', 'jw', 'kde', 'kea', 'km', 'ko', 'lkt', 'my', 'nqo', 'root', 'sah', 'ses', 'sg', 'th', 'to', 'wo', 'yo', 'zh'], {});\n\t\n\tadd(['br'], {\n\t  c: [1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100,\n\t        n1000000 = n % 1000000;\n\t    return n10 === 1 && !IN([11, 71, 91], n100) ? 0 : n10 === 2 && !IN([12, 72, 92], n100) ? 1 : (B(3, 4, n10) || n10 === 9) && !B(10, 19, n100) && !B(70, 79, n100) && !B(90, 99, n100) ? 2 : n !== 0 && n1000000 === 0 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['bs', 'hr', 'sh', 'sr'], {\n\t  c: [1, 3, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100,\n\t        f10 = f % 10,\n\t        f100 = f % 100;\n\t    return v === 0 && i10 === 1 && i100 !== 11 || f10 === 1 && f100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) || B(2, 4, f10) && !B(12, 14, f100) ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['ca'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([1, 3], n) ? 0 : n === 2 ? 1 : n === 4 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['cs', 'sk'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : B(2, 4, i) && v === 0 ? 1 : v !== 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['cy'], {\n\t  c: [0, 1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n === 3 ? 3 : n === 6 ? 4 : 5;\n\t  },\n\t  o: [0, 1, 2, 3, 4, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([0, 7, 8, 9], n) ? 0 : n === 1 ? 1 : n === 2 ? 2 : IN([3, 4], n) ? 3 : IN([5, 6], n) ? 4 : 5;\n\t  }\n\t});\n\t\n\tadd(['da'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f, t) {\n\t    return n === 1 || t !== 0 && IN([0, 1], i) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['dsb', 'hsb'], {\n\t  c: [1, 2, 3, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i100 = i % 100,\n\t        f100 = f % 100;\n\t    return v === 0 && i100 === 1 || f100 === 1 ? 0 : v === 0 && i100 === 2 || f100 === 2 ? 1 : v === 0 && B(3, 4, i100) || B(3, 4, f100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['en'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 1 && n100 !== 11 ? 0 : n10 === 2 && n100 !== 12 ? 1 : n10 === 3 && n100 !== 13 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['ff', 'kab'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return IN([0, 1], i) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['fil', 'tl'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i10 = i % 10,\n\t        f10 = f % 10;\n\t    return v === 0 && IN([1, 2, 3], i) || v === 0 && !IN([4, 6, 9], i10) || v !== 0 && !IN([4, 6, 9], f10) ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['fr', 'hy'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return IN([0, 1], i) ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ga'], {\n\t  c: [1, 2, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : n === 2 ? 1 : B(3, 6, n) ? 2 : B(7, 10, n) ? 3 : 4;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['gd'], {\n\t  c: [1, 2, 3, 5],\n\t  cFn: function cFn(n) {\n\t    return IN([1, 11], n) ? 0 : IN([2, 12], n) ? 1 : B(3, 10, n) || B(13, 19, n) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['gu', 'hi'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 4, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : IN([2, 3], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['gv'], {\n\t  c: [1, 2, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return v === 0 && i10 === 1 ? 0 : v === 0 && i10 === 2 ? 1 : v === 0 && IN([0, 20, 40, 60, 80], i100) ? 2 : v !== 0 ? 3 : 4;\n\t  }\n\t});\n\t\n\tadd(['he', 'iw'], {\n\t  c: [1, 2, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var n10 = n % 10;\n\t    return i === 1 && v === 0 ? 0 : i === 2 && v === 0 ? 1 : v === 0 && !B(0, 10, n) && n10 === 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['hu'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([1, 5], n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['is'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f, t) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return t === 0 && i10 === 1 && i100 !== 11 || t !== 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['it'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [4, 5],\n\t  oFn: function oFn(n) {\n\t    return IN([11, 8, 80, 800], n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['iu', 'kw', 'naq', 'se', 'sma', 'smi', 'smj', 'smn', 'sms'], {\n\t  c: [1, 2, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : n === 2 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['ka'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 4, 5],\n\t  oFn: function oFn(n, i) {\n\t    var i100 = i % 100;\n\t    return i === 1 ? 0 : i === 0 || B(2, 20, i100) || i100 === 40 || i100 === 60 || i100 === 80 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['kk'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [4, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10;\n\t    return n10 === 6 || n10 === 9 || n10 === 0 && n !== 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ksh'], {\n\t  c: [0, 1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 0 ? 0 : n === 1 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['lag'], {\n\t  c: [0, 1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return n === 0 ? 0 : IN([0, 1], i) && n !== 0 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['lo', 'ms', 'vi'], {\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['lt'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 1 && !B(11, 19, n100) ? 0 : B(2, 9, n10) && !B(11, 19, n100) ? 1 : f !== 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['lv', 'prg'], {\n\t  c: [0, 1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100,\n\t        f100 = f % 100,\n\t        f10 = f % 10;\n\t    return n10 === 0 || B(11, 19, n100) || v === 2 && B(11, 19, f100) ? 0 : n10 === 1 && n100 !== 11 || v === 2 && f10 === 1 && f100 !== 11 || v !== 2 && f10 === 1 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['mk'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    var i10 = i % 10,\n\t        f10 = f % 10;\n\t    return v === 0 && i10 === 1 || f10 === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 4, 5],\n\t  oFn: function oFn(n, i) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return i10 === 1 && i100 !== 11 ? 0 : i10 === 2 && i100 !== 12 ? 1 : IN([7, 8], i10) && !IN([17, 18], i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['mo', 'ro'], {\n\t  c: [1, 3, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var n100 = n % 100;\n\t    return i === 1 && v === 0 ? 0 : v !== 0 || n === 0 || n !== 1 && B(1, 19, n100) ? 1 : 2;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['mr'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 2, 3, 5],\n\t  oFn: function oFn(n) {\n\t    return n === 1 ? 0 : IN([2, 3], n) ? 1 : n === 4 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['mt'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n) {\n\t    var n100 = n % 100;\n\t    return n === 1 ? 0 : n === 0 || B(2, 10, n100) ? 1 : B(11, 19, n100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['ne'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    return B(1, 4, n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['pl'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return i === 1 && v === 0 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i !== 1 && B(0, 1, i10) || v === 0 && B(5, 9, i10) || v === 0 && B(12, 14, i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['pt'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return B(0, 2, n) && n !== 2 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['pt-pt'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return n === 1 && v === 0 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['ru'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['shi'], {\n\t  c: [1, 3, 5],\n\t  cFn: function cFn(n, i) {\n\t    return i === 0 || n === 1 ? 0 : B(2, 10, n) ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['si'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v, f) {\n\t    return IN([0, 1], n) || i === 0 && f === 1 ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['sl'], {\n\t  c: [1, 2, 3, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i100 = i % 100;\n\t    return v === 0 && i100 === 1 ? 0 : v === 0 && i100 === 2 ? 1 : v === 0 && B(3, 4, i100) || v !== 0 ? 2 : 3;\n\t  }\n\t});\n\t\n\tadd(['sq'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return n === 1 ? 0 : 1;\n\t  },\n\t  o: [1, 4, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n === 1 ? 0 : n10 === 4 && n100 !== 14 ? 1 : 2;\n\t  }\n\t});\n\t\n\tadd(['sv'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    return i === 1 && v === 0 ? 0 : 1;\n\t  },\n\t  o: [1, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return IN([1, 2], n10) && !IN([11, 12], n100) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['tzm'], {\n\t  c: [1, 5],\n\t  cFn: function cFn(n) {\n\t    return B(0, 1, n) || B(11, 99, n) ? 0 : 1;\n\t  }\n\t});\n\t\n\tadd(['uk'], {\n\t  c: [1, 3, 4, 5],\n\t  cFn: function cFn(n, i, v) {\n\t    var i10 = i % 10,\n\t        i100 = i % 100;\n\t    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n\t  },\n\t  o: [3, 5],\n\t  oFn: function oFn(n) {\n\t    var n10 = n % 10,\n\t        n100 = n % 100;\n\t    return n10 === 3 && n100 !== 13 ? 0 : 1;\n\t  }\n\t});\n\t\n\t////////////////////////////////////////////////////////////////////////////////\n\n/***/ },\n/* 331 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./en.yml\": 332,\n\t\t\"./ru.yml\": 333\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 331;\n\n\n/***/ },\n/* 332 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"smart\": \"Please note:\",\n\t\t\"warn\": \"Important:\",\n\t\t\"ponder\": \"How do you think?\"\n\t};\n\n/***/ },\n/* 333 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"smart\": \" :\",\n\t\t\"warn\": \":\",\n\t\t\"ponder\": \"  ?\"\n\t};\n\n/***/ },\n/* 334 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Client/server plugin\n\t * Rewrites fenced blocks to blocktag_source\n\t * adds the renderer for it\n\t */\n\t\n\tvar parseAttrs = __webpack_require__(325);\n\tvar stripIndents = __webpack_require__(335);\n\tvar extractHighlight = __webpack_require__(336);\n\tvar t = __webpack_require__(326);\n\tvar getPrismLanguage = __webpack_require__(337);\n\t\n\tvar LANG = __webpack_require__(252).lang;\n\t\n\tt.requirePhrase('markit.code', __webpack_require__(345)(\"./\" + LANG + '.yml'));\n\t\n\tfunction rewriteFenceToSource(state) {\n\t\n\t  for (var idx = 0; idx < state.tokens.length; idx++) {\n\t\n\t    if (state.tokens[idx].type == 'fence') {\n\t      var attrs = parseAttrs(state.tokens[idx].info, true);\n\t\n\t      var langOrExt = attrs.blockName || '';\n\t\n\t      if (getPrismLanguage.allSupported.indexOf(langOrExt) == -1) continue;\n\t\n\t      state.tokens[idx].type = 'blocktag_source';\n\t      state.tokens[idx].blockTagAttrs = attrs;\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function (md) {\n\t\n\t  md.core.ruler.push('rewrite_fence_to_source', rewriteFenceToSource);\n\t\n\t  md.renderer.rules.blocktag_source = function (tokens, idx, options, env, slf) {\n\t    var token = tokens[idx];\n\t\n\t    var attrs = token.blockTagAttrs;\n\t\n\t    var lang = attrs.blockName;\n\t    var prismLanguage = getPrismLanguage(lang);\n\t\n\t    token.attrPush(['data-trusted', options.html && !attrs.untrusted ? 1 : 0]);\n\t\n\t    token.attrPush(['class', 'code-example']);\n\t\n\t    if (attrs['no-strict']) {\n\t      token.attrPush(['data-no-strict', 1]);\n\t    }\n\t\n\t    var height = undefined;\n\t    // demo height of\n\t    if (+attrs.height) {\n\t      height = +attrs.height;\n\t      if (!options.html) height = Math.max(height, 800);\n\t      token.attrPush(['data-demo-height', height]);\n\t    }\n\t\n\t    if (options.html && attrs.autorun) {\n\t      // autorun may have \"no-epub\" value meaning that it shouldn't run on epub (code not supported)\n\t      token.attrPush(['data-autorun', attrs.autorun]);\n\t    }\n\t\n\t    if (attrs.refresh) {\n\t      token.attrPush(['data-refresh', '1']);\n\t    }\n\t\n\t    if (options.html && attrs.demo) {\n\t      token.attrPush(['data-demo', '1']);\n\t    }\n\t\n\t    // strip first empty lines\n\t    var content = stripIndents(token.content);\n\t\n\t    var highlight = extractHighlight(content);\n\t\n\t    if (highlight.block) {\n\t      token.attrPush(['data-highlight-block', highlight.block]);\n\t    }\n\t    if (highlight.inline) {\n\t      token.attrPush(['data-highlight-inline', highlight.inline]);\n\t    }\n\t\n\t    content = highlight.text;\n\t\n\t    var toolbarHtml = '';\n\t    if (attrs.run) {\n\t      toolbarHtml = '\\n        <div class=\"toolbar codebox__toolbar\">\\n          <div class=\"toolbar__tool\">\\n            <a href=\"#\" title=\"' + t(lang == 'js' ? 'markit.code.run' : 'markit.code.show') + '\" data-action=\"run\" class=\"toolbar__button toolbar__button_run\"></a>\\n          </div>\\n          <div class=\"toolbar__tool\">\\n            <a href=\"#\" title=\"' + t('markit.code.open.sandbox') + '\" target=\"_blank\" data-action=\"edit\" class=\"toolbar__button toolbar__button_edit\"></a>\\n          </div>\\n        </div>';\n\t    }\n\t\n\t    var codeResultHtml = '';\n\t\n\t    //- iframe must be in HTML with the right height\n\t    //- otherwise page sizes will be wrong and autorun leads to resizes/jumps\n\t    if (attrs.autorun && options.html && lang == 'html') {\n\t      //- iframes with about:html are saved to disk incorrectly by FF (1 iframe content for all)\n\t      //- @see https://bugzilla.mozilla.org/show_bug.cgi?id=1154167\n\t      codeResultHtml = '<div class=\"code-result code-example__result\">\\n        <iframe\\n          class=\"code-result__iframe\"\\n          name=\"code-result-' + (Math.random() * 1e9 ^ 0).toString(36) + '\"\\n          style=\"height:' + (height || 200) + 'px\"\\n          src=\"' + (options.ebookType == 'epub' ? \"/bookify/blank.html?\" + Math.random() : 'about:blank') + '\"></iframe>\\n      </div>';\n\t    }\n\t\n\t    return '<div' + slf.renderAttrs(token) + '>\\n      <div class=\"codebox code-example__codebox\">\\n        ' + toolbarHtml + '\\n        <div class=\"codebox__code\" data-code=\"1\">\\n          <pre class=\"line-numbers language-' + prismLanguage + '\"><code class=\"language-' + prismLanguage + '\">' + md.utils.escapeHtml(content) + '</code></pre>\\n        </div>\\n      </div>\\n      ' + codeResultHtml + '\\n      </div>';\n\t  };\n\t};\n\n/***/ },\n/* 335 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction stripFirstEmptyLines(text) {\n\t  return text.replace(/^\\n+/, ''); // no 'm' flag!\n\t}\n\t// strip first empty lines\n\tfunction rtrim(text) {\n\t  return text.replace(/\\s+$/, ''); // no 'm' flag!\n\t}\n\t\n\tfunction rtrimLines(text) {\n\t  return text.replace(/[ \\t]+$/gim, '');\n\t}\n\t\n\tfunction stripSpaceIndent(text) {\n\t\n\t  if (!text) return text;\n\t\n\t  var stripPattern = /^ *(?=\\S+)/gm;\n\t\n\t  var indentLen = text.match(stripPattern).reduce(function (min, line) {\n\t    return Math.min(min, line.length);\n\t  }, Infinity);\n\t\n\t  var indent = new RegExp('^ {' + indentLen + '}', 'gm');\n\t  return indentLen > 0 ? text.replace(indent, '') : text;\n\t}\n\t\n\tfunction stripTabIndent(text) {\n\t  if (!text) return text;\n\t\n\t  var stripPattern = /^\\t*(?=\\S+)/gm;\n\t\n\t  var indentLen = text.match(stripPattern).reduce(function (min, line) {\n\t    return Math.min(min, line.length);\n\t  }, Infinity);\n\t\n\t  var indent = new RegExp('^\\t{' + indentLen + '}', 'gm');\n\t  return indentLen > 0 ? text.replace(indent, '') : text;\n\t}\n\t\n\t// same as Ruby strip_heredoc + rtrim every line + strip first lines and rtrim\n\tmodule.exports = function (text) {\n\t  text = rtrim(text);\n\t  text = rtrimLines(text);\n\t  text = stripFirstEmptyLines(text);\n\t\n\t  text = stripSpaceIndent(text);\n\t  text = stripTabIndent(text);\n\t\n\t  return text;\n\t};\n\n/***/ },\n/* 336 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction deTab(text) {\n\t  // attacklab: Detab's completely rewritten for speed.\n\t  // In perl we could fix it by anchoring the regexp with \\G.\n\t  // In javascript we're less fortunate.\n\t\n\t  // expand first n-1 tabs\n\t  text = text.replace(/\\t(?=\\t)/g, \"  \"); // attacklab: g_tab_width\n\t\n\t  // replace the nth with two sentinels\n\t  text = text.replace(/\\t/g, \"~A~B\");\n\t\n\t  // use the sentinel to anchor our regex so it doesn't explode\n\t  text = text.replace(/~B(.+?)~A/g, function (wholeMatch, m1) {\n\t    var leadingText = m1;\n\t    var numSpaces = 2 - leadingText.length % 2; // attacklab: g_tab_width\n\t\n\t    // there *must* be a better way to do this:\n\t    for (var i = 0; i < numSpaces; i++) leadingText += \" \";\n\t\n\t    return leadingText;\n\t  });\n\t\n\t  // clean up sentinels\n\t  text = text.replace(/~A/g, \"  \"); // attacklab: g_tab_width\n\t  text = text.replace(/~B/g, \"\");\n\t\n\t  return text;\n\t}\n\t\n\tmodule.exports = function (text) {\n\t  text = deTab(text);\n\t  text += \"\\n\";\n\t\n\t  var r = { block: [], inline: [] };\n\t  var last = null;\n\t  var newText = [];\n\t\n\t  text.split(\"\\n\").forEach(function (line) {\n\t    if (/^\\s*\\*!\\*\\s*$/.test(line)) {\n\t      // only *!*\n\t      if (last) {\n\t        newText.push(line);\n\t      } else {\n\t        last = newText.length;\n\t      }\n\t    } else if (/^\\s*\\*\\/!\\*\\s*$/.test(line)) {\n\t      // only */!*\n\t      if (last !== null) {\n\t        r.block.push(last + '-' + (newText.length - 1));\n\t        last = null;\n\t      } else {\n\t        newText.push(line);\n\t      }\n\t    } else if (/\\s*\\*!\\*\\s*$/.test(line)) {\n\t      // ends with *!*\n\t      r.block.push(newText.length + '-' + newText.length);\n\t      line = line.replace(/\\s*\\*!\\*\\s*$/g, '');\n\t      newText.push(line);\n\t    } else {\n\t      newText.push(\"\");\n\t      var offset = 0;\n\t      while (true) {\n\t        var fromPos = line.indexOf('*!*');\n\t        var toPos = line.indexOf('*/!*');\n\t        if (fromPos != -1 && toPos != -1) {\n\t          r.inline.push(newText.length - 1 + ':' + (offset + fromPos) + '-' + (offset + toPos - 3));\n\t          newText[newText.length - 1] += line.slice(0, toPos + 4).replace(/\\*\\/?!\\*/g, '');\n\t          offset += toPos - 3;\n\t          line = line.slice(toPos + 4);\n\t        } else {\n\t          newText[newText.length - 1] += line;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  if (last) {\n\t    r.block.push(last + '-' + (newText.length - 1));\n\t  }\n\t\n\t  return {\n\t    block: r.block.join(','),\n\t    inline: r.inline.join(','),\n\t    text: newText.join(\"\\n\").replace(/\\s+$/, '')\n\t  };\n\t};\n\n/***/ },\n/* 337 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar ext2language = {\n\t  html: 'markup',\n\t  js: 'javascript',\n\t  coffee: 'coffeescript',\n\t  '': 'none'\n\t};\n\t\n\tvar languages = 'none markup javascript css coffeescript php http java ruby scss sql'.split(' ');\n\t\n\tvar allSupported = Object.keys(ext2language).concat(languages);\n\t\n\tfunction getPrismLanguage(language) {\n\t  language = ext2language[language] || language;\n\t  if (languages.indexOf(language) == -1) language = 'none';\n\t\n\t  return language;\n\t}\n\t\n\t// all supported programming languages\n\tgetPrismLanguage.languages = languages;\n\t\n\t// all supported programming languages and extensions\n\tgetPrismLanguage.allSupported = allSupported;\n\t\n\tmodule.exports = getPrismLanguage;\n\n/***/ },\n/* 338 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Reads attrs from ![alt|height=100 width=200](...) into image token\n\t *\n\t * P.S. Plugins that work like ![...](/url =100x150) require special parser, not markdown-compatible markup\n\t */\n\t\n\tvar parseAttrs = __webpack_require__(325);\n\tvar tokenUtils = __webpack_require__(339);\n\t\n\tfunction readImgAttrs(state) {\n\t\n\t  for (var idx = 0; idx < state.tokens.length; idx++) {\n\t    var token = state.tokens[idx];\n\t\n\t    if (token.type !== 'inline') continue;\n\t\n\t    for (var i = 0; i < token.children.length; i++) {\n\t      var inlineToken = token.children[i];\n\t\n\t      if (inlineToken.type == 'image') {\n\t        processImg(inlineToken);\n\t      }\n\t    }\n\t  }\n\t\n\t  // doesn't work for ![desc *me*|height=\"*hi*\"](fig.png)\n\t  // works for ![desc *me*|height=\"hi\"](fig.png)\n\t  function processImg(imgToken) {\n\t    if (!imgToken.children.length) return; // ![](..) empty image\n\t\n\t    // last always textToken\n\t    var lastTextToken = imgToken.children[imgToken.children.length - 1];\n\t\n\t    var parts = lastTextToken.content.split('|');\n\t    if (parts.length != 2) {\n\t      // no | or many || (invalid)\n\t      // try ', ' for tables\n\t      parts = lastTextToken.content.split(', ');\n\t      if (parts.length != 2) {\n\t        // still invalid\n\t        return;\n\t      }\n\t    }\n\t\n\t    lastTextToken.content = parts[0];\n\t\n\t    var attrs = parseAttrs(parts[1]);\n\t\n\t    for (var _name in attrs) {\n\t      if (!state.md.options.html && ['height', 'width'].indexOf(_name) == -1) continue;\n\t      tokenUtils.attrReplace(imgToken, _name, attrs[_name]);\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function (md) {\n\t\n\t  md.core.ruler.push('read_img_attrs', readImgAttrs);\n\t};\n\n/***/ },\n/* 339 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * tokenAttrReplace(name, value)\n\t *\n\t * Replace all attributes with name `name` with one with the value `attrData`\n\t **/\n\tfunction attrReplace(token, name, value) {\n\t  var found;\n\t\n\t  var attrs = token.attrs;\n\t\n\t  if (attrs) {\n\t    // modify the existing attr is possible\n\t    for (var i = 0; i < attrs.length; i++) {\n\t      if (attrs[i][0] === name) {\n\t        if (!found) {\n\t          attrs[i][1] = value;\n\t          found = true;\n\t        } else {\n\t          // remove extra attrs with same name\n\t          attrs.splice(i, 1);\n\t          i--;\n\t        }\n\t      }\n\t    }\n\t\n\t    // add a new attribute with such name if none was found\n\t    if (!found) {\n\t      attrs.push([name, value]);\n\t    }\n\t  } else {\n\t    token.attrs = [[name, value]];\n\t  }\n\t}\n\t\n\tfunction addClass(token, value) {\n\t  var classAttr = attrGet(token, 'class');\n\t  if (classAttr.match(new RegExp('\\b' + value + '\\b'))) return;\n\t\n\t  if (classAttr) {\n\t    classAttr += ' ' + value;\n\t  } else {\n\t    classAttr = value;\n\t  }\n\t  attrReplace(token, 'class', classAttr);\n\t}\n\t\n\tfunction attrGet(token, name) {\n\t  var idx = token.attrIndex(name);\n\t  if (idx == -1) return null;\n\t  return token.attrs[idx][1];\n\t}\n\t\n\tfunction attrDel(token, name) {\n\t  var idx = token.attrIndex(name);\n\t  if (idx == -1) return null;\n\t  token.attrs.splice(idx, 1);\n\t}\n\t\n\texports.attrReplace = attrReplace;\n\t\n\texports.attrGet = attrGet;\n\texports.attrDel = attrDel;\n\texports.addClass = addClass;\n\n/***/ },\n/* 340 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function (md) {\n\t\n\t  md.renderer.rules.markdown_error_block = function (tokens, idx, options, env, slf) {\n\t    return '<div class=\"markdown-error\">' + md.utils.escapeHtml(tokens[idx].content) + '</div>';\n\t  };\n\t\n\t  md.renderer.rules.markdown_error_inline = function (tokens, idx, options, env, slf) {\n\t    return '<span class=\"markdown-error\">' + md.utils.escapeHtml(tokens[idx].content) + '</span>';\n\t  };\n\t};\n\n/***/ },\n/* 341 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseAttrs = __webpack_require__(325);\n\tvar getPrismLanguage = __webpack_require__(337);\n\t\n\tfunction rewriteInlineToBlockTags(state) {\n\t  for (var idx = 1; idx < state.tokens.length - 1; idx++) {\n\t    if (state.tokens[idx - 1].type == 'paragraph_open' && state.tokens[idx + 1].type == 'paragraph_close' && state.tokens[idx].type == 'inline') {\n\t\n\t      var blockTagMatch = state.tokens[idx].content.trim().match(/^\\[(\\w+\\s*[^\\]]*)\\]$/);\n\t      if (!blockTagMatch) continue;\n\t\n\t      var blockTagAttrs = parseAttrs(blockTagMatch[1], true);\n\t\n\t      var blockName = blockTagAttrs.blockName;\n\t\n\t      // if not supported\n\t      if (!state.md.options.blockTags || state.md.options.blockTags.indexOf(blockName) == -1) continue;\n\t\n\t      var tokenType = getPrismLanguage.allSupported.indexOf(blockName) == -1 ? 'blocktag_' + blockName : 'blocktag_source';\n\t\n\t      var blockTagToken = new state.Token(tokenType, blockName, state.tokens[idx].nesting);\n\t\n\t      blockTagToken.blockTagAttrs = blockTagAttrs;\n\t      blockTagToken.map = state.tokens[idx].map.slice();\n\t      blockTagToken.block = true;\n\t      blockTagToken.level = state.tokens[idx].level;\n\t\n\t      state.tokens.splice(idx - 1, 3, blockTagToken);\n\t      // no need to move idx back, because\n\t      // p ! p p ! p\n\t      // 0 1 2\n\t      //   ^ if match here, we have this after move\n\t      // B p ! p\n\t      //   ^ idx position ok\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function (md) {\n\t\n\t  md.core.ruler.push('rewrite_inline_to_block_tags', rewriteInlineToBlockTags);\n\t};\n\n/***/ },\n/* 342 */,\n/* 343 */\n/***/ function(module, exports) {\n\n\t// Process definition lists\n\t//\n\t'use strict';\n\t\n\tmodule.exports = function deflist_plugin(md) {\n\t  var isSpace = md.utils.isSpace;\n\t\n\t  // Search `[:~][\\n ]`, returns next pos after marker on success\n\t  // or -1 on fail.\n\t  function skipMarker(state, line) {\n\t    var pos,\n\t        marker,\n\t        start = state.bMarks[line] + state.tShift[line],\n\t        max = state.eMarks[line];\n\t\n\t    if (start >= max) {\n\t      return -1;\n\t    }\n\t\n\t    // Check bullet\n\t    marker = state.src.charCodeAt(start++);\n\t    if (marker !== 0x7E /* ~ */ && marker !== 0x3A /* : */) {\n\t        return -1;\n\t      }\n\t\n\t    pos = state.skipSpaces(start);\n\t\n\t    // require space after \":\"\n\t    if (start === pos) {\n\t      return -1;\n\t    }\n\t\n\t    // no empty definitions, e.g. \"  : \"\n\t    if (pos >= max) {\n\t      return -1;\n\t    }\n\t\n\t    return start;\n\t  }\n\t\n\t  function markTightParagraphs(state, idx) {\n\t    var i,\n\t        l,\n\t        level = state.level + 2;\n\t\n\t    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n\t      if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n\t        state.tokens[i + 2].hidden = true;\n\t        state.tokens[i].hidden = true;\n\t        i += 2;\n\t      }\n\t    }\n\t  }\n\t\n\t  function deflist(state, startLine, endLine, silent) {\n\t    var ch, contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, max, nextLine, offset, oldDDIndent, oldIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, prevEmptyEnd, tight, token;\n\t\n\t    if (silent) {\n\t      // quirk: validation mode validates a dd block only, not a whole deflist\n\t      if (state.ddIndent < 0) {\n\t        return false;\n\t      }\n\t      return skipMarker(state, startLine) >= 0;\n\t    }\n\t\n\t    nextLine = startLine + 1;\n\t    if (state.isEmpty(nextLine)) {\n\t      if (++nextLine > endLine) {\n\t        return false;\n\t      }\n\t    }\n\t\n\t    if (state.sCount[nextLine] < state.blkIndent) {\n\t      return false;\n\t    }\n\t    contentStart = skipMarker(state, nextLine);\n\t    if (contentStart < 0) {\n\t      return false;\n\t    }\n\t\n\t    // Start list\n\t    listTokIdx = state.tokens.length;\n\t\n\t    token = state.push('dl_open', 'dl', 1);\n\t    token.map = listLines = [startLine, 0];\n\t\n\t    //\n\t    // Iterate list items\n\t    //\n\t\n\t    dtLine = startLine;\n\t    ddLine = nextLine;\n\t\n\t    // One definition list can contain multiple DTs,\n\t    // and one DT can be followed by multiple DDs.\n\t    //\n\t    // Thus, there is two loops here, and label is\n\t    // needed to break out of the second one\n\t    //\n\t    /*eslint no-labels:0,block-scoped-var:0*/\n\t    OUTER: for (;;) {\n\t      tight = true;\n\t      prevEmptyEnd = false;\n\t\n\t      token = state.push('dt_open', 'dt', 1);\n\t      token.map = [dtLine, dtLine];\n\t\n\t      token = state.push('inline', '', 0);\n\t      token.map = [dtLine, dtLine];\n\t      token.content = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim();\n\t      token.children = [];\n\t\n\t      token = state.push('dt_close', 'dt', -1);\n\t\n\t      for (;;) {\n\t        token = state.push('dd_open', 'dd', 1);\n\t        token.map = itemLines = [nextLine, 0];\n\t\n\t        pos = contentStart;\n\t        max = state.eMarks[ddLine];\n\t        offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine]);\n\t\n\t        while (pos < max) {\n\t          ch = state.src.charCodeAt(pos);\n\t\n\t          if (isSpace(ch)) {\n\t            if (ch === 0x09) {\n\t              offset += 4 - offset % 4;\n\t            } else {\n\t              offset++;\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t\n\t          pos++;\n\t        }\n\t\n\t        contentStart = pos;\n\t\n\t        oldTight = state.tight;\n\t        oldDDIndent = state.ddIndent;\n\t        oldIndent = state.blkIndent;\n\t        oldTShift = state.tShift[ddLine];\n\t        oldSCount = state.sCount[ddLine];\n\t        oldParentType = state.parentType;\n\t        state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;\n\t        state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n\t        state.sCount[ddLine] = offset;\n\t        state.tight = true;\n\t        state.parentType = 'deflist';\n\t\n\t        state.md.block.tokenize(state, ddLine, endLine, true);\n\t\n\t        // If any of list item is tight, mark list as tight\n\t        if (!state.tight || prevEmptyEnd) {\n\t          tight = false;\n\t        }\n\t        // Item become loose if finish with empty line,\n\t        // but we should filter last element, because it means list finish\n\t        prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n\t\n\t        state.tShift[ddLine] = oldTShift;\n\t        state.sCount[ddLine] = oldSCount;\n\t        state.tight = oldTight;\n\t        state.parentType = oldParentType;\n\t        state.blkIndent = oldIndent;\n\t        state.ddIndent = oldDDIndent;\n\t\n\t        token = state.push('dd_close', 'dd', -1);\n\t\n\t        itemLines[1] = nextLine = state.line;\n\t\n\t        if (nextLine >= endLine) {\n\t          break OUTER;\n\t        }\n\t\n\t        if (state.sCount[nextLine] < state.blkIndent) {\n\t          break OUTER;\n\t        }\n\t        contentStart = skipMarker(state, nextLine);\n\t        if (contentStart < 0) {\n\t          break;\n\t        }\n\t\n\t        ddLine = nextLine;\n\t\n\t        // go to the next loop iteration:\n\t        // insert DD tag and repeat checking\n\t      }\n\t\n\t      if (nextLine >= endLine) {\n\t        break;\n\t      }\n\t      dtLine = nextLine;\n\t\n\t      if (state.isEmpty(dtLine)) {\n\t        break;\n\t      }\n\t      if (state.sCount[dtLine] < state.blkIndent) {\n\t        break;\n\t      }\n\t\n\t      ddLine = dtLine + 1;\n\t      if (ddLine >= endLine) {\n\t        break;\n\t      }\n\t      if (state.isEmpty(ddLine)) {\n\t        ddLine++;\n\t      }\n\t      if (ddLine >= endLine) {\n\t        break;\n\t      }\n\t\n\t      if (state.sCount[ddLine] < state.blkIndent) {\n\t        break;\n\t      }\n\t      contentStart = skipMarker(state, ddLine);\n\t      if (contentStart < 0) {\n\t        break;\n\t      }\n\t\n\t      // go to the next loop iteration:\n\t      // insert DT and DD tags and repeat checking\n\t    }\n\t\n\t    // Finilize list\n\t    token = state.push('dl_close', 'dl', -1);\n\t\n\t    listLines[1] = nextLine;\n\t\n\t    state.line = nextLine;\n\t\n\t    // mark paragraphs tight if needed\n\t    if (tight) {\n\t      markTightParagraphs(state, listTokIdx);\n\t    }\n\t\n\t    return true;\n\t  }\n\t\n\t  md.block.ruler.before('paragraph', 'deflist', deflist, { alt: ['paragraph', 'reference'] });\n\t};\n\n/***/ },\n/* 344 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction charTypography(state) {\n\t  for (var idx = state.tokens.length - 1; idx >= 0; idx--) {\n\t\n\t    if (state.tokens[idx].type !== 'inline') continue;\n\t\n\t    doReplacementsInToken(state.tokens[idx].children);\n\t  }\n\t}\n\t\n\tfunction doReplacementsInToken(inlineTokens) {\n\t  var i, token;\n\t\n\t  for (i = 0; i < inlineTokens.length; i++) {\n\t    token = inlineTokens[i];\n\t    if (token.type === 'text') {\n\t      token.content = token.content.replace(/([^+])\\+\\-/gi, '$1').replace(/\\.\\.\\./mg, '').replace(/\\([cC]\\)(?=[^\\.\\,\\;\\:])/ig, '').replace(/\\(r\\)/ig, '<sup></sup>').replace(/\\(tm\\)/ig, '').replace(/(\\s|;)\\-(\\s)/gi, '$1$2').replace(/<->/gi, '').replace(/<-/gi, '').replace(/(\\s)->/gi, '$1').replace(/\\s-(\\w)/gim, '&#8209;$1'); // non-breaking hyphen: -Infinity won't get line-broken\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = function smartArrows_plugin(md, scheme) {\n\t  // must come before the built-in m-dash and n-dash support\n\t  md.core.ruler.before('replacements', 'char_typography', charTypography);\n\t};\n\n/***/ },\n/* 345 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./en.yml\": 346,\n\t\t\"./ru.yml\": 347\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 345;\n\n\n/***/ },\n/* 346 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"run\": \"run\",\n\t\t\"show\": \"show\",\n\t\t\"open\": {\n\t\t\t\"sandbox\": \"open in sandbox\"\n\t\t}\n\t};\n\n/***/ },\n/* 347 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"run\": \"\",\n\t\t\"show\": \"\",\n\t\t\"open\": {\n\t\t\t\"sandbox\": \"  \"\n\t\t}\n\t};\n\n/***/ },\n/* 348 */,\n/* 349 */,\n/* 350 */,\n/* 351 */,\n/* 352 */,\n/* 353 */,\n/* 354 */,\n/* 355 */,\n/* 356 */,\n/* 357 */,\n/* 358 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 359 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar BasicParser = __webpack_require__(251);\n\tvar CodeMirror = __webpack_require__(360);\n\tvar prism = __webpack_require__(237);\n\t__webpack_require__(361);\n\t\n\tvar template = __webpack_require__(366);\n\tvar throttle = __webpack_require__(370);\n\tvar clientRender = __webpack_require__(161);\n\t\n\tvar delegate = __webpack_require__(148);\n\t\n\tvar t = __webpack_require__(326);\n\t\n\tvar LANG = __webpack_require__(252).lang;\n\t\n\tt.requirePhrase('mdeditor', __webpack_require__(367)(\"./\" + LANG + '.yml'));\n\t\n\tvar buttonSets = {\n\t  standard: 'bold italic | link ul ol | code fencedCode | undo redo'.split(' ')\n\t};\n\t\n\tvar MdEditor = (function () {\n\t  _createClass(MdEditor, [{\n\t    key: 'actionBold',\n\t    value: function actionBold() {\n\t      this.replaceSelection(\"**\", \"**\", t(\"mdeditor.text.bold\"));\n\t    }\n\t  }, {\n\t    key: 'actionItalic',\n\t    value: function actionItalic() {\n\t      this.replaceSelection(\"*\", \"*\", t(\"mdeditor.text.italic\"));\n\t    }\n\t  }, {\n\t    key: 'actionCode',\n\t    value: function actionCode() {\n\t      this.replaceSelection(\"`\", \"`\", t(\"mdeditor.text.code\"));\n\t    }\n\t  }, {\n\t    key: 'actionRedo',\n\t    value: function actionRedo() {\n\t      this.codemirror.redo();\n\t    }\n\t  }, {\n\t    key: 'actionUndo',\n\t    value: function actionUndo() {\n\t      this.codemirror.undo();\n\t    }\n\t  }, {\n\t    key: 'actionFencedCode',\n\t    value: function actionFencedCode() {\n\t      var hadSelection = this.codemirror.getSelection();\n\t      this.replaceSelection(\"\\n```js\\n\", \"\\n```\\n\", t(\"mdeditor.text.fencedCode\"));\n\t\n\t      var cursorPos = this.codemirror.getCursor();\n\t      var line = cursorPos.line - 2;\n\t      this.codemirror.setCursor(line, 9999);\n\t      if (!hadSelection) {\n\t        // select default\n\t        this.codemirror.setSelection({ line: line, ch: 0 }, { line: line, ch: 9999 });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'actionLink',\n\t    value: function actionLink() {\n\t      var text = undefined;\n\t      var link = undefined;\n\t\n\t      var selection = this.codemirror.getSelection();\n\t\n\t      if (selection) {\n\t        if (selection.match(/^https?:\\/\\//)) {\n\t          link = selection;\n\t        } else {\n\t          text = selection;\n\t        }\n\t      }\n\t      var substitution = '[' + (text || t('mdeditor.text.link')) + '](' + (link || 'http://') + ')';\n\t\n\t      this.codemirror.replaceSelection(substitution);\n\t\n\t      var cursorPos = this.codemirror.getCursor();\n\t\n\t      if (!text) {\n\t        this.codemirror.setCursor(cursorPos.line, cursorPos.ch - substitution.length + 1 + t('mdeditor.text.link').length);\n\t        this.codemirror.setSelection({ line: cursorPos.line, ch: cursorPos.ch - substitution.length + 1 }, { line: cursorPos.line, ch: cursorPos.ch - substitution.length + 1 + t('mdeditor.text.link').length });\n\t      } else if (!link) {\n\t        this.codemirror.setCursor(cursorPos.line, cursorPos.ch - 1);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'actionOl',\n\t    value: function actionOl() {\n\t      var cursorPos = this.codemirror.getCursor();\n\t      this.codemirror.setSelection({ line: cursorPos.line, ch: 0 }, { line: cursorPos.line, ch: 99999 });\n\t\n\t      this.replaceSelection(\"1. \", \"\\n\", t('mdeditor.text.ol'));\n\t    }\n\t  }, {\n\t    key: 'actionUl',\n\t    value: function actionUl() {\n\t      var cursorPos = this.codemirror.getCursor();\n\t      this.codemirror.setSelection({ line: cursorPos.line, ch: 0 }, { line: cursorPos.line, ch: 99999 });\n\t\n\t      this.replaceSelection(\"- \", \"\\n\", t('mdeditor.text.ol'));\n\t    }\n\t  }, {\n\t    key: 'actionHeading',\n\t    value: function actionHeading() {\n\t      var cursorPos = this.codemirror.getCursor();\n\t      this.codemirror.setSelection({ line: cursorPos.line, ch: 0 }, { line: cursorPos.line, ch: 99999 });\n\t\n\t      this.replaceSelection(\"# \", \"\\n\", t('mdeditor.text.heading'));\n\t    }\n\t  }, {\n\t    key: 'actionImage',\n\t    value: function actionImage() {\n\t      // todo\n\t      var selection = this.codemirror.getSelection();\n\t      var text = t(\"mdeditor.text.alt\");\n\t\n\t      if (!selection) {\n\t        selection = \"http://my.jpg\";\n\t      }\n\t      this.codemirror.replaceSelection('![' + text + '](' + selection + ')');\n\t      var cursorPos = this.codemirror.getCursor();\n\t      this.codemirror.setCursor(cursorPos.line, cursorPos.ch - (1 + selection.length));\n\t    }\n\t  }, {\n\t    key: 'replaceSelection',\n\t    value: function replaceSelection(before, after, defaultText) {\n\t\n\t      var selection = this.codemirror.getSelection();\n\t\n\t      var defaultTextUsed = !selection;\n\t\n\t      var substitution = defaultTextUsed ? before + defaultText + after : before + selection + after;\n\t      this.codemirror.replaceSelection(substitution);\n\t\n\t      var cursorPos = this.codemirror.getCursor();\n\t\n\t      if (defaultTextUsed) {\n\t        this.codemirror.setCursor(cursorPos.line, cursorPos.ch - after.length);\n\t        this.codemirror.setSelection({ line: cursorPos.line, ch: cursorPos.ch - defaultText.length - after.length }, { line: cursorPos.line, ch: cursorPos.ch - after.length });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render(textArea) {\n\t\n\t      var buttonSet = buttonSets[this.options.buttonSet || 'standard'];\n\t\n\t      textArea.insertAdjacentHTML(\"afterEnd\", clientRender(template, {\n\t        buttons: buttonSet\n\t      }));\n\t\n\t      this.elem = textArea.nextElementSibling;\n\t\n\t      var templateArea = this.elem.querySelector('textarea');\n\t      templateArea.replace(textArea);\n\t\n\t      textArea.classList.remove('mdeditor');\n\t      // move all classes from template textarea to the existing one\n\t      for (var i = 0; i < templateArea.classList.length; i++) {\n\t        var cls = templateArea.classList[i];\n\t        textArea.classList.add(cls);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'onResizeMouseDown',\n\t    value: function onResizeMouseDown(e) {\n\t      this.elem.classList.add('mdeditor_resizing');\n\t      document.addEventListener('mousemove', this.onResizeMouseMove);\n\t      document.addEventListener('mouseup', this.onResizeMouseUp);\n\t      e.preventDefault();\n\t    }\n\t  }, {\n\t    key: 'onResizeMouseMove',\n\t    value: function onResizeMouseMove(e) {\n\t      var editorElem = this.codemirror.getWrapperElement();\n\t      var height = e.clientY - editorElem.getBoundingClientRect().top;\n\t      console.log(height);\n\t      if (height < 30) height = 30;\n\t      this.codemirror.setSize('100%', height);\n\t    }\n\t  }, {\n\t    key: 'onResizeMouseUp',\n\t    value: function onResizeMouseUp(e) {\n\t      this.elem.classList.remove('mdeditor_resizing');\n\t      document.removeEventListener('mousemove', this.onResizeMouseMove);\n\t      document.removeEventListener('mouseup', this.onResizeMouseUp);\n\t    }\n\t  }]);\n\t\n\t  function MdEditor(options) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, MdEditor);\n\t\n\t    this.options = Object.create(options);\n\t    if (!options.buttonSet) this.options.buttonSet = 'standard';\n\t\n\t    this.render(options.elem);\n\t    this.value = this.elem.value;\n\t\n\t    this.delegate('[data-action]', 'click', function (e) {\n\t      var actionName = 'action' + e.delegateTarget.getAttribute('data-action')[0].toUpperCase() + e.delegateTarget.getAttribute('data-action').slice(1);\n\t\n\t      if (!this[actionName]) return;\n\t\n\t      e.preventDefault();\n\t      this[actionName]();\n\t      this.codemirror.focus();\n\t    });\n\t\n\t    this.onResizeMouseDown = this.onResizeMouseDown.bind(this);\n\t    this.onResizeMouseMove = this.onResizeMouseMove.bind(this);\n\t    this.onResizeMouseUp = this.onResizeMouseUp.bind(this);\n\t\n\t    this.renderPreviewThrottled = throttle(this.renderPreview.bind(this), 100);\n\t    this.highlightInPreviewThrottled = throttle(this.highlightInPreview.bind(this), 500);\n\t\n\t    this.delegate('[data-mdeditor-resize]', 'mousedown', this.onResizeMouseDown);\n\t\n\t    this.codemirror = CodeMirror.fromTextArea(this.elem.querySelector('textarea'), {\n\t      tabSize: 2,\n\t      //lineNumbers: false,\n\t      mode: 'gfm'\n\t    });\n\t\n\t    this.codemirror.setOption(\"extraKeys\", {\n\t      'Ctrl-B': function CtrlB() {\n\t        return _this.actionBold();\n\t      },\n\t      'Ctrl-I': function CtrlI() {\n\t        return _this.actionItalic();\n\t      },\n\t      'Cmd-B': function CmdB() {\n\t        return _this.actionBold();\n\t      },\n\t      'Cmd-I': function CmdI() {\n\t        return _this.actionItalic();\n\t      }\n\t    });\n\t\n\t    this.codemirror.on(\"change\", this.renderPreviewThrottled);\n\t  }\n\t\n\t  _createClass(MdEditor, [{\n\t    key: 'highlightInPreview',\n\t    value: function highlightInPreview() {\n\t      prism.highlight(this.elem.querySelector('[data-editor-preview]'));\n\t    }\n\t  }, {\n\t    key: 'renderPreview',\n\t    value: function renderPreview() {\n\t      var value = this.codemirror.getValue();\n\t      var rendered = new BasicParser().render(value);\n\t      this.elem.querySelector('[data-editor-preview]').innerHTML = rendered;\n\t      this.highlightInPreviewThrottled();\n\t    }\n\t  }]);\n\t\n\t  return MdEditor;\n\t})();\n\t\n\tdelegate.delegateMixin(MdEditor.prototype);\n\t\n\tmodule.exports = MdEditor;\n\n/***/ },\n/* 360 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// This is CodeMirror (http://codemirror.net), a code editor\n\t// implemented in JavaScript on top of the browser's DOM.\n\t//\n\t// You can find some technical background for some of the code below\n\t// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    module.exports = mod();\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    return define([], mod);\n\t  else // Plain browser env\n\t    (this || window).CodeMirror = mod();\n\t})(function() {\n\t  \"use strict\";\n\t\n\t  // BROWSER SNIFFING\n\t\n\t  // Kludges for bugs and behavior differences that can't be feature\n\t  // detected are enabled based on userAgent etc sniffing.\n\t  var userAgent = navigator.userAgent;\n\t  var platform = navigator.platform;\n\t\n\t  var gecko = /gecko\\/\\d/i.test(userAgent);\n\t  var ie_upto10 = /MSIE \\d/.test(userAgent);\n\t  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n\t  var ie = ie_upto10 || ie_11up;\n\t  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n\t  var webkit = /WebKit\\//.test(userAgent);\n\t  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n\t  var chrome = /Chrome\\//.test(userAgent);\n\t  var presto = /Opera\\//.test(userAgent);\n\t  var safari = /Apple Computer/.test(navigator.vendor);\n\t  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n\t  var phantom = /PhantomJS/.test(userAgent);\n\t\n\t  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n\t  // This is woefully incomplete. Suggestions for alternative methods welcome.\n\t  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n\t  var mac = ios || /Mac/.test(platform);\n\t  var windows = /win/i.test(platform);\n\t\n\t  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\t  if (presto_version) presto_version = Number(presto_version[1]);\n\t  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n\t  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\t  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n\t  var captureRightClick = gecko || (ie && ie_version >= 9);\n\t\n\t  // Optimize some code when these features are not used.\n\t  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\t\n\t  // EDITOR CONSTRUCTOR\n\t\n\t  // A CodeMirror instance represents an editor. This is the object\n\t  // that user code is usually dealing with.\n\t\n\t  function CodeMirror(place, options) {\n\t    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\t\n\t    this.options = options = options ? copyObj(options) : {};\n\t    // Determine effective options based on given values and defaults.\n\t    copyObj(defaults, options, false);\n\t    setGuttersForLineNumbers(options);\n\t\n\t    var doc = options.value;\n\t    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n\t    this.doc = doc;\n\t\n\t    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n\t    var display = this.display = new Display(place, doc, input);\n\t    display.wrapper.CodeMirror = this;\n\t    updateGutters(this);\n\t    themeChanged(this);\n\t    if (options.lineWrapping)\n\t      this.display.wrapper.className += \" CodeMirror-wrap\";\n\t    if (options.autofocus && !mobile) display.input.focus();\n\t    initScrollbars(this);\n\t\n\t    this.state = {\n\t      keyMaps: [],  // stores maps added by addKeyMap\n\t      overlays: [], // highlighting overlays, as added by addOverlay\n\t      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n\t      overwrite: false,\n\t      delayingBlurEvent: false,\n\t      focused: false,\n\t      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n\t      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n\t      selectingText: false,\n\t      draggingText: false,\n\t      highlight: new Delayed(), // stores highlight worker timeout\n\t      keySeq: null,  // Unfinished key sequence\n\t      specialChars: null\n\t    };\n\t\n\t    var cm = this;\n\t\n\t    // Override magic textarea content restore that IE sometimes does\n\t    // on our hidden textarea on reload\n\t    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\t\n\t    registerEventHandlers(this);\n\t    ensureGlobalHandlers();\n\t\n\t    startOperation(this);\n\t    this.curOp.forceUpdate = true;\n\t    attachDoc(this, doc);\n\t\n\t    if ((options.autofocus && !mobile) || cm.hasFocus())\n\t      setTimeout(bind(onFocus, this), 20);\n\t    else\n\t      onBlur(this);\n\t\n\t    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n\t      optionHandlers[opt](this, options[opt], Init);\n\t    maybeUpdateLineNumberWidth(this);\n\t    if (options.finishInit) options.finishInit(this);\n\t    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n\t    endOperation(this);\n\t    // Suppress optimizelegibility in Webkit, since it breaks text\n\t    // measuring on line wrapping boundaries.\n\t    if (webkit && options.lineWrapping &&\n\t        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n\t      display.lineDiv.style.textRendering = \"auto\";\n\t  }\n\t\n\t  // DISPLAY CONSTRUCTOR\n\t\n\t  // The display handles the DOM integration, both for input reading\n\t  // and content drawing. It holds references to DOM nodes and\n\t  // display-related state.\n\t\n\t  function Display(place, doc, input) {\n\t    var d = this;\n\t    this.input = input;\n\t\n\t    // Covers bottom-right square when both scrollbars are present.\n\t    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n\t    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n\t    // and h scrollbar is present.\n\t    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n\t    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Will contain the actual code, positioned to cover the viewport.\n\t    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n\t    // Elements are added to these to represent selection and cursors.\n\t    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n\t    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n\t    // A visibility: hidden element used to find the size of things.\n\t    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // When lines outside of the viewport are measured, they are drawn in this.\n\t    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\t    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n\t                      null, \"position: relative; outline: none\");\n\t    // Moved around its parent to cover visible view.\n\t    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n\t    // Set to the height of the document, allowing scrolling.\n\t    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n\t    d.sizerWidth = null;\n\t    // Behavior of elts with overflow: auto and padding is\n\t    // inconsistent across browsers. This is used to ensure the\n\t    // scrollable area is big enough.\n\t    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n\t    // Will contain the gutters, if any.\n\t    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n\t    d.lineGutter = null;\n\t    // Actual scrollable element.\n\t    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n\t    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n\t    // The element in which the editor lives.\n\t    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\t\n\t    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\t    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n\t    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\t\n\t    if (place) {\n\t      if (place.appendChild) place.appendChild(d.wrapper);\n\t      else place(d.wrapper);\n\t    }\n\t\n\t    // Current rendered range (may be bigger than the view window).\n\t    d.viewFrom = d.viewTo = doc.first;\n\t    d.reportedViewFrom = d.reportedViewTo = doc.first;\n\t    // Information about the rendered lines.\n\t    d.view = [];\n\t    d.renderedView = null;\n\t    // Holds info about a single rendered line when it was rendered\n\t    // for measurement, while not in view.\n\t    d.externalMeasured = null;\n\t    // Empty space (in pixels) above the view\n\t    d.viewOffset = 0;\n\t    d.lastWrapHeight = d.lastWrapWidth = 0;\n\t    d.updateLineNumbers = null;\n\t\n\t    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n\t    d.scrollbarsClipped = false;\n\t\n\t    // Used to only resize the line number gutter when necessary (when\n\t    // the amount of lines crosses a boundary that makes its width change)\n\t    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n\t    // Set to true when a non-horizontal-scrolling line widget is\n\t    // added. As an optimization, line widget aligning is skipped when\n\t    // this is false.\n\t    d.alignWidgets = false;\n\t\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t\n\t    // Tracks the maximum line length so that the horizontal scrollbar\n\t    // can be kept static when scrolling.\n\t    d.maxLine = null;\n\t    d.maxLineLength = 0;\n\t    d.maxLineChanged = false;\n\t\n\t    // Used for measuring wheel scrolling granularity\n\t    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\t\n\t    // True when shift is held down.\n\t    d.shift = false;\n\t\n\t    // Used to track whether anything happened since the context menu\n\t    // was opened.\n\t    d.selForContextMenu = null;\n\t\n\t    d.activeTouch = null;\n\t\n\t    input.init(d);\n\t  }\n\t\n\t  // STATE UPDATES\n\t\n\t  // Used to get the editor into a consistent state again when options change.\n\t\n\t  function loadMode(cm) {\n\t    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n\t    resetModeState(cm);\n\t  }\n\t\n\t  function resetModeState(cm) {\n\t    cm.doc.iter(function(line) {\n\t      if (line.stateAfter) line.stateAfter = null;\n\t      if (line.styles) line.styles = null;\n\t    });\n\t    cm.doc.frontier = cm.doc.first;\n\t    startWorker(cm, 100);\n\t    cm.state.modeGen++;\n\t    if (cm.curOp) regChange(cm);\n\t  }\n\t\n\t  function wrappingChanged(cm) {\n\t    if (cm.options.lineWrapping) {\n\t      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      cm.display.sizer.style.minWidth = \"\";\n\t      cm.display.sizerWidth = null;\n\t    } else {\n\t      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      findMaxLine(cm);\n\t    }\n\t    estimateLineHeights(cm);\n\t    regChange(cm);\n\t    clearCaches(cm);\n\t    setTimeout(function(){updateScrollbars(cm);}, 100);\n\t  }\n\t\n\t  // Returns a function that estimates the height of a line, to use as\n\t  // first approximation until the line becomes visible (and is thus\n\t  // properly measurable).\n\t  function estimateHeight(cm) {\n\t    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n\t    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n\t    return function(line) {\n\t      if (lineIsHidden(cm.doc, line)) return 0;\n\t\n\t      var widgetsHeight = 0;\n\t      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n\t        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n\t      }\n\t\n\t      if (wrapping)\n\t        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n\t      else\n\t        return widgetsHeight + th;\n\t    };\n\t  }\n\t\n\t  function estimateLineHeights(cm) {\n\t    var doc = cm.doc, est = estimateHeight(cm);\n\t    doc.iter(function(line) {\n\t      var estHeight = est(line);\n\t      if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t    });\n\t  }\n\t\n\t  function themeChanged(cm) {\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n\t      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n\t    clearCaches(cm);\n\t  }\n\t\n\t  function guttersChanged(cm) {\n\t    updateGutters(cm);\n\t    regChange(cm);\n\t    setTimeout(function(){alignHorizontally(cm);}, 20);\n\t  }\n\t\n\t  // Rebuild the gutter elements, ensure the margin to the left of the\n\t  // code matches their width.\n\t  function updateGutters(cm) {\n\t    var gutters = cm.display.gutters, specs = cm.options.gutters;\n\t    removeChildren(gutters);\n\t    for (var i = 0; i < specs.length; ++i) {\n\t      var gutterClass = specs[i];\n\t      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\t      if (gutterClass == \"CodeMirror-linenumbers\") {\n\t        cm.display.lineGutter = gElt;\n\t        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n\t      }\n\t    }\n\t    gutters.style.display = i ? \"\" : \"none\";\n\t    updateGutterSpace(cm);\n\t  }\n\t\n\t  function updateGutterSpace(cm) {\n\t    var width = cm.display.gutters.offsetWidth;\n\t    cm.display.sizer.style.marginLeft = width + \"px\";\n\t  }\n\t\n\t  // Compute the character length of a line, taking into account\n\t  // collapsed ranges (see markText) that might hide parts, and join\n\t  // other lines onto it.\n\t  function lineLength(line) {\n\t    if (line.height == 0) return 0;\n\t    var len = line.text.length, merged, cur = line;\n\t    while (merged = collapsedSpanAtStart(cur)) {\n\t      var found = merged.find(0, true);\n\t      cur = found.from.line;\n\t      len += found.from.ch - found.to.ch;\n\t    }\n\t    cur = line;\n\t    while (merged = collapsedSpanAtEnd(cur)) {\n\t      var found = merged.find(0, true);\n\t      len -= cur.text.length - found.from.ch;\n\t      cur = found.to.line;\n\t      len += cur.text.length - found.to.ch;\n\t    }\n\t    return len;\n\t  }\n\t\n\t  // Find the longest line in the document.\n\t  function findMaxLine(cm) {\n\t    var d = cm.display, doc = cm.doc;\n\t    d.maxLine = getLine(doc, doc.first);\n\t    d.maxLineLength = lineLength(d.maxLine);\n\t    d.maxLineChanged = true;\n\t    doc.iter(function(line) {\n\t      var len = lineLength(line);\n\t      if (len > d.maxLineLength) {\n\t        d.maxLineLength = len;\n\t        d.maxLine = line;\n\t      }\n\t    });\n\t  }\n\t\n\t  // Make sure the gutters options contains the element\n\t  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\t  function setGuttersForLineNumbers(options) {\n\t    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n\t    if (found == -1 && options.lineNumbers) {\n\t      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n\t    } else if (found > -1 && !options.lineNumbers) {\n\t      options.gutters = options.gutters.slice(0);\n\t      options.gutters.splice(found, 1);\n\t    }\n\t  }\n\t\n\t  // SCROLLBARS\n\t\n\t  // Prepare DOM reads needed to update the scrollbars. Done in one\n\t  // shot to minimize update/measure roundtrips.\n\t  function measureForScrollbars(cm) {\n\t    var d = cm.display, gutterW = d.gutters.offsetWidth;\n\t    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n\t    return {\n\t      clientHeight: d.scroller.clientHeight,\n\t      viewHeight: d.wrapper.clientHeight,\n\t      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n\t      viewWidth: d.wrapper.clientWidth,\n\t      barLeft: cm.options.fixedGutter ? gutterW : 0,\n\t      docHeight: docH,\n\t      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n\t      nativeBarWidth: d.nativeBarWidth,\n\t      gutterWidth: gutterW\n\t    };\n\t  }\n\t\n\t  function NativeScrollbars(place, scroll, cm) {\n\t    this.cm = cm;\n\t    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n\t    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n\t    place(vert); place(horiz);\n\t\n\t    on(vert, \"scroll\", function() {\n\t      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n\t    });\n\t    on(horiz, \"scroll\", function() {\n\t      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n\t    });\n\t\n\t    this.checkedZeroWidth = false;\n\t    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\t    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n\t  }\n\t\n\t  NativeScrollbars.prototype = copyObj({\n\t    update: function(measure) {\n\t      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n\t      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n\t      var sWidth = measure.nativeBarWidth;\n\t\n\t      if (needsV) {\n\t        this.vert.style.display = \"block\";\n\t        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n\t        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n\t        // A bug in IE8 can cause this value to be negative, so guard it.\n\t        this.vert.firstChild.style.height =\n\t          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n\t      } else {\n\t        this.vert.style.display = \"\";\n\t        this.vert.firstChild.style.height = \"0\";\n\t      }\n\t\n\t      if (needsH) {\n\t        this.horiz.style.display = \"block\";\n\t        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n\t        this.horiz.style.left = measure.barLeft + \"px\";\n\t        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n\t        this.horiz.firstChild.style.width =\n\t          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n\t      } else {\n\t        this.horiz.style.display = \"\";\n\t        this.horiz.firstChild.style.width = \"0\";\n\t      }\n\t\n\t      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n\t        if (sWidth == 0) this.zeroWidthHack();\n\t        this.checkedZeroWidth = true;\n\t      }\n\t\n\t      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n\t    },\n\t    setScrollLeft: function(pos) {\n\t      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n\t      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n\t    },\n\t    setScrollTop: function(pos) {\n\t      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n\t      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n\t    },\n\t    zeroWidthHack: function() {\n\t      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n\t      this.horiz.style.height = this.vert.style.width = w;\n\t      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n\t      this.disableHoriz = new Delayed;\n\t      this.disableVert = new Delayed;\n\t    },\n\t    enableZeroWidthBar: function(bar, delay) {\n\t      bar.style.pointerEvents = \"auto\";\n\t      function maybeDisable() {\n\t        // To find out whether the scrollbar is still visible, we\n\t        // check whether the element under the pixel in the bottom\n\t        // left corner of the scrollbar box is the scrollbar box\n\t        // itself (when the bar is still visible) or its filler child\n\t        // (when the bar is hidden). If it is still visible, we keep\n\t        // it enabled, if it's hidden, we disable pointer events.\n\t        var box = bar.getBoundingClientRect();\n\t        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n\t        if (elt != bar) bar.style.pointerEvents = \"none\";\n\t        else delay.set(1000, maybeDisable);\n\t      }\n\t      delay.set(1000, maybeDisable);\n\t    },\n\t    clear: function() {\n\t      var parent = this.horiz.parentNode;\n\t      parent.removeChild(this.horiz);\n\t      parent.removeChild(this.vert);\n\t    }\n\t  }, NativeScrollbars.prototype);\n\t\n\t  function NullScrollbars() {}\n\t\n\t  NullScrollbars.prototype = copyObj({\n\t    update: function() { return {bottom: 0, right: 0}; },\n\t    setScrollLeft: function() {},\n\t    setScrollTop: function() {},\n\t    clear: function() {}\n\t  }, NullScrollbars.prototype);\n\t\n\t  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\t\n\t  function initScrollbars(cm) {\n\t    if (cm.display.scrollbars) {\n\t      cm.display.scrollbars.clear();\n\t      if (cm.display.scrollbars.addClass)\n\t        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t    }\n\t\n\t    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n\t      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n\t      // Prevent clicks in the scrollbars from killing focus\n\t      on(node, \"mousedown\", function() {\n\t        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n\t      });\n\t      node.setAttribute(\"cm-not-content\", \"true\");\n\t    }, function(pos, axis) {\n\t      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n\t      else setScrollTop(cm, pos);\n\t    }, cm);\n\t    if (cm.display.scrollbars.addClass)\n\t      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t  }\n\t\n\t  function updateScrollbars(cm, measure) {\n\t    if (!measure) measure = measureForScrollbars(cm);\n\t    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n\t    updateScrollbarsInner(cm, measure);\n\t    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n\t      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n\t        updateHeightsInViewport(cm);\n\t      updateScrollbarsInner(cm, measureForScrollbars(cm));\n\t      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n\t    }\n\t  }\n\t\n\t  // Re-synchronize the fake scrollbars with the actual size of the\n\t  // content.\n\t  function updateScrollbarsInner(cm, measure) {\n\t    var d = cm.display;\n\t    var sizes = d.scrollbars.update(measure);\n\t\n\t    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n\t    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\t\n\t    if (sizes.right && sizes.bottom) {\n\t      d.scrollbarFiller.style.display = \"block\";\n\t      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n\t      d.scrollbarFiller.style.width = sizes.right + \"px\";\n\t    } else d.scrollbarFiller.style.display = \"\";\n\t    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n\t      d.gutterFiller.style.display = \"block\";\n\t      d.gutterFiller.style.height = sizes.bottom + \"px\";\n\t      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n\t    } else d.gutterFiller.style.display = \"\";\n\t  }\n\t\n\t  // Compute the lines that are visible in a given viewport (defaults\n\t  // the the current scroll position). viewport may contain top,\n\t  // height, and ensure (see op.scrollToPos) properties.\n\t  function visibleLines(display, doc, viewport) {\n\t    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n\t    top = Math.floor(top - paddingTop(display));\n\t    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\t\n\t    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n\t    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n\t    // forces those lines into the viewport (if possible).\n\t    if (viewport && viewport.ensure) {\n\t      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n\t      if (ensureFrom < from) {\n\t        from = ensureFrom;\n\t        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n\t      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n\t        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n\t        to = ensureTo;\n\t      }\n\t    }\n\t    return {from: from, to: Math.max(to, from + 1)};\n\t  }\n\t\n\t  // LINE NUMBERS\n\t\n\t  // Re-align line numbers and gutter marks to compensate for\n\t  // horizontal scrolling.\n\t  function alignHorizontally(cm) {\n\t    var display = cm.display, view = display.view;\n\t    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n\t    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n\t    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n\t    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n\t      if (cm.options.fixedGutter && view[i].gutter)\n\t        view[i].gutter.style.left = left;\n\t      var align = view[i].alignable;\n\t      if (align) for (var j = 0; j < align.length; j++)\n\t        align[j].style.left = left;\n\t    }\n\t    if (cm.options.fixedGutter)\n\t      display.gutters.style.left = (comp + gutterW) + \"px\";\n\t  }\n\t\n\t  // Used to ensure that the line number gutter is still the right\n\t  // size for the current document size. Returns true when an update\n\t  // is needed.\n\t  function maybeUpdateLineNumberWidth(cm) {\n\t    if (!cm.options.lineNumbers) return false;\n\t    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n\t    if (last.length != display.lineNumChars) {\n\t      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n\t                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n\t      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n\t      display.lineGutter.style.width = \"\";\n\t      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n\t      display.lineNumWidth = display.lineNumInnerWidth + padding;\n\t      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n\t      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n\t      updateGutterSpace(cm);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function lineNumberFor(options, i) {\n\t    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n\t  }\n\t\n\t  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n\t  // but using getBoundingClientRect to get a sub-pixel-accurate\n\t  // result.\n\t  function compensateForHScroll(display) {\n\t    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n\t  }\n\t\n\t  // DISPLAY DRAWING\n\t\n\t  function DisplayUpdate(cm, viewport, force) {\n\t    var display = cm.display;\n\t\n\t    this.viewport = viewport;\n\t    // Store some values that we'll need later (but don't want to force a relayout for)\n\t    this.visible = visibleLines(display, cm.doc, viewport);\n\t    this.editorIsHidden = !display.wrapper.offsetWidth;\n\t    this.wrapperHeight = display.wrapper.clientHeight;\n\t    this.wrapperWidth = display.wrapper.clientWidth;\n\t    this.oldDisplayWidth = displayWidth(cm);\n\t    this.force = force;\n\t    this.dims = getDimensions(cm);\n\t    this.events = [];\n\t  }\n\t\n\t  DisplayUpdate.prototype.signal = function(emitter, type) {\n\t    if (hasHandler(emitter, type))\n\t      this.events.push(arguments);\n\t  };\n\t  DisplayUpdate.prototype.finish = function() {\n\t    for (var i = 0; i < this.events.length; i++)\n\t      signal.apply(null, this.events[i]);\n\t  };\n\t\n\t  function maybeClipScrollbars(cm) {\n\t    var display = cm.display;\n\t    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n\t      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n\t      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n\t      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n\t      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n\t      display.scrollbarsClipped = true;\n\t    }\n\t  }\n\t\n\t  // Does the actual updating of the line display. Bails out\n\t  // (returning false) when there is nothing to be done and forced is\n\t  // false.\n\t  function updateDisplayIfNeeded(cm, update) {\n\t    var display = cm.display, doc = cm.doc;\n\t\n\t    if (update.editorIsHidden) {\n\t      resetView(cm);\n\t      return false;\n\t    }\n\t\n\t    // Bail out if the visible area is already rendered and nothing changed.\n\t    if (!update.force &&\n\t        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n\t        display.renderedView == display.view && countDirtyView(cm) == 0)\n\t      return false;\n\t\n\t    if (maybeUpdateLineNumberWidth(cm)) {\n\t      resetView(cm);\n\t      update.dims = getDimensions(cm);\n\t    }\n\t\n\t    // Compute a suitable new viewport (from & to)\n\t    var end = doc.first + doc.size;\n\t    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n\t    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\t    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n\t    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n\t    if (sawCollapsedSpans) {\n\t      from = visualLineNo(cm.doc, from);\n\t      to = visualLineEndNo(cm.doc, to);\n\t    }\n\t\n\t    var different = from != display.viewFrom || to != display.viewTo ||\n\t      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n\t    adjustView(cm, from, to);\n\t\n\t    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n\t    // Position the mover div to align with the current scroll position\n\t    cm.display.mover.style.top = display.viewOffset + \"px\";\n\t\n\t    var toUpdate = countDirtyView(cm);\n\t    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n\t      return false;\n\t\n\t    // For big changes, we hide the enclosing element during the\n\t    // update, since that speeds up the operations on most browsers.\n\t    var focused = activeElt();\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n\t    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n\t    display.renderedView = display.view;\n\t    // There might have been a widget with a focused element that got\n\t    // hidden or updated, if so re-focus it.\n\t    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\t\n\t    // Prevent selection and cursors from interfering with the scroll\n\t    // width and height.\n\t    removeChildren(display.cursorDiv);\n\t    removeChildren(display.selectionDiv);\n\t    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\t\n\t    if (different) {\n\t      display.lastWrapHeight = update.wrapperHeight;\n\t      display.lastWrapWidth = update.wrapperWidth;\n\t      startWorker(cm, 400);\n\t    }\n\t\n\t    display.updateLineNumbers = null;\n\t\n\t    return true;\n\t  }\n\t\n\t  function postUpdateDisplay(cm, update) {\n\t    var viewport = update.viewport;\n\t    for (var first = true;; first = false) {\n\t      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n\t        // Clip forced viewport to actual scrollable area.\n\t        if (viewport && viewport.top != null)\n\t          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n\t        // Updated line heights might result in the drawn area not\n\t        // actually covering the viewport. Keep looping until it does.\n\t        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\t        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n\t          break;\n\t      }\n\t      if (!updateDisplayIfNeeded(cm, update)) break;\n\t      updateHeightsInViewport(cm);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t    }\n\t\n\t    update.signal(cm, \"update\", cm);\n\t    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n\t      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n\t      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n\t    }\n\t  }\n\t\n\t  function updateDisplaySimple(cm, viewport) {\n\t    var update = new DisplayUpdate(cm, viewport);\n\t    if (updateDisplayIfNeeded(cm, update)) {\n\t      updateHeightsInViewport(cm);\n\t      postUpdateDisplay(cm, update);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t      update.finish();\n\t    }\n\t  }\n\t\n\t  function setDocumentHeight(cm, measure) {\n\t    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n\t    var total = measure.docHeight + cm.display.barHeight;\n\t    cm.display.heightForcer.style.top = total + \"px\";\n\t    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n\t  }\n\t\n\t  // Read the actual heights of the rendered lines, and update their\n\t  // stored heights to match.\n\t  function updateHeightsInViewport(cm) {\n\t    var display = cm.display;\n\t    var prevBottom = display.lineDiv.offsetTop;\n\t    for (var i = 0; i < display.view.length; i++) {\n\t      var cur = display.view[i], height;\n\t      if (cur.hidden) continue;\n\t      if (ie && ie_version < 8) {\n\t        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n\t        height = bot - prevBottom;\n\t        prevBottom = bot;\n\t      } else {\n\t        var box = cur.node.getBoundingClientRect();\n\t        height = box.bottom - box.top;\n\t      }\n\t      var diff = cur.line.height - height;\n\t      if (height < 2) height = textHeight(display);\n\t      if (diff > .001 || diff < -.001) {\n\t        updateLineHeight(cur.line, height);\n\t        updateWidgetHeight(cur.line);\n\t        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n\t          updateWidgetHeight(cur.rest[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Read and store the height of line widgets associated with the\n\t  // given line.\n\t  function updateWidgetHeight(line) {\n\t    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n\t      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n\t  }\n\t\n\t  // Do a bulk-read of the DOM positions and sizes needed to draw the\n\t  // view, so that we don't interleave reading and writing to the DOM.\n\t  function getDimensions(cm) {\n\t    var d = cm.display, left = {}, width = {};\n\t    var gutterLeft = d.gutters.clientLeft;\n\t    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n\t      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n\t      width[cm.options.gutters[i]] = n.clientWidth;\n\t    }\n\t    return {fixedPos: compensateForHScroll(d),\n\t            gutterTotalWidth: d.gutters.offsetWidth,\n\t            gutterLeft: left,\n\t            gutterWidth: width,\n\t            wrapperWidth: d.wrapper.clientWidth};\n\t  }\n\t\n\t  // Sync the actual display DOM structure with display.view, removing\n\t  // nodes for lines that are no longer in view, and creating the ones\n\t  // that are not there yet, and updating the ones that are out of\n\t  // date.\n\t  function patchDisplay(cm, updateNumbersFrom, dims) {\n\t    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n\t    var container = display.lineDiv, cur = container.firstChild;\n\t\n\t    function rm(node) {\n\t      var next = node.nextSibling;\n\t      // Works around a throw-scroll bug in OS X Webkit\n\t      if (webkit && mac && cm.display.currentWheelTarget == node)\n\t        node.style.display = \"none\";\n\t      else\n\t        node.parentNode.removeChild(node);\n\t      return next;\n\t    }\n\t\n\t    var view = display.view, lineN = display.viewFrom;\n\t    // Loop over the elements in the view, syncing cur (the DOM nodes\n\t    // in display.lineDiv) with the view as we go.\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (lineView.hidden) {\n\t      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n\t        var node = buildLineElement(cm, lineView, lineN, dims);\n\t        container.insertBefore(node, cur);\n\t      } else { // Already drawn\n\t        while (cur != lineView.node) cur = rm(cur);\n\t        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n\t          updateNumbersFrom <= lineN && lineView.lineNumber;\n\t        if (lineView.changes) {\n\t          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n\t          updateLineForChanges(cm, lineView, lineN, dims);\n\t        }\n\t        if (updateNumber) {\n\t          removeChildren(lineView.lineNumber);\n\t          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n\t        }\n\t        cur = lineView.node.nextSibling;\n\t      }\n\t      lineN += lineView.size;\n\t    }\n\t    while (cur) cur = rm(cur);\n\t  }\n\t\n\t  // When an aspect of a line changes, a string is added to\n\t  // lineView.changes. This updates the relevant part of the line's\n\t  // DOM structure.\n\t  function updateLineForChanges(cm, lineView, lineN, dims) {\n\t    for (var j = 0; j < lineView.changes.length; j++) {\n\t      var type = lineView.changes[j];\n\t      if (type == \"text\") updateLineText(cm, lineView);\n\t      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n\t      else if (type == \"class\") updateLineClasses(lineView);\n\t      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n\t    }\n\t    lineView.changes = null;\n\t  }\n\t\n\t  // Lines with gutter elements, widgets or a background class need to\n\t  // be wrapped, and have the extra elements added to the wrapper div\n\t  function ensureLineWrapped(lineView) {\n\t    if (lineView.node == lineView.text) {\n\t      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\t      if (lineView.text.parentNode)\n\t        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n\t      lineView.node.appendChild(lineView.text);\n\t      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n\t    }\n\t    return lineView.node;\n\t  }\n\t\n\t  function updateLineBackground(lineView) {\n\t    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\t    if (cls) cls += \" CodeMirror-linebackground\";\n\t    if (lineView.background) {\n\t      if (cls) lineView.background.className = cls;\n\t      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n\t    } else if (cls) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n\t    }\n\t  }\n\t\n\t  // Wrapper around buildLineContent which will reuse the structure\n\t  // in display.externalMeasured when possible.\n\t  function getLineContent(cm, lineView) {\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && ext.line == lineView.line) {\n\t      cm.display.externalMeasured = null;\n\t      lineView.measure = ext.measure;\n\t      return ext.built;\n\t    }\n\t    return buildLineContent(cm, lineView);\n\t  }\n\t\n\t  // Redraw the line's text. Interacts with the background and text\n\t  // classes because the mode may output tokens that influence these\n\t  // classes.\n\t  function updateLineText(cm, lineView) {\n\t    var cls = lineView.text.className;\n\t    var built = getLineContent(cm, lineView);\n\t    if (lineView.text == lineView.node) lineView.node = built.pre;\n\t    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n\t    lineView.text = built.pre;\n\t    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n\t      lineView.bgClass = built.bgClass;\n\t      lineView.textClass = built.textClass;\n\t      updateLineClasses(lineView);\n\t    } else if (cls) {\n\t      lineView.text.className = cls;\n\t    }\n\t  }\n\t\n\t  function updateLineClasses(lineView) {\n\t    updateLineBackground(lineView);\n\t    if (lineView.line.wrapClass)\n\t      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n\t    else if (lineView.node != lineView.text)\n\t      lineView.node.className = \"\";\n\t    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n\t    lineView.text.className = textClass || \"\";\n\t  }\n\t\n\t  function updateLineGutter(cm, lineView, lineN, dims) {\n\t    if (lineView.gutter) {\n\t      lineView.node.removeChild(lineView.gutter);\n\t      lineView.gutter = null;\n\t    }\n\t    if (lineView.gutterBackground) {\n\t      lineView.node.removeChild(lineView.gutterBackground);\n\t      lineView.gutterBackground = null;\n\t    }\n\t    if (lineView.line.gutterClass) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n\t                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n\t                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n\t      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n\t    }\n\t    var markers = lineView.line.gutterMarkers;\n\t    if (cm.options.lineNumbers || markers) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n\t                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n\t      cm.display.input.setUneditable(gutterWrap);\n\t      wrap.insertBefore(gutterWrap, lineView.text);\n\t      if (lineView.line.gutterClass)\n\t        gutterWrap.className += \" \" + lineView.line.gutterClass;\n\t      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n\t        lineView.lineNumber = gutterWrap.appendChild(\n\t          elt(\"div\", lineNumberFor(cm.options, lineN),\n\t              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n\t              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n\t              + cm.display.lineNumInnerWidth + \"px\"));\n\t      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n\t        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n\t        if (found)\n\t          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n\t                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateLineWidgets(cm, lineView, dims) {\n\t    if (lineView.alignable) lineView.alignable = null;\n\t    for (var node = lineView.node.firstChild, next; node; node = next) {\n\t      var next = node.nextSibling;\n\t      if (node.className == \"CodeMirror-linewidget\")\n\t        lineView.node.removeChild(node);\n\t    }\n\t    insertLineWidgets(cm, lineView, dims);\n\t  }\n\t\n\t  // Build a line's DOM representation from scratch\n\t  function buildLineElement(cm, lineView, lineN, dims) {\n\t    var built = getLineContent(cm, lineView);\n\t    lineView.text = lineView.node = built.pre;\n\t    if (built.bgClass) lineView.bgClass = built.bgClass;\n\t    if (built.textClass) lineView.textClass = built.textClass;\n\t\n\t    updateLineClasses(lineView);\n\t    updateLineGutter(cm, lineView, lineN, dims);\n\t    insertLineWidgets(cm, lineView, dims);\n\t    return lineView.node;\n\t  }\n\t\n\t  // A lineView may contain multiple logical lines (when merged by\n\t  // collapsed spans). The widgets for all of them need to be drawn.\n\t  function insertLineWidgets(cm, lineView, dims) {\n\t    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\t    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n\t  }\n\t\n\t  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n\t    if (!line.widgets) return;\n\t    var wrap = ensureLineWrapped(lineView);\n\t    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n\t      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\t      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      positionLineWidget(widget, node, lineView, dims);\n\t      cm.display.input.setUneditable(node);\n\t      if (allowAbove && widget.above)\n\t        wrap.insertBefore(node, lineView.gutter || lineView.text);\n\t      else\n\t        wrap.appendChild(node);\n\t      signalLater(widget, \"redraw\");\n\t    }\n\t  }\n\t\n\t  function positionLineWidget(widget, node, lineView, dims) {\n\t    if (widget.noHScroll) {\n\t      (lineView.alignable || (lineView.alignable = [])).push(node);\n\t      var width = dims.wrapperWidth;\n\t      node.style.left = dims.fixedPos + \"px\";\n\t      if (!widget.coverGutter) {\n\t        width -= dims.gutterTotalWidth;\n\t        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n\t      }\n\t      node.style.width = width + \"px\";\n\t    }\n\t    if (widget.coverGutter) {\n\t      node.style.zIndex = 5;\n\t      node.style.position = \"relative\";\n\t      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n\t    }\n\t  }\n\t\n\t  // POSITION OBJECT\n\t\n\t  // A Pos instance represents a position within the text.\n\t  var Pos = CodeMirror.Pos = function(line, ch) {\n\t    if (!(this instanceof Pos)) return new Pos(line, ch);\n\t    this.line = line; this.ch = ch;\n\t  };\n\t\n\t  // Compare two positions, return 0 if they are the same, a negative\n\t  // number when a is less, and a positive number otherwise.\n\t  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\t\n\t  function copyPos(x) {return Pos(x.line, x.ch);}\n\t  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n\t  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\t\n\t  // INPUT HANDLING\n\t\n\t  function ensureFocus(cm) {\n\t    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n\t  }\n\t\n\t  // This will be set to an array of strings when copying, so that,\n\t  // when pasting, we know what kind of selections the copied text\n\t  // was made out of.\n\t  var lastCopied = null;\n\t\n\t  function applyTextInput(cm, inserted, deleted, sel, origin) {\n\t    var doc = cm.doc;\n\t    cm.display.shift = false;\n\t    if (!sel) sel = doc.sel;\n\t\n\t    var paste = cm.state.pasteIncoming || origin == \"paste\";\n\t    var textLines = doc.splitLines(inserted), multiPaste = null;\n\t    // When pasing N lines into N selections, insert one line per selection\n\t    if (paste && sel.ranges.length > 1) {\n\t      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n\t        if (sel.ranges.length % lastCopied.length == 0) {\n\t          multiPaste = [];\n\t          for (var i = 0; i < lastCopied.length; i++)\n\t            multiPaste.push(doc.splitLines(lastCopied[i]));\n\t        }\n\t      } else if (textLines.length == sel.ranges.length) {\n\t        multiPaste = map(textLines, function(l) { return [l]; });\n\t      }\n\t    }\n\t\n\t    // Normal behavior is to insert the new text into every selection\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      var from = range.from(), to = range.to();\n\t      if (range.empty()) {\n\t        if (deleted && deleted > 0) // Handle deletion\n\t          from = Pos(from.line, from.ch - deleted);\n\t        else if (cm.state.overwrite && !paste) // Handle overwrite\n\t          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n\t      }\n\t      var updateInput = cm.curOp.updateInput;\n\t      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n\t                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n\t      makeChange(cm.doc, changeEvent);\n\t      signalLater(cm, \"inputRead\", cm, changeEvent);\n\t    }\n\t    if (inserted && !paste)\n\t      triggerElectric(cm, inserted);\n\t\n\t    ensureCursorVisible(cm);\n\t    cm.curOp.updateInput = updateInput;\n\t    cm.curOp.typing = true;\n\t    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n\t  }\n\t\n\t  function handlePaste(e, cm) {\n\t    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n\t    if (pasted) {\n\t      e.preventDefault();\n\t      if (!cm.isReadOnly() && !cm.options.disableInput)\n\t        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n\t      return true;\n\t    }\n\t  }\n\t\n\t  function triggerElectric(cm, inserted) {\n\t    // When an 'electric' character is inserted, immediately trigger a reindent\n\t    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n\t    var sel = cm.doc.sel;\n\t\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n\t      var mode = cm.getModeAt(range.head);\n\t      var indented = false;\n\t      if (mode.electricChars) {\n\t        for (var j = 0; j < mode.electricChars.length; j++)\n\t          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n\t            indented = indentLine(cm, range.head.line, \"smart\");\n\t            break;\n\t          }\n\t      } else if (mode.electricInput) {\n\t        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n\t          indented = indentLine(cm, range.head.line, \"smart\");\n\t      }\n\t      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n\t    }\n\t  }\n\t\n\t  function copyableRanges(cm) {\n\t    var text = [], ranges = [];\n\t    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n\t      var line = cm.doc.sel.ranges[i].head.line;\n\t      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n\t      ranges.push(lineRange);\n\t      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n\t    }\n\t    return {text: text, ranges: ranges};\n\t  }\n\t\n\t  function disableBrowserMagic(field) {\n\t    field.setAttribute(\"autocorrect\", \"off\");\n\t    field.setAttribute(\"autocapitalize\", \"off\");\n\t    field.setAttribute(\"spellcheck\", \"false\");\n\t  }\n\t\n\t  // TEXTAREA INPUT STYLE\n\t\n\t  function TextareaInput(cm) {\n\t    this.cm = cm;\n\t    // See input.poll and input.reset\n\t    this.prevInput = \"\";\n\t\n\t    // Flag that indicates whether we expect input to appear real soon\n\t    // now (after some event like 'keypress' or 'input') and are\n\t    // polling intensively.\n\t    this.pollingFast = false;\n\t    // Self-resetting timeout for the poller\n\t    this.polling = new Delayed();\n\t    // Tracks when input.reset has punted to just putting a short\n\t    // string into the textarea instead of the full selection.\n\t    this.inaccurateSelection = false;\n\t    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\t    this.hasSelection = false;\n\t    this.composing = null;\n\t  };\n\t\n\t  function hiddenTextarea() {\n\t    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n\t    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n\t    // The textarea is kept positioned near the cursor to prevent the\n\t    // fact that it'll be scrolled into view on input from scrolling\n\t    // our fake cursor out of view. On webkit, when wrap=off, paste is\n\t    // very slow. So make the area wide instead.\n\t    if (webkit) te.style.width = \"1000px\";\n\t    else te.setAttribute(\"wrap\", \"off\");\n\t    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\t    if (ios) te.style.border = \"1px solid black\";\n\t    disableBrowserMagic(te);\n\t    return div;\n\t  }\n\t\n\t  TextareaInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = this.cm;\n\t\n\t      // Wraps and hides input textarea\n\t      var div = this.wrapper = hiddenTextarea();\n\t      // The semihidden textarea that is focused when the editor is\n\t      // focused, and receives input.\n\t      var te = this.textarea = div.firstChild;\n\t      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\t\n\t      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\t      if (ios) te.style.width = \"0px\";\n\t\n\t      on(te, \"input\", function() {\n\t        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n\t        input.poll();\n\t      });\n\t\n\t      on(te, \"paste\", function(e) {\n\t        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\t\n\t        cm.state.pasteIncoming = true;\n\t        input.fastPoll();\n\t      });\n\t\n\t      function prepareCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (input.inaccurateSelection) {\n\t            input.prevInput = \"\";\n\t            input.inaccurateSelection = false;\n\t            te.value = lastCopied.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n\t          } else {\n\t            input.prevInput = \"\";\n\t            te.value = ranges.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        }\n\t        if (e.type == \"cut\") cm.state.cutIncoming = true;\n\t      }\n\t      on(te, \"cut\", prepareCopyCut);\n\t      on(te, \"copy\", prepareCopyCut);\n\t\n\t      on(display.scroller, \"paste\", function(e) {\n\t        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n\t        cm.state.pasteIncoming = true;\n\t        input.focus();\n\t      });\n\t\n\t      // Prevent normal selection in the editor (we handle our own)\n\t      on(display.lineSpace, \"selectstart\", function(e) {\n\t        if (!eventInWidget(display, e)) e_preventDefault(e);\n\t      });\n\t\n\t      on(te, \"compositionstart\", function() {\n\t        var start = cm.getCursor(\"from\");\n\t        if (input.composing) input.composing.range.clear()\n\t        input.composing = {\n\t          start: start,\n\t          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n\t        };\n\t      });\n\t      on(te, \"compositionend\", function() {\n\t        if (input.composing) {\n\t          input.poll();\n\t          input.composing.range.clear();\n\t          input.composing = null;\n\t        }\n\t      });\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      // Redraw the selection and/or cursor\n\t      var cm = this.cm, display = cm.display, doc = cm.doc;\n\t      var result = prepareSelection(cm);\n\t\n\t      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\t      if (cm.options.moveInputWithCursor) {\n\t        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n\t        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n\t        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n\t                                            headPos.top + lineOff.top - wrapOff.top));\n\t        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n\t                                             headPos.left + lineOff.left - wrapOff.left));\n\t      }\n\t\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(drawn) {\n\t      var cm = this.cm, display = cm.display;\n\t      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n\t      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\t      if (drawn.teTop != null) {\n\t        this.wrapper.style.top = drawn.teTop + \"px\";\n\t        this.wrapper.style.left = drawn.teLeft + \"px\";\n\t      }\n\t    },\n\t\n\t    // Reset the input to correspond to the selection (or to be empty,\n\t    // when not typing and nothing is selected)\n\t    reset: function(typing) {\n\t      if (this.contextMenuPending) return;\n\t      var minimal, selected, cm = this.cm, doc = cm.doc;\n\t      if (cm.somethingSelected()) {\n\t        this.prevInput = \"\";\n\t        var range = doc.sel.primary();\n\t        minimal = hasCopyEvent &&\n\t          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n\t        var content = minimal ? \"-\" : selected || cm.getSelection();\n\t        this.textarea.value = content;\n\t        if (cm.state.focused) selectInput(this.textarea);\n\t        if (ie && ie_version >= 9) this.hasSelection = content;\n\t      } else if (!typing) {\n\t        this.prevInput = this.textarea.value = \"\";\n\t        if (ie && ie_version >= 9) this.hasSelection = null;\n\t      }\n\t      this.inaccurateSelection = minimal;\n\t    },\n\t\n\t    getField: function() { return this.textarea; },\n\t\n\t    supportsTouch: function() { return false; },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n\t        try { this.textarea.focus(); }\n\t        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\t      }\n\t    },\n\t\n\t    blur: function() { this.textarea.blur(); },\n\t\n\t    resetPosition: function() {\n\t      this.wrapper.style.top = this.wrapper.style.left = 0;\n\t    },\n\t\n\t    receivedFocus: function() { this.slowPoll(); },\n\t\n\t    // Poll for input changes, using the normal rate of polling. This\n\t    // runs as long as the editor is focused.\n\t    slowPoll: function() {\n\t      var input = this;\n\t      if (input.pollingFast) return;\n\t      input.polling.set(this.cm.options.pollInterval, function() {\n\t        input.poll();\n\t        if (input.cm.state.focused) input.slowPoll();\n\t      });\n\t    },\n\t\n\t    // When an event has just come in that is likely to add or change\n\t    // something in the input textarea, we poll faster, to ensure that\n\t    // the change appears on the screen quickly.\n\t    fastPoll: function() {\n\t      var missed = false, input = this;\n\t      input.pollingFast = true;\n\t      function p() {\n\t        var changed = input.poll();\n\t        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n\t        else {input.pollingFast = false; input.slowPoll();}\n\t      }\n\t      input.polling.set(20, p);\n\t    },\n\t\n\t    // Read input from the textarea, and update the document to match.\n\t    // When something is selected, it is present in the textarea, and\n\t    // selected (unless it is huge, in which case a placeholder is\n\t    // used). When nothing is selected, the cursor sits after previously\n\t    // seen text (can be empty), which is stored in prevInput (we must\n\t    // not reset the textarea when typing, because that breaks IME).\n\t    poll: function() {\n\t      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n\t      // Since this is called a *lot*, try to bail out as cheaply as\n\t      // possible when it is clear that nothing happened. hasSelection\n\t      // will be the case when there is a lot of text in the textarea,\n\t      // in which case reading its value would be expensive.\n\t      if (this.contextMenuPending || !cm.state.focused ||\n\t          (hasSelection(input) && !prevInput && !this.composing) ||\n\t          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n\t        return false;\n\t\n\t      var text = input.value;\n\t      // If nothing changed, bail.\n\t      if (text == prevInput && !cm.somethingSelected()) return false;\n\t      // Work around nonsensical selection resetting in IE9/10, and\n\t      // inexplicable appearance of private area unicode characters on\n\t      // some key combos in Mac (#2689).\n\t      if (ie && ie_version >= 9 && this.hasSelection === text ||\n\t          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n\t        cm.display.input.reset();\n\t        return false;\n\t      }\n\t\n\t      if (cm.doc.sel == cm.display.selForContextMenu) {\n\t        var first = text.charCodeAt(0);\n\t        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n\t        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n\t      }\n\t      // Find the part of the input that is actually new\n\t      var same = 0, l = Math.min(prevInput.length, text.length);\n\t      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\t\n\t      var self = this;\n\t      runInOp(cm, function() {\n\t        applyTextInput(cm, text.slice(same), prevInput.length - same,\n\t                       null, self.composing ? \"*compose\" : null);\n\t\n\t        // Don't leave long text in the textarea, since it makes further polling slow\n\t        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n\t        else self.prevInput = text;\n\t\n\t        if (self.composing) {\n\t          self.composing.range.clear();\n\t          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n\t                                             {className: \"CodeMirror-composing\"});\n\t        }\n\t      });\n\t      return true;\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      if (this.pollingFast && this.poll()) this.pollingFast = false;\n\t    },\n\t\n\t    onKeyPress: function() {\n\t      if (ie && ie_version >= 9) this.hasSelection = null;\n\t      this.fastPoll();\n\t    },\n\t\n\t    onContextMenu: function(e) {\n\t      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n\t      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n\t      if (!pos || presto) return; // Opera is difficult.\n\t\n\t      // Reset the current text selection only if the click is done outside of the selection\n\t      // and 'resetSelectionOnContextMenu' option is true.\n\t      var reset = cm.options.resetSelectionOnContextMenu;\n\t      if (reset && cm.doc.sel.contains(pos) == -1)\n\t        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\t\n\t      var oldCSS = te.style.cssText;\n\t      input.wrapper.style.position = \"absolute\";\n\t      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n\t        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n\t        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n\t        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n\t      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n\t      display.input.focus();\n\t      if (webkit) window.scrollTo(null, oldScrollY);\n\t      display.input.reset();\n\t      // Adds \"Select all\" to context menu in FF\n\t      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n\t      input.contextMenuPending = true;\n\t      display.selForContextMenu = cm.doc.sel;\n\t      clearTimeout(display.detectingSelectAll);\n\t\n\t      // Select-all will be greyed out if there's nothing to select, so\n\t      // this adds a zero-width space so that we can later check whether\n\t      // it got selected.\n\t      function prepareSelectAllHack() {\n\t        if (te.selectionStart != null) {\n\t          var selected = cm.somethingSelected();\n\t          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n\t          te.value = \"\\u21da\"; // Used to catch context-menu undo\n\t          te.value = extval;\n\t          input.prevInput = selected ? \"\" : \"\\u200b\";\n\t          te.selectionStart = 1; te.selectionEnd = extval.length;\n\t          // Re-set this, in case some other handler touched the\n\t          // selection in the meantime.\n\t          display.selForContextMenu = cm.doc.sel;\n\t        }\n\t      }\n\t      function rehide() {\n\t        input.contextMenuPending = false;\n\t        input.wrapper.style.position = \"relative\";\n\t        te.style.cssText = oldCSS;\n\t        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\t\n\t        // Try to detect the user choosing select-all\n\t        if (te.selectionStart != null) {\n\t          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n\t          var i = 0, poll = function() {\n\t            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n\t                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n\t              operation(cm, commands.selectAll)(cm);\n\t            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n\t            else display.input.reset();\n\t          };\n\t          display.detectingSelectAll = setTimeout(poll, 200);\n\t        }\n\t      }\n\t\n\t      if (ie && ie_version >= 9) prepareSelectAllHack();\n\t      if (captureRightClick) {\n\t        e_stop(e);\n\t        var mouseup = function() {\n\t          off(window, \"mouseup\", mouseup);\n\t          setTimeout(rehide, 20);\n\t        };\n\t        on(window, \"mouseup\", mouseup);\n\t      } else {\n\t        setTimeout(rehide, 50);\n\t      }\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      if (!val) this.reset();\n\t    },\n\t\n\t    setUneditable: nothing,\n\t\n\t    needsContentAttribute: false\n\t  }, TextareaInput.prototype);\n\t\n\t  // CONTENTEDITABLE INPUT STYLE\n\t\n\t  function ContentEditableInput(cm) {\n\t    this.cm = cm;\n\t    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n\t    this.polling = new Delayed();\n\t    this.gracePeriod = false;\n\t  }\n\t\n\t  ContentEditableInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = input.cm;\n\t      var div = input.div = display.lineDiv;\n\t      disableBrowserMagic(div);\n\t\n\t      on(div, \"paste\", function(e) {\n\t        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);\n\t      })\n\t\n\t      on(div, \"compositionstart\", function(e) {\n\t        var data = e.data;\n\t        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n\t        if (!data) return;\n\t        var prim = cm.doc.sel.primary();\n\t        var line = cm.getLine(prim.head.line);\n\t        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n\t        if (found > -1 && found <= prim.head.ch)\n\t          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n\t                                                Pos(prim.head.line, found + data.length));\n\t      });\n\t      on(div, \"compositionupdate\", function(e) {\n\t        input.composing.data = e.data;\n\t      });\n\t      on(div, \"compositionend\", function(e) {\n\t        var ours = input.composing;\n\t        if (!ours) return;\n\t        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n\t          ours.data = e.data;\n\t        // Need a small delay to prevent other code (input event,\n\t        // selection polling) from doing damage when fired right after\n\t        // compositionend.\n\t        setTimeout(function() {\n\t          if (!ours.handled)\n\t            input.applyComposition(ours);\n\t          if (input.composing == ours)\n\t            input.composing = null;\n\t        }, 50);\n\t      });\n\t\n\t      on(div, \"touchstart\", function() {\n\t        input.forceCompositionEnd();\n\t      });\n\t\n\t      on(div, \"input\", function() {\n\t        if (input.composing) return;\n\t        if (cm.isReadOnly() || !input.pollContent())\n\t          runInOp(input.cm, function() {regChange(cm);});\n\t      });\n\t\n\t      function onCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.operation(function() {\n\t              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n\t              cm.replaceSelection(\"\", null, \"cut\");\n\t            });\n\t          }\n\t        }\n\t        // iOS exposes the clipboard API, but seems to discard content inserted into it\n\t        if (e.clipboardData && !ios) {\n\t          e.preventDefault();\n\t          e.clipboardData.clearData();\n\t          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n\t        } else {\n\t          // Old-fashioned briefly-focus-a-textarea hack\n\t          var kludge = hiddenTextarea(), te = kludge.firstChild;\n\t          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n\t          te.value = lastCopied.join(\"\\n\");\n\t          var hadFocus = document.activeElement;\n\t          selectInput(te);\n\t          setTimeout(function() {\n\t            cm.display.lineSpace.removeChild(kludge);\n\t            hadFocus.focus();\n\t          }, 50);\n\t        }\n\t      }\n\t      on(div, \"copy\", onCopyCut);\n\t      on(div, \"cut\", onCopyCut);\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      var result = prepareSelection(this.cm, false);\n\t      result.focus = this.cm.state.focused;\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(info) {\n\t      if (!info || !this.cm.display.view.length) return;\n\t      if (info.focus) this.showPrimarySelection();\n\t      this.showMultipleSelections(info);\n\t    },\n\t\n\t    showPrimarySelection: function() {\n\t      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n\t      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n\t      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n\t      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n\t          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n\t          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n\t        return;\n\t\n\t      var start = posToDOM(this.cm, prim.from());\n\t      var end = posToDOM(this.cm, prim.to());\n\t      if (!start && !end) return;\n\t\n\t      var view = this.cm.display.view;\n\t      var old = sel.rangeCount && sel.getRangeAt(0);\n\t      if (!start) {\n\t        start = {node: view[0].measure.map[2], offset: 0};\n\t      } else if (!end) { // FIXME dangerously hacky\n\t        var measure = view[view.length - 1].measure;\n\t        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n\t        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n\t      }\n\t\n\t      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n\t      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\t      if (rng) {\n\t        if (!gecko && this.cm.state.focused) {\n\t          sel.collapse(start.node, start.offset);\n\t          if (!rng.collapsed) sel.addRange(rng);\n\t        } else {\n\t          sel.removeAllRanges();\n\t          sel.addRange(rng);\n\t        }\n\t        if (old && sel.anchorNode == null) sel.addRange(old);\n\t        else if (gecko) this.startGracePeriod();\n\t      }\n\t      this.rememberSelection();\n\t    },\n\t\n\t    startGracePeriod: function() {\n\t      var input = this;\n\t      clearTimeout(this.gracePeriod);\n\t      this.gracePeriod = setTimeout(function() {\n\t        input.gracePeriod = false;\n\t        if (input.selectionChanged())\n\t          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n\t      }, 20);\n\t    },\n\t\n\t    showMultipleSelections: function(info) {\n\t      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n\t      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n\t    },\n\t\n\t    rememberSelection: function() {\n\t      var sel = window.getSelection();\n\t      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n\t      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n\t    },\n\t\n\t    selectionInEditor: function() {\n\t      var sel = window.getSelection();\n\t      if (!sel.rangeCount) return false;\n\t      var node = sel.getRangeAt(0).commonAncestorContainer;\n\t      return contains(this.div, node);\n\t    },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n\t    },\n\t    blur: function() { this.div.blur(); },\n\t    getField: function() { return this.div; },\n\t\n\t    supportsTouch: function() { return true; },\n\t\n\t    receivedFocus: function() {\n\t      var input = this;\n\t      if (this.selectionInEditor())\n\t        this.pollSelection();\n\t      else\n\t        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\t\n\t      function poll() {\n\t        if (input.cm.state.focused) {\n\t          input.pollSelection();\n\t          input.polling.set(input.cm.options.pollInterval, poll);\n\t        }\n\t      }\n\t      this.polling.set(this.cm.options.pollInterval, poll);\n\t    },\n\t\n\t    selectionChanged: function() {\n\t      var sel = window.getSelection();\n\t      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n\t        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n\t    },\n\t\n\t    pollSelection: function() {\n\t      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n\t        var sel = window.getSelection(), cm = this.cm;\n\t        this.rememberSelection();\n\t        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n\t        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\t        if (anchor && head) runInOp(cm, function() {\n\t          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\t          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n\t        });\n\t      }\n\t    },\n\t\n\t    pollContent: function() {\n\t      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n\t      var from = sel.from(), to = sel.to();\n\t      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\t\n\t      var fromIndex;\n\t      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n\t        var fromLine = lineNo(display.view[0].line);\n\t        var fromNode = display.view[0].node;\n\t      } else {\n\t        var fromLine = lineNo(display.view[fromIndex].line);\n\t        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n\t      }\n\t      var toIndex = findViewIndex(cm, to.line);\n\t      if (toIndex == display.view.length - 1) {\n\t        var toLine = display.viewTo - 1;\n\t        var toNode = display.lineDiv.lastChild;\n\t      } else {\n\t        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n\t        var toNode = display.view[toIndex + 1].node.previousSibling;\n\t      }\n\t\n\t      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n\t      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\t      while (newText.length > 1 && oldText.length > 1) {\n\t        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n\t        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n\t        else break;\n\t      }\n\t\n\t      var cutFront = 0, cutEnd = 0;\n\t      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n\t      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n\t        ++cutFront;\n\t      var newBot = lst(newText), oldBot = lst(oldText);\n\t      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n\t                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\t      while (cutEnd < maxCutEnd &&\n\t             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n\t        ++cutEnd;\n\t\n\t      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n\t      newText[0] = newText[0].slice(cutFront);\n\t\n\t      var chFrom = Pos(fromLine, cutFront);\n\t      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\t      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n\t        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\t        return true;\n\t      }\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    reset: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    forceCompositionEnd: function() {\n\t      if (!this.composing || this.composing.handled) return;\n\t      this.applyComposition(this.composing);\n\t      this.composing.handled = true;\n\t      this.div.blur();\n\t      this.div.focus();\n\t    },\n\t    applyComposition: function(composing) {\n\t      if (this.cm.isReadOnly())\n\t        operation(this.cm, regChange)(this.cm)\n\t      else if (composing.data && composing.data != composing.startData)\n\t        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n\t    },\n\t\n\t    setUneditable: function(node) {\n\t      node.contentEditable = \"false\"\n\t    },\n\t\n\t    onKeyPress: function(e) {\n\t      e.preventDefault();\n\t      if (!this.cm.isReadOnly())\n\t        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      this.div.contentEditable = String(val != \"nocursor\")\n\t    },\n\t\n\t    onContextMenu: nothing,\n\t    resetPosition: nothing,\n\t\n\t    needsContentAttribute: true\n\t  }, ContentEditableInput.prototype);\n\t\n\t  function posToDOM(cm, pos) {\n\t    var view = findViewForLine(cm, pos.line);\n\t    if (!view || view.hidden) return null;\n\t    var line = getLine(cm.doc, pos.line);\n\t    var info = mapFromLineView(view, line, pos.line);\n\t\n\t    var order = getOrder(line), side = \"left\";\n\t    if (order) {\n\t      var partPos = getBidiPartAt(order, pos.ch);\n\t      side = partPos % 2 ? \"right\" : \"left\";\n\t    }\n\t    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n\t    result.offset = result.collapse == \"right\" ? result.end : result.start;\n\t    return result;\n\t  }\n\t\n\t  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\t\n\t  function domToPos(cm, node, offset) {\n\t    var lineNode;\n\t    if (node == cm.display.lineDiv) {\n\t      lineNode = cm.display.lineDiv.childNodes[offset];\n\t      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n\t      node = null; offset = 0;\n\t    } else {\n\t      for (lineNode = node;; lineNode = lineNode.parentNode) {\n\t        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n\t        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n\t      }\n\t    }\n\t    for (var i = 0; i < cm.display.view.length; i++) {\n\t      var lineView = cm.display.view[i];\n\t      if (lineView.node == lineNode)\n\t        return locateNodeInLineView(lineView, node, offset);\n\t    }\n\t  }\n\t\n\t  function locateNodeInLineView(lineView, node, offset) {\n\t    var wrapper = lineView.text.firstChild, bad = false;\n\t    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n\t    if (node == wrapper) {\n\t      bad = true;\n\t      node = wrapper.childNodes[offset];\n\t      offset = 0;\n\t      if (!node) {\n\t        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n\t        return badPos(Pos(lineNo(line), line.text.length), bad);\n\t      }\n\t    }\n\t\n\t    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n\t    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n\t      textNode = node.firstChild;\n\t      if (offset) offset = textNode.nodeValue.length;\n\t    }\n\t    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n\t    var measure = lineView.measure, maps = measure.maps;\n\t\n\t    function find(textNode, topNode, offset) {\n\t      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n\t        var map = i < 0 ? measure.map : maps[i];\n\t        for (var j = 0; j < map.length; j += 3) {\n\t          var curNode = map[j + 2];\n\t          if (curNode == textNode || curNode == topNode) {\n\t            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n\t            var ch = map[j] + offset;\n\t            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n\t            return Pos(line, ch);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    var found = find(textNode, topNode, offset);\n\t    if (found) return badPos(found, bad);\n\t\n\t    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\t    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n\t      found = find(after, after.firstChild, 0);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch - dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n\t      found = find(before, before.firstChild, -1);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch + dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t  }\n\t\n\t  function domTextBetween(cm, from, to, fromLine, toLine) {\n\t    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n\t    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n\t    function walk(node) {\n\t      if (node.nodeType == 1) {\n\t        var cmText = node.getAttribute(\"cm-text\");\n\t        if (cmText != null) {\n\t          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n\t          text += cmText;\n\t          return;\n\t        }\n\t        var markerID = node.getAttribute(\"cm-marker\"), range;\n\t        if (markerID) {\n\t          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\t          if (found.length && (range = found[0].find()))\n\t            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n\t          return;\n\t        }\n\t        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n\t        for (var i = 0; i < node.childNodes.length; i++)\n\t          walk(node.childNodes[i]);\n\t        if (/^(pre|div|p)$/i.test(node.nodeName))\n\t          closing = true;\n\t      } else if (node.nodeType == 3) {\n\t        var val = node.nodeValue;\n\t        if (!val) return;\n\t        if (closing) {\n\t          text += lineSep;\n\t          closing = false;\n\t        }\n\t        text += val;\n\t      }\n\t    }\n\t    for (;;) {\n\t      walk(from);\n\t      if (from == to) break;\n\t      from = from.nextSibling;\n\t    }\n\t    return text;\n\t  }\n\t\n\t  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\t\n\t  // SELECTION / CURSOR\n\t\n\t  // Selection objects are immutable. A new one is created every time\n\t  // the selection changes. A selection is one or more non-overlapping\n\t  // (and non-touching) ranges, sorted, and an integer that indicates\n\t  // which one is the primary selection (the one that's scrolled into\n\t  // view, that getCursor returns, etc).\n\t  function Selection(ranges, primIndex) {\n\t    this.ranges = ranges;\n\t    this.primIndex = primIndex;\n\t  }\n\t\n\t  Selection.prototype = {\n\t    primary: function() { return this.ranges[this.primIndex]; },\n\t    equals: function(other) {\n\t      if (other == this) return true;\n\t      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var here = this.ranges[i], there = other.ranges[i];\n\t        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n\t      }\n\t      return true;\n\t    },\n\t    deepCopy: function() {\n\t      for (var out = [], i = 0; i < this.ranges.length; i++)\n\t        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n\t      return new Selection(out, this.primIndex);\n\t    },\n\t    somethingSelected: function() {\n\t      for (var i = 0; i < this.ranges.length; i++)\n\t        if (!this.ranges[i].empty()) return true;\n\t      return false;\n\t    },\n\t    contains: function(pos, end) {\n\t      if (!end) end = pos;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var range = this.ranges[i];\n\t        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n\t          return i;\n\t      }\n\t      return -1;\n\t    }\n\t  };\n\t\n\t  function Range(anchor, head) {\n\t    this.anchor = anchor; this.head = head;\n\t  }\n\t\n\t  Range.prototype = {\n\t    from: function() { return minPos(this.anchor, this.head); },\n\t    to: function() { return maxPos(this.anchor, this.head); },\n\t    empty: function() {\n\t      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n\t    }\n\t  };\n\t\n\t  // Take an unsorted, potentially overlapping set of ranges, and\n\t  // build a selection out of it. 'Consumes' ranges array (modifying\n\t  // it).\n\t  function normalizeSelection(ranges, primIndex) {\n\t    var prim = ranges[primIndex];\n\t    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n\t    primIndex = indexOf(ranges, prim);\n\t    for (var i = 1; i < ranges.length; i++) {\n\t      var cur = ranges[i], prev = ranges[i - 1];\n\t      if (cmp(prev.to(), cur.from()) >= 0) {\n\t        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n\t        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\t        if (i <= primIndex) --primIndex;\n\t        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n\t      }\n\t    }\n\t    return new Selection(ranges, primIndex);\n\t  }\n\t\n\t  function simpleSelection(anchor, head) {\n\t    return new Selection([new Range(anchor, head || anchor)], 0);\n\t  }\n\t\n\t  // Most of the external API clips given positions to make sure they\n\t  // actually exist within the document.\n\t  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n\t  function clipPos(doc, pos) {\n\t    if (pos.line < doc.first) return Pos(doc.first, 0);\n\t    var last = doc.first + doc.size - 1;\n\t    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n\t    return clipToLen(pos, getLine(doc, pos.line).text.length);\n\t  }\n\t  function clipToLen(pos, linelen) {\n\t    var ch = pos.ch;\n\t    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n\t    else if (ch < 0) return Pos(pos.line, 0);\n\t    else return pos;\n\t  }\n\t  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\t  function clipPosArray(doc, array) {\n\t    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n\t    return out;\n\t  }\n\t\n\t  // SELECTION UPDATES\n\t\n\t  // The 'scroll' parameter given to many of these indicated whether\n\t  // the new cursor position should be scrolled into view after\n\t  // modifying the selection.\n\t\n\t  // If shift is held or the extend flag is set, extends a range to\n\t  // include a given position (and optionally a second position).\n\t  // Otherwise, simply returns the range between the given positions.\n\t  // Used for cursor motion and such.\n\t  function extendRange(doc, range, head, other) {\n\t    if (doc.cm && doc.cm.display.shift || doc.extend) {\n\t      var anchor = range.anchor;\n\t      if (other) {\n\t        var posBefore = cmp(head, anchor) < 0;\n\t        if (posBefore != (cmp(other, anchor) < 0)) {\n\t          anchor = head;\n\t          head = other;\n\t        } else if (posBefore != (cmp(head, other) < 0)) {\n\t          head = other;\n\t        }\n\t      }\n\t      return new Range(anchor, head);\n\t    } else {\n\t      return new Range(other || head, head);\n\t    }\n\t  }\n\t\n\t  // Extend the primary selection range, discard the rest.\n\t  function extendSelection(doc, head, other, options) {\n\t    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n\t  }\n\t\n\t  // Extend all selections (pos is an array of selections with length\n\t  // equal the number of selections)\n\t  function extendSelections(doc, heads, options) {\n\t    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n\t      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n\t    var newSel = normalizeSelection(out, doc.sel.primIndex);\n\t    setSelection(doc, newSel, options);\n\t  }\n\t\n\t  // Updates a single range in the selection.\n\t  function replaceOneSelection(doc, i, range, options) {\n\t    var ranges = doc.sel.ranges.slice(0);\n\t    ranges[i] = range;\n\t    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n\t  }\n\t\n\t  // Reset the selection to a single range.\n\t  function setSimpleSelection(doc, anchor, head, options) {\n\t    setSelection(doc, simpleSelection(anchor, head), options);\n\t  }\n\t\n\t  // Give beforeSelectionChange handlers a change to influence a\n\t  // selection update.\n\t  function filterSelectionChange(doc, sel, options) {\n\t    var obj = {\n\t      ranges: sel.ranges,\n\t      update: function(ranges) {\n\t        this.ranges = [];\n\t        for (var i = 0; i < ranges.length; i++)\n\t          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n\t                                     clipPos(doc, ranges[i].head));\n\t      },\n\t      origin: options && options.origin\n\t    };\n\t    signal(doc, \"beforeSelectionChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n\t    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n\t    else return sel;\n\t  }\n\t\n\t  function setSelectionReplaceHistory(doc, sel, options) {\n\t    var done = doc.history.done, last = lst(done);\n\t    if (last && last.ranges) {\n\t      done[done.length - 1] = sel;\n\t      setSelectionNoUndo(doc, sel, options);\n\t    } else {\n\t      setSelection(doc, sel, options);\n\t    }\n\t  }\n\t\n\t  // Set a new selection.\n\t  function setSelection(doc, sel, options) {\n\t    setSelectionNoUndo(doc, sel, options);\n\t    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n\t  }\n\t\n\t  function setSelectionNoUndo(doc, sel, options) {\n\t    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n\t      sel = filterSelectionChange(doc, sel, options);\n\t\n\t    var bias = options && options.bias ||\n\t      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\t\n\t    if (!(options && options.scroll === false) && doc.cm)\n\t      ensureCursorVisible(doc.cm);\n\t  }\n\t\n\t  function setSelectionInner(doc, sel) {\n\t    if (sel.equals(doc.sel)) return;\n\t\n\t    doc.sel = sel;\n\t\n\t    if (doc.cm) {\n\t      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n\t      signalCursorActivity(doc.cm);\n\t    }\n\t    signalLater(doc, \"cursorActivity\", doc);\n\t  }\n\t\n\t  // Verify that the selection does not partially select any atomic\n\t  // marked ranges.\n\t  function reCheckSelection(doc) {\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n\t  }\n\t\n\t  // Return a selection that does not partially select any atomic\n\t  // ranges.\n\t  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n\t    var out;\n\t    for (var i = 0; i < sel.ranges.length; i++) {\n\t      var range = sel.ranges[i];\n\t      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n\t      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n\t      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n\t      if (out || newAnchor != range.anchor || newHead != range.head) {\n\t        if (!out) out = sel.ranges.slice(0, i);\n\t        out[i] = new Range(newAnchor, newHead);\n\t      }\n\t    }\n\t    return out ? normalizeSelection(out, sel.primIndex) : sel;\n\t  }\n\t\n\t  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n\t    var line = getLine(doc, pos.line);\n\t    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t      var sp = line.markedSpans[i], m = sp.marker;\n\t      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n\t          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n\t        if (mayClear) {\n\t          signal(m, \"beforeCursorEnter\");\n\t          if (m.explicitlyCleared) {\n\t            if (!line.markedSpans) break;\n\t            else {--i; continue;}\n\t          }\n\t        }\n\t        if (!m.atomic) continue;\n\t\n\t        if (oldPos) {\n\t          var near = m.find(dir < 0 ? 1 : -1), diff;\n\t          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) near = movePos(doc, near, -dir, line);\n\t          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n\t            return skipAtomicInner(doc, near, pos, dir, mayClear);\n\t        }\n\t\n\t        var far = m.find(dir < 0 ? -1 : 1);\n\t        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) far = movePos(doc, far, dir, line);\n\t        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n\t      }\n\t    }\n\t    return pos;\n\t  }\n\t\n\t  // Ensure a given position is not inside an atomic range.\n\t  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n\t    var dir = bias || 1;\n\t    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n\t        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n\t    if (!found) {\n\t      doc.cantEdit = true;\n\t      return Pos(doc.first, 0);\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function movePos(doc, pos, dir, line) {\n\t    if (dir < 0 && pos.ch == 0) {\n\t      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n\t      else return null;\n\t    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n\t      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n\t      else return null;\n\t    } else {\n\t      return new Pos(pos.line, pos.ch + dir);\n\t    }\n\t  }\n\t\n\t  // SELECTION DRAWING\n\t\n\t  function updateSelection(cm) {\n\t    cm.display.input.showSelection(cm.display.input.prepareSelection());\n\t  }\n\t\n\t  function prepareSelection(cm, primary) {\n\t    var doc = cm.doc, result = {};\n\t    var curFragment = result.cursors = document.createDocumentFragment();\n\t    var selFragment = result.selection = document.createDocumentFragment();\n\t\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      if (primary === false && i == doc.sel.primIndex) continue;\n\t      var range = doc.sel.ranges[i];\n\t      var collapsed = range.empty();\n\t      if (collapsed || cm.options.showCursorWhenSelecting)\n\t        drawSelectionCursor(cm, range.head, curFragment);\n\t      if (!collapsed)\n\t        drawSelectionRange(cm, range, selFragment);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Draws a cursor for the given range\n\t  function drawSelectionCursor(cm, head, output) {\n\t    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\t\n\t    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n\t    cursor.style.left = pos.left + \"px\";\n\t    cursor.style.top = pos.top + \"px\";\n\t    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\t\n\t    if (pos.other) {\n\t      // Secondary cursor, shown when on a 'jump' in bi-directional text\n\t      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n\t      otherCursor.style.display = \"\";\n\t      otherCursor.style.left = pos.other.left + \"px\";\n\t      otherCursor.style.top = pos.other.top + \"px\";\n\t      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n\t    }\n\t  }\n\t\n\t  // Draws the given range as a highlighted selection\n\t  function drawSelectionRange(cm, range, output) {\n\t    var display = cm.display, doc = cm.doc;\n\t    var fragment = document.createDocumentFragment();\n\t    var padding = paddingH(cm.display), leftSide = padding.left;\n\t    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\t\n\t    function add(left, top, width, bottom) {\n\t      if (top < 0) top = 0;\n\t      top = Math.round(top);\n\t      bottom = Math.round(bottom);\n\t      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n\t                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n\t                               \"px; height: \" + (bottom - top) + \"px\"));\n\t    }\n\t\n\t    function drawForLine(line, fromArg, toArg) {\n\t      var lineObj = getLine(doc, line);\n\t      var lineLen = lineObj.text.length;\n\t      var start, end;\n\t      function coords(ch, bias) {\n\t        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n\t      }\n\t\n\t      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n\t        var leftPos = coords(from, \"left\"), rightPos, left, right;\n\t        if (from == to) {\n\t          rightPos = leftPos;\n\t          left = right = leftPos.left;\n\t        } else {\n\t          rightPos = coords(to - 1, \"right\");\n\t          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n\t          left = leftPos.left;\n\t          right = rightPos.right;\n\t        }\n\t        if (fromArg == null && from == 0) left = leftSide;\n\t        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n\t          add(left, leftPos.top, null, leftPos.bottom);\n\t          left = leftSide;\n\t          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n\t        }\n\t        if (toArg == null && to == lineLen) right = rightSide;\n\t        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n\t          start = leftPos;\n\t        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n\t          end = rightPos;\n\t        if (left < leftSide + 1) left = leftSide;\n\t        add(left, rightPos.top, right - left, rightPos.bottom);\n\t      });\n\t      return {start: start, end: end};\n\t    }\n\t\n\t    var sFrom = range.from(), sTo = range.to();\n\t    if (sFrom.line == sTo.line) {\n\t      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n\t    } else {\n\t      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n\t      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n\t      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n\t      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\t      if (singleVLine) {\n\t        if (leftEnd.top < rightStart.top - 2) {\n\t          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n\t          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n\t        } else {\n\t          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n\t        }\n\t      }\n\t      if (leftEnd.bottom < rightStart.top)\n\t        add(leftSide, leftEnd.bottom, null, rightStart.top);\n\t    }\n\t\n\t    output.appendChild(fragment);\n\t  }\n\t\n\t  // Cursor-blinking\n\t  function restartBlink(cm) {\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display;\n\t    clearInterval(display.blinker);\n\t    var on = true;\n\t    display.cursorDiv.style.visibility = \"\";\n\t    if (cm.options.cursorBlinkRate > 0)\n\t      display.blinker = setInterval(function() {\n\t        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n\t      }, cm.options.cursorBlinkRate);\n\t    else if (cm.options.cursorBlinkRate < 0)\n\t      display.cursorDiv.style.visibility = \"hidden\";\n\t  }\n\t\n\t  // HIGHLIGHT WORKER\n\t\n\t  function startWorker(cm, time) {\n\t    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n\t      cm.state.highlight.set(time, bind(highlightWorker, cm));\n\t  }\n\t\n\t  function highlightWorker(cm) {\n\t    var doc = cm.doc;\n\t    if (doc.frontier < doc.first) doc.frontier = doc.first;\n\t    if (doc.frontier >= cm.display.viewTo) return;\n\t    var end = +new Date + cm.options.workTime;\n\t    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n\t    var changedLines = [];\n\t\n\t    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n\t      if (doc.frontier >= cm.display.viewFrom) { // Visible\n\t        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n\t        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n\t        line.styles = highlighted.styles;\n\t        var oldCls = line.styleClasses, newCls = highlighted.classes;\n\t        if (newCls) line.styleClasses = newCls;\n\t        else if (oldCls) line.styleClasses = null;\n\t        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n\t          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\t        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n\t        if (ischange) changedLines.push(doc.frontier);\n\t        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n\t      } else {\n\t        if (line.text.length <= cm.options.maxHighlightLength)\n\t          processLine(cm, line.text, state);\n\t        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n\t      }\n\t      ++doc.frontier;\n\t      if (+new Date > end) {\n\t        startWorker(cm, cm.options.workDelay);\n\t        return true;\n\t      }\n\t    });\n\t    if (changedLines.length) runInOp(cm, function() {\n\t      for (var i = 0; i < changedLines.length; i++)\n\t        regLineChange(cm, changedLines[i], \"text\");\n\t    });\n\t  }\n\t\n\t  // Finds the line to start with when starting a parse. Tries to\n\t  // find a line with a stateAfter, so that it can start with a\n\t  // valid state. If that fails, it returns the line with the\n\t  // smallest indentation, which tends to need the least context to\n\t  // parse correctly.\n\t  function findStartLine(cm, n, precise) {\n\t    var minindent, minline, doc = cm.doc;\n\t    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\t    for (var search = n; search > lim; --search) {\n\t      if (search <= doc.first) return doc.first;\n\t      var line = getLine(doc, search - 1);\n\t      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n\t      var indented = countColumn(line.text, null, cm.options.tabSize);\n\t      if (minline == null || minindent > indented) {\n\t        minline = search - 1;\n\t        minindent = indented;\n\t      }\n\t    }\n\t    return minline;\n\t  }\n\t\n\t  function getStateBefore(cm, n, precise) {\n\t    var doc = cm.doc, display = cm.display;\n\t    if (!doc.mode.startState) return true;\n\t    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n\t    if (!state) state = startState(doc.mode);\n\t    else state = copyState(doc.mode, state);\n\t    doc.iter(pos, n, function(line) {\n\t      processLine(cm, line.text, state);\n\t      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n\t      line.stateAfter = save ? copyState(doc.mode, state) : null;\n\t      ++pos;\n\t    });\n\t    if (precise) doc.frontier = pos;\n\t    return state;\n\t  }\n\t\n\t  // POSITION MEASUREMENT\n\t\n\t  function paddingTop(display) {return display.lineSpace.offsetTop;}\n\t  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n\t  function paddingH(display) {\n\t    if (display.cachedPaddingH) return display.cachedPaddingH;\n\t    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n\t    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n\t    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n\t    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n\t    return data;\n\t  }\n\t\n\t  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n\t  function displayWidth(cm) {\n\t    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n\t  }\n\t  function displayHeight(cm) {\n\t    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n\t  }\n\t\n\t  // Ensure the lineView.wrapping.heights array is populated. This is\n\t  // an array of bottom offsets for the lines that make up a drawn\n\t  // line. When lineWrapping is on, there might be more than one\n\t  // height.\n\t  function ensureLineHeights(cm, lineView, rect) {\n\t    var wrapping = cm.options.lineWrapping;\n\t    var curWidth = wrapping && displayWidth(cm);\n\t    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n\t      var heights = lineView.measure.heights = [];\n\t      if (wrapping) {\n\t        lineView.measure.width = curWidth;\n\t        var rects = lineView.text.firstChild.getClientRects();\n\t        for (var i = 0; i < rects.length - 1; i++) {\n\t          var cur = rects[i], next = rects[i + 1];\n\t          if (Math.abs(cur.bottom - next.bottom) > 2)\n\t            heights.push((cur.bottom + next.top) / 2 - rect.top);\n\t        }\n\t      }\n\t      heights.push(rect.bottom - rect.top);\n\t    }\n\t  }\n\t\n\t  // Find a line map (mapping character offsets to text nodes) and a\n\t  // measurement cache for the given line number. (A line view might\n\t  // contain multiple lines when collapsed ranges are present.)\n\t  function mapFromLineView(lineView, line, lineN) {\n\t    if (lineView.line == line)\n\t      return {map: lineView.measure.map, cache: lineView.measure.cache};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineView.rest[i] == line)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineNo(lineView.rest[i]) > lineN)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n\t  }\n\t\n\t  // Render a line into the hidden node display.externalMeasured. Used\n\t  // when measurement is needed for a line that's not in the viewport.\n\t  function updateExternalMeasurement(cm, line) {\n\t    line = visualLine(line);\n\t    var lineN = lineNo(line);\n\t    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n\t    view.lineN = lineN;\n\t    var built = view.built = buildLineContent(cm, view);\n\t    view.text = built.pre;\n\t    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n\t    return view;\n\t  }\n\t\n\t  // Get a {top, bottom, left, right} box (in line-local coordinates)\n\t  // for a given character.\n\t  function measureChar(cm, line, ch, bias) {\n\t    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n\t  }\n\t\n\t  // Find a line view that corresponds to the given line number.\n\t  function findViewForLine(cm, lineN) {\n\t    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n\t      return cm.display.view[findViewIndex(cm, lineN)];\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n\t      return ext;\n\t  }\n\t\n\t  // Measurement can be split in two steps, the set-up work that\n\t  // applies to the whole line, and the measurement of the actual\n\t  // character. Functions like coordsChar, that need to do a lot of\n\t  // measurements in a row, can thus ensure that the set-up work is\n\t  // only done once.\n\t  function prepareMeasureForLine(cm, line) {\n\t    var lineN = lineNo(line);\n\t    var view = findViewForLine(cm, lineN);\n\t    if (view && !view.text) {\n\t      view = null;\n\t    } else if (view && view.changes) {\n\t      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n\t      cm.curOp.forceUpdate = true;\n\t    }\n\t    if (!view)\n\t      view = updateExternalMeasurement(cm, line);\n\t\n\t    var info = mapFromLineView(view, line, lineN);\n\t    return {\n\t      line: line, view: view, rect: null,\n\t      map: info.map, cache: info.cache, before: info.before,\n\t      hasHeights: false\n\t    };\n\t  }\n\t\n\t  // Given a prepared measurement object, measures the position of an\n\t  // actual character (or fetches it from the cache).\n\t  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n\t    if (prepared.before) ch = -1;\n\t    var key = ch + (bias || \"\"), found;\n\t    if (prepared.cache.hasOwnProperty(key)) {\n\t      found = prepared.cache[key];\n\t    } else {\n\t      if (!prepared.rect)\n\t        prepared.rect = prepared.view.text.getBoundingClientRect();\n\t      if (!prepared.hasHeights) {\n\t        ensureLineHeights(cm, prepared.view, prepared.rect);\n\t        prepared.hasHeights = true;\n\t      }\n\t      found = measureCharInner(cm, prepared, ch, bias);\n\t      if (!found.bogus) prepared.cache[key] = found;\n\t    }\n\t    return {left: found.left, right: found.right,\n\t            top: varHeight ? found.rtop : found.top,\n\t            bottom: varHeight ? found.rbottom : found.bottom};\n\t  }\n\t\n\t  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\t\n\t  function nodeAndOffsetInLineMap(map, ch, bias) {\n\t    var node, start, end, collapse;\n\t    // First, search the line map for the text node corresponding to,\n\t    // or closest to, the target character.\n\t    for (var i = 0; i < map.length; i += 3) {\n\t      var mStart = map[i], mEnd = map[i + 1];\n\t      if (ch < mStart) {\n\t        start = 0; end = 1;\n\t        collapse = \"left\";\n\t      } else if (ch < mEnd) {\n\t        start = ch - mStart;\n\t        end = start + 1;\n\t      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n\t        end = mEnd - mStart;\n\t        start = end - 1;\n\t        if (ch >= mEnd) collapse = \"right\";\n\t      }\n\t      if (start != null) {\n\t        node = map[i + 2];\n\t        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n\t          collapse = bias;\n\t        if (bias == \"left\" && start == 0)\n\t          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n\t            node = map[(i -= 3) + 2];\n\t            collapse = \"left\";\n\t          }\n\t        if (bias == \"right\" && start == mEnd - mStart)\n\t          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n\t            node = map[(i += 3) + 2];\n\t            collapse = \"right\";\n\t          }\n\t        break;\n\t      }\n\t    }\n\t    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n\t  }\n\t\n\t  function measureCharInner(cm, prepared, ch, bias) {\n\t    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n\t    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\t\n\t    var rect;\n\t    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n\t      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n\t        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n\t        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n\t        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n\t          rect = node.parentNode.getBoundingClientRect();\n\t        } else if (ie && cm.options.lineWrapping) {\n\t          var rects = range(node, start, end).getClientRects();\n\t          if (rects.length)\n\t            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t          else\n\t            rect = nullRect;\n\t        } else {\n\t          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n\t        }\n\t        if (rect.left || rect.right || start == 0) break;\n\t        end = start;\n\t        start = start - 1;\n\t        collapse = \"right\";\n\t      }\n\t      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n\t    } else { // If it is a widget, simply get the box for the whole widget.\n\t      if (start > 0) collapse = bias = \"right\";\n\t      var rects;\n\t      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n\t        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t      else\n\t        rect = node.getBoundingClientRect();\n\t    }\n\t    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n\t      var rSpan = node.parentNode.getClientRects()[0];\n\t      if (rSpan)\n\t        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n\t      else\n\t        rect = nullRect;\n\t    }\n\t\n\t    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n\t    var mid = (rtop + rbot) / 2;\n\t    var heights = prepared.view.measure.heights;\n\t    for (var i = 0; i < heights.length - 1; i++)\n\t      if (mid < heights[i]) break;\n\t    var top = i ? heights[i - 1] : 0, bot = heights[i];\n\t    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n\t                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n\t                  top: top, bottom: bot};\n\t    if (!rect.left && !rect.right) result.bogus = true;\n\t    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Work around problem with bounding client rects on ranges being\n\t  // returned incorrectly when zoomed on IE10 and below.\n\t  function maybeUpdateRectForZooming(measure, rect) {\n\t    if (!window.screen || screen.logicalXDPI == null ||\n\t        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n\t      return rect;\n\t    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n\t    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n\t    return {left: rect.left * scaleX, right: rect.right * scaleX,\n\t            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n\t  }\n\t\n\t  function clearLineMeasurementCacheFor(lineView) {\n\t    if (lineView.measure) {\n\t      lineView.measure.cache = {};\n\t      lineView.measure.heights = null;\n\t      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t        lineView.measure.caches[i] = {};\n\t    }\n\t  }\n\t\n\t  function clearLineMeasurementCache(cm) {\n\t    cm.display.externalMeasure = null;\n\t    removeChildren(cm.display.lineMeasure);\n\t    for (var i = 0; i < cm.display.view.length; i++)\n\t      clearLineMeasurementCacheFor(cm.display.view[i]);\n\t  }\n\t\n\t  function clearCaches(cm) {\n\t    clearLineMeasurementCache(cm);\n\t    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\t    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n\t    cm.display.lineNumChars = null;\n\t  }\n\t\n\t  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n\t  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\t\n\t  // Converts a {top, bottom, left, right} box from line-local\n\t  // coordinates into another coordinate system. Context may be one of\n\t  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n\t  // or \"page\".\n\t  function intoCoordSystem(cm, lineObj, rect, context) {\n\t    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n\t      var size = widgetHeight(lineObj.widgets[i]);\n\t      rect.top += size; rect.bottom += size;\n\t    }\n\t    if (context == \"line\") return rect;\n\t    if (!context) context = \"local\";\n\t    var yOff = heightAtLine(lineObj);\n\t    if (context == \"local\") yOff += paddingTop(cm.display);\n\t    else yOff -= cm.display.viewOffset;\n\t    if (context == \"page\" || context == \"window\") {\n\t      var lOff = cm.display.lineSpace.getBoundingClientRect();\n\t      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n\t      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n\t      rect.left += xOff; rect.right += xOff;\n\t    }\n\t    rect.top += yOff; rect.bottom += yOff;\n\t    return rect;\n\t  }\n\t\n\t  // Coverts a box from \"div\" coords to another coordinate system.\n\t  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n\t  function fromCoordSystem(cm, coords, context) {\n\t    if (context == \"div\") return coords;\n\t    var left = coords.left, top = coords.top;\n\t    // First move into \"page\" coordinate system\n\t    if (context == \"page\") {\n\t      left -= pageScrollX();\n\t      top -= pageScrollY();\n\t    } else if (context == \"local\" || !context) {\n\t      var localBox = cm.display.sizer.getBoundingClientRect();\n\t      left += localBox.left;\n\t      top += localBox.top;\n\t    }\n\t\n\t    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n\t    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n\t  }\n\t\n\t  function charCoords(cm, pos, context, lineObj, bias) {\n\t    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n\t    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n\t  }\n\t\n\t  // Returns a box for a given cursor position, which may have an\n\t  // 'other' property containing the position of the secondary cursor\n\t  // on a bidi boundary.\n\t  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n\t    lineObj = lineObj || getLine(cm.doc, pos.line);\n\t    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t    function get(ch, right) {\n\t      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\t      if (right) m.left = m.right; else m.right = m.left;\n\t      return intoCoordSystem(cm, lineObj, m, context);\n\t    }\n\t    function getBidi(ch, partPos) {\n\t      var part = order[partPos], right = part.level % 2;\n\t      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n\t        part = order[--partPos];\n\t        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n\t        right = true;\n\t      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n\t        part = order[++partPos];\n\t        ch = bidiLeft(part) - part.level % 2;\n\t        right = false;\n\t      }\n\t      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n\t      return get(ch, right);\n\t    }\n\t    var order = getOrder(lineObj), ch = pos.ch;\n\t    if (!order) return get(ch);\n\t    var partPos = getBidiPartAt(order, ch);\n\t    var val = getBidi(ch, partPos);\n\t    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n\t    return val;\n\t  }\n\t\n\t  // Used to cheaply estimate the coordinates for a position. Used for\n\t  // intermediate scroll updates.\n\t  function estimateCoords(cm, pos) {\n\t    var left = 0, pos = clipPos(cm.doc, pos);\n\t    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n\t    var lineObj = getLine(cm.doc, pos.line);\n\t    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n\t    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n\t  }\n\t\n\t  // Positions returned by coordsChar contain some extra information.\n\t  // xRel is the relative x position of the input coordinates compared\n\t  // to the found position (so xRel > 0 means the coordinates are to\n\t  // the right of the character position, for example). When outside\n\t  // is true, that means the coordinates lie outside the line's\n\t  // vertical range.\n\t  function PosWithInfo(line, ch, outside, xRel) {\n\t    var pos = Pos(line, ch);\n\t    pos.xRel = xRel;\n\t    if (outside) pos.outside = true;\n\t    return pos;\n\t  }\n\t\n\t  // Compute the character position closest to the given coordinates.\n\t  // Input must be lineSpace-local (\"div\" coordinate system).\n\t  function coordsChar(cm, x, y) {\n\t    var doc = cm.doc;\n\t    y += cm.display.viewOffset;\n\t    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\t    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n\t    if (lineN > last)\n\t      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n\t    if (x < 0) x = 0;\n\t\n\t    var lineObj = getLine(doc, lineN);\n\t    for (;;) {\n\t      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n\t      var merged = collapsedSpanAtEnd(lineObj);\n\t      var mergedPos = merged && merged.find(0, true);\n\t      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n\t        lineN = lineNo(lineObj = mergedPos.to.line);\n\t      else\n\t        return found;\n\t    }\n\t  }\n\t\n\t  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n\t    var innerOff = y - heightAtLine(lineObj);\n\t    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n\t    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t\n\t    function getX(ch) {\n\t      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n\t      wrongLine = true;\n\t      if (innerOff > sp.bottom) return sp.left - adjust;\n\t      else if (innerOff < sp.top) return sp.left + adjust;\n\t      else wrongLine = false;\n\t      return sp.left;\n\t    }\n\t\n\t    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n\t    var from = lineLeft(lineObj), to = lineRight(lineObj);\n\t    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\t\n\t    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n\t    // Do a binary search between these bounds.\n\t    for (;;) {\n\t      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n\t        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n\t        var xDiff = x - (ch == from ? fromX : toX);\n\t        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n\t        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n\t                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n\t        return pos;\n\t      }\n\t      var step = Math.ceil(dist / 2), middle = from + step;\n\t      if (bidi) {\n\t        middle = from;\n\t        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n\t      }\n\t      var middleX = getX(middle);\n\t      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n\t      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n\t    }\n\t  }\n\t\n\t  var measureText;\n\t  // Compute the default text height.\n\t  function textHeight(display) {\n\t    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\t    if (measureText == null) {\n\t      measureText = elt(\"pre\");\n\t      // Measure a bunch of lines, for browsers that compute\n\t      // fractional heights.\n\t      for (var i = 0; i < 49; ++i) {\n\t        measureText.appendChild(document.createTextNode(\"x\"));\n\t        measureText.appendChild(elt(\"br\"));\n\t      }\n\t      measureText.appendChild(document.createTextNode(\"x\"));\n\t    }\n\t    removeChildrenAndAdd(display.measure, measureText);\n\t    var height = measureText.offsetHeight / 50;\n\t    if (height > 3) display.cachedTextHeight = height;\n\t    removeChildren(display.measure);\n\t    return height || 1;\n\t  }\n\t\n\t  // Compute the default character width.\n\t  function charWidth(display) {\n\t    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n\t    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n\t    var pre = elt(\"pre\", [anchor]);\n\t    removeChildrenAndAdd(display.measure, pre);\n\t    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n\t    if (width > 2) display.cachedCharWidth = width;\n\t    return width || 10;\n\t  }\n\t\n\t  // OPERATIONS\n\t\n\t  // Operations are used to wrap a series of changes to the editor\n\t  // state in such a way that each change won't have to update the\n\t  // cursor and display (which would be awkward, slow, and\n\t  // error-prone). Instead, display updates are batched and then all\n\t  // combined and executed at once.\n\t\n\t  var operationGroup = null;\n\t\n\t  var nextOpId = 0;\n\t  // Start a new operation.\n\t  function startOperation(cm) {\n\t    cm.curOp = {\n\t      cm: cm,\n\t      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n\t      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n\t      forceUpdate: false,      // Used to force a redraw\n\t      updateInput: null,       // Whether to reset the input textarea\n\t      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n\t      changeObjs: null,        // Accumulated changes, for firing change events\n\t      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n\t      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n\t      selectionChanged: false, // Whether the selection needs to be redrawn\n\t      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n\t      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n\t      scrollToPos: null,       // Used to scroll to a specific position\n\t      focus: false,\n\t      id: ++nextOpId           // Unique ID\n\t    };\n\t    if (operationGroup) {\n\t      operationGroup.ops.push(cm.curOp);\n\t    } else {\n\t      cm.curOp.ownsGroup = operationGroup = {\n\t        ops: [cm.curOp],\n\t        delayedCallbacks: []\n\t      };\n\t    }\n\t  }\n\t\n\t  function fireCallbacksForOps(group) {\n\t    // Calls delayed callbacks and cursorActivity handlers until no\n\t    // new ones appear\n\t    var callbacks = group.delayedCallbacks, i = 0;\n\t    do {\n\t      for (; i < callbacks.length; i++)\n\t        callbacks[i].call(null);\n\t      for (var j = 0; j < group.ops.length; j++) {\n\t        var op = group.ops[j];\n\t        if (op.cursorActivityHandlers)\n\t          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n\t            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n\t      }\n\t    } while (i < callbacks.length);\n\t  }\n\t\n\t  // Finish an operation, updating the display and signalling delayed events\n\t  function endOperation(cm) {\n\t    var op = cm.curOp, group = op.ownsGroup;\n\t    if (!group) return;\n\t\n\t    try { fireCallbacksForOps(group); }\n\t    finally {\n\t      operationGroup = null;\n\t      for (var i = 0; i < group.ops.length; i++)\n\t        group.ops[i].cm.curOp = null;\n\t      endOperations(group);\n\t    }\n\t  }\n\t\n\t  // The DOM updates done when an operation finishes are batched so\n\t  // that the minimum number of relayouts are required.\n\t  function endOperations(group) {\n\t    var ops = group.ops;\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_finish(ops[i]);\n\t  }\n\t\n\t  function endOperation_R1(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    maybeClipScrollbars(cm);\n\t    if (op.updateMaxLine) findMaxLine(cm);\n\t\n\t    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n\t      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n\t                         op.scrollToPos.to.line >= display.viewTo) ||\n\t      display.maxLineChanged && cm.options.lineWrapping;\n\t    op.update = op.mustUpdate &&\n\t      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n\t  }\n\t\n\t  function endOperation_W1(op) {\n\t    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n\t  }\n\t\n\t  function endOperation_R2(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\t\n\t    op.barMeasure = measureForScrollbars(cm);\n\t\n\t    // If the max line changed since it was last measured, measure it,\n\t    // and ensure the document's width matches it.\n\t    // updateDisplay_W2 will use these properties to do the actual resizing\n\t    if (display.maxLineChanged && !cm.options.lineWrapping) {\n\t      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n\t      cm.display.sizerWidth = op.adjustWidthTo;\n\t      op.barMeasure.scrollWidth =\n\t        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n\t      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n\t    }\n\t\n\t    if (op.updatedDisplay || op.selectionChanged)\n\t      op.preparedSelection = display.input.prepareSelection();\n\t  }\n\t\n\t  function endOperation_W2(op) {\n\t    var cm = op.cm;\n\t\n\t    if (op.adjustWidthTo != null) {\n\t      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\t      if (op.maxScrollLeft < cm.doc.scrollLeft)\n\t        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n\t      cm.display.maxLineChanged = false;\n\t    }\n\t\n\t    if (op.preparedSelection)\n\t      cm.display.input.showSelection(op.preparedSelection);\n\t    if (op.updatedDisplay)\n\t      setDocumentHeight(cm, op.barMeasure);\n\t    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n\t      updateScrollbars(cm, op.barMeasure);\n\t\n\t    if (op.selectionChanged) restartBlink(cm);\n\t\n\t    if (cm.state.focused && op.updateInput)\n\t      cm.display.input.reset(op.typing);\n\t    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))\n\t      ensureFocus(op.cm);\n\t  }\n\t\n\t  function endOperation_finish(op) {\n\t    var cm = op.cm, display = cm.display, doc = cm.doc;\n\t\n\t    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\t\n\t    // Abort mouse wheel delta measurement, when scrolling explicitly\n\t    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n\t      display.wheelStartX = display.wheelStartY = null;\n\t\n\t    // Propagate the scroll position to the actual DOM scroller\n\t    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n\t      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n\t      display.scrollbars.setScrollTop(doc.scrollTop);\n\t      display.scroller.scrollTop = doc.scrollTop;\n\t    }\n\t    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n\t      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n\t      display.scrollbars.setScrollLeft(doc.scrollLeft);\n\t      display.scroller.scrollLeft = doc.scrollLeft;\n\t      alignHorizontally(cm);\n\t    }\n\t    // If we need to scroll a specific position into view, do so.\n\t    if (op.scrollToPos) {\n\t      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n\t                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n\t      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n\t    }\n\t\n\t    // Fire events for markers that are hidden/unidden by editing or\n\t    // undoing\n\t    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n\t    if (hidden) for (var i = 0; i < hidden.length; ++i)\n\t      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n\t    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n\t      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\t\n\t    if (display.wrapper.offsetHeight)\n\t      doc.scrollTop = cm.display.scroller.scrollTop;\n\t\n\t    // Fire change events, and delayed event handlers\n\t    if (op.changeObjs)\n\t      signal(cm, \"changes\", cm, op.changeObjs);\n\t    if (op.update)\n\t      op.update.finish();\n\t  }\n\t\n\t  // Run the given function in an operation\n\t  function runInOp(cm, f) {\n\t    if (cm.curOp) return f();\n\t    startOperation(cm);\n\t    try { return f(); }\n\t    finally { endOperation(cm); }\n\t  }\n\t  // Wraps a function in an operation. Returns the wrapped function.\n\t  function operation(cm, f) {\n\t    return function() {\n\t      if (cm.curOp) return f.apply(cm, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(cm, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t  // Used to add methods to editor and doc instances, wrapping them in\n\t  // operations.\n\t  function methodOp(f) {\n\t    return function() {\n\t      if (this.curOp) return f.apply(this, arguments);\n\t      startOperation(this);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(this); }\n\t    };\n\t  }\n\t  function docMethodOp(f) {\n\t    return function() {\n\t      var cm = this.cm;\n\t      if (!cm || cm.curOp) return f.apply(this, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t\n\t  // VIEW TRACKING\n\t\n\t  // These objects are used to represent the visible (currently drawn)\n\t  // part of the document. A LineView may correspond to multiple\n\t  // logical lines, if those are connected by collapsed ranges.\n\t  function LineView(doc, line, lineN) {\n\t    // The starting line\n\t    this.line = line;\n\t    // Continuing lines, if any\n\t    this.rest = visualLineContinued(line);\n\t    // Number of logical lines in this visual line\n\t    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n\t    this.node = this.text = null;\n\t    this.hidden = lineIsHidden(doc, line);\n\t  }\n\t\n\t  // Create a range of LineView objects for the given lines.\n\t  function buildViewArray(cm, from, to) {\n\t    var array = [], nextPos;\n\t    for (var pos = from; pos < to; pos = nextPos) {\n\t      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n\t      nextPos = pos + view.size;\n\t      array.push(view);\n\t    }\n\t    return array;\n\t  }\n\t\n\t  // Updates the display.view data structure for a given change to the\n\t  // document. From and to are in pre-change coordinates. Lendiff is\n\t  // the amount of lines added or subtracted by the change. This is\n\t  // used for changes that span multiple lines, or change the way\n\t  // lines are divided into visual lines. regLineChange (below)\n\t  // registers single-line changes.\n\t  function regChange(cm, from, to, lendiff) {\n\t    if (from == null) from = cm.doc.first;\n\t    if (to == null) to = cm.doc.first + cm.doc.size;\n\t    if (!lendiff) lendiff = 0;\n\t\n\t    var display = cm.display;\n\t    if (lendiff && to < display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n\t      display.updateLineNumbers = from;\n\t\n\t    cm.curOp.viewChanged = true;\n\t\n\t    if (from >= display.viewTo) { // Change after\n\t      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n\t        resetView(cm);\n\t    } else if (to <= display.viewFrom) { // Change before\n\t      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n\t        resetView(cm);\n\t      } else {\n\t        display.viewFrom += lendiff;\n\t        display.viewTo += lendiff;\n\t      }\n\t    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n\t      resetView(cm);\n\t    } else if (from <= display.viewFrom) { // Top overlap\n\t      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cut) {\n\t        display.view = display.view.slice(cut.index);\n\t        display.viewFrom = cut.lineN;\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else if (to >= display.viewTo) { // Bottom overlap\n\t      var cut = viewCuttingPoint(cm, from, from, -1);\n\t      if (cut) {\n\t        display.view = display.view.slice(0, cut.index);\n\t        display.viewTo = cut.lineN;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else { // Gap in the middle\n\t      var cutTop = viewCuttingPoint(cm, from, from, -1);\n\t      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cutTop && cutBot) {\n\t        display.view = display.view.slice(0, cutTop.index)\n\t          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n\t          .concat(display.view.slice(cutBot.index));\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    }\n\t\n\t    var ext = display.externalMeasured;\n\t    if (ext) {\n\t      if (to < ext.lineN)\n\t        ext.lineN += lendiff;\n\t      else if (from < ext.lineN + ext.size)\n\t        display.externalMeasured = null;\n\t    }\n\t  }\n\t\n\t  // Register a change to a single line. Type must be one of \"text\",\n\t  // \"gutter\", \"class\", \"widget\"\n\t  function regLineChange(cm, line, type) {\n\t    cm.curOp.viewChanged = true;\n\t    var display = cm.display, ext = cm.display.externalMeasured;\n\t    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n\t      display.externalMeasured = null;\n\t\n\t    if (line < display.viewFrom || line >= display.viewTo) return;\n\t    var lineView = display.view[findViewIndex(cm, line)];\n\t    if (lineView.node == null) return;\n\t    var arr = lineView.changes || (lineView.changes = []);\n\t    if (indexOf(arr, type) == -1) arr.push(type);\n\t  }\n\t\n\t  // Clear the view.\n\t  function resetView(cm) {\n\t    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n\t    cm.display.view = [];\n\t    cm.display.viewOffset = 0;\n\t  }\n\t\n\t  // Find the view element corresponding to a given line. Return null\n\t  // when the line isn't visible.\n\t  function findViewIndex(cm, n) {\n\t    if (n >= cm.display.viewTo) return null;\n\t    n -= cm.display.viewFrom;\n\t    if (n < 0) return null;\n\t    var view = cm.display.view;\n\t    for (var i = 0; i < view.length; i++) {\n\t      n -= view[i].size;\n\t      if (n < 0) return i;\n\t    }\n\t  }\n\t\n\t  function viewCuttingPoint(cm, oldN, newN, dir) {\n\t    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n\t    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n\t      return {index: index, lineN: newN};\n\t    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n\t      n += view[i].size;\n\t    if (n != oldN) {\n\t      if (dir > 0) {\n\t        if (index == view.length - 1) return null;\n\t        diff = (n + view[index].size) - oldN;\n\t        index++;\n\t      } else {\n\t        diff = n - oldN;\n\t      }\n\t      oldN += diff; newN += diff;\n\t    }\n\t    while (visualLineNo(cm.doc, newN) != newN) {\n\t      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n\t      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n\t      index += dir;\n\t    }\n\t    return {index: index, lineN: newN};\n\t  }\n\t\n\t  // Force the view to cover a given range, adding empty view element\n\t  // or clipping off existing ones as needed.\n\t  function adjustView(cm, from, to) {\n\t    var display = cm.display, view = display.view;\n\t    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n\t      display.view = buildViewArray(cm, from, to);\n\t      display.viewFrom = from;\n\t    } else {\n\t      if (display.viewFrom > from)\n\t        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n\t      else if (display.viewFrom < from)\n\t        display.view = display.view.slice(findViewIndex(cm, from));\n\t      display.viewFrom = from;\n\t      if (display.viewTo < to)\n\t        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n\t      else if (display.viewTo > to)\n\t        display.view = display.view.slice(0, findViewIndex(cm, to));\n\t    }\n\t    display.viewTo = to;\n\t  }\n\t\n\t  // Count the number of lines in the view whose DOM representation is\n\t  // out of date (or nonexistent).\n\t  function countDirtyView(cm) {\n\t    var view = cm.display.view, dirty = 0;\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n\t    }\n\t    return dirty;\n\t  }\n\t\n\t  // EVENT HANDLERS\n\t\n\t  // Attach the necessary event handlers when initializing the editor\n\t  function registerEventHandlers(cm) {\n\t    var d = cm.display;\n\t    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\t    // Older IE's will not fire a second mousedown for a double click\n\t    if (ie && ie_version < 11)\n\t      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n\t        if (signalDOMEvent(cm, e)) return;\n\t        var pos = posFromMouse(cm, e);\n\t        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n\t        e_preventDefault(e);\n\t        var word = cm.findWordAt(pos);\n\t        extendSelection(cm.doc, word.anchor, word.head);\n\t      }));\n\t    else\n\t      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n\t    // Some browsers fire contextmenu *after* opening the menu, at\n\t    // which point we can't mess with it anymore. Context menu is\n\t    // handled in onMouseDown for these browsers.\n\t    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\t\n\t    // Used to suppress mouse event handling when a touch happens\n\t    var touchFinished, prevTouch = {end: 0};\n\t    function finishTouch() {\n\t      if (d.activeTouch) {\n\t        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n\t        prevTouch = d.activeTouch;\n\t        prevTouch.end = +new Date;\n\t      }\n\t    };\n\t    function isMouseLikeTouchEvent(e) {\n\t      if (e.touches.length != 1) return false;\n\t      var touch = e.touches[0];\n\t      return touch.radiusX <= 1 && touch.radiusY <= 1;\n\t    }\n\t    function farAway(touch, other) {\n\t      if (other.left == null) return true;\n\t      var dx = other.left - touch.left, dy = other.top - touch.top;\n\t      return dx * dx + dy * dy > 20 * 20;\n\t    }\n\t    on(d.scroller, \"touchstart\", function(e) {\n\t      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n\t        clearTimeout(touchFinished);\n\t        var now = +new Date;\n\t        d.activeTouch = {start: now, moved: false,\n\t                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n\t        if (e.touches.length == 1) {\n\t          d.activeTouch.left = e.touches[0].pageX;\n\t          d.activeTouch.top = e.touches[0].pageY;\n\t        }\n\t      }\n\t    });\n\t    on(d.scroller, \"touchmove\", function() {\n\t      if (d.activeTouch) d.activeTouch.moved = true;\n\t    });\n\t    on(d.scroller, \"touchend\", function(e) {\n\t      var touch = d.activeTouch;\n\t      if (touch && !eventInWidget(d, e) && touch.left != null &&\n\t          !touch.moved && new Date - touch.start < 300) {\n\t        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n\t        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n\t          range = new Range(pos, pos);\n\t        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n\t          range = cm.findWordAt(pos);\n\t        else // Triple tap\n\t          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n\t        cm.setSelection(range.anchor, range.head);\n\t        cm.focus();\n\t        e_preventDefault(e);\n\t      }\n\t      finishTouch();\n\t    });\n\t    on(d.scroller, \"touchcancel\", finishTouch);\n\t\n\t    // Sync scrolling between fake scrollbars and real scrollable\n\t    // area, ensure viewport is updated when scrolling.\n\t    on(d.scroller, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) {\n\t        setScrollTop(cm, d.scroller.scrollTop);\n\t        setScrollLeft(cm, d.scroller.scrollLeft, true);\n\t        signal(cm, \"scroll\", cm);\n\t      }\n\t    });\n\t\n\t    // Listen to wheel events in order to try and update the viewport on time.\n\t    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n\t    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\t\n\t    // Prevent wrapper from ever scrolling\n\t    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\t\n\t    d.dragFunctions = {\n\t      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n\t      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n\t      start: function(e){onDragStart(cm, e);},\n\t      drop: operation(cm, onDrop),\n\t      leave: function() {clearDragCursor(cm);}\n\t    };\n\t\n\t    var inp = d.input.getField();\n\t    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n\t    on(inp, \"keydown\", operation(cm, onKeyDown));\n\t    on(inp, \"keypress\", operation(cm, onKeyPress));\n\t    on(inp, \"focus\", bind(onFocus, cm));\n\t    on(inp, \"blur\", bind(onBlur, cm));\n\t  }\n\t\n\t  function dragDropChanged(cm, value, old) {\n\t    var wasOn = old && old != CodeMirror.Init;\n\t    if (!value != !wasOn) {\n\t      var funcs = cm.display.dragFunctions;\n\t      var toggle = value ? on : off;\n\t      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n\t      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n\t      toggle(cm.display.scroller, \"dragover\", funcs.over);\n\t      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n\t      toggle(cm.display.scroller, \"drop\", funcs.drop);\n\t    }\n\t  }\n\t\n\t  // Called when the window resizes\n\t  function onResize(cm) {\n\t    var d = cm.display;\n\t    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n\t      return;\n\t    // Might be a text scaling operation, clear size caches.\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t    d.scrollbarsClipped = false;\n\t    cm.setSize();\n\t  }\n\t\n\t  // MOUSE EVENTS\n\t\n\t  // Return true when the given mouse event happened in a widget\n\t  function eventInWidget(display, e) {\n\t    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n\t      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n\t          (n.parentNode == display.sizer && n != display.mover))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // Given a mouse event, find the corresponding position. If liberal\n\t  // is false, it checks whether a gutter or scrollbar was clicked,\n\t  // and returns null if it was. forRect is used by rectangular\n\t  // selections, and tries to estimate a character position even for\n\t  // coordinates beyond the right of the text.\n\t  function posFromMouse(cm, e, liberal, forRect) {\n\t    var display = cm.display;\n\t    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\t\n\t    var x, y, space = display.lineSpace.getBoundingClientRect();\n\t    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\t    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n\t    catch (e) { return null; }\n\t    var coords = coordsChar(cm, x, y), line;\n\t    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n\t      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n\t      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // A mouse down can be a single click, double click, triple click,\n\t  // start of selection drag, start of text drag, new cursor\n\t  // (ctrl-click), rectangle drag (alt-drag), or xwin\n\t  // middle-click-paste. Or it might be a click on something we should\n\t  // not interfere with, such as a scrollbar or widget.\n\t  function onMouseDown(e) {\n\t    var cm = this, display = cm.display;\n\t    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n\t    display.shift = e.shiftKey;\n\t\n\t    if (eventInWidget(display, e)) {\n\t      if (!webkit) {\n\t        // Briefly turn off draggability, to allow widgets to do\n\t        // normal dragging things.\n\t        display.scroller.draggable = false;\n\t        setTimeout(function(){display.scroller.draggable = true;}, 100);\n\t      }\n\t      return;\n\t    }\n\t    if (clickInGutter(cm, e)) return;\n\t    var start = posFromMouse(cm, e);\n\t    window.focus();\n\t\n\t    switch (e_button(e)) {\n\t    case 1:\n\t      // #3261: make sure, that we're not starting a second selection\n\t      if (cm.state.selectingText)\n\t        cm.state.selectingText(e);\n\t      else if (start)\n\t        leftButtonDown(cm, e, start);\n\t      else if (e_target(e) == display.scroller)\n\t        e_preventDefault(e);\n\t      break;\n\t    case 2:\n\t      if (webkit) cm.state.lastMiddleDown = +new Date;\n\t      if (start) extendSelection(cm.doc, start);\n\t      setTimeout(function() {display.input.focus();}, 20);\n\t      e_preventDefault(e);\n\t      break;\n\t    case 3:\n\t      if (captureRightClick) onContextMenu(cm, e);\n\t      else delayBlurEvent(cm);\n\t      break;\n\t    }\n\t  }\n\t\n\t  var lastClick, lastDoubleClick;\n\t  function leftButtonDown(cm, e, start) {\n\t    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n\t    else cm.curOp.focus = activeElt();\n\t\n\t    var now = +new Date, type;\n\t    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n\t      type = \"triple\";\n\t    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n\t      type = \"double\";\n\t      lastDoubleClick = {time: now, pos: start};\n\t    } else {\n\t      type = \"single\";\n\t      lastClick = {time: now, pos: start};\n\t    }\n\t\n\t    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n\t    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n\t        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n\t        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n\t        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n\t      leftButtonStartDrag(cm, e, start, modifier);\n\t    else\n\t      leftButtonSelect(cm, e, start, type, modifier);\n\t  }\n\t\n\t  // Start a text drag. When it ends, see if any dragging actually\n\t  // happen, and treat as a click if it didn't.\n\t  function leftButtonStartDrag(cm, e, start, modifier) {\n\t    var display = cm.display, startTime = +new Date;\n\t    var dragEnd = operation(cm, function(e2) {\n\t      if (webkit) display.scroller.draggable = false;\n\t      cm.state.draggingText = false;\n\t      off(document, \"mouseup\", dragEnd);\n\t      off(display.scroller, \"drop\", dragEnd);\n\t      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n\t        e_preventDefault(e2);\n\t        if (!modifier && +new Date - 200 < startTime)\n\t          extendSelection(cm.doc, start);\n\t        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\t        if (webkit || ie && ie_version == 9)\n\t          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n\t        else\n\t          display.input.focus();\n\t      }\n\t    });\n\t    // Let the drag handler handle this.\n\t    if (webkit) display.scroller.draggable = true;\n\t    cm.state.draggingText = dragEnd;\n\t    // IE's approach to draggable\n\t    if (display.scroller.dragDrop) display.scroller.dragDrop();\n\t    on(document, \"mouseup\", dragEnd);\n\t    on(display.scroller, \"drop\", dragEnd);\n\t  }\n\t\n\t  // Normal selection, as opposed to text dragging.\n\t  function leftButtonSelect(cm, e, start, type, addNew) {\n\t    var display = cm.display, doc = cm.doc;\n\t    e_preventDefault(e);\n\t\n\t    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n\t    if (addNew && !e.shiftKey) {\n\t      ourIndex = doc.sel.contains(start);\n\t      if (ourIndex > -1)\n\t        ourRange = ranges[ourIndex];\n\t      else\n\t        ourRange = new Range(start, start);\n\t    } else {\n\t      ourRange = doc.sel.primary();\n\t      ourIndex = doc.sel.primIndex;\n\t    }\n\t\n\t    if (e.altKey) {\n\t      type = \"rect\";\n\t      if (!addNew) ourRange = new Range(start, start);\n\t      start = posFromMouse(cm, e, true, true);\n\t      ourIndex = -1;\n\t    } else if (type == \"double\") {\n\t      var word = cm.findWordAt(start);\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n\t      else\n\t        ourRange = word;\n\t    } else if (type == \"triple\") {\n\t      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n\t      else\n\t        ourRange = line;\n\t    } else {\n\t      ourRange = extendRange(doc, ourRange, start);\n\t    }\n\t\n\t    if (!addNew) {\n\t      ourIndex = 0;\n\t      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n\t      startSel = doc.sel;\n\t    } else if (ourIndex == -1) {\n\t      ourIndex = ranges.length;\n\t      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n\t      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t      startSel = doc.sel;\n\t    } else {\n\t      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n\t    }\n\t\n\t    var lastPos = start;\n\t    function extendTo(pos) {\n\t      if (cmp(lastPos, pos) == 0) return;\n\t      lastPos = pos;\n\t\n\t      if (type == \"rect\") {\n\t        var ranges = [], tabSize = cm.options.tabSize;\n\t        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n\t        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n\t        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n\t        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n\t             line <= end; line++) {\n\t          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n\t          if (left == right)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n\t          else if (text.length > leftPos)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n\t        }\n\t        if (!ranges.length) ranges.push(new Range(start, start));\n\t        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n\t                     {origin: \"*mouse\", scroll: false});\n\t        cm.scrollIntoView(pos);\n\t      } else {\n\t        var oldRange = ourRange;\n\t        var anchor = oldRange.anchor, head = pos;\n\t        if (type != \"single\") {\n\t          if (type == \"double\")\n\t            var range = cm.findWordAt(pos);\n\t          else\n\t            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n\t          if (cmp(range.anchor, anchor) > 0) {\n\t            head = range.head;\n\t            anchor = minPos(oldRange.from(), range.anchor);\n\t          } else {\n\t            head = range.anchor;\n\t            anchor = maxPos(oldRange.to(), range.head);\n\t          }\n\t        }\n\t        var ranges = startSel.ranges.slice(0);\n\t        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n\t        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n\t      }\n\t    }\n\t\n\t    var editorSize = display.wrapper.getBoundingClientRect();\n\t    // Used to ensure timeout re-tries don't fire when another extend\n\t    // happened in the meantime (clearTimeout isn't reliable -- at\n\t    // least on Chrome, the timeouts still happen even when cleared,\n\t    // if the clear happens after their scheduled firing time).\n\t    var counter = 0;\n\t\n\t    function extend(e) {\n\t      var curCount = ++counter;\n\t      var cur = posFromMouse(cm, e, true, type == \"rect\");\n\t      if (!cur) return;\n\t      if (cmp(cur, lastPos) != 0) {\n\t        cm.curOp.focus = activeElt();\n\t        extendTo(cur);\n\t        var visible = visibleLines(display, doc);\n\t        if (cur.line >= visible.to || cur.line < visible.from)\n\t          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n\t      } else {\n\t        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\t        if (outside) setTimeout(operation(cm, function() {\n\t          if (counter != curCount) return;\n\t          display.scroller.scrollTop += outside;\n\t          extend(e);\n\t        }), 50);\n\t      }\n\t    }\n\t\n\t    function done(e) {\n\t      cm.state.selectingText = false;\n\t      counter = Infinity;\n\t      e_preventDefault(e);\n\t      display.input.focus();\n\t      off(document, \"mousemove\", move);\n\t      off(document, \"mouseup\", up);\n\t      doc.history.lastSelOrigin = null;\n\t    }\n\t\n\t    var move = operation(cm, function(e) {\n\t      if (!e_button(e)) done(e);\n\t      else extend(e);\n\t    });\n\t    var up = operation(cm, done);\n\t    cm.state.selectingText = up;\n\t    on(document, \"mousemove\", move);\n\t    on(document, \"mouseup\", up);\n\t  }\n\t\n\t  // Determines whether an event happened in the gutter, and fires the\n\t  // handlers for the corresponding event.\n\t  function gutterEvent(cm, e, type, prevent) {\n\t    try { var mX = e.clientX, mY = e.clientY; }\n\t    catch(e) { return false; }\n\t    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n\t    if (prevent) e_preventDefault(e);\n\t\n\t    var display = cm.display;\n\t    var lineBox = display.lineDiv.getBoundingClientRect();\n\t\n\t    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n\t    mY -= lineBox.top - display.viewOffset;\n\t\n\t    for (var i = 0; i < cm.options.gutters.length; ++i) {\n\t      var g = display.gutters.childNodes[i];\n\t      if (g && g.getBoundingClientRect().right >= mX) {\n\t        var line = lineAtHeight(cm.doc, mY);\n\t        var gutter = cm.options.gutters[i];\n\t        signal(cm, type, cm, line, gutter, e);\n\t        return e_defaultPrevented(e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function clickInGutter(cm, e) {\n\t    return gutterEvent(cm, e, \"gutterClick\", true);\n\t  }\n\t\n\t  // Kludge to work around strange IE behavior where it'll sometimes\n\t  // re-fire a series of drag-related events right after the drop (#1551)\n\t  var lastDrop = 0;\n\t\n\t  function onDrop(e) {\n\t    var cm = this;\n\t    clearDragCursor(cm);\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n\t      return;\n\t    e_preventDefault(e);\n\t    if (ie) lastDrop = +new Date;\n\t    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n\t    if (!pos || cm.isReadOnly()) return;\n\t    // Might be a file drop, in which case we simply extract the text\n\t    // and insert it.\n\t    if (files && files.length && window.FileReader && window.File) {\n\t      var n = files.length, text = Array(n), read = 0;\n\t      var loadFile = function(file, i) {\n\t        if (cm.options.allowDropFileTypes &&\n\t            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n\t          return;\n\t\n\t        var reader = new FileReader;\n\t        reader.onload = operation(cm, function() {\n\t          var content = reader.result;\n\t          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n\t          text[i] = content;\n\t          if (++read == n) {\n\t            pos = clipPos(cm.doc, pos);\n\t            var change = {from: pos, to: pos,\n\t                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n\t                          origin: \"paste\"};\n\t            makeChange(cm.doc, change);\n\t            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n\t          }\n\t        });\n\t        reader.readAsText(file);\n\t      };\n\t      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n\t    } else { // Normal drop\n\t      // Don't do a replace if the drop happened inside of the selected text.\n\t      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n\t        cm.state.draggingText(e);\n\t        // Ensure the editor is re-focused\n\t        setTimeout(function() {cm.display.input.focus();}, 20);\n\t        return;\n\t      }\n\t      try {\n\t        var text = e.dataTransfer.getData(\"Text\");\n\t        if (text) {\n\t          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n\t            var selected = cm.listSelections();\n\t          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\t          if (selected) for (var i = 0; i < selected.length; ++i)\n\t            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n\t          cm.replaceSelection(text, \"around\", \"paste\");\n\t          cm.display.input.focus();\n\t        }\n\t      }\n\t      catch(e){}\n\t    }\n\t  }\n\t\n\t  function onDragStart(cm, e) {\n\t    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\t\n\t    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\t\n\t    // Use dummy image instead of default browsers image.\n\t    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\t    if (e.dataTransfer.setDragImage && !safari) {\n\t      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\t      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t      if (presto) {\n\t        img.width = img.height = 1;\n\t        cm.display.wrapper.appendChild(img);\n\t        // Force a relayout, or Opera won't use our image for some obscure reason\n\t        img._top = img.offsetTop;\n\t      }\n\t      e.dataTransfer.setDragImage(img, 0, 0);\n\t      if (presto) img.parentNode.removeChild(img);\n\t    }\n\t  }\n\t\n\t  function onDragOver(cm, e) {\n\t    var pos = posFromMouse(cm, e);\n\t    if (!pos) return;\n\t    var frag = document.createDocumentFragment();\n\t    drawSelectionCursor(cm, pos, frag);\n\t    if (!cm.display.dragCursor) {\n\t      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n\t      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n\t    }\n\t    removeChildrenAndAdd(cm.display.dragCursor, frag);\n\t  }\n\t\n\t  function clearDragCursor(cm) {\n\t    if (cm.display.dragCursor) {\n\t      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n\t      cm.display.dragCursor = null;\n\t    }\n\t  }\n\t\n\t  // SCROLL EVENTS\n\t\n\t  // Sync the scrollable area and scrollbars, ensure the viewport\n\t  // covers the visible area.\n\t  function setScrollTop(cm, val) {\n\t    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n\t    cm.doc.scrollTop = val;\n\t    if (!gecko) updateDisplaySimple(cm, {top: val});\n\t    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n\t    cm.display.scrollbars.setScrollTop(val);\n\t    if (gecko) updateDisplaySimple(cm);\n\t    startWorker(cm, 100);\n\t  }\n\t  // Sync scroller and scrollbar, ensure the gutter elements are\n\t  // aligned.\n\t  function setScrollLeft(cm, val, isScroller) {\n\t    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n\t    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\t    cm.doc.scrollLeft = val;\n\t    alignHorizontally(cm);\n\t    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n\t    cm.display.scrollbars.setScrollLeft(val);\n\t  }\n\t\n\t  // Since the delta values reported on mouse wheel events are\n\t  // unstandardized between browsers and even browser versions, and\n\t  // generally horribly unpredictable, this code starts by measuring\n\t  // the scroll effect that the first few mouse wheel events have,\n\t  // and, from that, detects the way it can convert deltas to pixel\n\t  // offsets afterwards.\n\t  //\n\t  // The reason we want to know the amount a wheel event will scroll\n\t  // is that it gives us a chance to update the display before the\n\t  // actual scrolling happens, reducing flickering.\n\t\n\t  var wheelSamples = 0, wheelPixelsPerUnit = null;\n\t  // Fill in a browser-detected starting value on browsers where we\n\t  // know one. These don't have to be accurate -- the result of them\n\t  // being wrong would just be a slight flicker on the first wheel\n\t  // scroll (if it is large enough).\n\t  if (ie) wheelPixelsPerUnit = -.53;\n\t  else if (gecko) wheelPixelsPerUnit = 15;\n\t  else if (chrome) wheelPixelsPerUnit = -.7;\n\t  else if (safari) wheelPixelsPerUnit = -1/3;\n\t\n\t  var wheelEventDelta = function(e) {\n\t    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n\t    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n\t    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n\t    else if (dy == null) dy = e.wheelDelta;\n\t    return {x: dx, y: dy};\n\t  };\n\t  CodeMirror.wheelEventPixels = function(e) {\n\t    var delta = wheelEventDelta(e);\n\t    delta.x *= wheelPixelsPerUnit;\n\t    delta.y *= wheelPixelsPerUnit;\n\t    return delta;\n\t  };\n\t\n\t  function onScrollWheel(cm, e) {\n\t    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\t\n\t    var display = cm.display, scroll = display.scroller;\n\t    // Quit if there's nothing to scroll here\n\t    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n\t    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\t    if (!(dx && canScrollX || dy && canScrollY)) return;\n\t\n\t    // Webkit browsers on OS X abort momentum scrolls when the target\n\t    // of the scroll event is removed from the scrollable element.\n\t    // This hack (see related code in patchDisplay) makes sure the\n\t    // element is kept around.\n\t    if (dy && mac && webkit) {\n\t      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n\t        for (var i = 0; i < view.length; i++) {\n\t          if (view[i].node == cur) {\n\t            cm.display.currentWheelTarget = cur;\n\t            break outer;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // On some browsers, horizontal scrolling will cause redraws to\n\t    // happen before the gutter has been realigned, causing it to\n\t    // wriggle around in a most unseemly way. When we have an\n\t    // estimated pixels/delta value, we just handle horizontal\n\t    // scrolling entirely here. It'll be slightly off from native, but\n\t    // better than glitching out.\n\t    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n\t      if (dy && canScrollY)\n\t        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n\t      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n\t      // Only prevent default scrolling if vertical scrolling is\n\t      // actually possible. Otherwise, it causes vertical scroll\n\t      // jitter on OSX trackpads when deltaX is small and deltaY\n\t      // is large (issue #3579)\n\t      if (!dy || (dy && canScrollY))\n\t        e_preventDefault(e);\n\t      display.wheelStartX = null; // Abort measurement, if in progress\n\t      return;\n\t    }\n\t\n\t    // 'Project' the visible viewport to cover the area that is being\n\t    // scrolled into view (if we know enough to estimate it).\n\t    if (dy && wheelPixelsPerUnit != null) {\n\t      var pixels = dy * wheelPixelsPerUnit;\n\t      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n\t      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n\t      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n\t      updateDisplaySimple(cm, {top: top, bottom: bot});\n\t    }\n\t\n\t    if (wheelSamples < 20) {\n\t      if (display.wheelStartX == null) {\n\t        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n\t        display.wheelDX = dx; display.wheelDY = dy;\n\t        setTimeout(function() {\n\t          if (display.wheelStartX == null) return;\n\t          var movedX = scroll.scrollLeft - display.wheelStartX;\n\t          var movedY = scroll.scrollTop - display.wheelStartY;\n\t          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n\t            (movedX && display.wheelDX && movedX / display.wheelDX);\n\t          display.wheelStartX = display.wheelStartY = null;\n\t          if (!sample) return;\n\t          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n\t          ++wheelSamples;\n\t        }, 200);\n\t      } else {\n\t        display.wheelDX += dx; display.wheelDY += dy;\n\t      }\n\t    }\n\t  }\n\t\n\t  // KEY EVENTS\n\t\n\t  // Run a handler that was bound to a key.\n\t  function doHandleBinding(cm, bound, dropShift) {\n\t    if (typeof bound == \"string\") {\n\t      bound = commands[bound];\n\t      if (!bound) return false;\n\t    }\n\t    // Ensure previous input has been read, so that the handler sees a\n\t    // consistent view of the document\n\t    cm.display.input.ensurePolled();\n\t    var prevShift = cm.display.shift, done = false;\n\t    try {\n\t      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n\t      if (dropShift) cm.display.shift = false;\n\t      done = bound(cm) != Pass;\n\t    } finally {\n\t      cm.display.shift = prevShift;\n\t      cm.state.suppressEdits = false;\n\t    }\n\t    return done;\n\t  }\n\t\n\t  function lookupKeyForEditor(cm, name, handle) {\n\t    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n\t      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\t      if (result) return result;\n\t    }\n\t    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n\t      || lookupKey(name, cm.options.keyMap, handle, cm);\n\t  }\n\t\n\t  var stopSeq = new Delayed;\n\t  function dispatchKey(cm, name, e, handle) {\n\t    var seq = cm.state.keySeq;\n\t    if (seq) {\n\t      if (isModifierKey(name)) return \"handled\";\n\t      stopSeq.set(50, function() {\n\t        if (cm.state.keySeq == seq) {\n\t          cm.state.keySeq = null;\n\t          cm.display.input.reset();\n\t        }\n\t      });\n\t      name = seq + \" \" + name;\n\t    }\n\t    var result = lookupKeyForEditor(cm, name, handle);\n\t\n\t    if (result == \"multi\")\n\t      cm.state.keySeq = name;\n\t    if (result == \"handled\")\n\t      signalLater(cm, \"keyHandled\", cm, name, e);\n\t\n\t    if (result == \"handled\" || result == \"multi\") {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t    }\n\t\n\t    if (seq && !result && /\\'$/.test(name)) {\n\t      e_preventDefault(e);\n\t      return true;\n\t    }\n\t    return !!result;\n\t  }\n\t\n\t  // Handle a key from the keydown event.\n\t  function handleKeyBinding(cm, e) {\n\t    var name = keyName(e, true);\n\t    if (!name) return false;\n\t\n\t    if (e.shiftKey && !cm.state.keySeq) {\n\t      // First try to resolve full name (including 'Shift-'). Failing\n\t      // that, see if there is a cursor-motion command (starting with\n\t      // 'go') bound to the keyname without 'Shift-'.\n\t      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n\t          || dispatchKey(cm, name, e, function(b) {\n\t               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n\t                 return doHandleBinding(cm, b);\n\t             });\n\t    } else {\n\t      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n\t    }\n\t  }\n\t\n\t  // Handle a key from the keypress event\n\t  function handleCharBinding(cm, e, ch) {\n\t    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n\t                       function(b) { return doHandleBinding(cm, b, true); });\n\t  }\n\t\n\t  var lastStoppedKey = null;\n\t  function onKeyDown(e) {\n\t    var cm = this;\n\t    cm.curOp.focus = activeElt();\n\t    if (signalDOMEvent(cm, e)) return;\n\t    // IE does strange things with escape.\n\t    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n\t    var code = e.keyCode;\n\t    cm.display.shift = code == 16 || e.shiftKey;\n\t    var handled = handleKeyBinding(cm, e);\n\t    if (presto) {\n\t      lastStoppedKey = handled ? code : null;\n\t      // Opera has no cut event... we try to at least catch the key combo\n\t      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n\t        cm.replaceSelection(\"\", null, \"cut\");\n\t    }\n\t\n\t    // Turn mouse into crosshair when Alt is held on Mac.\n\t    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n\t      showCrossHair(cm);\n\t  }\n\t\n\t  function showCrossHair(cm) {\n\t    var lineDiv = cm.display.lineDiv;\n\t    addClass(lineDiv, \"CodeMirror-crosshair\");\n\t\n\t    function up(e) {\n\t      if (e.keyCode == 18 || !e.altKey) {\n\t        rmClass(lineDiv, \"CodeMirror-crosshair\");\n\t        off(document, \"keyup\", up);\n\t        off(document, \"mouseover\", up);\n\t      }\n\t    }\n\t    on(document, \"keyup\", up);\n\t    on(document, \"mouseover\", up);\n\t  }\n\t\n\t  function onKeyUp(e) {\n\t    if (e.keyCode == 16) this.doc.sel.shift = false;\n\t    signalDOMEvent(this, e);\n\t  }\n\t\n\t  function onKeyPress(e) {\n\t    var cm = this;\n\t    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n\t    var keyCode = e.keyCode, charCode = e.charCode;\n\t    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n\t    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n\t    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n\t    if (handleCharBinding(cm, e, ch)) return;\n\t    cm.display.input.onKeyPress(e);\n\t  }\n\t\n\t  // FOCUS/BLUR EVENTS\n\t\n\t  function delayBlurEvent(cm) {\n\t    cm.state.delayingBlurEvent = true;\n\t    setTimeout(function() {\n\t      if (cm.state.delayingBlurEvent) {\n\t        cm.state.delayingBlurEvent = false;\n\t        onBlur(cm);\n\t      }\n\t    }, 100);\n\t  }\n\t\n\t  function onFocus(cm) {\n\t    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\t\n\t    if (cm.options.readOnly == \"nocursor\") return;\n\t    if (!cm.state.focused) {\n\t      signal(cm, \"focus\", cm);\n\t      cm.state.focused = true;\n\t      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t      // This test prevents this from firing when a context\n\t      // menu is closed (since the input reset would kill the\n\t      // select-all detection hack)\n\t      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n\t        cm.display.input.reset();\n\t        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n\t      }\n\t      cm.display.input.receivedFocus();\n\t    }\n\t    restartBlink(cm);\n\t  }\n\t  function onBlur(cm) {\n\t    if (cm.state.delayingBlurEvent) return;\n\t\n\t    if (cm.state.focused) {\n\t      signal(cm, \"blur\", cm);\n\t      cm.state.focused = false;\n\t      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t    }\n\t    clearInterval(cm.display.blinker);\n\t    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n\t  }\n\t\n\t  // CONTEXT MENU HANDLING\n\t\n\t  // To make the context menu work, we need to briefly unhide the\n\t  // textarea (making it as unobtrusive as possible) to let the\n\t  // right-click take effect on it.\n\t  function onContextMenu(cm, e) {\n\t    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n\t    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n\t    cm.display.input.onContextMenu(e);\n\t  }\n\t\n\t  function contextMenuInGutter(cm, e) {\n\t    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n\t    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n\t  }\n\t\n\t  // UPDATING\n\t\n\t  // Compute the position of the end of a change (its 'to' property\n\t  // refers to the pre-change end).\n\t  var changeEnd = CodeMirror.changeEnd = function(change) {\n\t    if (!change.text) return change.to;\n\t    return Pos(change.from.line + change.text.length - 1,\n\t               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n\t  };\n\t\n\t  // Adjust a position to refer to the post-change position of the\n\t  // same text, or the end of the change if the change covers it.\n\t  function adjustForChange(pos, change) {\n\t    if (cmp(pos, change.from) < 0) return pos;\n\t    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\t\n\t    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n\t    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n\t    return Pos(line, ch);\n\t  }\n\t\n\t  function computeSelAfterChange(doc, change) {\n\t    var out = [];\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      var range = doc.sel.ranges[i];\n\t      out.push(new Range(adjustForChange(range.anchor, change),\n\t                         adjustForChange(range.head, change)));\n\t    }\n\t    return normalizeSelection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  function offsetPos(pos, old, nw) {\n\t    if (pos.line == old.line)\n\t      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n\t    else\n\t      return Pos(nw.line + (pos.line - old.line), pos.ch);\n\t  }\n\t\n\t  // Used by replaceSelections to allow moving the selection to the\n\t  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\t  function computeReplacedSel(doc, changes, hint) {\n\t    var out = [];\n\t    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n\t    for (var i = 0; i < changes.length; i++) {\n\t      var change = changes[i];\n\t      var from = offsetPos(change.from, oldPrev, newPrev);\n\t      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n\t      oldPrev = change.to;\n\t      newPrev = to;\n\t      if (hint == \"around\") {\n\t        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n\t        out[i] = new Range(inv ? to : from, inv ? from : to);\n\t      } else {\n\t        out[i] = new Range(from, from);\n\t      }\n\t    }\n\t    return new Selection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  // Allow \"beforeChange\" event handlers to influence a change\n\t  function filterChange(doc, change, update) {\n\t    var obj = {\n\t      canceled: false,\n\t      from: change.from,\n\t      to: change.to,\n\t      text: change.text,\n\t      origin: change.origin,\n\t      cancel: function() { this.canceled = true; }\n\t    };\n\t    if (update) obj.update = function(from, to, text, origin) {\n\t      if (from) this.from = clipPos(doc, from);\n\t      if (to) this.to = clipPos(doc, to);\n\t      if (text) this.text = text;\n\t      if (origin !== undefined) this.origin = origin;\n\t    };\n\t    signal(doc, \"beforeChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\t\n\t    if (obj.canceled) return null;\n\t    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n\t  }\n\t\n\t  // Apply a change to a document, and add it to the document's\n\t  // history, and propagating it to all linked documents.\n\t  function makeChange(doc, change, ignoreReadOnly) {\n\t    if (doc.cm) {\n\t      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n\t      if (doc.cm.state.suppressEdits) return;\n\t    }\n\t\n\t    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n\t      change = filterChange(doc, change, true);\n\t      if (!change) return;\n\t    }\n\t\n\t    // Possibly split or suppress the update based on the presence\n\t    // of read-only spans in its range.\n\t    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\t    if (split) {\n\t      for (var i = split.length - 1; i >= 0; --i)\n\t        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n\t    } else {\n\t      makeChangeInner(doc, change);\n\t    }\n\t  }\n\t\n\t  function makeChangeInner(doc, change) {\n\t    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n\t    var selAfter = computeSelAfterChange(doc, change);\n\t    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\t\n\t    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n\t    var rebased = [];\n\t\n\t    linkedDocs(doc, function(doc, sharedHist) {\n\t      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t        rebaseHist(doc.history, change);\n\t        rebased.push(doc.history);\n\t      }\n\t      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n\t    });\n\t  }\n\t\n\t  // Revert a change stored in a document's history.\n\t  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n\t    if (doc.cm && doc.cm.state.suppressEdits) return;\n\t\n\t    var hist = doc.history, event, selAfter = doc.sel;\n\t    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\t\n\t    // Verify that there is a useable event (so that ctrl-z won't\n\t    // needlessly clear selection events)\n\t    for (var i = 0; i < source.length; i++) {\n\t      event = source[i];\n\t      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n\t        break;\n\t    }\n\t    if (i == source.length) return;\n\t    hist.lastOrigin = hist.lastSelOrigin = null;\n\t\n\t    for (;;) {\n\t      event = source.pop();\n\t      if (event.ranges) {\n\t        pushSelectionToHistory(event, dest);\n\t        if (allowSelectionOnly && !event.equals(doc.sel)) {\n\t          setSelection(doc, event, {clearRedo: false});\n\t          return;\n\t        }\n\t        selAfter = event;\n\t      }\n\t      else break;\n\t    }\n\t\n\t    // Build up a reverse change object to add to the opposite history\n\t    // stack (redo when undoing, and vice versa).\n\t    var antiChanges = [];\n\t    pushSelectionToHistory(selAfter, dest);\n\t    dest.push({changes: antiChanges, generation: hist.generation});\n\t    hist.generation = event.generation || ++hist.maxGeneration;\n\t\n\t    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\t\n\t    for (var i = event.changes.length - 1; i >= 0; --i) {\n\t      var change = event.changes[i];\n\t      change.origin = type;\n\t      if (filter && !filterChange(doc, change, false)) {\n\t        source.length = 0;\n\t        return;\n\t      }\n\t\n\t      antiChanges.push(historyChangeFromChange(doc, change));\n\t\n\t      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n\t      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\t      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n\t      var rebased = [];\n\t\n\t      // Propagate to the linked documents\n\t      linkedDocs(doc, function(doc, sharedHist) {\n\t        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t          rebaseHist(doc.history, change);\n\t          rebased.push(doc.history);\n\t        }\n\t        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n\t      });\n\t    }\n\t  }\n\t\n\t  // Sub-views need their line numbers shifted when text is added\n\t  // above or below them in the parent document.\n\t  function shiftDoc(doc, distance) {\n\t    if (distance == 0) return;\n\t    doc.first += distance;\n\t    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n\t      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n\t                       Pos(range.head.line + distance, range.head.ch));\n\t    }), doc.sel.primIndex);\n\t    if (doc.cm) {\n\t      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\t      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n\t        regLineChange(doc.cm, l, \"gutter\");\n\t    }\n\t  }\n\t\n\t  // More lower-level change function, handling only a single document\n\t  // (not linked ones).\n\t  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n\t    if (doc.cm && !doc.cm.curOp)\n\t      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\t\n\t    if (change.to.line < doc.first) {\n\t      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n\t      return;\n\t    }\n\t    if (change.from.line > doc.lastLine()) return;\n\t\n\t    // Clip the change to the size of this doc\n\t    if (change.from.line < doc.first) {\n\t      var shift = change.text.length - 1 - (doc.first - change.from.line);\n\t      shiftDoc(doc, shift);\n\t      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n\t                text: [lst(change.text)], origin: change.origin};\n\t    }\n\t    var last = doc.lastLine();\n\t    if (change.to.line > last) {\n\t      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n\t                text: [change.text[0]], origin: change.origin};\n\t    }\n\t\n\t    change.removed = getBetween(doc, change.from, change.to);\n\t\n\t    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n\t    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n\t    else updateDoc(doc, change, spans);\n\t    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\t  }\n\t\n\t  // Handle the interaction of a change to a document with the editor\n\t  // that this document is part of.\n\t  function makeChangeSingleDocInEditor(cm, change, spans) {\n\t    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\t\n\t    var recomputeMaxLength = false, checkWidthStart = from.line;\n\t    if (!cm.options.lineWrapping) {\n\t      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n\t      doc.iter(checkWidthStart, to.line + 1, function(line) {\n\t        if (line == display.maxLine) {\n\t          recomputeMaxLength = true;\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t\n\t    if (doc.sel.contains(change.from, change.to) > -1)\n\t      signalCursorActivity(cm);\n\t\n\t    updateDoc(doc, change, spans, estimateHeight(cm));\n\t\n\t    if (!cm.options.lineWrapping) {\n\t      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n\t        var len = lineLength(line);\n\t        if (len > display.maxLineLength) {\n\t          display.maxLine = line;\n\t          display.maxLineLength = len;\n\t          display.maxLineChanged = true;\n\t          recomputeMaxLength = false;\n\t        }\n\t      });\n\t      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n\t    }\n\t\n\t    // Adjust frontier, schedule worker\n\t    doc.frontier = Math.min(doc.frontier, from.line);\n\t    startWorker(cm, 400);\n\t\n\t    var lendiff = change.text.length - (to.line - from.line) - 1;\n\t    // Remember that these lines changed, for updating the display\n\t    if (change.full)\n\t      regChange(cm);\n\t    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n\t      regLineChange(cm, from.line, \"text\");\n\t    else\n\t      regChange(cm, from.line, to.line + 1, lendiff);\n\t\n\t    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n\t    if (changeHandler || changesHandler) {\n\t      var obj = {\n\t        from: from, to: to,\n\t        text: change.text,\n\t        removed: change.removed,\n\t        origin: change.origin\n\t      };\n\t      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n\t      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n\t    }\n\t    cm.display.selForContextMenu = null;\n\t  }\n\t\n\t  function replaceRange(doc, code, from, to, origin) {\n\t    if (!to) to = from;\n\t    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n\t    if (typeof code == \"string\") code = doc.splitLines(code);\n\t    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n\t  }\n\t\n\t  // SCROLLING THINGS INTO VIEW\n\t\n\t  // If an editor sits on the top or bottom of the window, partially\n\t  // scrolled out of view, this ensures that the cursor is visible.\n\t  function maybeScrollWindow(cm, coords) {\n\t    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\t\n\t    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n\t    if (coords.top + box.top < 0) doScroll = true;\n\t    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\t    if (doScroll != null && !phantom) {\n\t      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n\t                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n\t                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n\t                           coords.left + \"px; width: 2px;\");\n\t      cm.display.lineSpace.appendChild(scrollNode);\n\t      scrollNode.scrollIntoView(doScroll);\n\t      cm.display.lineSpace.removeChild(scrollNode);\n\t    }\n\t  }\n\t\n\t  // Scroll a given position into view (immediately), verifying that\n\t  // it actually became visible (as line heights are accurately\n\t  // measured, the position of something may 'drift' during drawing).\n\t  function scrollPosIntoView(cm, pos, end, margin) {\n\t    if (margin == null) margin = 0;\n\t    for (var limit = 0; limit < 5; limit++) {\n\t      var changed = false, coords = cursorCoords(cm, pos);\n\t      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n\t      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n\t                                         Math.min(coords.top, endCoords.top) - margin,\n\t                                         Math.max(coords.left, endCoords.left),\n\t                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n\t      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n\t      if (scrollPos.scrollTop != null) {\n\t        setScrollTop(cm, scrollPos.scrollTop);\n\t        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n\t      }\n\t      if (scrollPos.scrollLeft != null) {\n\t        setScrollLeft(cm, scrollPos.scrollLeft);\n\t        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n\t      }\n\t      if (!changed) break;\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // Scroll a given set of coordinates into view (immediately).\n\t  function scrollIntoView(cm, x1, y1, x2, y2) {\n\t    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n\t    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n\t    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n\t  }\n\t\n\t  // Calculate a new scroll position needed to scroll the given\n\t  // rectangle into view. Returns an object with scrollTop and\n\t  // scrollLeft properties. When these are undefined, the\n\t  // vertical/horizontal position does not need to be adjusted.\n\t  function calculateScrollPos(cm, x1, y1, x2, y2) {\n\t    var display = cm.display, snapMargin = textHeight(cm.display);\n\t    if (y1 < 0) y1 = 0;\n\t    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n\t    var screen = displayHeight(cm), result = {};\n\t    if (y2 - y1 > screen) y2 = y1 + screen;\n\t    var docBottom = cm.doc.height + paddingVert(display);\n\t    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n\t    if (y1 < screentop) {\n\t      result.scrollTop = atTop ? 0 : y1;\n\t    } else if (y2 > screentop + screen) {\n\t      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n\t      if (newTop != screentop) result.scrollTop = newTop;\n\t    }\n\t\n\t    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n\t    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n\t    var tooWide = x2 - x1 > screenw;\n\t    if (tooWide) x2 = x1 + screenw;\n\t    if (x1 < 10)\n\t      result.scrollLeft = 0;\n\t    else if (x1 < screenleft)\n\t      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n\t    else if (x2 > screenw + screenleft - 3)\n\t      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\t    return result;\n\t  }\n\t\n\t  // Store a relative adjustment to the scroll position in the current\n\t  // operation (to be applied when the operation finishes).\n\t  function addToScrollPos(cm, left, top) {\n\t    if (left != null || top != null) resolveScrollToPos(cm);\n\t    if (left != null)\n\t      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n\t    if (top != null)\n\t      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n\t  }\n\t\n\t  // Make sure that at the end of the operation the current cursor is\n\t  // shown.\n\t  function ensureCursorVisible(cm) {\n\t    resolveScrollToPos(cm);\n\t    var cur = cm.getCursor(), from = cur, to = cur;\n\t    if (!cm.options.lineWrapping) {\n\t      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n\t      to = Pos(cur.line, cur.ch + 1);\n\t    }\n\t    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n\t  }\n\t\n\t  // When an operation has its scrollToPos property set, and another\n\t  // scroll action is applied before the end of the operation, this\n\t  // 'simulates' scrolling that position into view in a cheap way, so\n\t  // that the effect of intermediate scroll commands is not ignored.\n\t  function resolveScrollToPos(cm) {\n\t    var range = cm.curOp.scrollToPos;\n\t    if (range) {\n\t      cm.curOp.scrollToPos = null;\n\t      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n\t      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n\t                                    Math.min(from.top, to.top) - range.margin,\n\t                                    Math.max(from.right, to.right),\n\t                                    Math.max(from.bottom, to.bottom) + range.margin);\n\t      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t    }\n\t  }\n\t\n\t  // API UTILITIES\n\t\n\t  // Indent the given line. The how parameter can be \"smart\",\n\t  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n\t  // (typically set to true for forced single-line indents), empty\n\t  // lines are not indented, and places where the mode returns Pass\n\t  // are left alone.\n\t  function indentLine(cm, n, how, aggressive) {\n\t    var doc = cm.doc, state;\n\t    if (how == null) how = \"add\";\n\t    if (how == \"smart\") {\n\t      // Fall back to \"prev\" when the mode doesn't have an indentation\n\t      // method.\n\t      if (!doc.mode.indent) how = \"prev\";\n\t      else state = getStateBefore(cm, n);\n\t    }\n\t\n\t    var tabSize = cm.options.tabSize;\n\t    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n\t    if (!aggressive && !/\\S/.test(line.text)) {\n\t      indentation = 0;\n\t      how = \"not\";\n\t    } else if (how == \"smart\") {\n\t      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\t      if (indentation == Pass || indentation > 150) {\n\t        if (!aggressive) return;\n\t        how = \"prev\";\n\t      }\n\t    }\n\t    if (how == \"prev\") {\n\t      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n\t      else indentation = 0;\n\t    } else if (how == \"add\") {\n\t      indentation = curSpace + cm.options.indentUnit;\n\t    } else if (how == \"subtract\") {\n\t      indentation = curSpace - cm.options.indentUnit;\n\t    } else if (typeof how == \"number\") {\n\t      indentation = curSpace + how;\n\t    }\n\t    indentation = Math.max(0, indentation);\n\t\n\t    var indentString = \"\", pos = 0;\n\t    if (cm.options.indentWithTabs)\n\t      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n\t    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\t\n\t    if (indentString != curSpaceString) {\n\t      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\t      line.stateAfter = null;\n\t      return true;\n\t    } else {\n\t      // Ensure that, if the cursor was in the whitespace at the start\n\t      // of the line, it is moved to the end of that space.\n\t      for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t        var range = doc.sel.ranges[i];\n\t        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n\t          var pos = Pos(n, curSpaceString.length);\n\t          replaceOneSelection(doc, i, new Range(pos, pos));\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // Utility for applying a change to a line by handle or number,\n\t  // returning the number and optionally registering the line as\n\t  // changed.\n\t  function changeLine(doc, handle, changeType, op) {\n\t    var no = handle, line = handle;\n\t    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n\t    else no = lineNo(handle);\n\t    if (no == null) return null;\n\t    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n\t    return line;\n\t  }\n\t\n\t  // Helper for deleting text near the selection(s), used to implement\n\t  // backspace, delete, and similar functionality.\n\t  function deleteNearSelection(cm, compute) {\n\t    var ranges = cm.doc.sel.ranges, kill = [];\n\t    // Build up a set of ranges to kill first, merging overlapping\n\t    // ranges.\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var toKill = compute(ranges[i]);\n\t      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n\t        var replaced = kill.pop();\n\t        if (cmp(replaced.from, toKill.from) < 0) {\n\t          toKill.from = replaced.from;\n\t          break;\n\t        }\n\t      }\n\t      kill.push(toKill);\n\t    }\n\t    // Next, remove those actual ranges.\n\t    runInOp(cm, function() {\n\t      for (var i = kill.length - 1; i >= 0; i--)\n\t        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n\t      ensureCursorVisible(cm);\n\t    });\n\t  }\n\t\n\t  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n\t  // right), unit can be \"char\", \"column\" (like char, but doesn't\n\t  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n\t  // the start of next group of word or non-word-non-whitespace\n\t  // chars). The visually param controls whether, in right-to-left\n\t  // text, direction 1 means to move towards the next index in the\n\t  // string, or towards the character to the right of the current\n\t  // position. The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosH(doc, pos, dir, unit, visually) {\n\t    var line = pos.line, ch = pos.ch, origDir = dir;\n\t    var lineObj = getLine(doc, line);\n\t    function findNextLine() {\n\t      var l = line + dir;\n\t      if (l < doc.first || l >= doc.first + doc.size) return false\n\t      line = l;\n\t      return lineObj = getLine(doc, l);\n\t    }\n\t    function moveOnce(boundToLine) {\n\t      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\t      if (next == null) {\n\t        if (!boundToLine && findNextLine()) {\n\t          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n\t          else ch = dir < 0 ? lineObj.text.length : 0;\n\t        } else return false\n\t      } else ch = next;\n\t      return true;\n\t    }\n\t\n\t    if (unit == \"char\") {\n\t      moveOnce()\n\t    } else if (unit == \"column\") {\n\t      moveOnce(true)\n\t    } else if (unit == \"word\" || unit == \"group\") {\n\t      var sawType = null, group = unit == \"group\";\n\t      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\t      for (var first = true;; first = false) {\n\t        if (dir < 0 && !moveOnce(!first)) break;\n\t        var cur = lineObj.text.charAt(ch) || \"\\n\";\n\t        var type = isWordChar(cur, helper) ? \"w\"\n\t          : group && cur == \"\\n\" ? \"n\"\n\t          : !group || /\\s/.test(cur) ? null\n\t          : \"p\";\n\t        if (group && !first && !type) type = \"s\";\n\t        if (sawType && sawType != type) {\n\t          if (dir < 0) {dir = 1; moveOnce();}\n\t          break;\n\t        }\n\t\n\t        if (type) sawType = type;\n\t        if (dir > 0 && !moveOnce(!first)) break;\n\t      }\n\t    }\n\t    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n\t    if (!cmp(pos, result)) result.hitSide = true;\n\t    return result;\n\t  }\n\t\n\t  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n\t  // \"page\" or \"line\". The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosV(cm, pos, dir, unit) {\n\t    var doc = cm.doc, x = pos.left, y;\n\t    if (unit == \"page\") {\n\t      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n\t      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n\t    } else if (unit == \"line\") {\n\t      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n\t    }\n\t    for (;;) {\n\t      var target = coordsChar(cm, x, y);\n\t      if (!target.outside) break;\n\t      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n\t      y += dir * 5;\n\t    }\n\t    return target;\n\t  }\n\t\n\t  // EDITOR METHODS\n\t\n\t  // The publicly visible API. Note that methodOp(f) means\n\t  // 'wrap f in an operation, performed on its `this` parameter'.\n\t\n\t  // This is not the complete set of editor methods. Most of the\n\t  // methods defined on the Doc type are also injected into\n\t  // CodeMirror.prototype, for backwards compatibility and\n\t  // convenience.\n\t\n\t  CodeMirror.prototype = {\n\t    constructor: CodeMirror,\n\t    focus: function(){window.focus(); this.display.input.focus();},\n\t\n\t    setOption: function(option, value) {\n\t      var options = this.options, old = options[option];\n\t      if (options[option] == value && option != \"mode\") return;\n\t      options[option] = value;\n\t      if (optionHandlers.hasOwnProperty(option))\n\t        operation(this, optionHandlers[option])(this, value, old);\n\t    },\n\t\n\t    getOption: function(option) {return this.options[option];},\n\t    getDoc: function() {return this.doc;},\n\t\n\t    addKeyMap: function(map, bottom) {\n\t      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n\t    },\n\t    removeKeyMap: function(map) {\n\t      var maps = this.state.keyMaps;\n\t      for (var i = 0; i < maps.length; ++i)\n\t        if (maps[i] == map || maps[i].name == map) {\n\t          maps.splice(i, 1);\n\t          return true;\n\t        }\n\t    },\n\t\n\t    addOverlay: methodOp(function(spec, options) {\n\t      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\t      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n\t      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n\t      this.state.modeGen++;\n\t      regChange(this);\n\t    }),\n\t    removeOverlay: methodOp(function(spec) {\n\t      var overlays = this.state.overlays;\n\t      for (var i = 0; i < overlays.length; ++i) {\n\t        var cur = overlays[i].modeSpec;\n\t        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n\t          overlays.splice(i, 1);\n\t          this.state.modeGen++;\n\t          regChange(this);\n\t          return;\n\t        }\n\t      }\n\t    }),\n\t\n\t    indentLine: methodOp(function(n, dir, aggressive) {\n\t      if (typeof dir != \"string\" && typeof dir != \"number\") {\n\t        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n\t        else dir = dir ? \"add\" : \"subtract\";\n\t      }\n\t      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n\t    }),\n\t    indentSelection: methodOp(function(how) {\n\t      var ranges = this.doc.sel.ranges, end = -1;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (!range.empty()) {\n\t          var from = range.from(), to = range.to();\n\t          var start = Math.max(end, from.line);\n\t          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\t          for (var j = start; j < end; ++j)\n\t            indentLine(this, j, how);\n\t          var newRanges = this.doc.sel.ranges;\n\t          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n\t            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n\t        } else if (range.head.line > end) {\n\t          indentLine(this, range.head.line, how, true);\n\t          end = range.head.line;\n\t          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n\t        }\n\t      }\n\t    }),\n\t\n\t    // Fetch the parser token for a given character. Useful for hacks\n\t    // that want to inspect the mode state (say, for completion).\n\t    getTokenAt: function(pos, precise) {\n\t      return takeToken(this, pos, precise);\n\t    },\n\t\n\t    getLineTokens: function(line, precise) {\n\t      return takeToken(this, Pos(line), precise, true);\n\t    },\n\t\n\t    getTokenTypeAt: function(pos) {\n\t      pos = clipPos(this.doc, pos);\n\t      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n\t      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n\t      var type;\n\t      if (ch == 0) type = styles[2];\n\t      else for (;;) {\n\t        var mid = (before + after) >> 1;\n\t        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n\t        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n\t        else { type = styles[mid * 2 + 2]; break; }\n\t      }\n\t      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n\t      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n\t    },\n\t\n\t    getModeAt: function(pos) {\n\t      var mode = this.doc.mode;\n\t      if (!mode.innerMode) return mode;\n\t      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n\t    },\n\t\n\t    getHelper: function(pos, type) {\n\t      return this.getHelpers(pos, type)[0];\n\t    },\n\t\n\t    getHelpers: function(pos, type) {\n\t      var found = [];\n\t      if (!helpers.hasOwnProperty(type)) return found;\n\t      var help = helpers[type], mode = this.getModeAt(pos);\n\t      if (typeof mode[type] == \"string\") {\n\t        if (help[mode[type]]) found.push(help[mode[type]]);\n\t      } else if (mode[type]) {\n\t        for (var i = 0; i < mode[type].length; i++) {\n\t          var val = help[mode[type][i]];\n\t          if (val) found.push(val);\n\t        }\n\t      } else if (mode.helperType && help[mode.helperType]) {\n\t        found.push(help[mode.helperType]);\n\t      } else if (help[mode.name]) {\n\t        found.push(help[mode.name]);\n\t      }\n\t      for (var i = 0; i < help._global.length; i++) {\n\t        var cur = help._global[i];\n\t        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n\t          found.push(cur.val);\n\t      }\n\t      return found;\n\t    },\n\t\n\t    getStateAfter: function(line, precise) {\n\t      var doc = this.doc;\n\t      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n\t      return getStateBefore(this, line + 1, precise);\n\t    },\n\t\n\t    cursorCoords: function(start, mode) {\n\t      var pos, range = this.doc.sel.primary();\n\t      if (start == null) pos = range.head;\n\t      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n\t      else pos = start ? range.from() : range.to();\n\t      return cursorCoords(this, pos, mode || \"page\");\n\t    },\n\t\n\t    charCoords: function(pos, mode) {\n\t      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n\t    },\n\t\n\t    coordsChar: function(coords, mode) {\n\t      coords = fromCoordSystem(this, coords, mode || \"page\");\n\t      return coordsChar(this, coords.left, coords.top);\n\t    },\n\t\n\t    lineAtHeight: function(height, mode) {\n\t      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n\t      return lineAtHeight(this.doc, height + this.display.viewOffset);\n\t    },\n\t    heightAtLine: function(line, mode) {\n\t      var end = false, lineObj;\n\t      if (typeof line == \"number\") {\n\t        var last = this.doc.first + this.doc.size - 1;\n\t        if (line < this.doc.first) line = this.doc.first;\n\t        else if (line > last) { line = last; end = true; }\n\t        lineObj = getLine(this.doc, line);\n\t      } else {\n\t        lineObj = line;\n\t      }\n\t      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n\t        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n\t    },\n\t\n\t    defaultTextHeight: function() { return textHeight(this.display); },\n\t    defaultCharWidth: function() { return charWidth(this.display); },\n\t\n\t    setGutterMarker: methodOp(function(line, gutterID, value) {\n\t      return changeLine(this.doc, line, \"gutter\", function(line) {\n\t        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n\t        markers[gutterID] = value;\n\t        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    clearGutter: methodOp(function(gutterID) {\n\t      var cm = this, doc = cm.doc, i = doc.first;\n\t      doc.iter(function(line) {\n\t        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n\t          line.gutterMarkers[gutterID] = null;\n\t          regLineChange(cm, i, \"gutter\");\n\t          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n\t        }\n\t        ++i;\n\t      });\n\t    }),\n\t\n\t    lineInfo: function(line) {\n\t      if (typeof line == \"number\") {\n\t        if (!isLine(this.doc, line)) return null;\n\t        var n = line;\n\t        line = getLine(this.doc, line);\n\t        if (!line) return null;\n\t      } else {\n\t        var n = lineNo(line);\n\t        if (n == null) return null;\n\t      }\n\t      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n\t              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n\t              widgets: line.widgets};\n\t    },\n\t\n\t    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\t\n\t    addWidget: function(pos, node, scroll, vert, horiz) {\n\t      var display = this.display;\n\t      pos = cursorCoords(this, clipPos(this.doc, pos));\n\t      var top = pos.bottom, left = pos.left;\n\t      node.style.position = \"absolute\";\n\t      node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      this.display.input.setUneditable(node);\n\t      display.sizer.appendChild(node);\n\t      if (vert == \"over\") {\n\t        top = pos.top;\n\t      } else if (vert == \"above\" || vert == \"near\") {\n\t        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n\t        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n\t        // Default to positioning above (if specified and possible); otherwise default to positioning below\n\t        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n\t          top = pos.top - node.offsetHeight;\n\t        else if (pos.bottom + node.offsetHeight <= vspace)\n\t          top = pos.bottom;\n\t        if (left + node.offsetWidth > hspace)\n\t          left = hspace - node.offsetWidth;\n\t      }\n\t      node.style.top = top + \"px\";\n\t      node.style.left = node.style.right = \"\";\n\t      if (horiz == \"right\") {\n\t        left = display.sizer.clientWidth - node.offsetWidth;\n\t        node.style.right = \"0px\";\n\t      } else {\n\t        if (horiz == \"left\") left = 0;\n\t        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n\t        node.style.left = left + \"px\";\n\t      }\n\t      if (scroll)\n\t        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n\t    },\n\t\n\t    triggerOnKeyDown: methodOp(onKeyDown),\n\t    triggerOnKeyPress: methodOp(onKeyPress),\n\t    triggerOnKeyUp: onKeyUp,\n\t\n\t    execCommand: function(cmd) {\n\t      if (commands.hasOwnProperty(cmd))\n\t        return commands[cmd].call(null, this);\n\t    },\n\t\n\t    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\t\n\t    findPosH: function(from, amount, unit, visually) {\n\t      var dir = 1;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        cur = findPosH(this.doc, cur, dir, unit, visually);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveH: methodOp(function(dir, unit) {\n\t      var cm = this;\n\t      cm.extendSelectionsBy(function(range) {\n\t        if (cm.display.shift || cm.doc.extend || range.empty())\n\t          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n\t        else\n\t          return dir < 0 ? range.from() : range.to();\n\t      }, sel_move);\n\t    }),\n\t\n\t    deleteH: methodOp(function(dir, unit) {\n\t      var sel = this.doc.sel, doc = this.doc;\n\t      if (sel.somethingSelected())\n\t        doc.replaceSelection(\"\", null, \"+delete\");\n\t      else\n\t        deleteNearSelection(this, function(range) {\n\t          var other = findPosH(doc, range.head, dir, unit, false);\n\t          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n\t        });\n\t    }),\n\t\n\t    findPosV: function(from, amount, unit, goalColumn) {\n\t      var dir = 1, x = goalColumn;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        var coords = cursorCoords(this, cur, \"div\");\n\t        if (x == null) x = coords.left;\n\t        else coords.left = x;\n\t        cur = findPosV(this, coords, dir, unit);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveV: methodOp(function(dir, unit) {\n\t      var cm = this, doc = this.doc, goals = [];\n\t      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n\t      doc.extendSelectionsBy(function(range) {\n\t        if (collapse)\n\t          return dir < 0 ? range.from() : range.to();\n\t        var headPos = cursorCoords(cm, range.head, \"div\");\n\t        if (range.goalColumn != null) headPos.left = range.goalColumn;\n\t        goals.push(headPos.left);\n\t        var pos = findPosV(cm, headPos, dir, unit);\n\t        if (unit == \"page\" && range == doc.sel.primary())\n\t          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n\t        return pos;\n\t      }, sel_move);\n\t      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n\t        doc.sel.ranges[i].goalColumn = goals[i];\n\t    }),\n\t\n\t    // Find the word at the given position (as returned by coordsChar).\n\t    findWordAt: function(pos) {\n\t      var doc = this.doc, line = getLine(doc, pos.line).text;\n\t      var start = pos.ch, end = pos.ch;\n\t      if (line) {\n\t        var helper = this.getHelper(pos, \"wordChars\");\n\t        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n\t        var startChar = line.charAt(start);\n\t        var check = isWordChar(startChar, helper)\n\t          ? function(ch) { return isWordChar(ch, helper); }\n\t          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n\t          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n\t        while (start > 0 && check(line.charAt(start - 1))) --start;\n\t        while (end < line.length && check(line.charAt(end))) ++end;\n\t      }\n\t      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n\t    },\n\t\n\t    toggleOverwrite: function(value) {\n\t      if (value != null && value == this.state.overwrite) return;\n\t      if (this.state.overwrite = !this.state.overwrite)\n\t        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t      else\n\t        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t\n\t      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n\t    },\n\t    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\t    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\t\n\t    scrollTo: methodOp(function(x, y) {\n\t      if (x != null || y != null) resolveScrollToPos(this);\n\t      if (x != null) this.curOp.scrollLeft = x;\n\t      if (y != null) this.curOp.scrollTop = y;\n\t    }),\n\t    getScrollInfo: function() {\n\t      var scroller = this.display.scroller;\n\t      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n\t              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n\t              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n\t              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n\t    },\n\t\n\t    scrollIntoView: methodOp(function(range, margin) {\n\t      if (range == null) {\n\t        range = {from: this.doc.sel.primary().head, to: null};\n\t        if (margin == null) margin = this.options.cursorScrollMargin;\n\t      } else if (typeof range == \"number\") {\n\t        range = {from: Pos(range, 0), to: null};\n\t      } else if (range.from == null) {\n\t        range = {from: range, to: null};\n\t      }\n\t      if (!range.to) range.to = range.from;\n\t      range.margin = margin || 0;\n\t\n\t      if (range.from.line != null) {\n\t        resolveScrollToPos(this);\n\t        this.curOp.scrollToPos = range;\n\t      } else {\n\t        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n\t                                      Math.min(range.from.top, range.to.top) - range.margin,\n\t                                      Math.max(range.from.right, range.to.right),\n\t                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n\t        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t      }\n\t    }),\n\t\n\t    setSize: methodOp(function(width, height) {\n\t      var cm = this;\n\t      function interpret(val) {\n\t        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n\t      }\n\t      if (width != null) cm.display.wrapper.style.width = interpret(width);\n\t      if (height != null) cm.display.wrapper.style.height = interpret(height);\n\t      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n\t      var lineNo = cm.display.viewFrom;\n\t      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n\t        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n\t          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n\t        ++lineNo;\n\t      });\n\t      cm.curOp.forceUpdate = true;\n\t      signal(cm, \"refresh\", this);\n\t    }),\n\t\n\t    operation: function(f){return runInOp(this, f);},\n\t\n\t    refresh: methodOp(function() {\n\t      var oldHeight = this.display.cachedTextHeight;\n\t      regChange(this);\n\t      this.curOp.forceUpdate = true;\n\t      clearCaches(this);\n\t      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n\t      updateGutterSpace(this);\n\t      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n\t        estimateLineHeights(this);\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    swapDoc: methodOp(function(doc) {\n\t      var old = this.doc;\n\t      old.cm = null;\n\t      attachDoc(this, doc);\n\t      clearCaches(this);\n\t      this.display.input.reset();\n\t      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n\t      this.curOp.forceScroll = true;\n\t      signalLater(this, \"swapDoc\", this, old);\n\t      return old;\n\t    }),\n\t\n\t    getInputField: function(){return this.display.input.getField();},\n\t    getWrapperElement: function(){return this.display.wrapper;},\n\t    getScrollerElement: function(){return this.display.scroller;},\n\t    getGutterElement: function(){return this.display.gutters;}\n\t  };\n\t  eventMixin(CodeMirror);\n\t\n\t  // OPTION DEFAULTS\n\t\n\t  // The default configuration options.\n\t  var defaults = CodeMirror.defaults = {};\n\t  // Functions to run when options are changed.\n\t  var optionHandlers = CodeMirror.optionHandlers = {};\n\t\n\t  function option(name, deflt, handle, notOnInit) {\n\t    CodeMirror.defaults[name] = deflt;\n\t    if (handle) optionHandlers[name] =\n\t      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n\t  }\n\t\n\t  // Passed to option handlers when there is no old value.\n\t  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\t\n\t  // These two are, on init, called from the constructor because they\n\t  // have to be initialized before the editor can start at all.\n\t  option(\"value\", \"\", function(cm, val) {\n\t    cm.setValue(val);\n\t  }, true);\n\t  option(\"mode\", null, function(cm, val) {\n\t    cm.doc.modeOption = val;\n\t    loadMode(cm);\n\t  }, true);\n\t\n\t  option(\"indentUnit\", 2, loadMode, true);\n\t  option(\"indentWithTabs\", false);\n\t  option(\"smartIndent\", true);\n\t  option(\"tabSize\", 4, function(cm) {\n\t    resetModeState(cm);\n\t    clearCaches(cm);\n\t    regChange(cm);\n\t  }, true);\n\t  option(\"lineSeparator\", null, function(cm, val) {\n\t    cm.doc.lineSep = val;\n\t    if (!val) return;\n\t    var newBreaks = [], lineNo = cm.doc.first;\n\t    cm.doc.iter(function(line) {\n\t      for (var pos = 0;;) {\n\t        var found = line.text.indexOf(val, pos);\n\t        if (found == -1) break;\n\t        pos = found + val.length;\n\t        newBreaks.push(Pos(lineNo, found));\n\t      }\n\t      lineNo++;\n\t    });\n\t    for (var i = newBreaks.length - 1; i >= 0; i--)\n\t      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n\t  });\n\t  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n\t    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\t    if (old != CodeMirror.Init) cm.refresh();\n\t  });\n\t  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n\t  option(\"electricChars\", true);\n\t  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n\t    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n\t  }, true);\n\t  option(\"rtlMoveVisually\", !windows);\n\t  option(\"wholeLineUpdateBefore\", true);\n\t\n\t  option(\"theme\", \"default\", function(cm) {\n\t    themeChanged(cm);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"keyMap\", \"default\", function(cm, val, old) {\n\t    var next = getKeyMap(val);\n\t    var prev = old != CodeMirror.Init && getKeyMap(old);\n\t    if (prev && prev.detach) prev.detach(cm, next);\n\t    if (next.attach) next.attach(cm, prev || null);\n\t  });\n\t  option(\"extraKeys\", null);\n\t\n\t  option(\"lineWrapping\", false, wrappingChanged, true);\n\t  option(\"gutters\", [], function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"fixedGutter\", true, function(cm, val) {\n\t    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n\t  option(\"scrollbarStyle\", \"native\", function(cm) {\n\t    initScrollbars(cm);\n\t    updateScrollbars(cm);\n\t    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n\t    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n\t  }, true);\n\t  option(\"lineNumbers\", false, function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"firstLineNumber\", 1, guttersChanged, true);\n\t  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n\t  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\t\n\t  option(\"resetSelectionOnContextMenu\", true);\n\t  option(\"lineWiseCopyCut\", true);\n\t\n\t  option(\"readOnly\", false, function(cm, val) {\n\t    if (val == \"nocursor\") {\n\t      onBlur(cm);\n\t      cm.display.input.blur();\n\t      cm.display.disabled = true;\n\t    } else {\n\t      cm.display.disabled = false;\n\t    }\n\t    cm.display.input.readOnlyChanged(val)\n\t  });\n\t  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n\t  option(\"dragDrop\", true, dragDropChanged);\n\t  option(\"allowDropFileTypes\", null);\n\t\n\t  option(\"cursorBlinkRate\", 530);\n\t  option(\"cursorScrollMargin\", 0);\n\t  option(\"cursorHeight\", 1, updateSelection, true);\n\t  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n\t  option(\"workTime\", 100);\n\t  option(\"workDelay\", 100);\n\t  option(\"flattenSpans\", true, resetModeState, true);\n\t  option(\"addModeClass\", false, resetModeState, true);\n\t  option(\"pollInterval\", 100);\n\t  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n\t  option(\"historyEventDelay\", 1250);\n\t  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\t  option(\"maxHighlightLength\", 10000, resetModeState, true);\n\t  option(\"moveInputWithCursor\", true, function(cm, val) {\n\t    if (!val) cm.display.input.resetPosition();\n\t  });\n\t\n\t  option(\"tabindex\", null, function(cm, val) {\n\t    cm.display.input.getField().tabIndex = val || \"\";\n\t  });\n\t  option(\"autofocus\", null);\n\t\n\t  // MODE DEFINITION AND QUERYING\n\t\n\t  // Known modes, by name and by MIME\n\t  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\t\n\t  // Extra arguments are stored as the mode's dependencies, which is\n\t  // used by (legacy) mechanisms like loadmode.js to automatically\n\t  // load a mode. (Preferred mechanism is the require/define calls.)\n\t  CodeMirror.defineMode = function(name, mode) {\n\t    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\t    if (arguments.length > 2)\n\t      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n\t    modes[name] = mode;\n\t  };\n\t\n\t  CodeMirror.defineMIME = function(mime, spec) {\n\t    mimeModes[mime] = spec;\n\t  };\n\t\n\t  // Given a MIME type, a {name, ...options} config object, or a name\n\t  // string, return a mode config object.\n\t  CodeMirror.resolveMode = function(spec) {\n\t    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n\t      spec = mimeModes[spec];\n\t    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n\t      var found = mimeModes[spec.name];\n\t      if (typeof found == \"string\") found = {name: found};\n\t      spec = createObj(found, spec);\n\t      spec.name = found.name;\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/xml\");\n\t    }\n\t    if (typeof spec == \"string\") return {name: spec};\n\t    else return spec || {name: \"null\"};\n\t  };\n\t\n\t  // Given a mode spec (anything that resolveMode accepts), find and\n\t  // initialize an actual mode object.\n\t  CodeMirror.getMode = function(options, spec) {\n\t    var spec = CodeMirror.resolveMode(spec);\n\t    var mfactory = modes[spec.name];\n\t    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n\t    var modeObj = mfactory(options, spec);\n\t    if (modeExtensions.hasOwnProperty(spec.name)) {\n\t      var exts = modeExtensions[spec.name];\n\t      for (var prop in exts) {\n\t        if (!exts.hasOwnProperty(prop)) continue;\n\t        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n\t        modeObj[prop] = exts[prop];\n\t      }\n\t    }\n\t    modeObj.name = spec.name;\n\t    if (spec.helperType) modeObj.helperType = spec.helperType;\n\t    if (spec.modeProps) for (var prop in spec.modeProps)\n\t      modeObj[prop] = spec.modeProps[prop];\n\t\n\t    return modeObj;\n\t  };\n\t\n\t  // Minimal default mode.\n\t  CodeMirror.defineMode(\"null\", function() {\n\t    return {token: function(stream) {stream.skipToEnd();}};\n\t  });\n\t  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\t\n\t  // This can be used to attach properties to mode objects from\n\t  // outside the actual mode definition.\n\t  var modeExtensions = CodeMirror.modeExtensions = {};\n\t  CodeMirror.extendMode = function(mode, properties) {\n\t    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n\t    copyObj(properties, exts);\n\t  };\n\t\n\t  // EXTENSIONS\n\t\n\t  CodeMirror.defineExtension = function(name, func) {\n\t    CodeMirror.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineDocExtension = function(name, func) {\n\t    Doc.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineOption = option;\n\t\n\t  var initHooks = [];\n\t  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\t\n\t  var helpers = CodeMirror.helpers = {};\n\t  CodeMirror.registerHelper = function(type, name, value) {\n\t    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n\t    helpers[type][name] = value;\n\t  };\n\t  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n\t    CodeMirror.registerHelper(type, name, value);\n\t    helpers[type]._global.push({pred: predicate, val: value});\n\t  };\n\t\n\t  // MODE STATE HANDLING\n\t\n\t  // Utility functions for working with state. Exported because nested\n\t  // modes need to do this for their inner modes.\n\t\n\t  var copyState = CodeMirror.copyState = function(mode, state) {\n\t    if (state === true) return state;\n\t    if (mode.copyState) return mode.copyState(state);\n\t    var nstate = {};\n\t    for (var n in state) {\n\t      var val = state[n];\n\t      if (val instanceof Array) val = val.concat([]);\n\t      nstate[n] = val;\n\t    }\n\t    return nstate;\n\t  };\n\t\n\t  var startState = CodeMirror.startState = function(mode, a1, a2) {\n\t    return mode.startState ? mode.startState(a1, a2) : true;\n\t  };\n\t\n\t  // Given a mode and a state (for that mode), find the inner mode and\n\t  // state at the position that the state refers to.\n\t  CodeMirror.innerMode = function(mode, state) {\n\t    while (mode.innerMode) {\n\t      var info = mode.innerMode(state);\n\t      if (!info || info.mode == mode) break;\n\t      state = info.state;\n\t      mode = info.mode;\n\t    }\n\t    return info || {mode: mode, state: state};\n\t  };\n\t\n\t  // STANDARD COMMANDS\n\t\n\t  // Commands are parameter-less actions that can be performed on an\n\t  // editor, mostly used for keybindings.\n\t  var commands = CodeMirror.commands = {\n\t    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n\t    singleSelection: function(cm) {\n\t      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n\t    },\n\t    killLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        if (range.empty()) {\n\t          var len = getLine(cm.doc, range.head.line).text.length;\n\t          if (range.head.ch == len && range.head.line < cm.lastLine())\n\t            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n\t          else\n\t            return {from: range.head, to: Pos(range.head.line, len)};\n\t        } else {\n\t          return {from: range.from(), to: range.to()};\n\t        }\n\t      });\n\t    },\n\t    deleteLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0),\n\t                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n\t      });\n\t    },\n\t    delLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0), to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        return {from: leftPos, to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineRight: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t        return {from: range.from(), to: rightPos };\n\t      });\n\t    },\n\t    undo: function(cm) {cm.undo();},\n\t    redo: function(cm) {cm.redo();},\n\t    undoSelection: function(cm) {cm.undoSelection();},\n\t    redoSelection: function(cm) {cm.redoSelection();},\n\t    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n\t    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n\t    goLineStart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineStartSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        return lineStartSmart(cm, range.head);\n\t      }, {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineEnd: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: -1});\n\t    },\n\t    goLineRight: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeft: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: 0, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeftSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n\t        return pos;\n\t      }, sel_move);\n\t    },\n\t    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n\t    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n\t    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n\t    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n\t    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n\t    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n\t    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n\t    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n\t    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n\t    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n\t    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n\t    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n\t    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n\t    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n\t    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n\t    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n\t    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n\t    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n\t    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n\t    indentMore: function(cm) {cm.indentSelection(\"add\");},\n\t    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n\t    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n\t    insertSoftTab: function(cm) {\n\t      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var pos = ranges[i].from();\n\t        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n\t        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n\t      }\n\t      cm.replaceSelections(spaces);\n\t    },\n\t    defaultTab: function(cm) {\n\t      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n\t      else cm.execCommand(\"insertTab\");\n\t    },\n\t    transposeChars: function(cm) {\n\t      runInOp(cm, function() {\n\t        var ranges = cm.listSelections(), newSel = [];\n\t        for (var i = 0; i < ranges.length; i++) {\n\t          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n\t          if (line) {\n\t            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n\t            if (cur.ch > 0) {\n\t              cur = new Pos(cur.line, cur.ch + 1);\n\t              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n\t                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n\t            } else if (cur.line > cm.doc.first) {\n\t              var prev = getLine(cm.doc, cur.line - 1).text;\n\t              if (prev)\n\t                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n\t                                prev.charAt(prev.length - 1),\n\t                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n\t            }\n\t          }\n\t          newSel.push(new Range(cur, cur));\n\t        }\n\t        cm.setSelections(newSel);\n\t      });\n\t    },\n\t    newlineAndIndent: function(cm) {\n\t      runInOp(cm, function() {\n\t        var len = cm.listSelections().length;\n\t        for (var i = 0; i < len; i++) {\n\t          var range = cm.listSelections()[i];\n\t          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n\t          cm.indentLine(range.from().line + 1, null, true);\n\t        }\n\t        ensureCursorVisible(cm);\n\t      });\n\t    },\n\t    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n\t  };\n\t\n\t\n\t  // STANDARD KEYMAPS\n\t\n\t  var keyMap = CodeMirror.keyMap = {};\n\t\n\t  keyMap.basic = {\n\t    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n\t    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n\t    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n\t    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n\t    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n\t    \"Esc\": \"singleSelection\"\n\t  };\n\t  // Note that the save and find-related commands aren't defined by\n\t  // default. User code or addons can define them. Unknown commands\n\t  // are simply ignored.\n\t  keyMap.pcDefault = {\n\t    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n\t    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n\t    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n\t    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n\t    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n\t    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n\t    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n\t    fallthrough: \"basic\"\n\t  };\n\t  // Very basic readline/emacs-style bindings, which are standard on Mac.\n\t  keyMap.emacsy = {\n\t    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n\t    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n\t    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n\t    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n\t  };\n\t  keyMap.macDefault = {\n\t    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n\t    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n\t    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n\t    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n\t    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n\t    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n\t    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n\t    fallthrough: [\"basic\", \"emacsy\"]\n\t  };\n\t  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\t\n\t  // KEYMAP DISPATCH\n\t\n\t  function normalizeKeyName(name) {\n\t    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n\t    var alt, ctrl, shift, cmd;\n\t    for (var i = 0; i < parts.length - 1; i++) {\n\t      var mod = parts[i];\n\t      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n\t      else if (/^a(lt)?$/i.test(mod)) alt = true;\n\t      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n\t      else if (/^s(hift)$/i.test(mod)) shift = true;\n\t      else throw new Error(\"Unrecognized modifier name: \" + mod);\n\t    }\n\t    if (alt) name = \"Alt-\" + name;\n\t    if (ctrl) name = \"Ctrl-\" + name;\n\t    if (cmd) name = \"Cmd-\" + name;\n\t    if (shift) name = \"Shift-\" + name;\n\t    return name;\n\t  }\n\t\n\t  // This is a kludge to keep keymaps mostly working as raw objects\n\t  // (backwards compatibility) while at the same time support features\n\t  // like normalization and multi-stroke key bindings. It compiles a\n\t  // new normalized keymap, and then updates the old object to reflect\n\t  // this.\n\t  CodeMirror.normalizeKeyMap = function(keymap) {\n\t    var copy = {};\n\t    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n\t      var value = keymap[keyname];\n\t      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n\t      if (value == \"...\") { delete keymap[keyname]; continue; }\n\t\n\t      var keys = map(keyname.split(\" \"), normalizeKeyName);\n\t      for (var i = 0; i < keys.length; i++) {\n\t        var val, name;\n\t        if (i == keys.length - 1) {\n\t          name = keys.join(\" \");\n\t          val = value;\n\t        } else {\n\t          name = keys.slice(0, i + 1).join(\" \");\n\t          val = \"...\";\n\t        }\n\t        var prev = copy[name];\n\t        if (!prev) copy[name] = val;\n\t        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n\t      }\n\t      delete keymap[keyname];\n\t    }\n\t    for (var prop in copy) keymap[prop] = copy[prop];\n\t    return keymap;\n\t  };\n\t\n\t  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n\t    map = getKeyMap(map);\n\t    var found = map.call ? map.call(key, context) : map[key];\n\t    if (found === false) return \"nothing\";\n\t    if (found === \"...\") return \"multi\";\n\t    if (found != null && handle(found)) return \"handled\";\n\t\n\t    if (map.fallthrough) {\n\t      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n\t        return lookupKey(key, map.fallthrough, handle, context);\n\t      for (var i = 0; i < map.fallthrough.length; i++) {\n\t        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\t        if (result) return result;\n\t      }\n\t    }\n\t  };\n\t\n\t  // Modifier key presses don't count as 'real' key presses for the\n\t  // purpose of keymap fallthrough.\n\t  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n\t    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n\t    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n\t  };\n\t\n\t  // Look up the name of a key as indicated by an event object.\n\t  var keyName = CodeMirror.keyName = function(event, noShift) {\n\t    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n\t    var base = keyNames[event.keyCode], name = base;\n\t    if (name == null || event.altGraphKey) return false;\n\t    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n\t    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n\t    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n\t    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n\t    return name;\n\t  };\n\t\n\t  function getKeyMap(val) {\n\t    return typeof val == \"string\" ? keyMap[val] : val;\n\t  }\n\t\n\t  // FROMTEXTAREA\n\t\n\t  CodeMirror.fromTextArea = function(textarea, options) {\n\t    options = options ? copyObj(options) : {};\n\t    options.value = textarea.value;\n\t    if (!options.tabindex && textarea.tabIndex)\n\t      options.tabindex = textarea.tabIndex;\n\t    if (!options.placeholder && textarea.placeholder)\n\t      options.placeholder = textarea.placeholder;\n\t    // Set autofocus to true if this textarea is focused, or if it has\n\t    // autofocus and no other element is focused.\n\t    if (options.autofocus == null) {\n\t      var hasFocus = activeElt();\n\t      options.autofocus = hasFocus == textarea ||\n\t        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n\t    }\n\t\n\t    function save() {textarea.value = cm.getValue();}\n\t    if (textarea.form) {\n\t      on(textarea.form, \"submit\", save);\n\t      // Deplorable hack to make the submit method do the right thing.\n\t      if (!options.leaveSubmitMethodAlone) {\n\t        var form = textarea.form, realSubmit = form.submit;\n\t        try {\n\t          var wrappedSubmit = form.submit = function() {\n\t            save();\n\t            form.submit = realSubmit;\n\t            form.submit();\n\t            form.submit = wrappedSubmit;\n\t          };\n\t        } catch(e) {}\n\t      }\n\t    }\n\t\n\t    options.finishInit = function(cm) {\n\t      cm.save = save;\n\t      cm.getTextArea = function() { return textarea; };\n\t      cm.toTextArea = function() {\n\t        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\t        save();\n\t        textarea.parentNode.removeChild(cm.getWrapperElement());\n\t        textarea.style.display = \"\";\n\t        if (textarea.form) {\n\t          off(textarea.form, \"submit\", save);\n\t          if (typeof textarea.form.submit == \"function\")\n\t            textarea.form.submit = realSubmit;\n\t        }\n\t      };\n\t    };\n\t\n\t    textarea.style.display = \"none\";\n\t    var cm = CodeMirror(function(node) {\n\t      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n\t    }, options);\n\t    return cm;\n\t  };\n\t\n\t  // STRING STREAM\n\t\n\t  // Fed to the mode parsers, provides helper functions to make\n\t  // parsers more succinct.\n\t\n\t  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n\t    this.pos = this.start = 0;\n\t    this.string = string;\n\t    this.tabSize = tabSize || 8;\n\t    this.lastColumnPos = this.lastColumnValue = 0;\n\t    this.lineStart = 0;\n\t  };\n\t\n\t  StringStream.prototype = {\n\t    eol: function() {return this.pos >= this.string.length;},\n\t    sol: function() {return this.pos == this.lineStart;},\n\t    peek: function() {return this.string.charAt(this.pos) || undefined;},\n\t    next: function() {\n\t      if (this.pos < this.string.length)\n\t        return this.string.charAt(this.pos++);\n\t    },\n\t    eat: function(match) {\n\t      var ch = this.string.charAt(this.pos);\n\t      if (typeof match == \"string\") var ok = ch == match;\n\t      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\t      if (ok) {++this.pos; return ch;}\n\t    },\n\t    eatWhile: function(match) {\n\t      var start = this.pos;\n\t      while (this.eat(match)){}\n\t      return this.pos > start;\n\t    },\n\t    eatSpace: function() {\n\t      var start = this.pos;\n\t      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\t      return this.pos > start;\n\t    },\n\t    skipToEnd: function() {this.pos = this.string.length;},\n\t    skipTo: function(ch) {\n\t      var found = this.string.indexOf(ch, this.pos);\n\t      if (found > -1) {this.pos = found; return true;}\n\t    },\n\t    backUp: function(n) {this.pos -= n;},\n\t    column: function() {\n\t      if (this.lastColumnPos < this.start) {\n\t        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n\t        this.lastColumnPos = this.start;\n\t      }\n\t      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    indentation: function() {\n\t      return countColumn(this.string, null, this.tabSize) -\n\t        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    match: function(pattern, consume, caseInsensitive) {\n\t      if (typeof pattern == \"string\") {\n\t        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n\t        var substr = this.string.substr(this.pos, pattern.length);\n\t        if (cased(substr) == cased(pattern)) {\n\t          if (consume !== false) this.pos += pattern.length;\n\t          return true;\n\t        }\n\t      } else {\n\t        var match = this.string.slice(this.pos).match(pattern);\n\t        if (match && match.index > 0) return null;\n\t        if (match && consume !== false) this.pos += match[0].length;\n\t        return match;\n\t      }\n\t    },\n\t    current: function(){return this.string.slice(this.start, this.pos);},\n\t    hideFirstChars: function(n, inner) {\n\t      this.lineStart += n;\n\t      try { return inner(); }\n\t      finally { this.lineStart -= n; }\n\t    }\n\t  };\n\t\n\t  // TEXTMARKERS\n\t\n\t  // Created with markText and setBookmark methods. A TextMarker is a\n\t  // handle that can be used to clear or find a marked position in the\n\t  // document. Line objects hold arrays (markedSpans) containing\n\t  // {from, to, marker} object pointing to such marker objects, and\n\t  // indicating that such a marker is present on that line. Multiple\n\t  // lines may point to the same marker when it spans across lines.\n\t  // The spans will have null for their from/to properties when the\n\t  // marker continues beyond the start/end of the line. Markers have\n\t  // links back to the lines they currently touch.\n\t\n\t  var nextMarkerId = 0;\n\t\n\t  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n\t    this.lines = [];\n\t    this.type = type;\n\t    this.doc = doc;\n\t    this.id = ++nextMarkerId;\n\t  };\n\t  eventMixin(TextMarker);\n\t\n\t  // Clear the marker.\n\t  TextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    if (hasHandler(this, \"clear\")) {\n\t      var found = this.find();\n\t      if (found) signalLater(this, \"clear\", found.from, found.to);\n\t    }\n\t    var min = null, max = null;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n\t      else if (cm) {\n\t        if (span.to != null) max = lineNo(line);\n\t        if (span.from != null) min = lineNo(line);\n\t      }\n\t      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\t      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n\t        updateLineHeight(line, textHeight(cm.display));\n\t    }\n\t    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n\t      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n\t      if (len > cm.display.maxLineLength) {\n\t        cm.display.maxLine = visual;\n\t        cm.display.maxLineLength = len;\n\t        cm.display.maxLineChanged = true;\n\t      }\n\t    }\n\t\n\t    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n\t    this.lines.length = 0;\n\t    this.explicitlyCleared = true;\n\t    if (this.atomic && this.doc.cantEdit) {\n\t      this.doc.cantEdit = false;\n\t      if (cm) reCheckSelection(cm.doc);\n\t    }\n\t    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n\t    if (withOp) endOperation(cm);\n\t    if (this.parent) this.parent.clear();\n\t  };\n\t\n\t  // Find the position of the marker in the document. Returns a {from,\n\t  // to} object by default. Side can be passed to get a specific side\n\t  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n\t  // Pos objects returned contain a line object, rather than a line\n\t  // number (used to prevent looking up the same line twice).\n\t  TextMarker.prototype.find = function(side, lineObj) {\n\t    if (side == null && this.type == \"bookmark\") side = 1;\n\t    var from, to;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.from != null) {\n\t        from = Pos(lineObj ? line : lineNo(line), span.from);\n\t        if (side == -1) return from;\n\t      }\n\t      if (span.to != null) {\n\t        to = Pos(lineObj ? line : lineNo(line), span.to);\n\t        if (side == 1) return to;\n\t      }\n\t    }\n\t    return from && {from: from, to: to};\n\t  };\n\t\n\t  // Signals that the marker's widget changed, and surrounding layout\n\t  // should be recomputed.\n\t  TextMarker.prototype.changed = function() {\n\t    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n\t    if (!pos || !cm) return;\n\t    runInOp(cm, function() {\n\t      var line = pos.line, lineN = lineNo(pos.line);\n\t      var view = findViewForLine(cm, lineN);\n\t      if (view) {\n\t        clearLineMeasurementCacheFor(view);\n\t        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n\t      }\n\t      cm.curOp.updateMaxLine = true;\n\t      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n\t        var oldHeight = widget.height;\n\t        widget.height = null;\n\t        var dHeight = widgetHeight(widget) - oldHeight;\n\t        if (dHeight)\n\t          updateLineHeight(line, line.height + dHeight);\n\t      }\n\t    });\n\t  };\n\t\n\t  TextMarker.prototype.attachLine = function(line) {\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n\t        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n\t    }\n\t    this.lines.push(line);\n\t  };\n\t  TextMarker.prototype.detachLine = function(line) {\n\t    this.lines.splice(indexOf(this.lines, line), 1);\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n\t    }\n\t  };\n\t\n\t  // Collapsed markers have unique ids, in order to be able to order\n\t  // them, which is needed for uniquely determining an outer marker\n\t  // when they overlap (they may nest, but not partially overlap).\n\t  var nextMarkerId = 0;\n\t\n\t  // Create a marker, wire it up to the right lines, and\n\t  function markText(doc, from, to, options, type) {\n\t    // Shared markers (across linked documents) are handled separately\n\t    // (markTextShared will call out to this again, once per\n\t    // document).\n\t    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n\t    // Ensure we are in an operation.\n\t    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\t\n\t    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n\t    if (options) copyObj(options, marker, false);\n\t    // Don't connect empty markers unless clearWhenEmpty is false\n\t    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n\t      return marker;\n\t    if (marker.replacedWith) {\n\t      // Showing up as a widget implies collapsed (widget replaces text)\n\t      marker.collapsed = true;\n\t      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\t      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n\t      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n\t    }\n\t    if (marker.collapsed) {\n\t      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n\t          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n\t        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n\t      sawCollapsedSpans = true;\n\t    }\n\t\n\t    if (marker.addToHistory)\n\t      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\t\n\t    var curLine = from.line, cm = doc.cm, updateMaxLine;\n\t    doc.iter(curLine, to.line + 1, function(line) {\n\t      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n\t        updateMaxLine = true;\n\t      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n\t      addMarkedSpan(line, new MarkedSpan(marker,\n\t                                         curLine == from.line ? from.ch : null,\n\t                                         curLine == to.line ? to.ch : null));\n\t      ++curLine;\n\t    });\n\t    // lineIsHidden depends on the presence of the spans, so needs a second pass\n\t    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n\t      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n\t    });\n\t\n\t    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\t\n\t    if (marker.readOnly) {\n\t      sawReadOnlySpans = true;\n\t      if (doc.history.done.length || doc.history.undone.length)\n\t        doc.clearHistory();\n\t    }\n\t    if (marker.collapsed) {\n\t      marker.id = ++nextMarkerId;\n\t      marker.atomic = true;\n\t    }\n\t    if (cm) {\n\t      // Sync editor state\n\t      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n\t      if (marker.collapsed)\n\t        regChange(cm, from.line, to.line + 1);\n\t      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n\t        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n\t      if (marker.atomic) reCheckSelection(cm.doc);\n\t      signalLater(cm, \"markerAdded\", cm, marker);\n\t    }\n\t    return marker;\n\t  }\n\t\n\t  // SHARED TEXTMARKERS\n\t\n\t  // A shared marker spans multiple linked documents. It is\n\t  // implemented as a meta-marker-object controlling multiple normal\n\t  // markers.\n\t  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n\t    this.markers = markers;\n\t    this.primary = primary;\n\t    for (var i = 0; i < markers.length; ++i)\n\t      markers[i].parent = this;\n\t  };\n\t  eventMixin(SharedTextMarker);\n\t\n\t  SharedTextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    this.explicitlyCleared = true;\n\t    for (var i = 0; i < this.markers.length; ++i)\n\t      this.markers[i].clear();\n\t    signalLater(this, \"clear\");\n\t  };\n\t  SharedTextMarker.prototype.find = function(side, lineObj) {\n\t    return this.primary.find(side, lineObj);\n\t  };\n\t\n\t  function markTextShared(doc, from, to, options, type) {\n\t    options = copyObj(options);\n\t    options.shared = false;\n\t    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n\t    var widget = options.widgetNode;\n\t    linkedDocs(doc, function(doc) {\n\t      if (widget) options.widgetNode = widget.cloneNode(true);\n\t      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n\t      for (var i = 0; i < doc.linked.length; ++i)\n\t        if (doc.linked[i].isParent) return;\n\t      primary = lst(markers);\n\t    });\n\t    return new SharedTextMarker(markers, primary);\n\t  }\n\t\n\t  function findSharedMarkers(doc) {\n\t    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n\t                         function(m) { return m.parent; });\n\t  }\n\t\n\t  function copySharedMarkers(doc, markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], pos = marker.find();\n\t      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n\t      if (cmp(mFrom, mTo)) {\n\t        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\t        marker.markers.push(subMark);\n\t        subMark.parent = marker;\n\t      }\n\t    }\n\t  }\n\t\n\t  function detachSharedMarkers(markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], linked = [marker.primary.doc];;\n\t      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n\t      for (var j = 0; j < marker.markers.length; j++) {\n\t        var subMarker = marker.markers[j];\n\t        if (indexOf(linked, subMarker.doc) == -1) {\n\t          subMarker.parent = null;\n\t          marker.markers.splice(j--, 1);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // TEXTMARKER SPANS\n\t\n\t  function MarkedSpan(marker, from, to) {\n\t    this.marker = marker;\n\t    this.from = from; this.to = to;\n\t  }\n\t\n\t  // Search an array of spans for a span matching the given marker.\n\t  function getMarkedSpanFor(spans, marker) {\n\t    if (spans) for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.marker == marker) return span;\n\t    }\n\t  }\n\t  // Remove a span from an array, returning undefined if no spans are\n\t  // left (we don't store arrays for lines without spans).\n\t  function removeMarkedSpan(spans, span) {\n\t    for (var r, i = 0; i < spans.length; ++i)\n\t      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n\t    return r;\n\t  }\n\t  // Add a span to a line.\n\t  function addMarkedSpan(line, span) {\n\t    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\t    span.marker.attachLine(line);\n\t  }\n\t\n\t  // Used for the algorithm that adjusts markers for a change in the\n\t  // document. These functions cut an array of spans at a given\n\t  // character position, returning an array of remaining chunks (or\n\t  // undefined if nothing remains).\n\t  function markedSpansBefore(old, startCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\t      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n\t        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t  function markedSpansAfter(old, endCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\t      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n\t        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n\t                                              span.to == null ? null : span.to - endCh));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  // Given a change object, compute the new set of marker spans that\n\t  // cover the line in which the change took place. Removes spans\n\t  // entirely within the change, reconnects spans belonging to the\n\t  // same marker that appear on both sides of the change, and cuts off\n\t  // spans partially within the change. Returns an array of span\n\t  // arrays with one element for each line in (after) the change.\n\t  function stretchSpansOverChange(doc, change) {\n\t    if (change.full) return null;\n\t    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n\t    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\t    if (!oldFirst && !oldLast) return null;\n\t\n\t    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n\t    // Get the spans that 'stick out' on both sides\n\t    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n\t    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\t\n\t    // Next, merge those two ends\n\t    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n\t    if (first) {\n\t      // Fix up .to properties of first\n\t      for (var i = 0; i < first.length; ++i) {\n\t        var span = first[i];\n\t        if (span.to == null) {\n\t          var found = getMarkedSpanFor(last, span.marker);\n\t          if (!found) span.to = startCh;\n\t          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n\t        }\n\t      }\n\t    }\n\t    if (last) {\n\t      // Fix up .from in last (or move them into first in case of sameLine)\n\t      for (var i = 0; i < last.length; ++i) {\n\t        var span = last[i];\n\t        if (span.to != null) span.to += offset;\n\t        if (span.from == null) {\n\t          var found = getMarkedSpanFor(first, span.marker);\n\t          if (!found) {\n\t            span.from = offset;\n\t            if (sameLine) (first || (first = [])).push(span);\n\t          }\n\t        } else {\n\t          span.from += offset;\n\t          if (sameLine) (first || (first = [])).push(span);\n\t        }\n\t      }\n\t    }\n\t    // Make sure we didn't create any zero-length spans\n\t    if (first) first = clearEmptySpans(first);\n\t    if (last && last != first) last = clearEmptySpans(last);\n\t\n\t    var newMarkers = [first];\n\t    if (!sameLine) {\n\t      // Fill gap with whole-line-spans\n\t      var gap = change.text.length - 2, gapMarkers;\n\t      if (gap > 0 && first)\n\t        for (var i = 0; i < first.length; ++i)\n\t          if (first[i].to == null)\n\t            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n\t      for (var i = 0; i < gap; ++i)\n\t        newMarkers.push(gapMarkers);\n\t      newMarkers.push(last);\n\t    }\n\t    return newMarkers;\n\t  }\n\t\n\t  // Remove spans that are empty and don't have a clearWhenEmpty\n\t  // option of false.\n\t  function clearEmptySpans(spans) {\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n\t        spans.splice(i--, 1);\n\t    }\n\t    if (!spans.length) return null;\n\t    return spans;\n\t  }\n\t\n\t  // Used for un/re-doing changes from the history. Combines the\n\t  // result of computing the existing spans with the set of spans that\n\t  // existed in the history (so that deleting around a span and then\n\t  // undoing brings back the span).\n\t  function mergeOldSpans(doc, change) {\n\t    var old = getOldSpans(doc, change);\n\t    var stretched = stretchSpansOverChange(doc, change);\n\t    if (!old) return stretched;\n\t    if (!stretched) return old;\n\t\n\t    for (var i = 0; i < old.length; ++i) {\n\t      var oldCur = old[i], stretchCur = stretched[i];\n\t      if (oldCur && stretchCur) {\n\t        spans: for (var j = 0; j < stretchCur.length; ++j) {\n\t          var span = stretchCur[j];\n\t          for (var k = 0; k < oldCur.length; ++k)\n\t            if (oldCur[k].marker == span.marker) continue spans;\n\t          oldCur.push(span);\n\t        }\n\t      } else if (stretchCur) {\n\t        old[i] = stretchCur;\n\t      }\n\t    }\n\t    return old;\n\t  }\n\t\n\t  // Used to 'clip' out readOnly ranges when making a change.\n\t  function removeReadOnlyRanges(doc, from, to) {\n\t    var markers = null;\n\t    doc.iter(from.line, to.line + 1, function(line) {\n\t      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t        var mark = line.markedSpans[i].marker;\n\t        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n\t          (markers || (markers = [])).push(mark);\n\t      }\n\t    });\n\t    if (!markers) return null;\n\t    var parts = [{from: from, to: to}];\n\t    for (var i = 0; i < markers.length; ++i) {\n\t      var mk = markers[i], m = mk.find(0);\n\t      for (var j = 0; j < parts.length; ++j) {\n\t        var p = parts[j];\n\t        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n\t        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n\t        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n\t          newParts.push({from: p.from, to: m.from});\n\t        if (dto > 0 || !mk.inclusiveRight && !dto)\n\t          newParts.push({from: m.to, to: p.to});\n\t        parts.splice.apply(parts, newParts);\n\t        j += newParts.length - 1;\n\t      }\n\t    }\n\t    return parts;\n\t  }\n\t\n\t  // Connect or disconnect spans from a line.\n\t  function detachMarkedSpans(line) {\n\t    var spans = line.markedSpans;\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.detachLine(line);\n\t    line.markedSpans = null;\n\t  }\n\t  function attachMarkedSpans(line, spans) {\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.attachLine(line);\n\t    line.markedSpans = spans;\n\t  }\n\t\n\t  // Helpers used when computing which overlapping collapsed span\n\t  // counts as the larger one.\n\t  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n\t  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\t\n\t  // Returns a number indicating which of two overlapping collapsed\n\t  // spans is larger (and thus includes the other). Falls back to\n\t  // comparing ids when the spans cover exactly the same range.\n\t  function compareCollapsedMarkers(a, b) {\n\t    var lenDiff = a.lines.length - b.lines.length;\n\t    if (lenDiff != 0) return lenDiff;\n\t    var aPos = a.find(), bPos = b.find();\n\t    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\t    if (fromCmp) return -fromCmp;\n\t    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\t    if (toCmp) return toCmp;\n\t    return b.id - a.id;\n\t  }\n\t\n\t  // Find out whether a line ends or starts in a collapsed span. If\n\t  // so, return the marker for that span.\n\t  function collapsedSpanAtSide(line, start) {\n\t    var sps = sawCollapsedSpans && line.markedSpans, found;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n\t          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n\t        found = sp.marker;\n\t    }\n\t    return found;\n\t  }\n\t  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n\t  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\t\n\t  // Test whether there exists a collapsed span that partially\n\t  // overlaps (covers the start or end, but not both) of a new span.\n\t  // Such overlap is not allowed.\n\t  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n\t    var line = getLine(doc, lineNo);\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var i = 0; i < sps.length; ++i) {\n\t      var sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      var found = sp.marker.find(0);\n\t      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n\t      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\t      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n\t      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n\t          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // A visual line is a line as drawn on the screen. Folding, for\n\t  // example, can cause multiple logical lines to appear on the same\n\t  // visual line. This finds the start of the visual line that the\n\t  // given line is part of (usually that is the line itself).\n\t  function visualLine(line) {\n\t    var merged;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = merged.find(-1, true).line;\n\t    return line;\n\t  }\n\t\n\t  // Returns an array of logical lines that continue the visual line\n\t  // started by the argument, or undefined if there are no such lines.\n\t  function visualLineContinued(line) {\n\t    var merged, lines;\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      (lines || (lines = [])).push(line);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  // Get the line number of the start of the visual line that the\n\t  // given line number is part of.\n\t  function visualLineNo(doc, lineN) {\n\t    var line = getLine(doc, lineN), vis = visualLine(line);\n\t    if (line == vis) return lineN;\n\t    return lineNo(vis);\n\t  }\n\t  // Get the line number of the start of the next visual line after\n\t  // the given line.\n\t  function visualLineEndNo(doc, lineN) {\n\t    if (lineN > doc.lastLine()) return lineN;\n\t    var line = getLine(doc, lineN), merged;\n\t    if (!lineIsHidden(doc, line)) return lineN;\n\t    while (merged = collapsedSpanAtEnd(line))\n\t      line = merged.find(1, true).line;\n\t    return lineNo(line) + 1;\n\t  }\n\t\n\t  // Compute whether a line is hidden. Lines count as hidden when they\n\t  // are part of a visual line that starts with another line, or when\n\t  // they are entirely covered by collapsed, non-widget span.\n\t  function lineIsHidden(doc, line) {\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      if (sp.from == null) return true;\n\t      if (sp.marker.widgetNode) continue;\n\t      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n\t        return true;\n\t    }\n\t  }\n\t  function lineIsHiddenInner(doc, line, span) {\n\t    if (span.to == null) {\n\t      var end = span.marker.find(1, true);\n\t      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n\t    }\n\t    if (span.marker.inclusiveRight && span.to == line.text.length)\n\t      return true;\n\t    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n\t      sp = line.markedSpans[i];\n\t      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n\t          (sp.to == null || sp.to != span.from) &&\n\t          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n\t          lineIsHiddenInner(doc, line, sp)) return true;\n\t    }\n\t  }\n\t\n\t  // LINE WIDGETS\n\t\n\t  // Line widgets are block elements displayed above or below a line.\n\t\n\t  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n\t    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n\t      this[opt] = options[opt];\n\t    this.doc = doc;\n\t    this.node = node;\n\t  };\n\t  eventMixin(LineWidget);\n\t\n\t  function adjustScrollWhenAboveVisible(cm, line, diff) {\n\t    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n\t      addToScrollPos(cm, null, diff);\n\t  }\n\t\n\t  LineWidget.prototype.clear = function() {\n\t    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n\t    if (no == null || !ws) return;\n\t    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n\t    if (!ws.length) line.widgets = null;\n\t    var height = widgetHeight(this);\n\t    updateLineHeight(line, Math.max(0, line.height - height));\n\t    if (cm) runInOp(cm, function() {\n\t      adjustScrollWhenAboveVisible(cm, line, -height);\n\t      regLineChange(cm, no, \"widget\");\n\t    });\n\t  };\n\t  LineWidget.prototype.changed = function() {\n\t    var oldH = this.height, cm = this.doc.cm, line = this.line;\n\t    this.height = null;\n\t    var diff = widgetHeight(this) - oldH;\n\t    if (!diff) return;\n\t    updateLineHeight(line, line.height + diff);\n\t    if (cm) runInOp(cm, function() {\n\t      cm.curOp.forceUpdate = true;\n\t      adjustScrollWhenAboveVisible(cm, line, diff);\n\t    });\n\t  };\n\t\n\t  function widgetHeight(widget) {\n\t    if (widget.height != null) return widget.height;\n\t    var cm = widget.doc.cm;\n\t    if (!cm) return 0;\n\t    if (!contains(document.body, widget.node)) {\n\t      var parentStyle = \"position: relative;\";\n\t      if (widget.coverGutter)\n\t        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n\t      if (widget.noHScroll)\n\t        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n\t      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n\t    }\n\t    return widget.height = widget.node.parentNode.offsetHeight;\n\t  }\n\t\n\t  function addLineWidget(doc, handle, node, options) {\n\t    var widget = new LineWidget(doc, node, options);\n\t    var cm = doc.cm;\n\t    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n\t    changeLine(doc, handle, \"widget\", function(line) {\n\t      var widgets = line.widgets || (line.widgets = []);\n\t      if (widget.insertAt == null) widgets.push(widget);\n\t      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n\t      widget.line = line;\n\t      if (cm && !lineIsHidden(doc, line)) {\n\t        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n\t        updateLineHeight(line, line.height + widgetHeight(widget));\n\t        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n\t        cm.curOp.forceUpdate = true;\n\t      }\n\t      return true;\n\t    });\n\t    return widget;\n\t  }\n\t\n\t  // LINE DATA STRUCTURE\n\t\n\t  // Line objects. These hold state related to a line, including\n\t  // highlighting info (the styles array).\n\t  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n\t    this.text = text;\n\t    attachMarkedSpans(this, markedSpans);\n\t    this.height = estimateHeight ? estimateHeight(this) : 1;\n\t  };\n\t  eventMixin(Line);\n\t  Line.prototype.lineNo = function() { return lineNo(this); };\n\t\n\t  // Change the content (text, markers) of a line. Automatically\n\t  // invalidates cached information and tries to re-estimate the\n\t  // line's height.\n\t  function updateLine(line, text, markedSpans, estimateHeight) {\n\t    line.text = text;\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    if (line.styles) line.styles = null;\n\t    if (line.order != null) line.order = null;\n\t    detachMarkedSpans(line);\n\t    attachMarkedSpans(line, markedSpans);\n\t    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\t    if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t  }\n\t\n\t  // Detach a line from the document tree and its markers.\n\t  function cleanUpLine(line) {\n\t    line.parent = null;\n\t    detachMarkedSpans(line);\n\t  }\n\t\n\t  function extractLineClasses(type, output) {\n\t    if (type) for (;;) {\n\t      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\t      if (!lineClass) break;\n\t      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n\t      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\t      if (output[prop] == null)\n\t        output[prop] = lineClass[2];\n\t      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n\t        output[prop] += \" \" + lineClass[2];\n\t    }\n\t    return type;\n\t  }\n\t\n\t  function callBlankLine(mode, state) {\n\t    if (mode.blankLine) return mode.blankLine(state);\n\t    if (!mode.innerMode) return;\n\t    var inner = CodeMirror.innerMode(mode, state);\n\t    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n\t  }\n\t\n\t  function readToken(mode, stream, state, inner) {\n\t    for (var i = 0; i < 10; i++) {\n\t      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n\t      var style = mode.token(stream, state);\n\t      if (stream.pos > stream.start) return style;\n\t    }\n\t    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n\t  }\n\t\n\t  // Utility for getTokenAt and getLineTokens\n\t  function takeToken(cm, pos, precise, asArray) {\n\t    function getObj(copy) {\n\t      return {start: stream.start, end: stream.pos,\n\t              string: stream.current(),\n\t              type: style || null,\n\t              state: copy ? copyState(doc.mode, state) : state};\n\t    }\n\t\n\t    var doc = cm.doc, mode = doc.mode, style;\n\t    pos = clipPos(doc, pos);\n\t    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n\t    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n\t    if (asArray) tokens = [];\n\t    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n\t      stream.start = stream.pos;\n\t      style = readToken(mode, stream, state);\n\t      if (asArray) tokens.push(getObj(true));\n\t    }\n\t    return asArray ? tokens : getObj();\n\t  }\n\t\n\t  // Run the given mode's parser over a line, calling f for each token.\n\t  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n\t    var flattenSpans = mode.flattenSpans;\n\t    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n\t    var curStart = 0, curStyle = null;\n\t    var stream = new StringStream(text, cm.options.tabSize), style;\n\t    var inner = cm.options.addModeClass && [null];\n\t    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n\t    while (!stream.eol()) {\n\t      if (stream.pos > cm.options.maxHighlightLength) {\n\t        flattenSpans = false;\n\t        if (forceToEnd) processLine(cm, text, state, stream.pos);\n\t        stream.pos = text.length;\n\t        style = null;\n\t      } else {\n\t        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n\t      }\n\t      if (inner) {\n\t        var mName = inner[0].name;\n\t        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n\t      }\n\t      if (!flattenSpans || curStyle != style) {\n\t        while (curStart < stream.start) {\n\t          curStart = Math.min(stream.start, curStart + 50000);\n\t          f(curStart, curStyle);\n\t        }\n\t        curStyle = style;\n\t      }\n\t      stream.start = stream.pos;\n\t    }\n\t    while (curStart < stream.pos) {\n\t      // Webkit seems to refuse to render text nodes longer than 57444 characters\n\t      var pos = Math.min(stream.pos, curStart + 50000);\n\t      f(pos, curStyle);\n\t      curStart = pos;\n\t    }\n\t  }\n\t\n\t  // Compute a style array (an array starting with a mode generation\n\t  // -- for invalidation -- followed by pairs of end positions and\n\t  // style strings), which is used to highlight the tokens on the\n\t  // line.\n\t  function highlightLine(cm, line, state, forceToEnd) {\n\t    // A styles array always starts with a number identifying the\n\t    // mode/overlays that it is based on (for easy invalidation).\n\t    var st = [cm.state.modeGen], lineClasses = {};\n\t    // Compute the base array of styles\n\t    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n\t      st.push(end, style);\n\t    }, lineClasses, forceToEnd);\n\t\n\t    // Run overlays, adjust style array.\n\t    for (var o = 0; o < cm.state.overlays.length; ++o) {\n\t      var overlay = cm.state.overlays[o], i = 1, at = 0;\n\t      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n\t        var start = i;\n\t        // Ensure there's a token end at the current position, and that i points at it\n\t        while (at < end) {\n\t          var i_end = st[i];\n\t          if (i_end > end)\n\t            st.splice(i, 1, end, st[i+1], i_end);\n\t          i += 2;\n\t          at = Math.min(end, i_end);\n\t        }\n\t        if (!style) return;\n\t        if (overlay.opaque) {\n\t          st.splice(start, i - start, end, \"cm-overlay \" + style);\n\t          i = start + 2;\n\t        } else {\n\t          for (; start < i; start += 2) {\n\t            var cur = st[start+1];\n\t            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n\t          }\n\t        }\n\t      }, lineClasses);\n\t    }\n\t\n\t    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n\t  }\n\t\n\t  function getLineStyles(cm, line, updateFrontier) {\n\t    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n\t      var state = getStateBefore(cm, lineNo(line));\n\t      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n\t      line.stateAfter = state;\n\t      line.styles = result.styles;\n\t      if (result.classes) line.styleClasses = result.classes;\n\t      else if (line.styleClasses) line.styleClasses = null;\n\t      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n\t    }\n\t    return line.styles;\n\t  }\n\t\n\t  // Lightweight form of highlight -- proceed over this line and\n\t  // update state, but don't save a style array. Used for lines that\n\t  // aren't currently visible.\n\t  function processLine(cm, text, state, startAt) {\n\t    var mode = cm.doc.mode;\n\t    var stream = new StringStream(text, cm.options.tabSize);\n\t    stream.start = stream.pos = startAt || 0;\n\t    if (text == \"\") callBlankLine(mode, state);\n\t    while (!stream.eol()) {\n\t      readToken(mode, stream, state);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t\n\t  // Convert a style as returned by a mode (either null, or a string\n\t  // containing one or more styles) to a CSS style. This is cached,\n\t  // and also looks for line-wide styles.\n\t  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n\t  function interpretTokenStyle(style, options) {\n\t    if (!style || /^\\s*$/.test(style)) return null;\n\t    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n\t    return cache[style] ||\n\t      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n\t  }\n\t\n\t  // Render the DOM representation of the text of a line. Also builds\n\t  // up a 'line map', which points at the DOM nodes that represent\n\t  // specific stretches of text, and is used by the measuring code.\n\t  // The returned object contains the DOM node, this map, and\n\t  // information about line-wide styles that were set by the mode.\n\t  function buildLineContent(cm, lineView) {\n\t    // The padding-right forces the element to have a 'border', which\n\t    // is needed on Webkit to be able to get line-level bounding\n\t    // rectangles for it (in measureChar).\n\t    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n\t    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n\t                   col: 0, pos: 0, cm: cm,\n\t                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n\t    lineView.measure = {};\n\t\n\t    // Iterate over the logical lines that make up this visual line.\n\t    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n\t      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n\t      builder.pos = 0;\n\t      builder.addToken = buildToken;\n\t      // Optionally wire in some hacks into the token-rendering\n\t      // algorithm, to deal with browser quirks.\n\t      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n\t        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n\t      builder.map = [];\n\t      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n\t      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\t      if (line.styleClasses) {\n\t        if (line.styleClasses.bgClass)\n\t          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n\t        if (line.styleClasses.textClass)\n\t          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n\t      }\n\t\n\t      // Ensure at least a single node is present, for measuring.\n\t      if (builder.map.length == 0)\n\t        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\t\n\t      // Store the map and a cache object for the current logical line\n\t      if (i == 0) {\n\t        lineView.measure.map = builder.map;\n\t        lineView.measure.cache = {};\n\t      } else {\n\t        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n\t        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n\t      }\n\t    }\n\t\n\t    // See issue #2901\n\t    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n\t      builder.content.className = \"cm-tab-wrap-hack\";\n\t\n\t    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\t    if (builder.pre.className)\n\t      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\t\n\t    return builder;\n\t  }\n\t\n\t  function defaultSpecialCharPlaceholder(ch) {\n\t    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n\t    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n\t    token.setAttribute(\"aria-label\", token.title);\n\t    return token;\n\t  }\n\t\n\t  // Build up the DOM representation for a single token, and add it to\n\t  // the line map. Takes care to render special characters separately.\n\t  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n\t    if (!text) return;\n\t    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n\t    var special = builder.cm.state.specialChars, mustWrap = false;\n\t    if (!special.test(text)) {\n\t      builder.col += text.length;\n\t      var content = document.createTextNode(displayText);\n\t      builder.map.push(builder.pos, builder.pos + text.length, content);\n\t      if (ie && ie_version < 9) mustWrap = true;\n\t      builder.pos += text.length;\n\t    } else {\n\t      var content = document.createDocumentFragment(), pos = 0;\n\t      while (true) {\n\t        special.lastIndex = pos;\n\t        var m = special.exec(text);\n\t        var skipped = m ? m.index - pos : text.length - pos;\n\t        if (skipped) {\n\t          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.map.push(builder.pos, builder.pos + skipped, txt);\n\t          builder.col += skipped;\n\t          builder.pos += skipped;\n\t        }\n\t        if (!m) break;\n\t        pos += skipped + 1;\n\t        if (m[0] == \"\\t\") {\n\t          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n\t          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n\t          txt.setAttribute(\"role\", \"presentation\");\n\t          txt.setAttribute(\"cm-text\", \"\\t\");\n\t          builder.col += tabWidth;\n\t        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n\t          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          builder.col += 1;\n\t        } else {\n\t          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.col += 1;\n\t        }\n\t        builder.map.push(builder.pos, builder.pos + 1, txt);\n\t        builder.pos++;\n\t      }\n\t    }\n\t    if (style || startStyle || endStyle || mustWrap || css) {\n\t      var fullStyle = style || \"\";\n\t      if (startStyle) fullStyle += startStyle;\n\t      if (endStyle) fullStyle += endStyle;\n\t      var token = elt(\"span\", [content], fullStyle, css);\n\t      if (title) token.title = title;\n\t      return builder.content.appendChild(token);\n\t    }\n\t    builder.content.appendChild(content);\n\t  }\n\t\n\t  function splitSpaces(old) {\n\t    var out = \" \";\n\t    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n\t    out += \" \";\n\t    return out;\n\t  }\n\t\n\t  // Work around nonsense dimensions being reported for stretches of\n\t  // right-to-left text.\n\t  function buildTokenBadBidi(inner, order) {\n\t    return function(builder, text, style, startStyle, endStyle, title, css) {\n\t      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n\t      var start = builder.pos, end = start + text.length;\n\t      for (;;) {\n\t        // Find the part that overlaps with the start of this text\n\t        for (var i = 0; i < order.length; i++) {\n\t          var part = order[i];\n\t          if (part.to > start && part.from <= start) break;\n\t        }\n\t        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n\t        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n\t        startStyle = null;\n\t        text = text.slice(part.to - start);\n\t        start = part.to;\n\t      }\n\t    };\n\t  }\n\t\n\t  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n\t    var widget = !ignoreWidget && marker.widgetNode;\n\t    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n\t    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n\t      if (!widget)\n\t        widget = builder.content.appendChild(document.createElement(\"span\"));\n\t      widget.setAttribute(\"cm-marker\", marker.id);\n\t    }\n\t    if (widget) {\n\t      builder.cm.display.input.setUneditable(widget);\n\t      builder.content.appendChild(widget);\n\t    }\n\t    builder.pos += size;\n\t  }\n\t\n\t  // Outputs a number of spans to make up a line, taking highlighting\n\t  // and marked text into account.\n\t  function insertLineContent(line, builder, styles) {\n\t    var spans = line.markedSpans, allText = line.text, at = 0;\n\t    if (!spans) {\n\t      for (var i = 1; i < styles.length; i+=2)\n\t        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n\t      return;\n\t    }\n\t\n\t    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n\t    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n\t    for (;;) {\n\t      if (nextChange == pos) { // Update current marker set\n\t        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n\t        collapsed = null; nextChange = Infinity;\n\t        var foundBookmarks = [], endStyles\n\t        for (var j = 0; j < spans.length; ++j) {\n\t          var sp = spans[j], m = sp.marker;\n\t          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n\t            foundBookmarks.push(m);\n\t          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n\t            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n\t              nextChange = sp.to;\n\t              spanEndStyle = \"\";\n\t            }\n\t            if (m.className) spanStyle += \" \" + m.className;\n\t            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n\t            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n\t            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n\t            if (m.title && !title) title = m.title;\n\t            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n\t              collapsed = sp;\n\t          } else if (sp.from > pos && nextChange > sp.from) {\n\t            nextChange = sp.from;\n\t          }\n\t        }\n\t        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n\t          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\t\n\t        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n\t          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n\t        if (collapsed && (collapsed.from || 0) == pos) {\n\t          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n\t                             collapsed.marker, collapsed.from == null);\n\t          if (collapsed.to == null) return;\n\t          if (collapsed.to == pos) collapsed = false;\n\t        }\n\t      }\n\t      if (pos >= len) break;\n\t\n\t      var upto = Math.min(len, nextChange);\n\t      while (true) {\n\t        if (text) {\n\t          var end = pos + text.length;\n\t          if (!collapsed) {\n\t            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n\t            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n\t                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n\t          }\n\t          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n\t          pos = end;\n\t          spanStartStyle = \"\";\n\t        }\n\t        text = allText.slice(at, at = styles[i++]);\n\t        style = interpretTokenStyle(styles[i++], builder.cm.options);\n\t      }\n\t    }\n\t  }\n\t\n\t  // DOCUMENT DATA STRUCTURE\n\t\n\t  // By default, updates that start and end at the beginning of a line\n\t  // are treated specially, in order to make the association of line\n\t  // widgets and marker elements with the text behave more intuitive.\n\t  function isWholeLineUpdate(doc, change) {\n\t    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n\t      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n\t  }\n\t\n\t  // Perform a change on the document data structure.\n\t  function updateDoc(doc, change, markedSpans, estimateHeight) {\n\t    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\t    function update(line, text, spans) {\n\t      updateLine(line, text, spans, estimateHeight);\n\t      signalLater(line, \"change\", line, change);\n\t    }\n\t    function linesFor(start, end) {\n\t      for (var i = start, result = []; i < end; ++i)\n\t        result.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      return result;\n\t    }\n\t\n\t    var from = change.from, to = change.to, text = change.text;\n\t    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n\t    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\t\n\t    // Adjust the line structure\n\t    if (change.full) {\n\t      doc.insert(0, linesFor(0, text.length));\n\t      doc.remove(text.length, doc.size - text.length);\n\t    } else if (isWholeLineUpdate(doc, change)) {\n\t      // This is a whole-line replace. Treated specially to make\n\t      // sure line objects move the way they are supposed to.\n\t      var added = linesFor(0, text.length - 1);\n\t      update(lastLine, lastLine.text, lastSpans);\n\t      if (nlines) doc.remove(from.line, nlines);\n\t      if (added.length) doc.insert(from.line, added);\n\t    } else if (firstLine == lastLine) {\n\t      if (text.length == 1) {\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n\t      } else {\n\t        var added = linesFor(1, text.length - 1);\n\t        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t        doc.insert(from.line + 1, added);\n\t      }\n\t    } else if (text.length == 1) {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n\t      doc.remove(from.line + 1, nlines);\n\t    } else {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\t      var added = linesFor(1, text.length - 1);\n\t      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n\t      doc.insert(from.line + 1, added);\n\t    }\n\t\n\t    signalLater(doc, \"change\", doc, change);\n\t  }\n\t\n\t  // The document is represented as a BTree consisting of leaves, with\n\t  // chunk of lines in them, and branches, with up to ten leaves or\n\t  // other branch nodes below them. The top node is always a branch\n\t  // node, and is the document object itself (meaning it has\n\t  // additional methods and properties).\n\t  //\n\t  // All nodes have parent links. The tree is used both to go from\n\t  // line numbers to line objects, and to go from objects to numbers.\n\t  // It also indexes by height, and is used to convert between height\n\t  // and line object, and to find the total height of the document.\n\t  //\n\t  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\t\n\t  function LeafChunk(lines) {\n\t    this.lines = lines;\n\t    this.parent = null;\n\t    for (var i = 0, height = 0; i < lines.length; ++i) {\n\t      lines[i].parent = this;\n\t      height += lines[i].height;\n\t    }\n\t    this.height = height;\n\t  }\n\t\n\t  LeafChunk.prototype = {\n\t    chunkSize: function() { return this.lines.length; },\n\t    // Remove the n lines at offset 'at'.\n\t    removeInner: function(at, n) {\n\t      for (var i = at, e = at + n; i < e; ++i) {\n\t        var line = this.lines[i];\n\t        this.height -= line.height;\n\t        cleanUpLine(line);\n\t        signalLater(line, \"delete\");\n\t      }\n\t      this.lines.splice(at, n);\n\t    },\n\t    // Helper used to collapse a small branch into a single leaf.\n\t    collapse: function(lines) {\n\t      lines.push.apply(lines, this.lines);\n\t    },\n\t    // Insert the given array of lines at offset 'at', count them as\n\t    // having the given height.\n\t    insertInner: function(at, lines, height) {\n\t      this.height += height;\n\t      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\t      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n\t    },\n\t    // Used to iterate over a part of the tree.\n\t    iterN: function(at, n, op) {\n\t      for (var e = at + n; at < e; ++at)\n\t        if (op(this.lines[at])) return true;\n\t    }\n\t  };\n\t\n\t  function BranchChunk(children) {\n\t    this.children = children;\n\t    var size = 0, height = 0;\n\t    for (var i = 0; i < children.length; ++i) {\n\t      var ch = children[i];\n\t      size += ch.chunkSize(); height += ch.height;\n\t      ch.parent = this;\n\t    }\n\t    this.size = size;\n\t    this.height = height;\n\t    this.parent = null;\n\t  }\n\t\n\t  BranchChunk.prototype = {\n\t    chunkSize: function() { return this.size; },\n\t    removeInner: function(at, n) {\n\t      this.size -= n;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var rm = Math.min(n, sz - at), oldHeight = child.height;\n\t          child.removeInner(at, rm);\n\t          this.height -= oldHeight - child.height;\n\t          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n\t          if ((n -= rm) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t      // If the result is smaller than 25 lines, ensure that it is a\n\t      // single leaf node.\n\t      if (this.size - n < 25 &&\n\t          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n\t        var lines = [];\n\t        this.collapse(lines);\n\t        this.children = [new LeafChunk(lines)];\n\t        this.children[0].parent = this;\n\t      }\n\t    },\n\t    collapse: function(lines) {\n\t      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.size += lines.length;\n\t      this.height += height;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at <= sz) {\n\t          child.insertInner(at, lines, height);\n\t          if (child.lines && child.lines.length > 50) {\n\t            while (child.lines.length > 50) {\n\t              var spilled = child.lines.splice(child.lines.length - 25, 25);\n\t              var newleaf = new LeafChunk(spilled);\n\t              child.height -= newleaf.height;\n\t              this.children.splice(i + 1, 0, newleaf);\n\t              newleaf.parent = this;\n\t            }\n\t            this.maybeSpill();\n\t          }\n\t          break;\n\t        }\n\t        at -= sz;\n\t      }\n\t    },\n\t    // When a node has grown, check whether it should be split.\n\t    maybeSpill: function() {\n\t      if (this.children.length <= 10) return;\n\t      var me = this;\n\t      do {\n\t        var spilled = me.children.splice(me.children.length - 5, 5);\n\t        var sibling = new BranchChunk(spilled);\n\t        if (!me.parent) { // Become the parent node\n\t          var copy = new BranchChunk(me.children);\n\t          copy.parent = me;\n\t          me.children = [copy, sibling];\n\t          me = copy;\n\t        } else {\n\t          me.size -= sibling.size;\n\t          me.height -= sibling.height;\n\t          var myIndex = indexOf(me.parent.children, me);\n\t          me.parent.children.splice(myIndex + 1, 0, sibling);\n\t        }\n\t        sibling.parent = me.parent;\n\t      } while (me.children.length > 10);\n\t      me.parent.maybeSpill();\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var used = Math.min(n, sz - at);\n\t          if (child.iterN(at, used, op)) return true;\n\t          if ((n -= used) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t    }\n\t  };\n\t\n\t  var nextDocId = 0;\n\t  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n\t    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n\t    if (firstLine == null) firstLine = 0;\n\t\n\t    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n\t    this.first = firstLine;\n\t    this.scrollTop = this.scrollLeft = 0;\n\t    this.cantEdit = false;\n\t    this.cleanGeneration = 1;\n\t    this.frontier = firstLine;\n\t    var start = Pos(firstLine, 0);\n\t    this.sel = simpleSelection(start);\n\t    this.history = new History(null);\n\t    this.id = ++nextDocId;\n\t    this.modeOption = mode;\n\t    this.lineSep = lineSep;\n\t    this.extend = false;\n\t\n\t    if (typeof text == \"string\") text = this.splitLines(text);\n\t    updateDoc(this, {from: start, to: start, text: text});\n\t    setSelection(this, simpleSelection(start), sel_dontScroll);\n\t  };\n\t\n\t  Doc.prototype = createObj(BranchChunk.prototype, {\n\t    constructor: Doc,\n\t    // Iterate over the document. Supports two forms -- with only one\n\t    // argument, it calls that for each line in the document. With\n\t    // three, it iterates over the range given by the first two (with\n\t    // the second being non-inclusive).\n\t    iter: function(from, to, op) {\n\t      if (op) this.iterN(from - this.first, to - from, op);\n\t      else this.iterN(this.first, this.first + this.size, from);\n\t    },\n\t\n\t    // Non-public interface for adding and removing lines.\n\t    insert: function(at, lines) {\n\t      var height = 0;\n\t      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n\t      this.insertInner(at - this.first, lines, height);\n\t    },\n\t    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\t\n\t    // From here, the methods are part of the public interface. Most\n\t    // are also available from CodeMirror (editor) instances.\n\t\n\t    getValue: function(lineSep) {\n\t      var lines = getLines(this, this.first, this.first + this.size);\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    setValue: docMethodOp(function(code) {\n\t      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n\t      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n\t                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n\t      setSelection(this, simpleSelection(top));\n\t    }),\n\t    replaceRange: function(code, from, to, origin) {\n\t      from = clipPos(this, from);\n\t      to = to ? clipPos(this, to) : from;\n\t      replaceRange(this, code, from, to, origin);\n\t    },\n\t    getRange: function(from, to, lineSep) {\n\t      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t\n\t    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\t\n\t    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n\t    getLineNumber: function(line) {return lineNo(line);},\n\t\n\t    getLineHandleVisualStart: function(line) {\n\t      if (typeof line == \"number\") line = getLine(this, line);\n\t      return visualLine(line);\n\t    },\n\t\n\t    lineCount: function() {return this.size;},\n\t    firstLine: function() {return this.first;},\n\t    lastLine: function() {return this.first + this.size - 1;},\n\t\n\t    clipPos: function(pos) {return clipPos(this, pos);},\n\t\n\t    getCursor: function(start) {\n\t      var range = this.sel.primary(), pos;\n\t      if (start == null || start == \"head\") pos = range.head;\n\t      else if (start == \"anchor\") pos = range.anchor;\n\t      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n\t      else pos = range.from();\n\t      return pos;\n\t    },\n\t    listSelections: function() { return this.sel.ranges; },\n\t    somethingSelected: function() {return this.sel.somethingSelected();},\n\t\n\t    setCursor: docMethodOp(function(line, ch, options) {\n\t      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n\t    }),\n\t    setSelection: docMethodOp(function(anchor, head, options) {\n\t      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n\t    }),\n\t    extendSelection: docMethodOp(function(head, other, options) {\n\t      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n\t    }),\n\t    extendSelections: docMethodOp(function(heads, options) {\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    extendSelectionsBy: docMethodOp(function(f, options) {\n\t      var heads = map(this.sel.ranges, f);\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    setSelections: docMethodOp(function(ranges, primary, options) {\n\t      if (!ranges.length) return;\n\t      for (var i = 0, out = []; i < ranges.length; i++)\n\t        out[i] = new Range(clipPos(this, ranges[i].anchor),\n\t                           clipPos(this, ranges[i].head));\n\t      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n\t      setSelection(this, normalizeSelection(out, primary), options);\n\t    }),\n\t    addSelection: docMethodOp(function(anchor, head, options) {\n\t      var ranges = this.sel.ranges.slice(0);\n\t      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n\t      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n\t    }),\n\t\n\t    getSelection: function(lineSep) {\n\t      var ranges = this.sel.ranges, lines;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        lines = lines ? lines.concat(sel) : sel;\n\t      }\n\t      if (lineSep === false) return lines;\n\t      else return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    getSelections: function(lineSep) {\n\t      var parts = [], ranges = this.sel.ranges;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n\t        parts[i] = sel;\n\t      }\n\t      return parts;\n\t    },\n\t    replaceSelection: function(code, collapse, origin) {\n\t      var dup = [];\n\t      for (var i = 0; i < this.sel.ranges.length; i++)\n\t        dup[i] = code;\n\t      this.replaceSelections(dup, collapse, origin || \"+input\");\n\t    },\n\t    replaceSelections: docMethodOp(function(code, collapse, origin) {\n\t      var changes = [], sel = this.sel;\n\t      for (var i = 0; i < sel.ranges.length; i++) {\n\t        var range = sel.ranges[i];\n\t        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n\t      }\n\t      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\t      for (var i = changes.length - 1; i >= 0; i--)\n\t        makeChange(this, changes[i]);\n\t      if (newSel) setSelectionReplaceHistory(this, newSel);\n\t      else if (this.cm) ensureCursorVisible(this.cm);\n\t    }),\n\t    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n\t    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n\t    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n\t    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\t\n\t    setExtending: function(val) {this.extend = val;},\n\t    getExtending: function() {return this.extend;},\n\t\n\t    historySize: function() {\n\t      var hist = this.history, done = 0, undone = 0;\n\t      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n\t      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n\t      return {undo: done, redo: undone};\n\t    },\n\t    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\t\n\t    markClean: function() {\n\t      this.cleanGeneration = this.changeGeneration(true);\n\t    },\n\t    changeGeneration: function(forceSplit) {\n\t      if (forceSplit)\n\t        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n\t      return this.history.generation;\n\t    },\n\t    isClean: function (gen) {\n\t      return this.history.generation == (gen || this.cleanGeneration);\n\t    },\n\t\n\t    getHistory: function() {\n\t      return {done: copyHistoryArray(this.history.done),\n\t              undone: copyHistoryArray(this.history.undone)};\n\t    },\n\t    setHistory: function(histData) {\n\t      var hist = this.history = new History(this.history.maxGeneration);\n\t      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n\t      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n\t    },\n\t\n\t    addLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        if (!line[prop]) line[prop] = cls;\n\t        else if (classTest(cls).test(line[prop])) return false;\n\t        else line[prop] += \" \" + cls;\n\t        return true;\n\t      });\n\t    }),\n\t    removeLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        var cur = line[prop];\n\t        if (!cur) return false;\n\t        else if (cls == null) line[prop] = null;\n\t        else {\n\t          var found = cur.match(classTest(cls));\n\t          if (!found) return false;\n\t          var end = found.index + found[0].length;\n\t          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n\t        }\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    addLineWidget: docMethodOp(function(handle, node, options) {\n\t      return addLineWidget(this, handle, node, options);\n\t    }),\n\t    removeLineWidget: function(widget) { widget.clear(); },\n\t\n\t    markText: function(from, to, options) {\n\t      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n\t    },\n\t    setBookmark: function(pos, options) {\n\t      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n\t                      insertLeft: options && options.insertLeft,\n\t                      clearWhenEmpty: false, shared: options && options.shared,\n\t                      handleMouseEvents: options && options.handleMouseEvents};\n\t      pos = clipPos(this, pos);\n\t      return markText(this, pos, pos, realOpts, \"bookmark\");\n\t    },\n\t    findMarksAt: function(pos) {\n\t      pos = clipPos(this, pos);\n\t      var markers = [], spans = getLine(this, pos.line).markedSpans;\n\t      if (spans) for (var i = 0; i < spans.length; ++i) {\n\t        var span = spans[i];\n\t        if ((span.from == null || span.from <= pos.ch) &&\n\t            (span.to == null || span.to >= pos.ch))\n\t          markers.push(span.marker.parent || span.marker);\n\t      }\n\t      return markers;\n\t    },\n\t    findMarks: function(from, to, filter) {\n\t      from = clipPos(this, from); to = clipPos(this, to);\n\t      var found = [], lineNo = from.line;\n\t      this.iter(from.line, to.line + 1, function(line) {\n\t        var spans = line.markedSpans;\n\t        if (spans) for (var i = 0; i < spans.length; i++) {\n\t          var span = spans[i];\n\t          if (!(lineNo == from.line && from.ch > span.to ||\n\t                span.from == null && lineNo != from.line||\n\t                lineNo == to.line && span.from > to.ch) &&\n\t              (!filter || filter(span.marker)))\n\t            found.push(span.marker.parent || span.marker);\n\t        }\n\t        ++lineNo;\n\t      });\n\t      return found;\n\t    },\n\t    getAllMarks: function() {\n\t      var markers = [];\n\t      this.iter(function(line) {\n\t        var sps = line.markedSpans;\n\t        if (sps) for (var i = 0; i < sps.length; ++i)\n\t          if (sps[i].from != null) markers.push(sps[i].marker);\n\t      });\n\t      return markers;\n\t    },\n\t\n\t    posFromIndex: function(off) {\n\t      var ch, lineNo = this.first;\n\t      this.iter(function(line) {\n\t        var sz = line.text.length + 1;\n\t        if (sz > off) { ch = off; return true; }\n\t        off -= sz;\n\t        ++lineNo;\n\t      });\n\t      return clipPos(this, Pos(lineNo, ch));\n\t    },\n\t    indexFromPos: function (coords) {\n\t      coords = clipPos(this, coords);\n\t      var index = coords.ch;\n\t      if (coords.line < this.first || coords.ch < 0) return 0;\n\t      this.iter(this.first, coords.line, function (line) {\n\t        index += line.text.length + 1;\n\t      });\n\t      return index;\n\t    },\n\t\n\t    copy: function(copyHistory) {\n\t      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n\t                        this.modeOption, this.first, this.lineSep);\n\t      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n\t      doc.sel = this.sel;\n\t      doc.extend = false;\n\t      if (copyHistory) {\n\t        doc.history.undoDepth = this.history.undoDepth;\n\t        doc.setHistory(this.getHistory());\n\t      }\n\t      return doc;\n\t    },\n\t\n\t    linkedDoc: function(options) {\n\t      if (!options) options = {};\n\t      var from = this.first, to = this.first + this.size;\n\t      if (options.from != null && options.from > from) from = options.from;\n\t      if (options.to != null && options.to < to) to = options.to;\n\t      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n\t      if (options.sharedHist) copy.history = this.history;\n\t      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n\t      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n\t      copySharedMarkers(copy, findSharedMarkers(this));\n\t      return copy;\n\t    },\n\t    unlinkDoc: function(other) {\n\t      if (other instanceof CodeMirror) other = other.doc;\n\t      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n\t        var link = this.linked[i];\n\t        if (link.doc != other) continue;\n\t        this.linked.splice(i, 1);\n\t        other.unlinkDoc(this);\n\t        detachSharedMarkers(findSharedMarkers(this));\n\t        break;\n\t      }\n\t      // If the histories were shared, split them again\n\t      if (other.history == this.history) {\n\t        var splitIds = [other.id];\n\t        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n\t        other.history = new History(null);\n\t        other.history.done = copyHistoryArray(this.history.done, splitIds);\n\t        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n\t      }\n\t    },\n\t    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\t\n\t    getMode: function() {return this.mode;},\n\t    getEditor: function() {return this.cm;},\n\t\n\t    splitLines: function(str) {\n\t      if (this.lineSep) return str.split(this.lineSep);\n\t      return splitLinesAuto(str);\n\t    },\n\t    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n\t  });\n\t\n\t  // Public alias.\n\t  Doc.prototype.eachLine = Doc.prototype.iter;\n\t\n\t  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\t  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\t  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n\t    CodeMirror.prototype[prop] = (function(method) {\n\t      return function() {return method.apply(this.doc, arguments);};\n\t    })(Doc.prototype[prop]);\n\t\n\t  eventMixin(Doc);\n\t\n\t  // Call f for all linked documents.\n\t  function linkedDocs(doc, f, sharedHistOnly) {\n\t    function propagate(doc, skip, sharedHist) {\n\t      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n\t        var rel = doc.linked[i];\n\t        if (rel.doc == skip) continue;\n\t        var shared = sharedHist && rel.sharedHist;\n\t        if (sharedHistOnly && !shared) continue;\n\t        f(rel.doc, shared);\n\t        propagate(rel.doc, doc, shared);\n\t      }\n\t    }\n\t    propagate(doc, null, true);\n\t  }\n\t\n\t  // Attach a document to an editor.\n\t  function attachDoc(cm, doc) {\n\t    if (doc.cm) throw new Error(\"This document is already in use.\");\n\t    cm.doc = doc;\n\t    doc.cm = cm;\n\t    estimateLineHeights(cm);\n\t    loadMode(cm);\n\t    if (!cm.options.lineWrapping) findMaxLine(cm);\n\t    cm.options.mode = doc.modeOption;\n\t    regChange(cm);\n\t  }\n\t\n\t  // LINE UTILITIES\n\t\n\t  // Find the line object corresponding to the given line number.\n\t  function getLine(doc, n) {\n\t    n -= doc.first;\n\t    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n\t    for (var chunk = doc; !chunk.lines;) {\n\t      for (var i = 0;; ++i) {\n\t        var child = chunk.children[i], sz = child.chunkSize();\n\t        if (n < sz) { chunk = child; break; }\n\t        n -= sz;\n\t      }\n\t    }\n\t    return chunk.lines[n];\n\t  }\n\t\n\t  // Get the part of a document between two positions, as an array of\n\t  // strings.\n\t  function getBetween(doc, start, end) {\n\t    var out = [], n = start.line;\n\t    doc.iter(start.line, end.line + 1, function(line) {\n\t      var text = line.text;\n\t      if (n == end.line) text = text.slice(0, end.ch);\n\t      if (n == start.line) text = text.slice(start.ch);\n\t      out.push(text);\n\t      ++n;\n\t    });\n\t    return out;\n\t  }\n\t  // Get the lines between from and to, as array of strings.\n\t  function getLines(doc, from, to) {\n\t    var out = [];\n\t    doc.iter(from, to, function(line) { out.push(line.text); });\n\t    return out;\n\t  }\n\t\n\t  // Update the height of a line, propagating the height change\n\t  // upwards to parent nodes.\n\t  function updateLineHeight(line, height) {\n\t    var diff = height - line.height;\n\t    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n\t  }\n\t\n\t  // Given a line object, find its line number by walking up through\n\t  // its parent links.\n\t  function lineNo(line) {\n\t    if (line.parent == null) return null;\n\t    var cur = line.parent, no = indexOf(cur.lines, line);\n\t    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n\t      for (var i = 0;; ++i) {\n\t        if (chunk.children[i] == cur) break;\n\t        no += chunk.children[i].chunkSize();\n\t      }\n\t    }\n\t    return no + cur.first;\n\t  }\n\t\n\t  // Find the line at the given vertical position, using the height\n\t  // information in the document tree.\n\t  function lineAtHeight(chunk, h) {\n\t    var n = chunk.first;\n\t    outer: do {\n\t      for (var i = 0; i < chunk.children.length; ++i) {\n\t        var child = chunk.children[i], ch = child.height;\n\t        if (h < ch) { chunk = child; continue outer; }\n\t        h -= ch;\n\t        n += child.chunkSize();\n\t      }\n\t      return n;\n\t    } while (!chunk.lines);\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i], lh = line.height;\n\t      if (h < lh) break;\n\t      h -= lh;\n\t    }\n\t    return n + i;\n\t  }\n\t\n\t\n\t  // Find the height above the given line.\n\t  function heightAtLine(lineObj) {\n\t    lineObj = visualLine(lineObj);\n\t\n\t    var h = 0, chunk = lineObj.parent;\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i];\n\t      if (line == lineObj) break;\n\t      else h += line.height;\n\t    }\n\t    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n\t      for (var i = 0; i < p.children.length; ++i) {\n\t        var cur = p.children[i];\n\t        if (cur == chunk) break;\n\t        else h += cur.height;\n\t      }\n\t    }\n\t    return h;\n\t  }\n\t\n\t  // Get the bidi ordering for the given line (and cache it). Returns\n\t  // false for lines that are fully left-to-right, and an array of\n\t  // BidiSpan objects otherwise.\n\t  function getOrder(line) {\n\t    var order = line.order;\n\t    if (order == null) order = line.order = bidiOrdering(line.text);\n\t    return order;\n\t  }\n\t\n\t  // HISTORY\n\t\n\t  function History(startGen) {\n\t    // Arrays of change events and selections. Doing something adds an\n\t    // event to done and clears undo. Undoing moves events from done\n\t    // to undone, redoing moves them in the other direction.\n\t    this.done = []; this.undone = [];\n\t    this.undoDepth = Infinity;\n\t    // Used to track when changes can be merged into a single undo\n\t    // event\n\t    this.lastModTime = this.lastSelTime = 0;\n\t    this.lastOp = this.lastSelOp = null;\n\t    this.lastOrigin = this.lastSelOrigin = null;\n\t    // Used by the isClean() method\n\t    this.generation = this.maxGeneration = startGen || 1;\n\t  }\n\t\n\t  // Create a history change event from an updateDoc-style change\n\t  // object.\n\t  function historyChangeFromChange(doc, change) {\n\t    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n\t    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n\t    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n\t    return histChange;\n\t  }\n\t\n\t  // Pop all selection events off the end of a history array. Stop at\n\t  // a change event.\n\t  function clearSelectionEvents(array) {\n\t    while (array.length) {\n\t      var last = lst(array);\n\t      if (last.ranges) array.pop();\n\t      else break;\n\t    }\n\t  }\n\t\n\t  // Find the top change event in the history. Pop off selection\n\t  // events that are in the way.\n\t  function lastChangeEvent(hist, force) {\n\t    if (force) {\n\t      clearSelectionEvents(hist.done);\n\t      return lst(hist.done);\n\t    } else if (hist.done.length && !lst(hist.done).ranges) {\n\t      return lst(hist.done);\n\t    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n\t      hist.done.pop();\n\t      return lst(hist.done);\n\t    }\n\t  }\n\t\n\t  // Register a change in the history. Merges changes that are within\n\t  // a single operation, ore are close together with an origin that\n\t  // allows merging (starting with \"+\") into a single event.\n\t  function addChangeToHistory(doc, change, selAfter, opId) {\n\t    var hist = doc.history;\n\t    hist.undone.length = 0;\n\t    var time = +new Date, cur;\n\t\n\t    if ((hist.lastOp == opId ||\n\t         hist.lastOrigin == change.origin && change.origin &&\n\t         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n\t          change.origin.charAt(0) == \"*\")) &&\n\t        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n\t      // Merge this change into the last event\n\t      var last = lst(cur.changes);\n\t      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n\t        // Optimized case for simple insertion -- don't want to add\n\t        // new changesets for every character typed\n\t        last.to = changeEnd(change);\n\t      } else {\n\t        // Add new sub-event\n\t        cur.changes.push(historyChangeFromChange(doc, change));\n\t      }\n\t    } else {\n\t      // Can not be merged, start a new event.\n\t      var before = lst(hist.done);\n\t      if (!before || !before.ranges)\n\t        pushSelectionToHistory(doc.sel, hist.done);\n\t      cur = {changes: [historyChangeFromChange(doc, change)],\n\t             generation: hist.generation};\n\t      hist.done.push(cur);\n\t      while (hist.done.length > hist.undoDepth) {\n\t        hist.done.shift();\n\t        if (!hist.done[0].ranges) hist.done.shift();\n\t      }\n\t    }\n\t    hist.done.push(selAfter);\n\t    hist.generation = ++hist.maxGeneration;\n\t    hist.lastModTime = hist.lastSelTime = time;\n\t    hist.lastOp = hist.lastSelOp = opId;\n\t    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\t\n\t    if (!last) signal(doc, \"historyAdded\");\n\t  }\n\t\n\t  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n\t    var ch = origin.charAt(0);\n\t    return ch == \"*\" ||\n\t      ch == \"+\" &&\n\t      prev.ranges.length == sel.ranges.length &&\n\t      prev.somethingSelected() == sel.somethingSelected() &&\n\t      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n\t  }\n\t\n\t  // Called whenever the selection changes, sets the new selection as\n\t  // the pending selection in the history, and pushes the old pending\n\t  // selection into the 'done' array when it was significantly\n\t  // different (in number of selected ranges, emptiness, or time).\n\t  function addSelectionToHistory(doc, sel, opId, options) {\n\t    var hist = doc.history, origin = options && options.origin;\n\t\n\t    // A new event is started when the previous origin does not match\n\t    // the current, or the origins don't allow matching. Origins\n\t    // starting with * are always merged, those starting with + are\n\t    // merged when similar and close together in time.\n\t    if (opId == hist.lastSelOp ||\n\t        (origin && hist.lastSelOrigin == origin &&\n\t         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n\t          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n\t      hist.done[hist.done.length - 1] = sel;\n\t    else\n\t      pushSelectionToHistory(sel, hist.done);\n\t\n\t    hist.lastSelTime = +new Date;\n\t    hist.lastSelOrigin = origin;\n\t    hist.lastSelOp = opId;\n\t    if (options && options.clearRedo !== false)\n\t      clearSelectionEvents(hist.undone);\n\t  }\n\t\n\t  function pushSelectionToHistory(sel, dest) {\n\t    var top = lst(dest);\n\t    if (!(top && top.ranges && top.equals(sel)))\n\t      dest.push(sel);\n\t  }\n\t\n\t  // Used to store marked span information in the history.\n\t  function attachLocalSpans(doc, change, from, to) {\n\t    var existing = change[\"spans_\" + doc.id], n = 0;\n\t    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n\t      if (line.markedSpans)\n\t        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n\t      ++n;\n\t    });\n\t  }\n\t\n\t  // When un/re-doing restores text containing marked spans, those\n\t  // that have been explicitly cleared should not be restored.\n\t  function removeClearedSpans(spans) {\n\t    if (!spans) return null;\n\t    for (var i = 0, out; i < spans.length; ++i) {\n\t      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n\t      else if (out) out.push(spans[i]);\n\t    }\n\t    return !out ? spans : out.length ? out : null;\n\t  }\n\t\n\t  // Retrieve and filter the old marked spans stored in a change event.\n\t  function getOldSpans(doc, change) {\n\t    var found = change[\"spans_\" + doc.id];\n\t    if (!found) return null;\n\t    for (var i = 0, nw = []; i < change.text.length; ++i)\n\t      nw.push(removeClearedSpans(found[i]));\n\t    return nw;\n\t  }\n\t\n\t  // Used both to provide a JSON-safe object in .getHistory, and, when\n\t  // detaching a document, to split the history in two\n\t  function copyHistoryArray(events, newGroup, instantiateSel) {\n\t    for (var i = 0, copy = []; i < events.length; ++i) {\n\t      var event = events[i];\n\t      if (event.ranges) {\n\t        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n\t        continue;\n\t      }\n\t      var changes = event.changes, newChanges = [];\n\t      copy.push({changes: newChanges});\n\t      for (var j = 0; j < changes.length; ++j) {\n\t        var change = changes[j], m;\n\t        newChanges.push({from: change.from, to: change.to, text: change.text});\n\t        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n\t          if (indexOf(newGroup, Number(m[1])) > -1) {\n\t            lst(newChanges)[prop] = change[prop];\n\t            delete change[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return copy;\n\t  }\n\t\n\t  // Rebasing/resetting history to deal with externally-sourced changes\n\t\n\t  function rebaseHistSelSingle(pos, from, to, diff) {\n\t    if (to < pos.line) {\n\t      pos.line += diff;\n\t    } else if (from < pos.line) {\n\t      pos.line = from;\n\t      pos.ch = 0;\n\t    }\n\t  }\n\t\n\t  // Tries to rebase an array of history events given a change in the\n\t  // document. If the change touches the same lines as the event, the\n\t  // event, and everything 'behind' it, is discarded. If the change is\n\t  // before the event, the event's positions are updated. Uses a\n\t  // copy-on-write scheme for the positions, to avoid having to\n\t  // reallocate them all on every rebase, but also avoid problems with\n\t  // shared position objects being unsafely updated.\n\t  function rebaseHistArray(array, from, to, diff) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t      var sub = array[i], ok = true;\n\t      if (sub.ranges) {\n\t        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n\t        for (var j = 0; j < sub.ranges.length; j++) {\n\t          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n\t          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n\t        }\n\t        continue;\n\t      }\n\t      for (var j = 0; j < sub.changes.length; ++j) {\n\t        var cur = sub.changes[j];\n\t        if (to < cur.from.line) {\n\t          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n\t          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n\t        } else if (from <= cur.to.line) {\n\t          ok = false;\n\t          break;\n\t        }\n\t      }\n\t      if (!ok) {\n\t        array.splice(0, i + 1);\n\t        i = 0;\n\t      }\n\t    }\n\t  }\n\t\n\t  function rebaseHist(hist, change) {\n\t    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n\t    rebaseHistArray(hist.done, from, to, diff);\n\t    rebaseHistArray(hist.undone, from, to, diff);\n\t  }\n\t\n\t  // EVENT UTILITIES\n\t\n\t  // Due to the fact that we still support jurassic IE versions, some\n\t  // compatibility wrappers are needed.\n\t\n\t  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n\t    if (e.preventDefault) e.preventDefault();\n\t    else e.returnValue = false;\n\t  };\n\t  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n\t    if (e.stopPropagation) e.stopPropagation();\n\t    else e.cancelBubble = true;\n\t  };\n\t  function e_defaultPrevented(e) {\n\t    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n\t  }\n\t  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\t\n\t  function e_target(e) {return e.target || e.srcElement;}\n\t  function e_button(e) {\n\t    var b = e.which;\n\t    if (b == null) {\n\t      if (e.button & 1) b = 1;\n\t      else if (e.button & 2) b = 3;\n\t      else if (e.button & 4) b = 2;\n\t    }\n\t    if (mac && e.ctrlKey && b == 1) b = 3;\n\t    return b;\n\t  }\n\t\n\t  // EVENT HANDLING\n\t\n\t  // Lightweight event framework. on/off also work on DOM nodes,\n\t  // registering native DOM handlers.\n\t\n\t  var on = CodeMirror.on = function(emitter, type, f) {\n\t    if (emitter.addEventListener)\n\t      emitter.addEventListener(type, f, false);\n\t    else if (emitter.attachEvent)\n\t      emitter.attachEvent(\"on\" + type, f);\n\t    else {\n\t      var map = emitter._handlers || (emitter._handlers = {});\n\t      var arr = map[type] || (map[type] = []);\n\t      arr.push(f);\n\t    }\n\t  };\n\t\n\t  var noHandlers = []\n\t  function getHandlers(emitter, type, copy) {\n\t    var arr = emitter._handlers && emitter._handlers[type]\n\t    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n\t    else return arr || noHandlers\n\t  }\n\t\n\t  var off = CodeMirror.off = function(emitter, type, f) {\n\t    if (emitter.removeEventListener)\n\t      emitter.removeEventListener(type, f, false);\n\t    else if (emitter.detachEvent)\n\t      emitter.detachEvent(\"on\" + type, f);\n\t    else {\n\t      var handlers = getHandlers(emitter, type, false)\n\t      for (var i = 0; i < handlers.length; ++i)\n\t        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n\t    }\n\t  };\n\t\n\t  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n\t    var handlers = getHandlers(emitter, type, true)\n\t    if (!handlers.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n\t  };\n\t\n\t  var orphanDelayedCallbacks = null;\n\t\n\t  // Often, we want to signal events at a point where we are in the\n\t  // middle of some work, but don't want the handler to start calling\n\t  // other methods on the editor, which might be in an inconsistent\n\t  // state or simply not expect any other events to happen.\n\t  // signalLater looks whether there are any handlers, and schedules\n\t  // them to be executed when the last operation ends, or, if no\n\t  // operation is active, when a timeout fires.\n\t  function signalLater(emitter, type /*, values...*/) {\n\t    var arr = getHandlers(emitter, type, false)\n\t    if (!arr.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2), list;\n\t    if (operationGroup) {\n\t      list = operationGroup.delayedCallbacks;\n\t    } else if (orphanDelayedCallbacks) {\n\t      list = orphanDelayedCallbacks;\n\t    } else {\n\t      list = orphanDelayedCallbacks = [];\n\t      setTimeout(fireOrphanDelayed, 0);\n\t    }\n\t    function bnd(f) {return function(){f.apply(null, args);};};\n\t    for (var i = 0; i < arr.length; ++i)\n\t      list.push(bnd(arr[i]));\n\t  }\n\t\n\t  function fireOrphanDelayed() {\n\t    var delayed = orphanDelayedCallbacks;\n\t    orphanDelayedCallbacks = null;\n\t    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  // The DOM events that CodeMirror handles can be overridden by\n\t  // registering a (non-DOM) handler on the editor for the event name,\n\t  // and preventDefault-ing the event in that handler.\n\t  function signalDOMEvent(cm, e, override) {\n\t    if (typeof e == \"string\")\n\t      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n\t    signal(cm, override || e.type, cm, e);\n\t    return e_defaultPrevented(e) || e.codemirrorIgnore;\n\t  }\n\t\n\t  function signalCursorActivity(cm) {\n\t    var arr = cm._handlers && cm._handlers.cursorActivity;\n\t    if (!arr) return;\n\t    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\t    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n\t      set.push(arr[i]);\n\t  }\n\t\n\t  function hasHandler(emitter, type) {\n\t    return getHandlers(emitter, type).length > 0\n\t  }\n\t\n\t  // Add on and off methods to a constructor's prototype, to make\n\t  // registering events on such objects more convenient.\n\t  function eventMixin(ctor) {\n\t    ctor.prototype.on = function(type, f) {on(this, type, f);};\n\t    ctor.prototype.off = function(type, f) {off(this, type, f);};\n\t  }\n\t\n\t  // MISC UTILITIES\n\t\n\t  // Number of pixels added to scroller and sizer to hide scrollbar\n\t  var scrollerGap = 30;\n\t\n\t  // Returned or thrown by various protocols to signal 'I'm not\n\t  // handling this'.\n\t  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\t\n\t  // Reused option objects for setSelection & friends\n\t  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\t\n\t  function Delayed() {this.id = null;}\n\t  Delayed.prototype.set = function(ms, f) {\n\t    clearTimeout(this.id);\n\t    this.id = setTimeout(f, ms);\n\t  };\n\t\n\t  // Counts the column offset in a string, taking tabs into account.\n\t  // Used mostly to find indentation.\n\t  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n\t    if (end == null) {\n\t      end = string.search(/[^\\s\\u00a0]/);\n\t      if (end == -1) end = string.length;\n\t    }\n\t    for (var i = startIndex || 0, n = startValue || 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", i);\n\t      if (nextTab < 0 || nextTab >= end)\n\t        return n + (end - i);\n\t      n += nextTab - i;\n\t      n += tabSize - (n % tabSize);\n\t      i = nextTab + 1;\n\t    }\n\t  };\n\t\n\t  // The inverse of countColumn -- find the offset that corresponds to\n\t  // a particular column.\n\t  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n\t    for (var pos = 0, col = 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", pos);\n\t      if (nextTab == -1) nextTab = string.length;\n\t      var skipped = nextTab - pos;\n\t      if (nextTab == string.length || col + skipped >= goal)\n\t        return pos + Math.min(skipped, goal - col);\n\t      col += nextTab - pos;\n\t      col += tabSize - (col % tabSize);\n\t      pos = nextTab + 1;\n\t      if (col >= goal) return pos;\n\t    }\n\t  }\n\t\n\t  var spaceStrs = [\"\"];\n\t  function spaceStr(n) {\n\t    while (spaceStrs.length <= n)\n\t      spaceStrs.push(lst(spaceStrs) + \" \");\n\t    return spaceStrs[n];\n\t  }\n\t\n\t  function lst(arr) { return arr[arr.length-1]; }\n\t\n\t  var selectInput = function(node) { node.select(); };\n\t  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n\t    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n\t  else if (ie) // Suppress mysterious IE10 errors\n\t    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\t\n\t  function indexOf(array, elt) {\n\t    for (var i = 0; i < array.length; ++i)\n\t      if (array[i] == elt) return i;\n\t    return -1;\n\t  }\n\t  function map(array, f) {\n\t    var out = [];\n\t    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n\t    return out;\n\t  }\n\t\n\t  function nothing() {}\n\t\n\t  function createObj(base, props) {\n\t    var inst;\n\t    if (Object.create) {\n\t      inst = Object.create(base);\n\t    } else {\n\t      nothing.prototype = base;\n\t      inst = new nothing();\n\t    }\n\t    if (props) copyObj(props, inst);\n\t    return inst;\n\t  };\n\t\n\t  function copyObj(obj, target, overwrite) {\n\t    if (!target) target = {};\n\t    for (var prop in obj)\n\t      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n\t        target[prop] = obj[prop];\n\t    return target;\n\t  }\n\t\n\t  function bind(f) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return function(){return f.apply(null, args);};\n\t  }\n\t\n\t  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\t  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n\t    return /\\w/.test(ch) || ch > \"\\x80\" &&\n\t      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n\t  };\n\t  function isWordChar(ch, helper) {\n\t    if (!helper) return isWordCharBasic(ch);\n\t    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n\t    return helper.test(ch);\n\t  }\n\t\n\t  function isEmpty(obj) {\n\t    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\t    return true;\n\t  }\n\t\n\t  // Extending unicode characters. A series of a non-extending char +\n\t  // any number of extending chars is treated as a single unit as far\n\t  // as editing and measuring is concerned. This is not fully correct,\n\t  // since some scripts/fonts/browsers also treat other configurations\n\t  // of code points as a group.\n\t  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\t  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\t\n\t  // DOM UTILITIES\n\t\n\t  function elt(tag, content, className, style) {\n\t    var e = document.createElement(tag);\n\t    if (className) e.className = className;\n\t    if (style) e.style.cssText = style;\n\t    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n\t    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n\t    return e;\n\t  }\n\t\n\t  var range;\n\t  if (document.createRange) range = function(node, start, end, endNode) {\n\t    var r = document.createRange();\n\t    r.setEnd(endNode || node, end);\n\t    r.setStart(node, start);\n\t    return r;\n\t  };\n\t  else range = function(node, start, end) {\n\t    var r = document.body.createTextRange();\n\t    try { r.moveToElementText(node.parentNode); }\n\t    catch(e) { return r; }\n\t    r.collapse(true);\n\t    r.moveEnd(\"character\", end);\n\t    r.moveStart(\"character\", start);\n\t    return r;\n\t  };\n\t\n\t  function removeChildren(e) {\n\t    for (var count = e.childNodes.length; count > 0; --count)\n\t      e.removeChild(e.firstChild);\n\t    return e;\n\t  }\n\t\n\t  function removeChildrenAndAdd(parent, e) {\n\t    return removeChildren(parent).appendChild(e);\n\t  }\n\t\n\t  var contains = CodeMirror.contains = function(parent, child) {\n\t    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n\t      child = child.parentNode;\n\t    if (parent.contains)\n\t      return parent.contains(child);\n\t    do {\n\t      if (child.nodeType == 11) child = child.host;\n\t      if (child == parent) return true;\n\t    } while (child = child.parentNode);\n\t  };\n\t\n\t  function activeElt() {\n\t    var activeElement = document.activeElement;\n\t    while (activeElement && activeElement.root && activeElement.root.activeElement)\n\t      activeElement = activeElement.root.activeElement;\n\t    return activeElement;\n\t  }\n\t  // Older versions of IE throws unspecified error when touching\n\t  // document.activeElement in some cases (during loading, in iframe)\n\t  if (ie && ie_version < 11) activeElt = function() {\n\t    try { return document.activeElement; }\n\t    catch(e) { return document.body; }\n\t  };\n\t\n\t  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n\t  var rmClass = CodeMirror.rmClass = function(node, cls) {\n\t    var current = node.className;\n\t    var match = classTest(cls).exec(current);\n\t    if (match) {\n\t      var after = current.slice(match.index + match[0].length);\n\t      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n\t    }\n\t  };\n\t  var addClass = CodeMirror.addClass = function(node, cls) {\n\t    var current = node.className;\n\t    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n\t  };\n\t  function joinClasses(a, b) {\n\t    var as = a.split(\" \");\n\t    for (var i = 0; i < as.length; i++)\n\t      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n\t    return b;\n\t  }\n\t\n\t  // WINDOW-WIDE EVENTS\n\t\n\t  // These must be handled carefully, because naively registering a\n\t  // handler for each editor will cause the editors to never be\n\t  // garbage collected.\n\t\n\t  function forEachCodeMirror(f) {\n\t    if (!document.body.getElementsByClassName) return;\n\t    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n\t    for (var i = 0; i < byClass.length; i++) {\n\t      var cm = byClass[i].CodeMirror;\n\t      if (cm) f(cm);\n\t    }\n\t  }\n\t\n\t  var globalsRegistered = false;\n\t  function ensureGlobalHandlers() {\n\t    if (globalsRegistered) return;\n\t    registerGlobalHandlers();\n\t    globalsRegistered = true;\n\t  }\n\t  function registerGlobalHandlers() {\n\t    // When the window resizes, we need to refresh active editors.\n\t    var resizeTimer;\n\t    on(window, \"resize\", function() {\n\t      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n\t        resizeTimer = null;\n\t        forEachCodeMirror(onResize);\n\t      }, 100);\n\t    });\n\t    // When the window loses focus, we want to show the editor as blurred\n\t    on(window, \"blur\", function() {\n\t      forEachCodeMirror(onBlur);\n\t    });\n\t  }\n\t\n\t  // FEATURE DETECTION\n\t\n\t  // Detect drag-and-drop\n\t  var dragAndDrop = function() {\n\t    // There is *some* kind of drag-and-drop support in IE6-8, but I\n\t    // couldn't get it to work yet.\n\t    if (ie && ie_version < 9) return false;\n\t    var div = elt('div');\n\t    return \"draggable\" in div || \"dragDrop\" in div;\n\t  }();\n\t\n\t  var zwspSupported;\n\t  function zeroWidthElement(measure) {\n\t    if (zwspSupported == null) {\n\t      var test = elt(\"span\", \"\\u200b\");\n\t      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\t      if (measure.firstChild.offsetHeight != 0)\n\t        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n\t    }\n\t    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n\t      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n\t    node.setAttribute(\"cm-text\", \"\");\n\t    return node;\n\t  }\n\t\n\t  // Feature-detect IE's crummy client rect reporting for bidi text\n\t  var badBidiRects;\n\t  function hasBadBidiRects(measure) {\n\t    if (badBidiRects != null) return badBidiRects;\n\t    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n\t    var r0 = range(txt, 0, 1).getBoundingClientRect();\n\t    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n\t    var r1 = range(txt, 1, 2).getBoundingClientRect();\n\t    return badBidiRects = (r1.right - r0.right < 3);\n\t  }\n\t\n\t  // See if \"\".split is the broken IE version, if so, provide an\n\t  // alternative way to split lines.\n\t  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n\t    var pos = 0, result = [], l = string.length;\n\t    while (pos <= l) {\n\t      var nl = string.indexOf(\"\\n\", pos);\n\t      if (nl == -1) nl = string.length;\n\t      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n\t      var rt = line.indexOf(\"\\r\");\n\t      if (rt != -1) {\n\t        result.push(line.slice(0, rt));\n\t        pos += rt + 1;\n\t      } else {\n\t        result.push(line);\n\t        pos = nl + 1;\n\t      }\n\t    }\n\t    return result;\n\t  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\t\n\t  var hasSelection = window.getSelection ? function(te) {\n\t    try { return te.selectionStart != te.selectionEnd; }\n\t    catch(e) { return false; }\n\t  } : function(te) {\n\t    try {var range = te.ownerDocument.selection.createRange();}\n\t    catch(e) {}\n\t    if (!range || range.parentElement() != te) return false;\n\t    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n\t  };\n\t\n\t  var hasCopyEvent = (function() {\n\t    var e = elt(\"div\");\n\t    if (\"oncopy\" in e) return true;\n\t    e.setAttribute(\"oncopy\", \"return;\");\n\t    return typeof e.oncopy == \"function\";\n\t  })();\n\t\n\t  var badZoomedRects = null;\n\t  function hasBadZoomedRects(measure) {\n\t    if (badZoomedRects != null) return badZoomedRects;\n\t    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n\t    var normal = node.getBoundingClientRect();\n\t    var fromRange = range(node, 0, 1).getBoundingClientRect();\n\t    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n\t  }\n\t\n\t  // KEY NAMES\n\t\n\t  var keyNames = CodeMirror.keyNames = {\n\t    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n\t    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n\t    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n\t    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n\t    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n\t    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n\t    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n\t  };\n\t  (function() {\n\t    // Number keys\n\t    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n\t    // Alphabetic keys\n\t    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n\t    // Function keys\n\t    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n\t  })();\n\t\n\t  // BIDI HELPERS\n\t\n\t  function iterateBidiSections(order, from, to, f) {\n\t    if (!order) return f(from, to, \"ltr\");\n\t    var found = false;\n\t    for (var i = 0; i < order.length; ++i) {\n\t      var part = order[i];\n\t      if (part.from < to && part.to > from || from == to && part.to == from) {\n\t        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n\t        found = true;\n\t      }\n\t    }\n\t    if (!found) f(from, to, \"ltr\");\n\t  }\n\t\n\t  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n\t  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\t\n\t  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n\t  function lineRight(line) {\n\t    var order = getOrder(line);\n\t    if (!order) return line.text.length;\n\t    return bidiRight(lst(order));\n\t  }\n\t\n\t  function lineStart(cm, lineN) {\n\t    var line = getLine(cm.doc, lineN);\n\t    var visual = visualLine(line);\n\t    if (visual != line) lineN = lineNo(visual);\n\t    var order = getOrder(visual);\n\t    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n\t    return Pos(lineN, ch);\n\t  }\n\t  function lineEnd(cm, lineN) {\n\t    var merged, line = getLine(cm.doc, lineN);\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      lineN = null;\n\t    }\n\t    var order = getOrder(line);\n\t    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n\t    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n\t  }\n\t  function lineStartSmart(cm, pos) {\n\t    var start = lineStart(cm, pos.line);\n\t    var line = getLine(cm.doc, start.line);\n\t    var order = getOrder(line);\n\t    if (!order || order[0].level == 0) {\n\t      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n\t      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n\t      return Pos(start.line, inWS ? 0 : firstNonWS);\n\t    }\n\t    return start;\n\t  }\n\t\n\t  function compareBidiLevel(order, a, b) {\n\t    var linedir = order[0].level;\n\t    if (a == linedir) return true;\n\t    if (b == linedir) return false;\n\t    return a < b;\n\t  }\n\t  var bidiOther;\n\t  function getBidiPartAt(order, pos) {\n\t    bidiOther = null;\n\t    for (var i = 0, found; i < order.length; ++i) {\n\t      var cur = order[i];\n\t      if (cur.from < pos && cur.to > pos) return i;\n\t      if ((cur.from == pos || cur.to == pos)) {\n\t        if (found == null) {\n\t          found = i;\n\t        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n\t          if (cur.from != cur.to) bidiOther = found;\n\t          return i;\n\t        } else {\n\t          if (cur.from != cur.to) bidiOther = i;\n\t          return found;\n\t        }\n\t      }\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function moveInLine(line, pos, dir, byUnit) {\n\t    if (!byUnit) return pos + dir;\n\t    do pos += dir;\n\t    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n\t    return pos;\n\t  }\n\t\n\t  // This is needed in order to move 'visually' through bi-directional\n\t  // text -- i.e., pressing left should make the cursor go left, even\n\t  // when in RTL text. The tricky part is the 'jumps', where RTL and\n\t  // LTR text touch each other. This often requires the cursor offset\n\t  // to move more than one unit, in order to visually move one unit.\n\t  function moveVisually(line, start, dir, byUnit) {\n\t    var bidi = getOrder(line);\n\t    if (!bidi) return moveLogically(line, start, dir, byUnit);\n\t    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n\t    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\t\n\t    for (;;) {\n\t      if (target > part.from && target < part.to) return target;\n\t      if (target == part.from || target == part.to) {\n\t        if (getBidiPartAt(bidi, target) == pos) return target;\n\t        part = bidi[pos += dir];\n\t        return (dir > 0) == part.level % 2 ? part.to : part.from;\n\t      } else {\n\t        part = bidi[pos += dir];\n\t        if (!part) return null;\n\t        if ((dir > 0) == part.level % 2)\n\t          target = moveInLine(line, part.to, -1, byUnit);\n\t        else\n\t          target = moveInLine(line, part.from, 1, byUnit);\n\t      }\n\t    }\n\t  }\n\t\n\t  function moveLogically(line, start, dir, byUnit) {\n\t    var target = start + dir;\n\t    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n\t    return target < 0 || target > line.text.length ? null : target;\n\t  }\n\t\n\t  // Bidirectional ordering algorithm\n\t  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n\t  // that this (partially) implements.\n\t\n\t  // One-char codes used for character types:\n\t  // L (L):   Left-to-Right\n\t  // R (R):   Right-to-Left\n\t  // r (AL):  Right-to-Left Arabic\n\t  // 1 (EN):  European Number\n\t  // + (ES):  European Number Separator\n\t  // % (ET):  European Number Terminator\n\t  // n (AN):  Arabic Number\n\t  // , (CS):  Common Number Separator\n\t  // m (NSM): Non-Spacing Mark\n\t  // b (BN):  Boundary Neutral\n\t  // s (B):   Paragraph Separator\n\t  // t (S):   Segment Separator\n\t  // w (WS):  Whitespace\n\t  // N (ON):  Other Neutrals\n\t\n\t  // Returns null if characters are ordered as they appear\n\t  // (left-to-right), or an array of sections ({from, to, level}\n\t  // objects) in the order in which they occur visually.\n\t  var bidiOrdering = (function() {\n\t    // Character types for codepoints 0 to 0xff\n\t    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n\t    // Character types for codepoints 0x600 to 0x6ff\n\t    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n\t    function charType(code) {\n\t      if (code <= 0xf7) return lowTypes.charAt(code);\n\t      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n\t      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n\t      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n\t      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n\t      else if (code == 0x200c) return \"b\";\n\t      else return \"L\";\n\t    }\n\t\n\t    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\t    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\t    // Browsers seem to always treat the boundaries of block elements as being L.\n\t    var outerType = \"L\";\n\t\n\t    function BidiSpan(level, from, to) {\n\t      this.level = level;\n\t      this.from = from; this.to = to;\n\t    }\n\t\n\t    return function(str) {\n\t      if (!bidiRE.test(str)) return false;\n\t      var len = str.length, types = [];\n\t      for (var i = 0, type; i < len; ++i)\n\t        types.push(type = charType(str.charCodeAt(i)));\n\t\n\t      // W1. Examine each non-spacing mark (NSM) in the level run, and\n\t      // change the type of the NSM to the type of the previous\n\t      // character. If the NSM is at the start of the level run, it will\n\t      // get the type of sor.\n\t      for (var i = 0, prev = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"m\") types[i] = prev;\n\t        else prev = type;\n\t      }\n\t\n\t      // W2. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, AL, or sor) is found. If an\n\t      // AL is found, change the type of the European number to Arabic\n\t      // number.\n\t      // W3. Change all ALs to R.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n\t        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n\t      }\n\t\n\t      // W4. A single European separator between two European numbers\n\t      // changes to a European number. A single common separator between\n\t      // two numbers of the same type changes to that type.\n\t      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n\t        var type = types[i];\n\t        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n\t        else if (type == \",\" && prev == types[i+1] &&\n\t                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n\t        prev = type;\n\t      }\n\t\n\t      // W5. A sequence of European terminators adjacent to European\n\t      // numbers changes to all European numbers.\n\t      // W6. Otherwise, separators and terminators change to Other\n\t      // Neutral.\n\t      for (var i = 0; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \",\") types[i] = \"N\";\n\t        else if (type == \"%\") {\n\t          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\t          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // W7. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, or sor) is found. If an L is\n\t      // found, then change the type of the European number to L.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n\t        else if (isStrong.test(type)) cur = type;\n\t      }\n\t\n\t      // N1. A sequence of neutrals takes the direction of the\n\t      // surrounding strong text if the text on both sides has the same\n\t      // direction. European and Arabic numbers act as if they were R in\n\t      // terms of their influence on neutrals. Start-of-level-run (sor)\n\t      // and end-of-level-run (eor) are used at level run boundaries.\n\t      // N2. Any remaining neutrals take the embedding direction.\n\t      for (var i = 0; i < len; ++i) {\n\t        if (isNeutral.test(types[i])) {\n\t          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\t          var before = (i ? types[i-1] : outerType) == \"L\";\n\t          var after = (end < len ? types[end] : outerType) == \"L\";\n\t          var replace = before || after ? \"L\" : \"R\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // Here we depart from the documented algorithm, in order to avoid\n\t      // building up an actual levels array. Since there are only three\n\t      // levels (0, 1, 2) in an implementation that doesn't take\n\t      // explicit embedding into account, we can build up the order on\n\t      // the fly, without following the level-based algorithm.\n\t      var order = [], m;\n\t      for (var i = 0; i < len;) {\n\t        if (countsAsLeft.test(types[i])) {\n\t          var start = i;\n\t          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\t          order.push(new BidiSpan(0, start, i));\n\t        } else {\n\t          var pos = i, at = order.length;\n\t          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\t          for (var j = pos; j < i;) {\n\t            if (countsAsNum.test(types[j])) {\n\t              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n\t              var nstart = j;\n\t              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\t              order.splice(at, 0, new BidiSpan(2, nstart, j));\n\t              pos = j;\n\t            } else ++j;\n\t          }\n\t          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n\t        }\n\t      }\n\t      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n\t        order[0].from = m[0].length;\n\t        order.unshift(new BidiSpan(0, 0, m[0].length));\n\t      }\n\t      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n\t        lst(order).to -= m[0].length;\n\t        order.push(new BidiSpan(0, len - m[0].length, len));\n\t      }\n\t      if (order[0].level == 2)\n\t        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n\t      if (order[0].level != lst(order).level)\n\t        order.push(new BidiSpan(order[0].level, len, len));\n\t\n\t      return order;\n\t    };\n\t  })();\n\t\n\t  // THE END\n\t\n\t  CodeMirror.version = \"5.11.0\";\n\t\n\t  return CodeMirror;\n\t});\n\n\n/***/ },\n/* 361 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360), __webpack_require__(362), __webpack_require__(365));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\", \"../markdown/markdown\", \"../../addon/mode/overlay\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tvar urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\\.beep|\\.lwz|\\.xpc|\\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\\.beeps?|xmpp|xri|ymsgr|z39\\.50[rs]?):(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]|\\([^\\s()<>]*\\))+(?:\\([^\\s()<>]*\\)|[^\\s`*!()\\[\\]{};:'\".,<>?]))/i\n\t\n\tCodeMirror.defineMode(\"gfm\", function(config, modeConfig) {\n\t  var codeDepth = 0;\n\t  function blankLine(state) {\n\t    state.code = false;\n\t    return null;\n\t  }\n\t  var gfmOverlay = {\n\t    startState: function() {\n\t      return {\n\t        code: false,\n\t        codeBlock: false,\n\t        ateSpace: false\n\t      };\n\t    },\n\t    copyState: function(s) {\n\t      return {\n\t        code: s.code,\n\t        codeBlock: s.codeBlock,\n\t        ateSpace: s.ateSpace\n\t      };\n\t    },\n\t    token: function(stream, state) {\n\t      state.combineTokens = null;\n\t\n\t      // Hack to prevent formatting override inside code blocks (block and inline)\n\t      if (state.codeBlock) {\n\t        if (stream.match(/^```+/)) {\n\t          state.codeBlock = false;\n\t          return null;\n\t        }\n\t        stream.skipToEnd();\n\t        return null;\n\t      }\n\t      if (stream.sol()) {\n\t        state.code = false;\n\t      }\n\t      if (stream.sol() && stream.match(/^```+/)) {\n\t        stream.skipToEnd();\n\t        state.codeBlock = true;\n\t        return null;\n\t      }\n\t      // If this block is changed, it may need to be updated in Markdown mode\n\t      if (stream.peek() === '`') {\n\t        stream.next();\n\t        var before = stream.pos;\n\t        stream.eatWhile('`');\n\t        var difference = 1 + stream.pos - before;\n\t        if (!state.code) {\n\t          codeDepth = difference;\n\t          state.code = true;\n\t        } else {\n\t          if (difference === codeDepth) { // Must be exact\n\t            state.code = false;\n\t          }\n\t        }\n\t        return null;\n\t      } else if (state.code) {\n\t        stream.next();\n\t        return null;\n\t      }\n\t      // Check if space. If so, links can be formatted later on\n\t      if (stream.eatSpace()) {\n\t        state.ateSpace = true;\n\t        return null;\n\t      }\n\t      if (stream.sol() || state.ateSpace) {\n\t        state.ateSpace = false;\n\t        if (modeConfig.gitHubSpice !== false) {\n\t          if(stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+@)?(?:[a-f0-9]{7,40}\\b)/)) {\n\t            // User/Project@SHA\n\t            // User@SHA\n\t            // SHA\n\t            state.combineTokens = true;\n\t            return \"link\";\n\t          } else if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+)?#[0-9]+\\b/)) {\n\t            // User/Project#Num\n\t            // User#Num\n\t            // #Num\n\t            state.combineTokens = true;\n\t            return \"link\";\n\t          }\n\t        }\n\t      }\n\t      if (stream.match(urlRE) &&\n\t          stream.string.slice(stream.start - 2, stream.start) != \"](\" &&\n\t          (stream.start == 0 || /\\W/.test(stream.string.charAt(stream.start - 1)))) {\n\t        // URLs\n\t        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n\t        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine\n\t        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL\n\t        state.combineTokens = true;\n\t        return \"link\";\n\t      }\n\t      stream.next();\n\t      return null;\n\t    },\n\t    blankLine: blankLine\n\t  };\n\t\n\t  var markdownConfig = {\n\t    underscoresBreakWords: false,\n\t    taskLists: true,\n\t    fencedCodeBlocks: '```',\n\t    strikethrough: true\n\t  };\n\t  for (var attr in modeConfig) {\n\t    markdownConfig[attr] = modeConfig[attr];\n\t  }\n\t  markdownConfig.name = \"markdown\";\n\t  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);\n\t\n\t}, \"markdown\");\n\t\n\t  CodeMirror.defineMIME(\"text/x-gfm\", \"gfm\");\n\t});\n\n\n/***/ },\n/* 362 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360), __webpack_require__(363), __webpack_require__(364));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\n\t\n\t  var htmlFound = CodeMirror.modes.hasOwnProperty(\"xml\");\n\t  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: \"xml\", htmlMode: true} : \"text/plain\");\n\t\n\t  function getMode(name) {\n\t    if (CodeMirror.findModeByName) {\n\t      var found = CodeMirror.findModeByName(name);\n\t      if (found) name = found.mime || found.mimes[0];\n\t    }\n\t    var mode = CodeMirror.getMode(cmCfg, name);\n\t    return mode.name == \"null\" ? null : mode;\n\t  }\n\t\n\t  // Should characters that affect highlighting be highlighted separate?\n\t  // Does not include characters that will be output (such as `1.` and `-` for lists)\n\t  if (modeCfg.highlightFormatting === undefined)\n\t    modeCfg.highlightFormatting = false;\n\t\n\t  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\n\t  // Excess `>` will emit `error` token.\n\t  if (modeCfg.maxBlockquoteDepth === undefined)\n\t    modeCfg.maxBlockquoteDepth = 0;\n\t\n\t  // Should underscores in words open/close em/strong?\n\t  if (modeCfg.underscoresBreakWords === undefined)\n\t    modeCfg.underscoresBreakWords = true;\n\t\n\t  // Use `fencedCodeBlocks` to configure fenced code blocks. false to\n\t  // disable, string to specify a precise regexp that the fence should\n\t  // match, and true to allow three or more backticks or tildes (as\n\t  // per CommonMark).\n\t\n\t  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\n\t  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\n\t\n\t  // Turn on strikethrough syntax\n\t  if (modeCfg.strikethrough === undefined)\n\t    modeCfg.strikethrough = false;\n\t\n\t  // Allow token types to be overridden by user-provided token types.\n\t  if (modeCfg.tokenTypeOverrides === undefined)\n\t    modeCfg.tokenTypeOverrides = {};\n\t\n\t  var codeDepth = 0;\n\t\n\t  var tokenTypes = {\n\t    header: \"header\",\n\t    code: \"comment\",\n\t    quote: \"quote\",\n\t    list1: \"variable-2\",\n\t    list2: \"variable-3\",\n\t    list3: \"keyword\",\n\t    hr: \"hr\",\n\t    image: \"tag\",\n\t    formatting: \"formatting\",\n\t    linkInline: \"link\",\n\t    linkEmail: \"link\",\n\t    linkText: \"link\",\n\t    linkHref: \"string\",\n\t    em: \"em\",\n\t    strong: \"strong\",\n\t    strikethrough: \"strikethrough\"\n\t  };\n\t\n\t  for (var tokenType in tokenTypes) {\n\t    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\n\t      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\n\t    }\n\t  }\n\t\n\t  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\n\t  ,   ulRE = /^[*\\-+]\\s+/\n\t  ,   olRE = /^[0-9]+([.)])\\s+/\n\t  ,   taskListRE = /^\\[(x| )\\](?=\\s)/ // Must follow ulRE or olRE\n\t  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\n\t  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\n\t  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~]+/\n\t  ,   fencedCodeRE = new RegExp(\"^(\" + (modeCfg.fencedCodeBlocks === true ? \"~~~+|```+\" : modeCfg.fencedCodeBlocks) +\n\t                                \")[ \\\\t]*([\\\\w+#]*)\");\n\t\n\t  function switchInline(stream, state, f) {\n\t    state.f = state.inline = f;\n\t    return f(stream, state);\n\t  }\n\t\n\t  function switchBlock(stream, state, f) {\n\t    state.f = state.block = f;\n\t    return f(stream, state);\n\t  }\n\t\n\t  function lineIsEmpty(line) {\n\t    return !line || !/\\S/.test(line.string)\n\t  }\n\t\n\t  // Blocks\n\t\n\t  function blankLine(state) {\n\t    // Reset linkTitle state\n\t    state.linkTitle = false;\n\t    // Reset EM state\n\t    state.em = false;\n\t    // Reset STRONG state\n\t    state.strong = false;\n\t    // Reset strikethrough state\n\t    state.strikethrough = false;\n\t    // Reset state.quote\n\t    state.quote = 0;\n\t    // Reset state.indentedCode\n\t    state.indentedCode = false;\n\t    if (!htmlFound && state.f == htmlBlock) {\n\t      state.f = inlineNormal;\n\t      state.block = blockNormal;\n\t    }\n\t    // Reset state.trailingSpace\n\t    state.trailingSpace = 0;\n\t    state.trailingSpaceNewLine = false;\n\t    // Mark this line as blank\n\t    state.prevLine = state.thisLine\n\t    state.thisLine = null\n\t    return null;\n\t  }\n\t\n\t  function blockNormal(stream, state) {\n\t\n\t    var sol = stream.sol();\n\t\n\t    var prevLineIsList = state.list !== false,\n\t        prevLineIsIndentedCode = state.indentedCode;\n\t\n\t    state.indentedCode = false;\n\t\n\t    if (prevLineIsList) {\n\t      if (state.indentationDiff >= 0) { // Continued list\n\t        if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block\n\t          state.indentation -= state.indentationDiff;\n\t        }\n\t        state.list = null;\n\t      } else if (state.indentation > 0) {\n\t        state.list = null;\n\t        state.listDepth = Math.floor(state.indentation / 4);\n\t      } else { // No longer a list\n\t        state.list = false;\n\t        state.listDepth = 0;\n\t      }\n\t    }\n\t\n\t    var match = null;\n\t    if (state.indentationDiff >= 4) {\n\t      stream.skipToEnd();\n\t      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {\n\t        state.indentation -= 4;\n\t        state.indentedCode = true;\n\t        return tokenTypes.code;\n\t      } else {\n\t        return null;\n\t      }\n\t    } else if (stream.eatSpace()) {\n\t      return null;\n\t    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\n\t      state.header = match[1].length;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n\t      state.f = state.inline;\n\t      return getType(state);\n\t    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&\n\t               !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {\n\t      state.header = match[0].charAt(0) == '=' ? 1 : 2;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n\t      state.f = state.inline;\n\t      return getType(state);\n\t    } else if (stream.eat('>')) {\n\t      state.quote = sol ? 1 : state.quote + 1;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\n\t      stream.eatSpace();\n\t      return getType(state);\n\t    } else if (stream.peek() === '[') {\n\t      return switchInline(stream, state, footnoteLink);\n\t    } else if (stream.match(hrRE, true)) {\n\t      state.hr = true;\n\t      return tokenTypes.hr;\n\t    } else if ((lineIsEmpty(state.prevLine) || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {\n\t      var listType = null;\n\t      if (stream.match(ulRE, true)) {\n\t        listType = 'ul';\n\t      } else {\n\t        stream.match(olRE, true);\n\t        listType = 'ol';\n\t      }\n\t      state.indentation = stream.column() + stream.current().length;\n\t      state.list = true;\n\t      state.listDepth++;\n\t      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\n\t        state.taskList = true;\n\t      }\n\t      state.f = state.inline;\n\t      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\n\t      return getType(state);\n\t    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {\n\t      state.fencedChars = match[1]\n\t      // try switching mode\n\t      state.localMode = getMode(match[2]);\n\t      if (state.localMode) state.localState = state.localMode.startState();\n\t      state.f = state.block = local;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n\t      state.code = true;\n\t      return getType(state);\n\t    }\n\t\n\t    return switchInline(stream, state, state.inline);\n\t  }\n\t\n\t  function htmlBlock(stream, state) {\n\t    var style = htmlMode.token(stream, state.htmlState);\n\t    if ((htmlFound && state.htmlState.tagStart === null &&\n\t         (!state.htmlState.context && state.htmlState.tokenize.isInText)) ||\n\t        (state.md_inside && stream.current().indexOf(\">\") > -1)) {\n\t      state.f = inlineNormal;\n\t      state.block = blockNormal;\n\t      state.htmlState = null;\n\t    }\n\t    return style;\n\t  }\n\t\n\t  function local(stream, state) {\n\t    if (state.fencedChars && stream.match(state.fencedChars, false)) {\n\t      state.localMode = state.localState = null;\n\t      state.f = state.block = leavingLocal;\n\t      return null;\n\t    } else if (state.localMode) {\n\t      return state.localMode.token(stream, state.localState);\n\t    } else {\n\t      stream.skipToEnd();\n\t      return tokenTypes.code;\n\t    }\n\t  }\n\t\n\t  function leavingLocal(stream, state) {\n\t    stream.match(state.fencedChars);\n\t    state.block = blockNormal;\n\t    state.f = inlineNormal;\n\t    state.fencedChars = null;\n\t    if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n\t    state.code = true;\n\t    var returnType = getType(state);\n\t    state.code = false;\n\t    return returnType;\n\t  }\n\t\n\t  // Inline\n\t  function getType(state) {\n\t    var styles = [];\n\t\n\t    if (state.formatting) {\n\t      styles.push(tokenTypes.formatting);\n\t\n\t      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\n\t\n\t      for (var i = 0; i < state.formatting.length; i++) {\n\t        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\n\t\n\t        if (state.formatting[i] === \"header\") {\n\t          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\n\t        }\n\t\n\t        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\n\t        // Add `error` instead if the maximum blockquote nesting depth is passed\n\t        if (state.formatting[i] === \"quote\") {\n\t          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n\t            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\n\t          } else {\n\t            styles.push(\"error\");\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (state.taskOpen) {\n\t      styles.push(\"meta\");\n\t      return styles.length ? styles.join(' ') : null;\n\t    }\n\t    if (state.taskClosed) {\n\t      styles.push(\"property\");\n\t      return styles.length ? styles.join(' ') : null;\n\t    }\n\t\n\t    if (state.linkHref) {\n\t      styles.push(tokenTypes.linkHref, \"url\");\n\t    } else { // Only apply inline styles to non-url text\n\t      if (state.strong) { styles.push(tokenTypes.strong); }\n\t      if (state.em) { styles.push(tokenTypes.em); }\n\t      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\n\t      if (state.linkText) { styles.push(tokenTypes.linkText); }\n\t      if (state.code) { styles.push(tokenTypes.code); }\n\t    }\n\t\n\t    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\n\t\n\t    if (state.quote) {\n\t      styles.push(tokenTypes.quote);\n\t\n\t      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\n\t      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n\t        styles.push(tokenTypes.quote + \"-\" + state.quote);\n\t      } else {\n\t        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\n\t      }\n\t    }\n\t\n\t    if (state.list !== false) {\n\t      var listMod = (state.listDepth - 1) % 3;\n\t      if (!listMod) {\n\t        styles.push(tokenTypes.list1);\n\t      } else if (listMod === 1) {\n\t        styles.push(tokenTypes.list2);\n\t      } else {\n\t        styles.push(tokenTypes.list3);\n\t      }\n\t    }\n\t\n\t    if (state.trailingSpaceNewLine) {\n\t      styles.push(\"trailing-space-new-line\");\n\t    } else if (state.trailingSpace) {\n\t      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\n\t    }\n\t\n\t    return styles.length ? styles.join(' ') : null;\n\t  }\n\t\n\t  function handleText(stream, state) {\n\t    if (stream.match(textRE, true)) {\n\t      return getType(state);\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function inlineNormal(stream, state) {\n\t    var style = state.text(stream, state);\n\t    if (typeof style !== 'undefined')\n\t      return style;\n\t\n\t    if (state.list) { // List marker (*, +, -, 1., etc)\n\t      state.list = null;\n\t      return getType(state);\n\t    }\n\t\n\t    if (state.taskList) {\n\t      var taskOpen = stream.match(taskListRE, true)[1] !== \"x\";\n\t      if (taskOpen) state.taskOpen = true;\n\t      else state.taskClosed = true;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"task\";\n\t      state.taskList = false;\n\t      return getType(state);\n\t    }\n\t\n\t    state.taskOpen = false;\n\t    state.taskClosed = false;\n\t\n\t    if (state.header && stream.match(/^#+$/, true)) {\n\t      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n\t      return getType(state);\n\t    }\n\t\n\t    // Get sol() value now, before character is consumed\n\t    var sol = stream.sol();\n\t\n\t    var ch = stream.next();\n\t\n\t    if (ch === '\\\\') {\n\t      stream.next();\n\t      if (modeCfg.highlightFormatting) {\n\t        var type = getType(state);\n\t        var formattingEscape = tokenTypes.formatting + \"-escape\";\n\t        return type ? type + \" \" + formattingEscape : formattingEscape;\n\t      }\n\t    }\n\t\n\t    // Matches link titles present on next line\n\t    if (state.linkTitle) {\n\t      state.linkTitle = false;\n\t      var matchCh = ch;\n\t      if (ch === '(') {\n\t        matchCh = ')';\n\t      }\n\t      matchCh = (matchCh+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n\t      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\n\t      if (stream.match(new RegExp(regex), true)) {\n\t        return tokenTypes.linkHref;\n\t      }\n\t    }\n\t\n\t    // If this block is changed, it may need to be updated in GFM mode\n\t    if (ch === '`') {\n\t      var previousFormatting = state.formatting;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"code\";\n\t      var t = getType(state);\n\t      var before = stream.pos;\n\t      stream.eatWhile('`');\n\t      var difference = 1 + stream.pos - before;\n\t      if (!state.code) {\n\t        codeDepth = difference;\n\t        state.code = true;\n\t        return getType(state);\n\t      } else {\n\t        if (difference === codeDepth) { // Must be exact\n\t          state.code = false;\n\t          return t;\n\t        }\n\t        state.formatting = previousFormatting;\n\t        return getType(state);\n\t      }\n\t    } else if (state.code) {\n\t      return getType(state);\n\t    }\n\t\n\t    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\n\t      stream.match(/\\[[^\\]]*\\]/);\n\t      state.inline = state.f = linkHref;\n\t      return tokenTypes.image;\n\t    }\n\t\n\t    if (ch === '[' && stream.match(/.*\\](\\(.*\\)| ?\\[.*\\])/, false)) {\n\t      state.linkText = true;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      return getType(state);\n\t    }\n\t\n\t    if (ch === ']' && state.linkText && stream.match(/\\(.*\\)| ?\\[.*\\]/, false)) {\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      state.linkText = false;\n\t      state.inline = state.f = linkHref;\n\t      return type;\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\n\t      state.f = state.inline = linkInline;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      if (type){\n\t        type += \" \";\n\t      } else {\n\t        type = \"\";\n\t      }\n\t      return type + tokenTypes.linkInline;\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\n\t      state.f = state.inline = linkInline;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      if (type){\n\t        type += \" \";\n\t      } else {\n\t        type = \"\";\n\t      }\n\t      return type + tokenTypes.linkEmail;\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^(!--|\\w)/, false)) {\n\t      var end = stream.string.indexOf(\">\", stream.pos);\n\t      if (end != -1) {\n\t        var atts = stream.string.substring(stream.start, end);\n\t        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\n\t      }\n\t      stream.backUp(1);\n\t      state.htmlState = CodeMirror.startState(htmlMode);\n\t      return switchBlock(stream, state, htmlBlock);\n\t    }\n\t\n\t    if (ch === '<' && stream.match(/^\\/\\w*?>/)) {\n\t      state.md_inside = false;\n\t      return \"tag\";\n\t    }\n\t\n\t    var ignoreUnderscore = false;\n\t    if (!modeCfg.underscoresBreakWords) {\n\t      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\\w)/, false)) {\n\t        var prevPos = stream.pos - 2;\n\t        if (prevPos >= 0) {\n\t          var prevCh = stream.string.charAt(prevPos);\n\t          if (prevCh !== '_' && prevCh.match(/(\\w)/, false)) {\n\t            ignoreUnderscore = true;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {\n\t      if (sol && stream.peek() === ' ') {\n\t        // Do nothing, surrounded by newline and space\n\t      } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG\n\t        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n\t        var t = getType(state);\n\t        state.strong = false;\n\t        return t;\n\t      } else if (!state.strong && stream.eat(ch)) { // Add STRONG\n\t        state.strong = ch;\n\t        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n\t        return getType(state);\n\t      } else if (state.em === ch) { // Remove EM\n\t        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n\t        var t = getType(state);\n\t        state.em = false;\n\t        return t;\n\t      } else if (!state.em) { // Add EM\n\t        state.em = ch;\n\t        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n\t        return getType(state);\n\t      }\n\t    } else if (ch === ' ') {\n\t      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\n\t        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n\t          return getType(state);\n\t        } else { // Not surrounded by spaces, back up pointer\n\t          stream.backUp(1);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (modeCfg.strikethrough) {\n\t      if (ch === '~' && stream.eatWhile(ch)) {\n\t        if (state.strikethrough) {// Remove strikethrough\n\t          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n\t          var t = getType(state);\n\t          state.strikethrough = false;\n\t          return t;\n\t        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\n\t          state.strikethrough = true;\n\t          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n\t          return getType(state);\n\t        }\n\t      } else if (ch === ' ') {\n\t        if (stream.match(/^~~/, true)) { // Probably surrounded by space\n\t          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n\t            return getType(state);\n\t          } else { // Not surrounded by spaces, back up pointer\n\t            stream.backUp(2);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (ch === ' ') {\n\t      if (stream.match(/ +$/, false)) {\n\t        state.trailingSpace++;\n\t      } else if (state.trailingSpace) {\n\t        state.trailingSpaceNewLine = true;\n\t      }\n\t    }\n\t\n\t    return getType(state);\n\t  }\n\t\n\t  function linkInline(stream, state) {\n\t    var ch = stream.next();\n\t\n\t    if (ch === \">\") {\n\t      state.f = state.inline = inlineNormal;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var type = getType(state);\n\t      if (type){\n\t        type += \" \";\n\t      } else {\n\t        type = \"\";\n\t      }\n\t      return type + tokenTypes.linkInline;\n\t    }\n\t\n\t    stream.match(/^[^>]+/, true);\n\t\n\t    return tokenTypes.linkInline;\n\t  }\n\t\n\t  function linkHref(stream, state) {\n\t    // Check if space, and return NULL if so (to avoid marking the space)\n\t    if(stream.eatSpace()){\n\t      return null;\n\t    }\n\t    var ch = stream.next();\n\t    if (ch === '(' || ch === '[') {\n\t      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n\t      state.linkHref = true;\n\t      return getType(state);\n\t    }\n\t    return 'error';\n\t  }\n\t\n\t  function getLinkHrefInside(endChar) {\n\t    return function(stream, state) {\n\t      var ch = stream.next();\n\t\n\t      if (ch === endChar) {\n\t        state.f = state.inline = inlineNormal;\n\t        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n\t        var returnState = getType(state);\n\t        state.linkHref = false;\n\t        return returnState;\n\t      }\n\t\n\t      if (stream.match(inlineRE(endChar), true)) {\n\t        stream.backUp(1);\n\t      }\n\t\n\t      state.linkHref = true;\n\t      return getType(state);\n\t    };\n\t  }\n\t\n\t  function footnoteLink(stream, state) {\n\t    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\n\t      state.f = footnoteLinkInside;\n\t      stream.next(); // Consume [\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      state.linkText = true;\n\t      return getType(state);\n\t    }\n\t    return switchInline(stream, state, inlineNormal);\n\t  }\n\t\n\t  function footnoteLinkInside(stream, state) {\n\t    if (stream.match(/^\\]:/, true)) {\n\t      state.f = state.inline = footnoteUrl;\n\t      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n\t      var returnType = getType(state);\n\t      state.linkText = false;\n\t      return returnType;\n\t    }\n\t\n\t    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\n\t\n\t    return tokenTypes.linkText;\n\t  }\n\t\n\t  function footnoteUrl(stream, state) {\n\t    // Check if space, and return NULL if so (to avoid marking the space)\n\t    if(stream.eatSpace()){\n\t      return null;\n\t    }\n\t    // Match URL\n\t    stream.match(/^[^\\s]+/, true);\n\t    // Check for link title\n\t    if (stream.peek() === undefined) { // End of line, set flag to check next line\n\t      state.linkTitle = true;\n\t    } else { // More content on line, check if link title\n\t      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\n\t    }\n\t    state.f = state.inline = inlineNormal;\n\t    return tokenTypes.linkHref + \" url\";\n\t  }\n\t\n\t  var savedInlineRE = [];\n\t  function inlineRE(endChar) {\n\t    if (!savedInlineRE[endChar]) {\n\t      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)\n\t      endChar = (endChar+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n\t      // Match any non-endChar, escaped character, as well as the closing\n\t      // endChar.\n\t      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\\\\\]|\\\\\\\\.)*?(' + endChar + ')');\n\t    }\n\t    return savedInlineRE[endChar];\n\t  }\n\t\n\t  var mode = {\n\t    startState: function() {\n\t      return {\n\t        f: blockNormal,\n\t\n\t        prevLine: null,\n\t        thisLine: null,\n\t\n\t        block: blockNormal,\n\t        htmlState: null,\n\t        indentation: 0,\n\t\n\t        inline: inlineNormal,\n\t        text: handleText,\n\t\n\t        formatting: false,\n\t        linkText: false,\n\t        linkHref: false,\n\t        linkTitle: false,\n\t        em: false,\n\t        strong: false,\n\t        header: 0,\n\t        hr: false,\n\t        taskList: false,\n\t        list: false,\n\t        listDepth: 0,\n\t        quote: 0,\n\t        trailingSpace: 0,\n\t        trailingSpaceNewLine: false,\n\t        strikethrough: false,\n\t        fencedChars: null\n\t      };\n\t    },\n\t\n\t    copyState: function(s) {\n\t      return {\n\t        f: s.f,\n\t\n\t        prevLine: s.prevLine,\n\t        thisLine: s.thisLine,\n\t\n\t        block: s.block,\n\t        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\n\t        indentation: s.indentation,\n\t\n\t        localMode: s.localMode,\n\t        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\n\t\n\t        inline: s.inline,\n\t        text: s.text,\n\t        formatting: false,\n\t        linkTitle: s.linkTitle,\n\t        code: s.code,\n\t        em: s.em,\n\t        strong: s.strong,\n\t        strikethrough: s.strikethrough,\n\t        header: s.header,\n\t        hr: s.hr,\n\t        taskList: s.taskList,\n\t        list: s.list,\n\t        listDepth: s.listDepth,\n\t        quote: s.quote,\n\t        indentedCode: s.indentedCode,\n\t        trailingSpace: s.trailingSpace,\n\t        trailingSpaceNewLine: s.trailingSpaceNewLine,\n\t        md_inside: s.md_inside,\n\t        fencedChars: s.fencedChars\n\t      };\n\t    },\n\t\n\t    token: function(stream, state) {\n\t\n\t      // Reset state.formatting\n\t      state.formatting = false;\n\t\n\t      if (stream != state.thisLine) {\n\t        var forceBlankLine = state.header || state.hr;\n\t\n\t        // Reset state.header and state.hr\n\t        state.header = 0;\n\t        state.hr = false;\n\t\n\t        if (stream.match(/^\\s*$/, true) || forceBlankLine) {\n\t          blankLine(state);\n\t          if (!forceBlankLine) return null\n\t          state.prevLine = null\n\t        }\n\t\n\t        state.prevLine = state.thisLine\n\t        state.thisLine = stream\n\t\n\t        // Reset state.taskList\n\t        state.taskList = false;\n\t\n\t        // Reset state.trailingSpace\n\t        state.trailingSpace = 0;\n\t        state.trailingSpaceNewLine = false;\n\t\n\t        state.f = state.block;\n\t        var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, '    ').length;\n\t        var difference = Math.floor((indentation - state.indentation) / 4) * 4;\n\t        if (difference > 4) difference = 4;\n\t        var adjustedIndentation = state.indentation + difference;\n\t        state.indentationDiff = adjustedIndentation - state.indentation;\n\t        state.indentation = adjustedIndentation;\n\t        if (indentation > 0) return null;\n\t      }\n\t      return state.f(stream, state);\n\t    },\n\t\n\t    innerMode: function(state) {\n\t      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\n\t      if (state.localState) return {state: state.localState, mode: state.localMode};\n\t      return {state: state, mode: mode};\n\t    },\n\t\n\t    blankLine: blankLine,\n\t\n\t    getType: getType,\n\t\n\t    fold: \"markdown\"\n\t  };\n\t  return mode;\n\t}, \"xml\");\n\t\n\tCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\n\t\n\t});\n\n\n/***/ },\n/* 363 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tvar htmlConfig = {\n\t  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n\t                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n\t                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n\t                    'track': true, 'wbr': true, 'menuitem': true},\n\t  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n\t                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n\t                     'th': true, 'tr': true},\n\t  contextGrabbers: {\n\t    'dd': {'dd': true, 'dt': true},\n\t    'dt': {'dd': true, 'dt': true},\n\t    'li': {'li': true},\n\t    'option': {'option': true, 'optgroup': true},\n\t    'optgroup': {'optgroup': true},\n\t    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n\t          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n\t          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n\t          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n\t          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n\t    'rp': {'rp': true, 'rt': true},\n\t    'rt': {'rp': true, 'rt': true},\n\t    'tbody': {'tbody': true, 'tfoot': true},\n\t    'td': {'td': true, 'th': true},\n\t    'tfoot': {'tbody': true},\n\t    'th': {'td': true, 'th': true},\n\t    'thead': {'tbody': true, 'tfoot': true},\n\t    'tr': {'tr': true}\n\t  },\n\t  doNotIndent: {\"pre\": true},\n\t  allowUnquoted: true,\n\t  allowMissing: true,\n\t  caseFold: true\n\t}\n\t\n\tvar xmlConfig = {\n\t  autoSelfClosers: {},\n\t  implicitlyClosed: {},\n\t  contextGrabbers: {},\n\t  doNotIndent: {},\n\t  allowUnquoted: false,\n\t  allowMissing: false,\n\t  caseFold: false\n\t}\n\t\n\tCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n\t  var indentUnit = editorConf.indentUnit\n\t  var config = {}\n\t  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n\t  for (var prop in defaults) config[prop] = defaults[prop]\n\t  for (var prop in config_) config[prop] = config_[prop]\n\t\n\t  // Return variables for tokenizers\n\t  var type, setStyle;\n\t\n\t  function inText(stream, state) {\n\t    function chain(parser) {\n\t      state.tokenize = parser;\n\t      return parser(stream, state);\n\t    }\n\t\n\t    var ch = stream.next();\n\t    if (ch == \"<\") {\n\t      if (stream.eat(\"!\")) {\n\t        if (stream.eat(\"[\")) {\n\t          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n\t          else return null;\n\t        } else if (stream.match(\"--\")) {\n\t          return chain(inBlock(\"comment\", \"-->\"));\n\t        } else if (stream.match(\"DOCTYPE\", true, true)) {\n\t          stream.eatWhile(/[\\w\\._\\-]/);\n\t          return chain(doctype(1));\n\t        } else {\n\t          return null;\n\t        }\n\t      } else if (stream.eat(\"?\")) {\n\t        stream.eatWhile(/[\\w\\._\\-]/);\n\t        state.tokenize = inBlock(\"meta\", \"?>\");\n\t        return \"meta\";\n\t      } else {\n\t        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t        state.tokenize = inTag;\n\t        return \"tag bracket\";\n\t      }\n\t    } else if (ch == \"&\") {\n\t      var ok;\n\t      if (stream.eat(\"#\")) {\n\t        if (stream.eat(\"x\")) {\n\t          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t        } else {\n\t          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t        }\n\t      } else {\n\t        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t      }\n\t      return ok ? \"atom\" : \"error\";\n\t    } else {\n\t      stream.eatWhile(/[^&<]/);\n\t      return null;\n\t    }\n\t  }\n\t  inText.isInText = true;\n\t\n\t  function inTag(stream, state) {\n\t    var ch = stream.next();\n\t    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t      state.tokenize = inText;\n\t      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t      return \"tag bracket\";\n\t    } else if (ch == \"=\") {\n\t      type = \"equals\";\n\t      return null;\n\t    } else if (ch == \"<\") {\n\t      state.tokenize = inText;\n\t      state.state = baseState;\n\t      state.tagName = state.tagStart = null;\n\t      var next = state.tokenize(stream, state);\n\t      return next ? next + \" tag error\" : \"tag error\";\n\t    } else if (/[\\'\\\"]/.test(ch)) {\n\t      state.tokenize = inAttribute(ch);\n\t      state.stringStartCol = stream.column();\n\t      return state.tokenize(stream, state);\n\t    } else {\n\t      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n\t      return \"word\";\n\t    }\n\t  }\n\t\n\t  function inAttribute(quote) {\n\t    var closure = function(stream, state) {\n\t      while (!stream.eol()) {\n\t        if (stream.next() == quote) {\n\t          state.tokenize = inTag;\n\t          break;\n\t        }\n\t      }\n\t      return \"string\";\n\t    };\n\t    closure.isInAttribute = true;\n\t    return closure;\n\t  }\n\t\n\t  function inBlock(style, terminator) {\n\t    return function(stream, state) {\n\t      while (!stream.eol()) {\n\t        if (stream.match(terminator)) {\n\t          state.tokenize = inText;\n\t          break;\n\t        }\n\t        stream.next();\n\t      }\n\t      return style;\n\t    };\n\t  }\n\t  function doctype(depth) {\n\t    return function(stream, state) {\n\t      var ch;\n\t      while ((ch = stream.next()) != null) {\n\t        if (ch == \"<\") {\n\t          state.tokenize = doctype(depth + 1);\n\t          return state.tokenize(stream, state);\n\t        } else if (ch == \">\") {\n\t          if (depth == 1) {\n\t            state.tokenize = inText;\n\t            break;\n\t          } else {\n\t            state.tokenize = doctype(depth - 1);\n\t            return state.tokenize(stream, state);\n\t          }\n\t        }\n\t      }\n\t      return \"meta\";\n\t    };\n\t  }\n\t\n\t  function Context(state, tagName, startOfLine) {\n\t    this.prev = state.context;\n\t    this.tagName = tagName;\n\t    this.indent = state.indented;\n\t    this.startOfLine = startOfLine;\n\t    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n\t      this.noIndent = true;\n\t  }\n\t  function popContext(state) {\n\t    if (state.context) state.context = state.context.prev;\n\t  }\n\t  function maybePopContext(state, nextTagName) {\n\t    var parentTagName;\n\t    while (true) {\n\t      if (!state.context) {\n\t        return;\n\t      }\n\t      parentTagName = state.context.tagName;\n\t      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n\t          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t        return;\n\t      }\n\t      popContext(state);\n\t    }\n\t  }\n\t\n\t  function baseState(type, stream, state) {\n\t    if (type == \"openTag\") {\n\t      state.tagStart = stream.column();\n\t      return tagNameState;\n\t    } else if (type == \"closeTag\") {\n\t      return closeTagNameState;\n\t    } else {\n\t      return baseState;\n\t    }\n\t  }\n\t  function tagNameState(type, stream, state) {\n\t    if (type == \"word\") {\n\t      state.tagName = stream.current();\n\t      setStyle = \"tag\";\n\t      return attrState;\n\t    } else {\n\t      setStyle = \"error\";\n\t      return tagNameState;\n\t    }\n\t  }\n\t  function closeTagNameState(type, stream, state) {\n\t    if (type == \"word\") {\n\t      var tagName = stream.current();\n\t      if (state.context && state.context.tagName != tagName &&\n\t          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n\t        popContext(state);\n\t      if (state.context && state.context.tagName == tagName) {\n\t        setStyle = \"tag\";\n\t        return closeState;\n\t      } else {\n\t        setStyle = \"tag error\";\n\t        return closeStateErr;\n\t      }\n\t    } else {\n\t      setStyle = \"error\";\n\t      return closeStateErr;\n\t    }\n\t  }\n\t\n\t  function closeState(type, _stream, state) {\n\t    if (type != \"endTag\") {\n\t      setStyle = \"error\";\n\t      return closeState;\n\t    }\n\t    popContext(state);\n\t    return baseState;\n\t  }\n\t  function closeStateErr(type, stream, state) {\n\t    setStyle = \"error\";\n\t    return closeState(type, stream, state);\n\t  }\n\t\n\t  function attrState(type, _stream, state) {\n\t    if (type == \"word\") {\n\t      setStyle = \"attribute\";\n\t      return attrEqState;\n\t    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n\t      var tagName = state.tagName, tagStart = state.tagStart;\n\t      state.tagName = state.tagStart = null;\n\t      if (type == \"selfcloseTag\" ||\n\t          config.autoSelfClosers.hasOwnProperty(tagName)) {\n\t        maybePopContext(state, tagName);\n\t      } else {\n\t        maybePopContext(state, tagName);\n\t        state.context = new Context(state, tagName, tagStart == state.indented);\n\t      }\n\t      return baseState;\n\t    }\n\t    setStyle = \"error\";\n\t    return attrState;\n\t  }\n\t  function attrEqState(type, stream, state) {\n\t    if (type == \"equals\") return attrValueState;\n\t    if (!config.allowMissing) setStyle = \"error\";\n\t    return attrState(type, stream, state);\n\t  }\n\t  function attrValueState(type, stream, state) {\n\t    if (type == \"string\") return attrContinuedState;\n\t    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n\t    setStyle = \"error\";\n\t    return attrState(type, stream, state);\n\t  }\n\t  function attrContinuedState(type, stream, state) {\n\t    if (type == \"string\") return attrContinuedState;\n\t    return attrState(type, stream, state);\n\t  }\n\t\n\t  return {\n\t    startState: function(baseIndent) {\n\t      var state = {tokenize: inText,\n\t                   state: baseState,\n\t                   indented: baseIndent || 0,\n\t                   tagName: null, tagStart: null,\n\t                   context: null}\n\t      if (baseIndent != null) state.baseIndent = baseIndent\n\t      return state\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (!state.tagName && stream.sol())\n\t        state.indented = stream.indentation();\n\t\n\t      if (stream.eatSpace()) return null;\n\t      type = null;\n\t      var style = state.tokenize(stream, state);\n\t      if ((style || type) && style != \"comment\") {\n\t        setStyle = null;\n\t        state.state = state.state(type || style, stream, state);\n\t        if (setStyle)\n\t          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n\t      }\n\t      return style;\n\t    },\n\t\n\t    indent: function(state, textAfter, fullLine) {\n\t      var context = state.context;\n\t      // Indent multi-line strings (e.g. css).\n\t      if (state.tokenize.isInAttribute) {\n\t        if (state.tagStart == state.indented)\n\t          return state.stringStartCol + 1;\n\t        else\n\t          return state.indented + indentUnit;\n\t      }\n\t      if (context && context.noIndent) return CodeMirror.Pass;\n\t      if (state.tokenize != inTag && state.tokenize != inText)\n\t        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n\t      // Indent the starts of attribute names.\n\t      if (state.tagName) {\n\t        if (config.multilineTagIndentPastTag !== false)\n\t          return state.tagStart + state.tagName.length + 2;\n\t        else\n\t          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n\t      }\n\t      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n\t      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n\t      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n\t        while (context) {\n\t          if (context.tagName == tagAfter[2]) {\n\t            context = context.prev;\n\t            break;\n\t          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n\t            context = context.prev;\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t      } else if (tagAfter) { // Opening tag spotted\n\t        while (context) {\n\t          var grabbers = config.contextGrabbers[context.tagName];\n\t          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n\t            context = context.prev;\n\t          else\n\t            break;\n\t        }\n\t      }\n\t      while (context && context.prev && !context.startOfLine)\n\t        context = context.prev;\n\t      if (context) return context.indent + indentUnit;\n\t      else return state.baseIndent || 0;\n\t    },\n\t\n\t    electricInput: /<\\/[\\s\\w:]+>$/,\n\t    blockCommentStart: \"<!--\",\n\t    blockCommentEnd: \"-->\",\n\t\n\t    configuration: config.htmlMode ? \"html\" : \"xml\",\n\t    helperType: config.htmlMode ? \"html\" : \"xml\",\n\t\n\t    skipAttribute: function(state) {\n\t      if (state.state == attrValueState)\n\t        state.state = attrState\n\t    }\n\t  };\n\t});\n\t\n\tCodeMirror.defineMIME(\"text/xml\", \"xml\");\n\tCodeMirror.defineMIME(\"application/xml\", \"xml\");\n\tif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n\t  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\t\n\t});\n\n\n/***/ },\n/* 364 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  CodeMirror.modeInfo = [\n\t    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\n\t    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"pgp\"]},\n\t    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\n\t    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\n\t    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\n\t    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\"]},\n\t    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\n\t    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\n\t    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\n\t    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\"]},\n\t    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\n\t    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\n\t    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\n\t    {name: \"CoffeeScript\", mime: \"text/x-coffeescript\", mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\n\t    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\n\t    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\n\t    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\n\t    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\n\t    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\n\t    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\n\t    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\n\t    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\n\t    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\n\t    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\n\t    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\n\t    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\n\t    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\n\t    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\n\t    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\n\t    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\n\t    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\n\t    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\n\t    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\n\t    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\n\t    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\n\t    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\n\t    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\"]},\n\t    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\n\t    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\n\t    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\n\t    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\n\t    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\n\t    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\"]},\n\t    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\n\t    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\n\t    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\n\t    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\n\t    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\n\t    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\n\t    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\"], alias: [\"xhtml\"]},\n\t    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\n\t    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\n\t    {name: \"Jade\", mime: \"text/x-jade\", mode: \"jade\", ext: [\"jade\"]},\n\t    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\n\t    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\n\t    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\n\t     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\n\t    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\n\t    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\n\t    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\n\t    {name: \"Jinja2\", mime: \"null\", mode: \"jinja2\"},\n\t    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\n\t    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\n\t    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\n\t    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\n\t    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\n\t    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\n\t    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\n\t    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\n\t    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\n\t    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\n\t    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\"},\n\t    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\n\t    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\n\t    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\n\t    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\n\t    {name: \"NTriples\", mime: \"text/n-triples\", mode: \"ntriples\", ext: [\"nt\"]},\n\t    {name: \"Objective C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"]},\n\t    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\n\t    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\n\t    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\n\t    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\n\t    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\n\t    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\n\t    {name: \"PHP\", mime: \"application/x-httpd-php\", mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"phtml\"]},\n\t    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\n\t    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\n\t    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\n\t    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\n\t    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"py\", \"pyw\"]},\n\t    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\n\t    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\n\t    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\"], alias: [\"rscript\"]},\n\t    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\n\t    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\n\t    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\n\t    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\n\t    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\n\t    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\n\t    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\n\t    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\n\t    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\n\t    {name: \"Shell\", mime: \"text/x-sh\", mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\n\t    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\n\t    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\n\t    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\n\t    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\n\t    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\n\t    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\n\t    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\n\t    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\n\t    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\n\t    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\n\t    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\n\t    {name: \"MariaDB\", mime: \"text/x-mariadb\", mode: \"sql\"},\n\t    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\n\t    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\"], alias: [\"tex\"]},\n\t    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\"]},\n\t    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\n\t    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\n\t    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\n\t    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\n\t    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\n\t    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\n\t    {name: \"troff\", mime: \"troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\n\t    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\n\t    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\n\t    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\n\t    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\n\t    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\n\t    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\n\t    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\n\t    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\n\t    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\n\t    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\n\t    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\n\t    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\n\t    {name: \"YAML\", mime: \"text/x-yaml\", mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\n\t    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\n\t    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\n\t    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\n\t    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\n\t  ];\n\t  // Ensure all modes have a mime property for backwards compatibility\n\t  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t    var info = CodeMirror.modeInfo[i];\n\t    if (info.mimes) info.mime = info.mimes[0];\n\t  }\n\t\n\t  CodeMirror.findModeByMIME = function(mime) {\n\t    mime = mime.toLowerCase();\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.mime == mime) return info;\n\t      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\n\t        if (info.mimes[j] == mime) return info;\n\t    }\n\t  };\n\t\n\t  CodeMirror.findModeByExtension = function(ext) {\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.ext) for (var j = 0; j < info.ext.length; j++)\n\t        if (info.ext[j] == ext) return info;\n\t    }\n\t  };\n\t\n\t  CodeMirror.findModeByFileName = function(filename) {\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.file && info.file.test(filename)) return info;\n\t    }\n\t    var dot = filename.lastIndexOf(\".\");\n\t    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n\t    if (ext) return CodeMirror.findModeByExtension(ext);\n\t  };\n\t\n\t  CodeMirror.findModeByName = function(name) {\n\t    name = name.toLowerCase();\n\t    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n\t      var info = CodeMirror.modeInfo[i];\n\t      if (info.name.toLowerCase() == name) return info;\n\t      if (info.alias) for (var j = 0; j < info.alias.length; j++)\n\t        if (info.alias[j].toLowerCase() == name) return info;\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 365 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// Utility function that allows modes to be combined. The mode given\n\t// as the base argument takes care of most of the normal mode\n\t// functionality, but a second (typically simple) mode is used, which\n\t// can override the style of text. Both modes get to parse all of the\n\t// text, but when both assign a non-null style to a piece of code, the\n\t// overlay wins, unless the combine argument was true and not overridden,\n\t// or state.overlay.combineTokens was true, in which case the styles are\n\t// combined.\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(360));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.overlayMode = function(base, overlay, combine) {\n\t  return {\n\t    startState: function() {\n\t      return {\n\t        base: CodeMirror.startState(base),\n\t        overlay: CodeMirror.startState(overlay),\n\t        basePos: 0, baseCur: null,\n\t        overlayPos: 0, overlayCur: null,\n\t        streamSeen: null\n\t      };\n\t    },\n\t    copyState: function(state) {\n\t      return {\n\t        base: CodeMirror.copyState(base, state.base),\n\t        overlay: CodeMirror.copyState(overlay, state.overlay),\n\t        basePos: state.basePos, baseCur: null,\n\t        overlayPos: state.overlayPos, overlayCur: null\n\t      };\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (stream != state.streamSeen ||\n\t          Math.min(state.basePos, state.overlayPos) < stream.start) {\n\t        state.streamSeen = stream;\n\t        state.basePos = state.overlayPos = stream.start;\n\t      }\n\t\n\t      if (stream.start == state.basePos) {\n\t        state.baseCur = base.token(stream, state.base);\n\t        state.basePos = stream.pos;\n\t      }\n\t      if (stream.start == state.overlayPos) {\n\t        stream.pos = stream.start;\n\t        state.overlayCur = overlay.token(stream, state.overlay);\n\t        state.overlayPos = stream.pos;\n\t      }\n\t      stream.pos = Math.min(state.basePos, state.overlayPos);\n\t\n\t      // state.overlay.combineTokens always takes precedence over combine,\n\t      // unless set to null\n\t      if (state.overlayCur == null) return state.baseCur;\n\t      else if (state.baseCur != null &&\n\t               state.overlay.combineTokens ||\n\t               combine && state.overlay.combineTokens == null)\n\t        return state.baseCur + \" \" + state.overlayCur;\n\t      else return state.overlayCur;\n\t    },\n\t\n\t    indent: base.indent && function(state, textAfter) {\n\t      return base.indent(state.base, textAfter);\n\t    },\n\t    electricChars: base.electricChars,\n\t\n\t    innerMode: function(state) { return {state: state.base, mode: base}; },\n\t\n\t    blankLine: function(state) {\n\t      if (base.blankLine) base.blankLine(state.base);\n\t      if (overlay.blankLine) overlay.blankLine(state.overlay);\n\t    }\n\t  };\n\t};\n\t\n\t});\n\n\n/***/ },\n/* 366 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jade = __webpack_require__(158);\n\t\n\tmodule.exports = function template(locals) {\n\tvar buf = [];\n\tvar jade_mixins = {};\n\tvar jade_interp;\n\t;var locals_for_with = (locals || {});(function (bem, buttons, navigator, t) {\n\tbuf.push(\"\");\n\tvar bem_chain = [];\n\tjade_mixins[\"b\"] = jade_interp = function(tag, isElement, noBlockClass){\n\tvar block = (this && this.block), attributes = (this && this.attributes) || {};\n\tbem.call(this, buf, bem_chain, tag, isElement, noBlockClass)\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tjade_mixins[\"e\"] = jade_interp = function(tag){\n\tvar block = (this && this.block), attributes = (this && this.attributes) || {};\n\tjade_mixins[\"b\"].call({\n\tblock: function(){\n\tblock && block();\n\t},\n\tattributes: jade.merge([attributes])\n\t}, tag, true);\n\t};\n\tjade_mixins[\"b\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\t// iterate buttons\n\t;(function(){\n\t  var $$obj = buttons;\n\t  if ('number' == typeof $$obj.length) {\n\t\n\t    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n\t      var button = $$obj[$index];\n\t\n\tif ( button == '|')\n\t{\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"class\": \"button-separator\"}\n\t});\n\t}\n\telse\n\t{\n\tvar tooltip = t('mdeditor.buttons.'+ button);\n\tif (navigator.userAgent.indexOf('Mac OS X') != -1) tooltip = tooltip.replace('Ctrl', 'Cmd')\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"data-action\": (typeof (jade_interp = button) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"data-tooltip\": (typeof (jade_interp = tooltip) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"class\": \"button\"}\n\t}, 'button');\n\t}\n\t    }\n\t\n\t  } else {\n\t    var $$l = 0;\n\t    for (var $index in $$obj) {\n\t      $$l++;      var button = $$obj[$index];\n\t\n\tif ( button == '|')\n\t{\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"class\": \"button-separator\"}\n\t});\n\t}\n\telse\n\t{\n\tvar tooltip = t('mdeditor.buttons.'+ button);\n\tif (navigator.userAgent.indexOf('Mac OS X') != -1) tooltip = tooltip.replace('Ctrl', 'Cmd')\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"data-action\": (typeof (jade_interp = button) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"data-tooltip\": (typeof (jade_interp = tooltip) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"class\": \"button\"}\n\t}, 'button');\n\t}\n\t    }\n\t\n\t  }\n\t}).call(this);\n\t\n\t},\n\tattributes: {\"class\": \"button-bar\"}\n\t});\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"class\": \"input\"}\n\t}, 'textarea');\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"data-mdeditor-resize\": true,\"class\": \"resize-handle\"}\n\t});\n\t},\n\tattributes: {\"class\": \"footer\"}\n\t});\n\t},\n\tattributes: {\"class\": \"editor\"}\n\t});\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tjade_mixins[\"e\"].call({\n\tblock: function(){\n\tbuf.push(\"\");\n\t}\n\t}, 'h2');\n\t},\n\tattributes: {\"class\": \"title-preview\"}\n\t});\n\tjade_mixins[\"e\"].call({\n\tattributes: {\"data-editor-preview\": true,\"class\": \"preview\"}\n\t});\n\t},\n\tattributes: {\"class\": \"mdeditor\"}\n\t});}.call(this,\"bem\" in locals_for_with?locals_for_with.bem:typeof bem!==\"undefined\"?bem:undefined,\"buttons\" in locals_for_with?locals_for_with.buttons:typeof buttons!==\"undefined\"?buttons:undefined,\"navigator\" in locals_for_with?locals_for_with.navigator:typeof navigator!==\"undefined\"?navigator:undefined,\"t\" in locals_for_with?locals_for_with.t:typeof t!==\"undefined\"?t:undefined));;return buf.join(\"\");\n\t}\n\n/***/ },\n/* 367 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./en.yml\": 368,\n\t\t\"./ru.yml\": 369\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 367;\n\n\n/***/ },\n/* 368 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"text\": {\n\t\t\t\"bold\": \"bold text\",\n\t\t\t\"italic\": \"italic text\",\n\t\t\t\"code\": \"code\",\n\t\t\t\"heading\": \"Heading\",\n\t\t\t\"fencedCode\": \"enter multiline code here\",\n\t\t\t\"ol\": \"List item\",\n\t\t\t\"ul\": \"List item\",\n\t\t\t\"alt\": \"Image desciption\",\n\t\t\t\"link\": \"link text\"\n\t\t},\n\t\t\"buttons\": {\n\t\t\t\"bold\": \"bold [Ctrl-B]\",\n\t\t\t\"italic\": \"italic [Ctrl-I]\",\n\t\t\t\"code\": \"inline code\",\n\t\t\t\"undo\": \"undo [Ctrl-Z]\",\n\t\t\t\"redo\": \"redo [Ctrl-Y]\",\n\t\t\t\"fencedCode\": \"multiline code\",\n\t\t\t\"link\": \"insert link\",\n\t\t\t\"ul\": \"itemized list\",\n\t\t\t\"ol\": \"ordered list\",\n\t\t\t\"heading\": \"heading\",\n\t\t\t\"image\": \"insert image\"\n\t\t}\n\t};\n\n/***/ },\n/* 369 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"text\": {\n\t\t\t\"bold\": \" \",\n\t\t\t\"italic\": \" \",\n\t\t\t\"code\": \"code\",\n\t\t\t\"heading\": \"\",\n\t\t\t\"fencedCode\": \"enter multiline code here\",\n\t\t\t\"link\": \" \",\n\t\t\t\"ol\": \" \",\n\t\t\t\"ul\": \" \",\n\t\t\t\"alt\": \" \"\n\t\t},\n\t\t\"buttons\": {\n\t\t\t\"bold\": \"  [Ctrl-B]\",\n\t\t\t\"italic\": \"  [Ctrl-I]\",\n\t\t\t\"code\": \" \",\n\t\t\t\"undo\": \" [Ctrl-Z]\",\n\t\t\t\"redo\": \"  [Ctrl-Y]\",\n\t\t\t\"fencedCode\": \"  \",\n\t\t\t\"link\": \"\",\n\t\t\t\"ul\": \"\",\n\t\t\t\"ol\": \" \",\n\t\t\t\"heading\": \"\",\n\t\t\t\"image\": \" \"\n\t\t}\n\t};\n\n/***/ },\n/* 370 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar debounce = __webpack_require__(371),\n\t    isObject = __webpack_require__(372);\n\t\n\t/** Used as the `TypeError` message for \"Functions\" methods. */\n\tvar FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t/**\n\t * Creates a throttled function that only invokes `func` at most once per\n\t * every `wait` milliseconds. The throttled function comes with a `cancel`\n\t * method to cancel delayed `func` invocations and a `flush` method to\n\t * immediately invoke them. Provide an options object to indicate whether\n\t * `func` should be invoked on the leading and/or trailing edge of the `wait`\n\t * timeout. The `func` is invoked with the last arguments provided to the\n\t * throttled function. Subsequent calls to the throttled function return the\n\t * result of the last `func` invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t * on the trailing edge of the timeout only if the throttled function is\n\t * invoked more than once during the `wait` timeout.\n\t *\n\t * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t * for details over the differences between `_.throttle` and `_.debounce`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Function\n\t * @param {Function} func The function to throttle.\n\t * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n\t * @param {Object} [options] The options object.\n\t * @param {boolean} [options.leading=true] Specify invoking on the leading\n\t *  edge of the timeout.\n\t * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t *  edge of the timeout.\n\t * @returns {Function} Returns the new throttled function.\n\t * @example\n\t *\n\t * // Avoid excessively updating the position while scrolling.\n\t * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n\t *\n\t * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n\t * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n\t * jQuery(element).on('click', throttled);\n\t *\n\t * // Cancel the trailing throttled invocation.\n\t * jQuery(window).on('popstate', throttled.cancel);\n\t */\n\tfunction throttle(func, wait, options) {\n\t  var leading = true,\n\t      trailing = true;\n\t\n\t  if (typeof func != 'function') {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  if (isObject(options)) {\n\t    leading = 'leading' in options ? !!options.leading : leading;\n\t    trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t  }\n\t  return debounce(func, wait, {\n\t    'leading': leading,\n\t    'maxWait': wait,\n\t    'trailing': trailing\n\t  });\n\t}\n\t\n\tmodule.exports = throttle;\n\n/***/ },\n/* 371 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isObject = __webpack_require__(372),\n\t    now = __webpack_require__(373),\n\t    toNumber = __webpack_require__(374);\n\t\n\t/** Used as the `TypeError` message for \"Functions\" methods. */\n\tvar FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeMax = Math.max;\n\t\n\t/**\n\t * Creates a debounced function that delays invoking `func` until after `wait`\n\t * milliseconds have elapsed since the last time the debounced function was\n\t * invoked. The debounced function comes with a `cancel` method to cancel\n\t * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t * Provide an options object to indicate whether `func` should be invoked on\n\t * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t * with the last arguments provided to the debounced function. Subsequent calls\n\t * to the debounced function return the result of the last `func` invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t * on the trailing edge of the timeout only if the debounced function is\n\t * invoked more than once during the `wait` timeout.\n\t *\n\t * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t * for details over the differences between `_.debounce` and `_.throttle`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Function\n\t * @param {Function} func The function to debounce.\n\t * @param {number} [wait=0] The number of milliseconds to delay.\n\t * @param {Object} [options] The options object.\n\t * @param {boolean} [options.leading=false] Specify invoking on the leading\n\t *  edge of the timeout.\n\t * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n\t *  delayed before it's invoked.\n\t * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t *  edge of the timeout.\n\t * @returns {Function} Returns the new debounced function.\n\t * @example\n\t *\n\t * // Avoid costly calculations while the window size is in flux.\n\t * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t *\n\t * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t *   'leading': true,\n\t *   'trailing': false\n\t * }));\n\t *\n\t * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t * var source = new EventSource('/stream');\n\t * jQuery(source).on('message', debounced);\n\t *\n\t * // Cancel the trailing debounced invocation.\n\t * jQuery(window).on('popstate', debounced.cancel);\n\t */\n\tfunction debounce(func, wait, options) {\n\t  var args,\n\t      maxTimeoutId,\n\t      result,\n\t      stamp,\n\t      thisArg,\n\t      timeoutId,\n\t      trailingCall,\n\t      lastCalled = 0,\n\t      leading = false,\n\t      maxWait = false,\n\t      trailing = true;\n\t\n\t  if (typeof func != 'function') {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  wait = toNumber(wait) || 0;\n\t  if (isObject(options)) {\n\t    leading = !!options.leading;\n\t    maxWait = 'maxWait' in options && nativeMax(toNumber(options.maxWait) || 0, wait);\n\t    trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t  }\n\t\n\t  function cancel() {\n\t    if (timeoutId) {\n\t      clearTimeout(timeoutId);\n\t    }\n\t    if (maxTimeoutId) {\n\t      clearTimeout(maxTimeoutId);\n\t    }\n\t    lastCalled = 0;\n\t    args = maxTimeoutId = thisArg = timeoutId = trailingCall = undefined;\n\t  }\n\t\n\t  function complete(isCalled, id) {\n\t    if (id) {\n\t      clearTimeout(id);\n\t    }\n\t    maxTimeoutId = timeoutId = trailingCall = undefined;\n\t    if (isCalled) {\n\t      lastCalled = now();\n\t      result = func.apply(thisArg, args);\n\t      if (!timeoutId && !maxTimeoutId) {\n\t        args = thisArg = undefined;\n\t      }\n\t    }\n\t  }\n\t\n\t  function delayed() {\n\t    var remaining = wait - (now() - stamp);\n\t    if (remaining <= 0 || remaining > wait) {\n\t      complete(trailingCall, maxTimeoutId);\n\t    } else {\n\t      timeoutId = setTimeout(delayed, remaining);\n\t    }\n\t  }\n\t\n\t  function flush() {\n\t    if (timeoutId && trailingCall || maxTimeoutId && trailing) {\n\t      result = func.apply(thisArg, args);\n\t    }\n\t    cancel();\n\t    return result;\n\t  }\n\t\n\t  function maxDelayed() {\n\t    complete(trailing, timeoutId);\n\t  }\n\t\n\t  function debounced() {\n\t    args = arguments;\n\t    stamp = now();\n\t    thisArg = this;\n\t    trailingCall = trailing && (timeoutId || !leading);\n\t\n\t    if (maxWait === false) {\n\t      var leadingCall = leading && !timeoutId;\n\t    } else {\n\t      if (!lastCalled && !maxTimeoutId && !leading) {\n\t        lastCalled = stamp;\n\t      }\n\t      var remaining = maxWait - (stamp - lastCalled);\n\t\n\t      var isCalled = (remaining <= 0 || remaining > maxWait) && (leading || maxTimeoutId);\n\t\n\t      if (isCalled) {\n\t        if (maxTimeoutId) {\n\t          maxTimeoutId = clearTimeout(maxTimeoutId);\n\t        }\n\t        lastCalled = stamp;\n\t        result = func.apply(thisArg, args);\n\t      } else if (!maxTimeoutId) {\n\t        maxTimeoutId = setTimeout(maxDelayed, remaining);\n\t      }\n\t    }\n\t    if (isCalled && timeoutId) {\n\t      timeoutId = clearTimeout(timeoutId);\n\t    } else if (!timeoutId && wait !== maxWait) {\n\t      timeoutId = setTimeout(delayed, wait);\n\t    }\n\t    if (leadingCall) {\n\t      isCalled = true;\n\t      result = func.apply(thisArg, args);\n\t    }\n\t    if (isCalled && !timeoutId && !maxTimeoutId) {\n\t      args = thisArg = undefined;\n\t    }\n\t    return result;\n\t  }\n\t  debounced.cancel = cancel;\n\t  debounced.flush = flush;\n\t  return debounced;\n\t}\n\t\n\tmodule.exports = debounce;\n\n/***/ },\n/* 372 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\t'use strict';\n\t\n\tfunction isObject(value) {\n\t  var type = typeof value;\n\t  return !!value && (type == 'object' || type == 'function');\n\t}\n\t\n\tmodule.exports = isObject;\n\n/***/ },\n/* 373 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Gets the timestamp of the number of milliseconds that have elapsed since\n\t * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @type {Function}\n\t * @category Date\n\t * @returns {number} Returns the timestamp.\n\t * @example\n\t *\n\t * _.defer(function(stamp) {\n\t *   console.log(_.now() - stamp);\n\t * }, _.now());\n\t * // => logs the number of milliseconds it took for the deferred function to be invoked\n\t */\n\t\"use strict\";\n\t\n\tvar now = Date.now;\n\t\n\tmodule.exports = now;\n\n/***/ },\n/* 374 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isFunction = __webpack_require__(375),\n\t    isObject = __webpack_require__(372);\n\t\n\t/** Used as references for various `Number` constants. */\n\tvar NAN = 0 / 0;\n\t\n\t/** Used to match leading and trailing whitespace. */\n\tvar reTrim = /^\\s+|\\s+$/g;\n\t\n\t/** Used to detect bad signed hexadecimal string values. */\n\tvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\t\n\t/** Used to detect binary string values. */\n\tvar reIsBinary = /^0b[01]+$/i;\n\t\n\t/** Used to detect octal string values. */\n\tvar reIsOctal = /^0o[0-7]+$/i;\n\t\n\t/** Built-in method references without a dependency on `root`. */\n\tvar freeParseInt = parseInt;\n\t\n\t/**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3);\n\t * // => 3\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3');\n\t * // => 3\n\t */\n\tfunction toNumber(value) {\n\t  if (isObject(value)) {\n\t    var other = isFunction(value.valueOf) ? value.valueOf() : value;\n\t    value = isObject(other) ? other + '' : other;\n\t  }\n\t  if (typeof value != 'string') {\n\t    return value === 0 ? value : +value;\n\t  }\n\t  value = value.replace(reTrim, '');\n\t  var isBinary = reIsBinary.test(value);\n\t  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n\t}\n\t\n\tmodule.exports = toNumber;\n\n/***/ },\n/* 375 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isObject = __webpack_require__(372);\n\t\n\t/** `Object#toString` result references. */\n\tvar funcTag = '[object Function]',\n\t    genTag = '[object GeneratorFunction]';\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString = objectProto.toString;\n\t\n\t/**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */\n\tfunction isFunction(value) {\n\t  // The use of `Object#toString` avoids issues with the `typeof` operator\n\t  // in Safari 8 which returns 'object' for typed array constructors, and\n\t  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n\t  var tag = isObject(value) ? objectToString.call(value) : '';\n\t  return tag == funcTag || tag == genTag;\n\t}\n\t\n\tmodule.exports = isFunction;\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** mdeditor.ea05a139cece7c8d9554.js\n **/","'use strict';\n\nrequire('./styles');\nconst MdEditor = require('./mdeditor');\n\n\nfunction init() {\n  let editorElems = document.querySelectorAll('.mdeditor');\n\n  for (var i = 0; i < editorElems.length; i++) {\n    var editorElem = editorElems[i];\n    new MdEditor({\n      elem: editorElem\n    });\n  }\n}\n\n// must be on document ready\ninit();\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/mdeditor/client/index.js\n **/","var _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t? self // if in worker\n\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function(){\n\n// Private helper vars\nvar lang = /\\blang(?:uage)?-(\\w+)\\b/i;\nvar uniqueId = 0;\n\nvar _ = _self.Prism = {\n\tutil: {\n\t\tencode: function (tokens) {\n\t\t\tif (tokens instanceof Token) {\n\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t} else {\n\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t}\n\t\t},\n\n\t\ttype: function (o) {\n\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t},\n\n\t\tobjId: function (obj) {\n\t\t\tif (!obj['__id']) {\n\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t}\n\t\t\treturn obj['__id'];\n\t\t},\n\n\t\t// Deep clone a language definition (e.g. to extend it)\n\t\tclone: function (o) {\n\t\t\tvar type = _.util.type(o);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Object':\n\t\t\t\t\tvar clone = {};\n\n\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn clone;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\t// Check for existence for IE8\n\t\t\t\t\treturn o.map && o.map(function(v) { return _.util.clone(v); });\n\t\t\t}\n\n\t\t\treturn o;\n\t\t}\n\t},\n\n\tlanguages: {\n\t\textend: function (id, redef) {\n\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\tfor (var key in redef) {\n\t\t\t\tlang[key] = redef[key];\n\t\t\t}\n\n\t\t\treturn lang;\n\t\t},\n\n\t\t/**\n\t\t * Insert a token before another token in a language literal\n\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n\t\t * we cannot just provide an object, we need anobject and a key.\n\t\t * @param inside The key (or language id) of the parent\n\t\t * @param before The key to insert before. If not provided, the function appends instead.\n\t\t * @param insert Object with the key/value pairs to insert\n\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n\t\t */\n\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\troot = root || _.languages;\n\t\t\tvar grammar = root[inside];\n\t\t\t\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tinsert = arguments[1];\n\t\t\t\t\n\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn grammar;\n\t\t\t}\n\t\t\t\n\t\t\tvar ret = {};\n\n\t\t\tfor (var token in grammar) {\n\n\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\tif (token == before) {\n\n\t\t\t\t\t\tfor (var newToken in insert) {\n\n\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Update references in other language definitions\n\t\t\t_.languages.DFS(_.languages, function(key, value) {\n\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\tthis[key] = ret;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn root[inside] = ret;\n\t\t},\n\n\t\t// Traverse a language definition with Depth First Search\n\t\tDFS: function(o, callback, type, visited) {\n\t\t\tvisited = visited || {};\n\t\t\tfor (var i in o) {\n\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tplugins: {},\n\t\n\thighlightAll: function(async, callback) {\n\t\tvar elements = document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code');\n\n\t\tfor (var i=0, element; element = elements[i++];) {\n\t\t\t_.highlightElement(element, async === true, callback);\n\t\t}\n\t},\n\n\thighlightElement: function(element, async, callback) {\n\t\t// Find language\n\t\tvar language, grammar, parent = element;\n\n\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\tif (parent) {\n\t\t\tlanguage = (parent.className.match(lang) || [,''])[1];\n\t\t\tgrammar = _.languages[language];\n\t\t}\n\n\t\t// Set language on the element, if not present\n\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n\t\t// Set language on the parent, for styling\n\t\tparent = element.parentNode;\n\n\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t}\n\n\t\tvar code = element.textContent;\n\n\t\tvar env = {\n\t\t\telement: element,\n\t\t\tlanguage: language,\n\t\t\tgrammar: grammar,\n\t\t\tcode: code\n\t\t};\n\n\t\tif (!code || !grammar) {\n\t\t\t_.hooks.run('complete', env);\n\t\t\treturn;\n\t\t}\n\n\t\t_.hooks.run('before-highlight', env);\n\n\t\tif (async && _self.Worker) {\n\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\tworker.onmessage = function(evt) {\n\t\t\t\tenv.highlightedCode = evt.data;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t};\n\n\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\tlanguage: env.language,\n\t\t\t\tcode: env.code,\n\t\t\t\timmediateClose: true\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\tcallback && callback.call(element);\n\n\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t_.hooks.run('complete', env);\n\t\t}\n\t},\n\n\thighlight: function (text, grammar, language) {\n\t\tvar tokens = _.tokenize(text, grammar);\n\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t},\n\n\ttokenize: function(text, grammar, language) {\n\t\tvar Token = _.Token;\n\n\t\tvar strarr = [text];\n\n\t\tvar rest = grammar.rest;\n\n\t\tif (rest) {\n\t\t\tfor (var token in rest) {\n\t\t\t\tgrammar[token] = rest[token];\n\t\t\t}\n\n\t\t\tdelete grammar.rest;\n\t\t}\n\n\t\ttokenloop: for (var token in grammar) {\n\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\tinside = pattern.inside,\n\t\t\t\t\tlookbehind = !!pattern.lookbehind,\n\t\t\t\t\tlookbehindLength = 0,\n\t\t\t\t\talias = pattern.alias;\n\n\t\t\t\tpattern = pattern.pattern || pattern;\n\n\t\t\t\tfor (var i=0; i<strarr.length; i++) { // Dont cache length as it changes during the loop\n\n\t\t\t\t\tvar str = strarr[i];\n\n\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpattern.lastIndex = 0;\n\n\t\t\t\t\tvar match = pattern.exec(str);\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tif(lookbehind) {\n\t\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index - 1 + lookbehindLength,\n\t\t\t\t\t\t\tmatch = match[0].slice(lookbehindLength),\n\t\t\t\t\t\t\tlen = match.length,\n\t\t\t\t\t\t\tto = from + len,\n\t\t\t\t\t\t\tbefore = str.slice(0, from + 1),\n\t\t\t\t\t\t\tafter = str.slice(to + 1);\n\n\t\t\t\t\t\tvar args = [i, 1];\n\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);\n\n\t\t\t\t\t\targs.push(wrapped);\n\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn strarr;\n\t},\n\n\thooks: {\n\t\tall: {},\n\n\t\tadd: function (name, callback) {\n\t\t\tvar hooks = _.hooks.all;\n\n\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\thooks[name].push(callback);\n\t\t},\n\n\t\trun: function (name, env) {\n\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\n\t\t\t\tcallback(env);\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar Token = _.Token = function(type, content, alias) {\n\tthis.type = type;\n\tthis.content = content;\n\tthis.alias = alias;\n};\n\nToken.stringify = function(o, language, parent) {\n\tif (typeof o == 'string') {\n\t\treturn o;\n\t}\n\n\tif (_.util.type(o) === 'Array') {\n\t\treturn o.map(function(element) {\n\t\t\treturn Token.stringify(element, language, o);\n\t\t}).join('');\n\t}\n\n\tvar env = {\n\t\ttype: o.type,\n\t\tcontent: Token.stringify(o.content, language, parent),\n\t\ttag: 'span',\n\t\tclasses: ['token', o.type],\n\t\tattributes: {},\n\t\tlanguage: language,\n\t\tparent: parent\n\t};\n\n\tif (env.type == 'comment') {\n\t\tenv.attributes['spellcheck'] = 'true';\n\t}\n\n\tif (o.alias) {\n\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\tArray.prototype.push.apply(env.classes, aliases);\n\t}\n\n\t_.hooks.run('wrap', env);\n\n\tvar attributes = '';\n\n\tfor (var name in env.attributes) {\n\t\tattributes += (attributes ? ' ' : '') + name + '=\"' + (env.attributes[name] || '') + '\"';\n\t}\n\n\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\n};\n\nif (!_self.document) {\n\tif (!_self.addEventListener) {\n\t\t// in Node.js\n\t\treturn _self.Prism;\n\t}\n \t// In worker\n\t_self.addEventListener('message', function(evt) {\n\t\tvar message = JSON.parse(evt.data),\n\t\t    lang = message.language,\n\t\t    code = message.code,\n\t\t    immediateClose = message.immediateClose;\n\n\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\tif (immediateClose) {\n\t\t\t_self.close();\n\t\t}\n\t}, false);\n\n\treturn _self.Prism;\n}\n\n//Get current script and highlight\nvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\n\nif (script) {\n\t_.filename = script.src;\n\n\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t}\n}\n\nreturn _self.Prism;\n\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-core.js\n ** module id = 87\n ** module chunks = 5 29\n **/","Prism.languages.markup = {\n\t'comment': /<!--[\\w\\W]*?-->/,\n\t'prolog': /<\\?[\\w\\W]+?\\?>/,\n\t'doctype': /<!DOCTYPE[\\w\\W]+?>/,\n\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=.$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\w\\W])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /[=>\"']/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': /&#?[\\da-z]{1,8};/i\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function(env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nPrism.languages.xml = Prism.languages.markup;\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-markup.js\n ** module id = 88\n ** module chunks = 5 29\n **/","Prism.languages.css = {\n\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t'atrule': {\n\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\tinside: {\n\t\t\t'rule': /@[\\w-]+/\n\t\t\t// See rest below\n\t\t}\n\t},\n\t'url': /url\\((?:([\"'])(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n\t'selector': /[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,\n\t'string': /(\"|')(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t'important': /\\B!important\\b/i,\n\t'function': /[-a-z0-9]+(?=\\()/i,\n\t'punctuation': /[(){};:]/\n};\n\nPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'style': {\n\t\t\tpattern: /(<style[\\w\\W]*?>)[\\w\\W]*?(?=<\\/style>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.css,\n\t\t\talias: 'language-css'\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t'style-attr': {\n\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\tinside: {\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t}, Prism.languages.markup.tag);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-css.js\n ** module id = 89\n ** module chunks = 5 29\n **/","Prism.languages.css.selector = {\n\tpattern: /[^\\{\\}\\s][^\\{\\}]*(?=\\s*\\{)/,\n\tinside: {\n\t\t'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n\t\t'pseudo-class': /:[-\\w]+(?:\\(.*\\))?/,\n\t\t'class': /\\.[-:\\.\\w]+/,\n\t\t'id': /#[-:\\.\\w]+/\n\t}\n};\n\nPrism.languages.insertBefore('css', 'function', {\n\t'hexcode': /#[\\da-f]{3,6}/i,\n\t'entity': /\\\\[\\da-f]{1,8}/i,\n\t'number': /[\\d%\\.]+/\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-css-extras.js\n ** module id = 90\n ** module chunks = 5 29\n **/","Prism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'string': /([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t'class-name': {\n\t\tpattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t}\n\t},\n\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t'boolean': /\\b(true|false)\\b/,\n\t'function': /[a-z0-9_]+(?=\\()/i,\n\t'number': /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\n\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-clike.js\n ** module id = 91\n ** module chunks = 5 29\n **/","Prism.languages.javascript = Prism.languages.extend('clike', {\n\t'keyword': /\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\\\\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'class-name', {\n\t'template-string': {\n\t\tpattern: /`(?:\\\\`|\\\\?[^`])*`/,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t}\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'script': {\n\t\t\tpattern: /(<script[\\w\\W]*?>)[\\w\\W]*?(?=<\\/script>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript,\n\t\t\talias: 'language-javascript'\n\t\t}\n\t});\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-javascript.js\n ** module id = 92\n ** module chunks = 5 29\n **/","(function(Prism) {\n\n// Ignore comments starting with { to privilege string interpolation highlighting\nvar comment = /#(?!\\{).+/,\n    interpolation = {\n    \tpattern: /#\\{[^}]+\\}/,\n    \talias: 'variable'\n    };\n\nPrism.languages.coffeescript = Prism.languages.extend('javascript', {\n\t'comment': comment,\n\t'string': [\n\n\t\t// Strings are multiline\n\t\t/'(?:\\\\?[^\\\\])*?'/,\n\n\t\t{\n\t\t\t// Strings are multiline\n\t\t\tpattern: /\"(?:\\\\?[^\\\\])*?\"/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t}\n\t],\n\t'keyword': /\\b(and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n\t'class-member': {\n\t\tpattern: /@(?!\\d)\\w+/,\n\t\talias: 'variable'\n\t}\n});\n\nPrism.languages.insertBefore('coffeescript', 'comment', {\n\t'multiline-comment': {\n\t\tpattern: /###[\\s\\S]+?###/,\n\t\talias: 'comment'\n\t},\n\n\t// Block regexp can contain comments and interpolation\n\t'block-regex': {\n\t\tpattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n\t\talias: 'regex',\n\t\tinside: {\n\t\t\t'comment': comment,\n\t\t\t'interpolation': interpolation\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('coffeescript', 'string', {\n\t'inline-javascript': {\n\t\tpattern: /`(?:\\\\?[\\s\\S])*?`/,\n\t\tinside: {\n\t\t\t'delimiter': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'punctuation'\n\t\t\t},\n\t\t\trest: Prism.languages.javascript\n\t\t}\n\t},\n\n\t// Block strings\n\t'multiline-string': [\n\t\t{\n\t\t\tpattern: /'''[\\s\\S]*?'''/,\n\t\t\talias: 'string'\n\t\t},\n\t\t{\n\t\t\tpattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\tinterpolation: interpolation\n\t\t\t}\n\t\t}\n\t]\n\n});\n\nPrism.languages.insertBefore('coffeescript', 'keyword', {\n\t// Object property\n\t'property': /(?!\\d)\\w+(?=\\s*:(?!:))/\n});\n\n}(Prism));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-coffeescript.js\n ** module id = 93\n ** module chunks = 5 29\n **/","Prism.languages.http = {\n\t'request-line': {\n\t\tpattern: /^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b\\shttps?:\\/\\/\\S+\\sHTTP\\/[0-9.]+/m,\n\t\tinside: {\n\t\t\t// HTTP Verb\n\t\t\tproperty: /^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b/,\n\t\t\t// Path or query argument\n\t\t\t'attr-name': /:\\w+/\n\t\t}\n\t},\n\t'response-status': {\n\t\tpattern: /^HTTP\\/1.[01] [0-9]+.*/m,\n\t\tinside: {\n\t\t\t// Status, e.g. 200 OK\n\t\t\tproperty: {\n                pattern: /(^HTTP\\/1.[01] )[0-9]+.*/i,\n                lookbehind: true\n            }\n\t\t}\n\t},\n\t// HTTP header name\n\t'header-name': {\n        pattern: /^[\\w-]+:(?=.)/m,\n        alias: 'keyword'\n    }\n};\n\n// Create a mapping of Content-Type headers to language definitions\nvar httpLanguages = {\n\t'application/json': Prism.languages.javascript,\n\t'application/xml': Prism.languages.markup,\n\t'text/xml': Prism.languages.markup,\n\t'text/html': Prism.languages.markup\n};\n\n// Insert each content type parser that has its associated language\n// currently loaded.\nfor (var contentType in httpLanguages) {\n\tif (httpLanguages[contentType]) {\n\t\tvar options = {};\n\t\toptions[contentType] = {\n\t\t\tpattern: new RegExp('(content-type:\\\\s*' + contentType + '[\\\\w\\\\W]*?)(?:\\\\r?\\\\n|\\\\r){2}[\\\\w\\\\W]*', 'i'),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\trest: httpLanguages[contentType]\n\t\t\t}\n\t\t};\n\t\tPrism.languages.insertBefore('http', 'header-name', options);\n\t}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-http.js\n ** module id = 94\n ** module chunks = 5 29\n **/","Prism.languages.scss = Prism.languages.extend('css', {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*)/,\n\t\tlookbehind: true\n\t},\n\t'atrule': {\n\t\tpattern: /@[\\w-]+(?:\\([^()]+\\)|[^(])*?(?=\\s+[{;])/,\n\t\tinside: {\n\t\t\t'rule': /@[\\w-]+/\n\t\t\t// See rest below\n\t\t}\n\t},\n\t// url, compassified\n\t'url': /(?:[-a-z]+-)*url(?=\\()/i,\n\t// CSS selector regex is not appropriate for Sass\n\t// since there can be lot more things (var, @ directive, nesting..)\n\t// a selector must start at the end of a property or after a brace (end of other rules or nesting)\n\t// it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n\t// the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n\t// can \"pass\" as a selector- e.g: proper#{$erty})\n\t// this one was hard to do, so please be careful if you edit this one :)\n\t'selector': {\n\t\t// Initial look-ahead is used to prevent matching of blank selectors\n\t\tpattern: /(?=\\S)[^@;\\{\\}\\(\\)]?([^@;\\{\\}\\(\\)]|&|#\\{\\$[-_\\w]+\\})+(?=\\s*\\{(\\}|\\s|[^\\}]+(:|\\{)[^\\}]+))/m,\n\t\tinside: {\n\t\t\t'placeholder': /%[-_\\w]+/\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('scss', 'atrule', {\n\t'keyword': [\n\t\t/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,\n\t\t{\n\t\t\tpattern: /( +)(?:from|through)(?= )/,\n\t\t\tlookbehind: true\n\t\t}\n\t]\n});\n\nPrism.languages.insertBefore('scss', 'property', {\n\t// var and interpolated vars\n\t'variable': /\\$[-_\\w]+|#\\{\\$[-_\\w]+\\}/\n});\n\nPrism.languages.insertBefore('scss', 'function', {\n\t'placeholder': {\n\t\tpattern: /%[-_\\w]+/,\n\t\talias: 'selector'\n\t},\n\t'statement': /\\B!(?:default|optional)\\b/i,\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'null': /\\bnull\\b/,\n\t'operator': {\n\t\tpattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|or|not)(?=\\s)/,\n\t\tlookbehind: true\n\t}\n});\n\nPrism.languages.scss['atrule'].inside.rest = Prism.util.clone(Prism.languages.scss);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-scss.js\n ** module id = 95\n ** module chunks = 5 29\n **/","Prism.languages.sql= { \n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\w\\W]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n\t\tlookbehind: true\n\t},\n\t'string' : {\n\t\tpattern: /(^|[^@\\\\])(\"|')(?:\\\\?[\\s\\S])*?\\2/,\n\t\tlookbehind: true\n\t},\n\t'variable': /@[\\w.$]+|@(\"|'|`)(?:\\\\?[\\s\\S])+?\\1/,\n\t'function': /\\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\\s*\\()/i, // Should we highlight user defined functions too?\n\t'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR VARYING|CHARACTER (?:SET|VARYING)|CHARSET|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|DATA(?:BASES?)?|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE(?: PRECISION)?|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE(?:D BY)?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEYS?|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL(?: CHAR VARYING| CHARACTER(?: VARYING)?| VARCHAR)?|NATURAL|NCHAR(?: VARCHAR)?|NEXT|NO(?: SQL|CHECK|CYCLE)?|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READ(?:S SQL DATA|TEXT)?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START(?:ING BY)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED BY|TEXT(?:SIZE)?|THEN|TIMESTAMP|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNPIVOT|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?)\\b/i,\n\t'boolean': /\\b(?:TRUE|FALSE|NULL)\\b/i,\n\t'number': /\\b-?(?:0x)?\\d*\\.?[\\da-f]+\\b/,\n\t'operator': /[-+*\\/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n\t'punctuation': /[;[\\]()`,.]/\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-sql.js\n ** module id = 96\n ** module chunks = 5 29\n **/","/**\n * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/\n * Modified by Miles Johnson: http://milesj.me\n *\n * Supports the following:\n * \t\t- Extends clike syntax\n * \t\t- Support for PHP 5.3+ (namespaces, traits, generators, etc)\n * \t\t- Smarter constant and function matching\n *\n * Adds the following new token classes:\n * \t\tconstant, delimiter, variable, function, package\n */\n\nPrism.languages.php = Prism.languages.extend('clike', {\n\t'keyword': /\\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\\b/i,\n\t'constant': /\\b[A-Z0-9_]{2,}\\b/,\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*)/,\n\t\tlookbehind: true\n\t}\n});\n\n// Shell-like comments are matched after strings, because they are less\n// common than strings containing hashes...\nPrism.languages.insertBefore('php', 'class-name', {\n\t'shell-comment': {\n\t\tpattern: /(^|[^\\\\])#.*/,\n\t\tlookbehind: true,\n\t\talias: 'comment'\n\t}\n});\n\nPrism.languages.insertBefore('php', 'keyword', {\n\t'delimiter': /\\?>|<\\?(?:php)?/i,\n\t'variable': /\\$\\w+\\b/i,\n\t'package': {\n\t\tpattern: /(\\\\|namespace\\s+|use\\s+)[\\w\\\\]+/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /\\\\/\n\t\t}\n\t}\n});\n\n// Must be defined after the function pattern\nPrism.languages.insertBefore('php', 'operator', {\n\t'property': {\n\t\tpattern: /(->)[\\w]+/,\n\t\tlookbehind: true\n\t}\n});\n\n// Add HTML support of the markup language exists\nif (Prism.languages.markup) {\n\n\t// Tokenize all inline PHP blocks that are wrapped in <?php ?>\n\t// This allows for easy PHP + markup highlighting\n\tPrism.hooks.add('before-highlight', function(env) {\n\t\tif (env.language !== 'php') {\n\t\t\treturn;\n\t\t}\n\n\t\tenv.tokenStack = [];\n\n\t\tenv.backupCode = env.code;\n\t\tenv.code = env.code.replace(/(?:<\\?php|<\\?)[\\w\\W]*?(?:\\?>)/ig, function(match) {\n\t\t\tenv.tokenStack.push(match);\n\n\t\t\treturn '{{{PHP' + env.tokenStack.length + '}}}';\n\t\t});\n\t});\n\n\t// Restore env.code for other plugins (e.g. line-numbers)\n\tPrism.hooks.add('before-insert', function(env) {\n\t\tif (env.language === 'php') {\n\t\t\tenv.code = env.backupCode;\n\t\t\tdelete env.backupCode;\n\t\t}\n\t});\n\n\t// Re-insert the tokens after highlighting\n\tPrism.hooks.add('after-highlight', function(env) {\n\t\tif (env.language !== 'php') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, t; t = env.tokenStack[i]; i++) {\n\t\t\t// The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns\n\t\t\tenv.highlightedCode = env.highlightedCode.replace('{{{PHP' + (i + 1) + '}}}', Prism.highlight(t, env.grammar, 'php').replace(/\\$/g, '$$$$'));\n\t\t}\n\n\t\tenv.element.innerHTML = env.highlightedCode;\n\t});\n\n\t// Wrap tokens in classes that are missing them\n\tPrism.hooks.add('wrap', function(env) {\n\t\tif (env.language === 'php' && env.type === 'markup') {\n\t\t\tenv.content = env.content.replace(/(\\{\\{\\{PHP[0-9]+\\}\\}\\})/g, \"<span class=\\\"token php\\\">$1</span>\");\n\t\t}\n\t});\n\n\t// Add the rules before all others\n\tPrism.languages.insertBefore('php', 'comment', {\n\t\t'markup': {\n\t\t\tpattern: /<[^?]\\/?(.*?)>/,\n\t\t\tinside: Prism.languages.markup\n\t\t},\n\t\t'php': /\\{\\{\\{PHP[0-9]+\\}\\}\\}/\n\t});\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-php.js\n ** module id = 97\n ** module chunks = 5 29\n **/","Prism.languages.insertBefore('php', 'variable', {\n\t'this': /\\$this\\b/,\n\t'global': /\\$(?:_(?:SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE)|GLOBALS|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/,\n\t'scope': {\n\t\tpattern: /\\b[\\w\\\\]+::/,\n\t\tinside: {\n\t\t\tkeyword: /(static|self|parent)/,\n\t\t\tpunctuation: /(::|\\\\)/\n\t\t}\n\t}\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-php-extras.js\n ** module id = 98\n ** module chunks = 5 29\n **/","Prism.languages.python= {\n\t'triple-quoted-string': {\n\t\tpattern: /\"\"\"[\\s\\S]+?\"\"\"|'''[\\s\\S]+?'''/,\n\t\talias: 'string'\n\t},\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])#.*/,\n\t\tlookbehind: true\n\t},\n\t'string': /(\"|')(?:\\\\?.)*?\\1/,\n\t'function' : {\n\t\tpattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\\()/g,\n\t\tlookbehind: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\bclass\\s+)[a-z0-9_]+/i,\n\t\tlookbehind: true\n\t},\n\t'keyword' : /\\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\\b/,\n\t'boolean' : /\\b(?:True|False)\\b/,\n\t'number' : /\\b-?(?:0[bo])?(?:(?:\\d|0x[\\da-f])[\\da-f]*\\.?\\d*|\\.\\d+)(?:e[+-]?\\d+)?j?\\b/i,\n\t'operator' : /[-+%=]=?|!=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]|\\b(?:or|and|not)\\b/,\n\t'punctuation' : /[{}[\\];(),.:]/\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-python.js\n ** module id = 99\n ** module chunks = 5 29\n **/","/**\n * Original by Samuel Flores\n *\n * Adds the following new token classes:\n * \t\tconstant, builtin, variable, symbol, regex\n */\n(function(Prism) {\n\tPrism.languages.ruby = Prism.languages.extend('clike', {\n\t\t'comment': /#(?!\\{[^\\r\\n]*?\\}).*/,\n\t\t'keyword': /\\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\\b/\n\t});\n\n\tvar interpolation = {\n\t\tpattern: /#\\{[^}]+\\}/,\n\t\tinside: {\n\t\t\t'delimiter': {\n\t\t\t\tpattern: /^#\\{|\\}$/,\n\t\t\t\talias: 'tag'\n\t\t\t},\n\t\t\trest: Prism.util.clone(Prism.languages.ruby)\n\t\t}\n\t};\n\n\tPrism.languages.insertBefore('ruby', 'keyword', {\n\t\t'regex': [\n\t\t\t{\n\t\t\t\tpattern: /%r([^a-zA-Z0-9\\s\\{\\(\\[<])(?:[^\\\\]|\\\\[\\s\\S])*?\\1[gim]{0,3}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /%r\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)[gim]{0,3}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Here we need to specifically allow interpolation\n\t\t\t\tpattern: /%r\\{(?:[^#{}\\\\]|#(?:\\{[^}]+\\})?|\\\\[\\s\\S])*\\}[gim]{0,3}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /%r\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\][gim]{0,3}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /%r<(?:[^<>\\\\]|\\\\[\\s\\S])*>[gim]{0,3}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'variable': /[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\\b)/,\n\t\t'symbol': /:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\\b)/\n\t});\n\n\tPrism.languages.insertBefore('ruby', 'number', {\n\t\t'builtin': /\\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\\b/,\n\t\t'constant': /\\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\\b)/\n\t});\n\n\tPrism.languages.ruby.string = [\n\t\t{\n\t\t\tpattern: /%[qQiIwWxs]?([^a-zA-Z0-9\\s\\{\\(\\[<])(?:[^\\\\]|\\\\[\\s\\S])*?\\1/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /%[qQiIwWxs]?\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t// Here we need to specifically allow interpolation\n\t\t\tpattern: /%[qQiIwWxs]?\\{(?:[^#{}\\\\]|#(?:\\{[^}]+\\})?|\\\\[\\s\\S])*\\}/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /%[qQiIwWxs]?\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\]/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /%[qQiIwWxs]?<(?:[^<>\\\\]|\\\\[\\s\\S])*>/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /(\"|')(#\\{[^}]+\\}|\\\\(?:\\r?\\n|\\r)|\\\\?.)*?\\1/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t}\n\t];\n}(Prism));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-ruby.js\n ** module id = 100\n ** module chunks = 5 29\n **/","Prism.languages.java = Prism.languages.extend('clike', {\n\t'keyword': /\\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\\b/,\n\t'number': /\\b0b[01]+\\b|\\b0x[\\da-f]*\\.?[\\da-fp\\-]+\\b|\\b\\d*\\.?\\d+(?:e[+-]?\\d+)?[df]?\\b/i,\n\t'operator': {\n\t\tpattern: /(^|[^.])(?:\\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\\|[|=]?|\\*=?|\\/=?|%=?|\\^=?|[?:~])/m,\n\t\tlookbehind: true\n\t}\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prismjs/components/prism-java.js\n ** module id = 101\n ** module chunks = 5 29\n **/","'use strict';\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    a['class'] = ac.concat(bc).filter(nulls);\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {*} val\n * @return {Boolean}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null && val !== '';\n}\n\n/**\n * join array as classes.\n *\n * @param {*} val\n * @return {String}\n */\nexports.joinClasses = joinClasses;\nfunction joinClasses(val) {\n  return (Array.isArray(val) ? val.map(joinClasses) :\n    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :\n    [val]).filter(nulls).join(' ');\n}\n\n/**\n * Render the given classes.\n *\n * @param {Array} classes\n * @param {Array.<Boolean>} escaped\n * @return {String}\n */\nexports.cls = function cls(classes, escaped) {\n  var buf = [];\n  for (var i = 0; i < classes.length; i++) {\n    if (escaped && escaped[i]) {\n      buf.push(exports.escape(joinClasses([classes[i]])));\n    } else {\n      buf.push(joinClasses(classes[i]));\n    }\n  }\n  var text = joinClasses(buf);\n  if (text.length) {\n    return ' class=\"' + text + '\"';\n  } else {\n    return '';\n  }\n};\n\n\nexports.style = function (val) {\n  if (val && typeof val === 'object') {\n    return Object.keys(val).map(function (style) {\n      return style + ':' + val[style];\n    }).join(';');\n  } else {\n    return val;\n  }\n};\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = function attr(key, val, escaped, terse) {\n  if (key === 'style') {\n    val = exports.style(val);\n  }\n  if ('boolean' == typeof val || null == val) {\n    if (val) {\n      return ' ' + (terse ? key : key + '=\"' + key + '\"');\n    } else {\n      return '';\n    }\n  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n    if (JSON.stringify(val).indexOf('&') !== -1) {\n      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +\n                   'will be escaped to `&amp;`');\n    };\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will eliminate the double quotes around dates in ' +\n                   'ISO form after 2.0.0');\n    }\n    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\n  } else if (escaped) {\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n    }\n    return ' ' + key + '=\"' + exports.escape(val) + '\"';\n  } else {\n    if (val && typeof val.toISOString === 'function') {\n      console.warn('Jade will stringify dates in ISO form after 2.0.0');\n    }\n    return ' ' + key + '=\"' + val + '\"';\n  }\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n */\nexports.attrs = function attrs(obj, terse){\n  var buf = [];\n\n  var keys = Object.keys(obj);\n\n  if (keys.length) {\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('class' == key) {\n        if (val = joinClasses(val)) {\n          buf.push(' ' + key + '=\"' + val + '\"');\n        }\n      } else {\n        buf.push(exports.attr(key, val, false, terse));\n      }\n    }\n  }\n\n  return buf.join('');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nvar jade_encode_html_rules = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\nvar jade_match_html = /[&<>\"]/g;\n\nfunction jade_encode_char(c) {\n  return jade_encode_html_rules[c] || c;\n}\n\nexports.escape = jade_escape;\nfunction jade_escape(html){\n  var result = String(html).replace(jade_match_html, jade_encode_char);\n  if (result === '' + html) return html;\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str = str || require('fs').readFileSync(filename, 'utf8')\n  } catch (ex) {\n    rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\nexports.DebugItem = function DebugItem(lineno, filename) {\n  this.lineno = lineno;\n  this.filename = filename;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/jade/lib/runtime.js\n **/","const bem = require('bem-jade')();\nconst thumb = require('client/image').thumb;\n\nconst t = require('i18n');\n\nmodule.exports = function(template, locals) {\n  locals = locals ? Object.create(locals) : {};\n  addStandardHelpers(locals);\n\n  return template(locals);\n};\n\nfunction addStandardHelpers(locals) {\n  locals.bem = bem;\n  locals.t = t;\n  locals.thumb = thumb;\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/clientRender.js\n **/","// Adapted from bemto.jade, copyright(c) 2012 Roman Komarov <kizu@kizu.ru>\n\n/* jshint -W106 */\n\nvar jade = require('jade/lib/runtime');\n\nmodule.exports = function(settings) {\n  settings = settings || {};\n\n  settings.prefix = settings.prefix || '';\n  settings.element = settings.element || '__';\n  settings.modifier = settings.modifier || '_';\n\n  return function(buf, bem_chain, tag, isElement) {\n    //console.log(\"-->\", arguments);\n    var block = this.block;\n    var attributes = this.attributes || {};\n\n    if (!attributes.class && tag && !isElement) {\n      throw new Error(\"Block without class: \" + tag);\n    }\n\n    // Rewriting the class for elements and modifiers\n    if (attributes.class) {\n      var bem_classes = attributes.class;\n\n      if (bem_classes instanceof Array) {\n        bem_classes = bem_classes.join(' ');\n      }\n      bem_classes = bem_classes.split(' ');\n\n      var bem_block;\n      try {\n        bem_block = bem_classes[0].match(new RegExp('^(((?!' + settings.element + '|' + settings.modifier + ').)+)'))[1];\n      } catch (e) {\n        throw new Error(\"Incorrect bem class: \" + bem_classes[0]);\n      }\n\n      if (!isElement) {\n        bem_chain[bem_chain.length] = bem_block;\n      } else {\n        bem_classes[0] = bem_chain[bem_chain.length - 1] + settings.element + bem_classes[0];\n      }\n\n      var current_block = (isElement ? bem_chain[bem_chain.length - 1] + settings.element : '') + bem_block;\n\n      // Adding the block if there is only modifier and/or element\n      if (bem_classes.indexOf(current_block) === -1) {\n        bem_classes[bem_classes.length] = current_block;\n      }\n\n      for (var i = 0; i < bem_classes.length; i++) {\n        var klass = bem_classes[i];\n\n        if (klass.match(new RegExp('^(?!' + settings.element + ')' + settings.modifier))) {\n          // Expanding the modifiers\n          bem_classes[i] = current_block + klass;\n        } else if (klass.match(new RegExp('^' + settings.element))) {\n          //- Expanding the mixed in elements\n          if (bem_chain[bem_chain.length - 2]) {\n            bem_classes[i] = bem_chain[bem_chain.length - 2] + klass;\n          } else {\n            bem_classes[i] = bem_chain[bem_chain.length - 1] + klass;\n          }\n        }\n\n        // Adding prefixes\n        if (bem_classes[i].match(new RegExp('^' + current_block + '($|(?=' + settings.element + '|' + settings.modifier + '))'))) {\n          bem_classes[i] = settings.prefix + bem_classes[i];\n        }\n      }\n\n      // Write modified classes to attributes in the correct order\n      attributes.class = bem_classes.sort().join(' ');\n    }\n\n    bem_tag(buf, block, attributes, bem_chain, tag);\n\n    // Closing actions (remove the current block from the chain)\n    if (!isElement) {\n      bem_chain.pop();\n    }\n  };\n\n\n  // used for tweaking what tag we are throwing and do we need to wrap anything here\n  function bem_tag(buf, block, attributes, bem_chain, tag) {\n    // rewriting tag name on different contexts\n    var newTag = tag || 'div';\n\n    switch (newTag) {\n    case 'img':\n      // If there is no title we don't need it to show even if there is some alt\n      if (attributes.alt && !attributes.title) {\n        attributes.title = '';\n      }\n      // If we have title, we must have it in alt if it's not set\n      if (attributes.title && !attributes.alt) {\n        attributes.alt = attributes.title;\n      }\n      if (!attributes.alt) {\n        attributes.alt = '';\n      }\n      break;\n    case 'input':\n      if (!attributes.type) {\n        attributes.type = \"text\";\n      }\n      break;\n    case 'html':\n      buf.push('<!DOCTYPE HTML>');\n      break;\n    case 'a':\n      if (!attributes.href) {\n        attributes.href = '#';\n      }\n    }\n\n    buf.push('<' + newTag + jade.attrs(jade.merge([attributes]), true) + \">\");\n\n    if (block) block();\n\n    if (['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'].indexOf(newTag) == -1) {\n      buf.push('</' + newTag + '>');\n    }\n\n  }\n\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/bem-jade.js\n **/","\nexports.thumb = function(url, width, height) {\n  // sometimes this may be called without url\n  if (!url) return url;\n\n  var pixelRatio = window.devicePixelRatio;\n\n  // return pixelRatio times larger image for retina\n  width *= pixelRatio;\n  height *= pixelRatio;\n\n  var modifier = (width <= 160 && height <= 160) ? 't' :\n    (width <= 320 && height <= 320) ? 'm' :\n      (width <= 640 && height <= 640) ? 'i' :\n        (width <= 1024 && height <= 1024) ? 'h' : '';\n\n  return url.slice(0, url.lastIndexOf('.')) + modifier + url.slice(url.lastIndexOf('.'));\n};\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/image.js\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** (webpack)/buildin/module.js\n **/","require('prismjs/components/prism-core.js');\nrequire('prismjs/components/prism-markup.js');\nrequire('prismjs/components/prism-css.js');\nrequire('prismjs/components/prism-css-extras.js');\nrequire('prismjs/components/prism-clike.js');\nrequire('prismjs/components/prism-javascript.js');\nrequire('prismjs/components/prism-coffeescript.js');\nrequire('prismjs/components/prism-http.js');\nrequire('prismjs/components/prism-scss.js');\nrequire('prismjs/components/prism-sql.js');\nrequire('prismjs/components/prism-php.js');\nrequire('prismjs/components/prism-php-extras.js');\nrequire('prismjs/components/prism-python.js');\nrequire('prismjs/components/prism-ruby.js');\nrequire('prismjs/components/prism-java.js');\n\nPrism.tokenTag = 'code'; // for iBooks to use monospace font\n\nvar CodeBox = require('./codeBox');\nvar CodeTabsBox = require('./codeTabsBox');\n\nfunction initCodeBoxes(container) {\n\n  // highlight inline\n  var codeExampleElems = container.querySelectorAll('.code-example:not([data-prism-done])');\n\n  for (var i = 0; i < codeExampleElems.length; i++) {\n    var codeExampleElem = codeExampleElems[i];\n    new CodeBox(codeExampleElem);\n    codeExampleElem.setAttribute('data-prism-done', '1');\n  }\n\n}\n\n\nfunction initCodeTabsBox(container) {\n\n  var elems = container.querySelectorAll('div.code-tabs:not([data-prism-done])');\n\n  for (var i = 0; i < elems.length; i++) {\n    new CodeTabsBox(elems[i]);\n    elems[i].setAttribute('data-prism-done', '1');\n  }\n\n}\n\nexports.init = function () {\n\n  document.removeEventListener('DOMContentLoaded', Prism.highlightAll);\n\n  document.addEventListener('DOMContentLoaded', function() {\n    highlight(document);\n  });\n\n};\n\nfunction highlight(elem) {\n  initCodeBoxes(elem);\n  initCodeTabsBox(elem);\n}\n\nexports.highlight = highlight;\n\n\n/** WEBPACK FOOTER **\n ** ./client/prism/index.js\n **/","var resizeOnload = require('client/head/resizeOnload');\nvar isScrolledIntoView = require('client/isScrolledIntoView');\nvar addLineNumbers = require('./addLineNumbers');\n\nfunction CodeBox(elem) {\n\n  var preElem = elem.querySelector('pre');\n  var codeElem = preElem.querySelector('code');\n  var code = codeElem.textContent;\n\n  Prism.highlightElement(codeElem);\n  addLineNumbers(preElem);\n\n  addBlockHighlight(preElem, elem.getAttribute('data-highlight-block'));\n  addInlineHighlight(preElem, elem.getAttribute('data-highlight-inline'));\n\n  var isJS = preElem.classList.contains('language-javascript');\n  var isHTML = preElem.classList.contains('language-markup');\n  var isTrusted = +elem.getAttribute('data-trusted');\n  var isNoStrict = +elem.getAttribute('data-no-strict');\n\n  if (!isNoStrict && isJS) code=\"'use strict';\\n\" + code;\n\n  var jsFrame;\n  var htmlResult;\n  var isFirstRun = true;\n\n  if (!isJS && !isHTML) return;\n\n  var runElem = elem.querySelector('[data-action=\"run\"]');\n  if (runElem) {\n    runElem.onclick = function() {\n      this.blur();\n      run();\n      return false;\n    };\n  }\n\n  var editElem = elem.querySelector('[data-action=\"edit\"]');\n  if (editElem) {\n    editElem.onclick = function() {\n      this.blur();\n      edit();\n      return false;\n    };\n  }\n\n  // some code can't be shown by epub engine\n  if (elem.hasAttribute('data-autorun')) {\n    if(window.ebookType == 'epub' && elem.getAttribute('data-autorun') == 'no-epub') {\n      elem.querySelector('iframe').remove();\n    } else {\n      // timeout should be small, around 10ms, or remove it to make crawler process the autorun\n      setTimeout(run, 100);\n    }\n  }\n\n  function postJSFrame() {\n    var win = jsFrame.contentWindow;\n    if (typeof win.postMessage != 'function') {\n      alert(\",      \");\n      return;\n    }\n    win.postMessage(code, 'https://ru.lookatcode.com/showjs');\n  }\n\n  function runHTML() {\n\n    var frame;\n\n    if (htmlResult && elem.hasAttribute('data-refresh')) {\n      htmlResult.remove();\n      htmlResult = null;\n    }\n\n    if (!htmlResult) {\n      // take from HTML if exists there (in markup when autorun is specified)\n      htmlResult = elem.querySelector('.code-result');\n    }\n\n    if (!htmlResult) {\n      // otherwise create (or recreate if refresh)\n      htmlResult = document.createElement('div');\n      htmlResult.className = \"code-result code-example__result\";\n\n      frame = document.createElement('iframe');\n      frame.name = 'frame-' + Math.random();\n      frame.className = 'code-result__iframe';\n\n      if (elem.getAttribute('data-demo-height') === \"0\") {\n        // this html has nothing to show\n        frame.style.display = 'none';\n      } else if (elem.hasAttribute('data-demo-height')) {\n        var height = +elem.getAttribute('data-demo-height');\n        frame.style.height = height + 'px';\n      }\n      htmlResult.appendChild(frame);\n\n      elem.appendChild(htmlResult);\n    } else {\n      frame = htmlResult.querySelector('iframe');\n    }\n\n    if (isTrusted) {\n      var doc = frame.contentDocument || frame.contentWindow.document;\n\n      doc.open();\n      doc.write(normalizeHtml(code));\n      doc.close();\n\n\n      if(window.ebookType == 'epub') {\n        setTimeout(function() {\n          // remove script from iframes\n          // firefox saves the file with full iframe content (including script-generated) and the scripts\n          // scripts must not execute and autogenerate content again\n          [].forEach.call(doc.querySelectorAll('script'), function(script) {\n            script.remove();\n          });\n\n          // do it after timeout to allow external scripts (if any) to execute\n        }, 2000);\n      }\n\n      if (!elem.hasAttribute('data-demo-height')) {\n        resizeOnload.iframe(frame);\n      }\n\n      if (!(isFirstRun && elem.hasAttribute('data-autorun'))) {\n        if (!isScrolledIntoView(htmlResult)) {\n          htmlResult.scrollIntoView(false);\n        }\n      }\n\n    } else {\n      var form = document.createElement('form');\n      form.style.display = 'none';\n      form.method = 'POST';\n      form.enctype = \"multipart/form-data\";\n      form.action = \"https://ru.lookatcode.com/showhtml\";\n      form.target = frame.name;\n\n      var textarea = document.createElement('textarea');\n      textarea.name = 'code';\n      textarea.value = normalizeHtml(code);\n      form.appendChild(textarea);\n\n      frame.parentNode.insertBefore(form, frame.nextSibling);\n      form.submit();\n      form.remove();\n\n      if (!(isFirstRun && elem.hasAttribute('data-autorun'))) {\n        frame.onload = function() {\n\n          if (!elem.hasAttribute('data-demo-height')) {\n            resizeOnload.iframe(frame);\n          }\n\n          if (!isScrolledIntoView(htmlResult)) {\n            htmlResult.scrollIntoView(false);\n          }\n        };\n      }\n    }\n\n  }\n\n  // Evaluates a script in a global context\n  function globalEval( code ) {\n    var script = document.createElement( \"script\" );\n    script.text = code;\n    document.head.appendChild( script ).parentNode.removeChild( script );\n  }\n\n  function runJS() {\n\n    //console.log(code);\n    if (isTrusted) {\n\n      if (elem.hasAttribute('data-autorun')) {\n        // make sure functions from \"autorun\" go to global scope\n        globalEval(code);\n        return;\n      }\n\n      try {\n        /* jshint -W061 */\n        window[\"eval\"].call(window, code);\n      } catch (e) {\n        alert(\"Error: \" + e.message);\n      }\n\n    } else {\n\n      if (elem.hasAttribute('data-refresh') && jsFrame) {\n        jsFrame.remove();\n        jsFrame = null;\n      }\n\n      if (!jsFrame) {\n        // create iframe for js\n        jsFrame = document.createElement('iframe');\n        jsFrame.className = 'js-frame';\n        jsFrame.src = 'https://ru.lookatcode.com/showjs';\n        jsFrame.style.width = 0;\n        jsFrame.style.height = 0;\n        jsFrame.style.border = 'none';\n        jsFrame.onload = function() {\n          postJSFrame();\n        };\n        document.body.appendChild(jsFrame);\n      } else {\n        postJSFrame();\n      }\n\n    }\n  }\n\n  function edit() {\n\n    var html;\n    if (isHTML) {\n      html = normalizeHtml(code);\n    } else {\n      var codeIndented = code.replace(/^/gim, '    ');\n      html = '<!DOCTYPE html>\\n<html>\\n\\n<body>\\n  <script>\\n' + codeIndented + '\\n  </script>\\n</body>\\n\\n</html>';\n    }\n\n    var form = document.createElement('form');\n    form.action = \"http://plnkr.co/edit/?p=preview\";\n    form.method = \"POST\";\n    form.target = \"_blank\";\n\n    document.body.appendChild(form);\n\n    var textarea = document.createElement('textarea');\n    textarea.name = \"files[index.html]\";\n    textarea.value = html;\n    form.appendChild(textarea);\n\n    var input = document.createElement('input');\n    input.name = \"description\";\n    input.value = \"Fork from \" + window.location;\n    form.appendChild(input);\n\n    form.submit();\n    form.remove();\n  }\n\n\n  function normalizeHtml() {\n    var codeLc = code.toLowerCase();\n    var hasBodyStart = codeLc.match('<body>');\n    var hasBodyEnd = codeLc.match('</body>');\n    var hasHtmlStart = codeLc.match('<html>');\n    var hasHtmlEnd = codeLc.match('</html>');\n\n    var hasDocType = codeLc.match(/^\\s*<!doctype/);\n\n    if (hasDocType) {\n      return code;\n    }\n\n    var result = code;\n\n    if (!hasHtmlStart) {\n      result = '<html>\\n' + result;\n    }\n\n    if (!hasHtmlEnd) {\n      result = result + '\\n</html>';\n    }\n\n    if (!hasBodyStart) {\n      result = result.replace('<html>', '<html>\\n<head>\\n  <meta charset=\"utf-8\">\\n</head><body>\\n');\n    }\n\n    if (!hasBodyEnd) {\n      result = result.replace('</html>', '\\n</body>\\n</html>');\n    }\n\n    result = '<!DOCTYPE HTML>\\n' + result;\n\n    return result;\n  }\n\n\n  function run() {\n    if (isJS) {\n      runJS();\n    } else {\n      runHTML();\n    }\n    isFirstRun = false;\n  }\n\n\n}\n\n\nfunction addBlockHighlight(pre, lines) {\n\n  if (!lines) {\n    return;\n  }\n\n  var ranges = lines.replace(/\\s+/g, '').split(',');\n\n  /*jshint -W084 */\n  for (var i = 0, range; range = ranges[i++];) {\n    range = range.split('-');\n\n    var start = +range[0],\n        end = +range[1] || start;\n\n\n    var mask = '<code class=\"block-highlight\" data-start=\"' + start + '\" data-end=\"' + end + '\">' +\n      new Array(start + 1).join('\\n') +\n      '<code class=\"mask\">' + new Array(end - start + 2).join('\\n') + '</code></code>';\n\n    pre.insertAdjacentHTML(\"afterBegin\", mask);\n  }\n\n}\n\n\nfunction addInlineHighlight(pre, ranges) {\n\n  // select code with the language text, not block-highlighter\n  var codeElem = pre.querySelector('code[class*=\"language-\"]');\n\n  ranges = ranges ? ranges.split(\",\") : [];\n\n  for (var i = 0; i < ranges.length; i++) {\n    var piece = ranges[i].split(':');\n    var lineNum = +piece[0], strRange = piece[1].split('-');\n    var start = +strRange[0], end = +strRange[1];\n    var mask = '<code class=\"inline-highlight\">' +\n      new Array(lineNum + 1).join('\\n') +\n      new Array(start + 1).join(' ') +\n      '<code class=\"mask\">' + new Array(end - start + 1).join(' ') + '</code></code>';\n\n    codeElem.insertAdjacentHTML(\"afterBegin\", mask);\n  }\n}\n\n\nmodule.exports = CodeBox;\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/prism/codeBox.js\n **/","\nfunction isScrolledIntoView(elem) {\n  var coords = elem.getBoundingClientRect();\n\n  var visibleHeight = 0;\n\n  if (coords.top < 0) {\n    visibleHeight = coords.bottom;\n  } else if (coords.bottom > window.innerHeight) {\n    visibleHeight = window.innerHeight - top;\n  } else {\n    return true;\n  }\n\n  return visibleHeight > 10;\n}\n\nmodule.exports = isScrolledIntoView;\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/isScrolledIntoView.js\n **/","\nfunction addLineNumbers(pre) {\n\n  var linesNum = (1 + pre.innerHTML.split('\\n').length);\n  var lineNumbersWrapper;\n\n  var lines = new Array(linesNum);\n  lines = lines.join('<span></span>');\n\n  lineNumbersWrapper = document.createElement('span');\n  lineNumbersWrapper.className = 'line-numbers-rows';\n  lineNumbersWrapper.innerHTML = lines;\n\n  if (pre.hasAttribute('data-start')) {\n    pre.style.counterReset = 'linenumber ' + Number(pre.dataset.start) - 1;\n  }\n\n  pre.appendChild(lineNumbersWrapper);\n}\n\n\nmodule.exports = addLineNumbers;\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/prism/addLineNumbers.js\n **/","var delegate = require('client/delegate');\nvar addLineNumbers = require('./addLineNumbers');\n\nfunction CodeTabsBox(elem) {\n  if (window.ebookType) {\n    return;\n  }\n\n  this.elem = elem;\n  this.translateX = 0;\n\n  this.switchesElem = elem.querySelector('[data-code-tabs-switches]');\n  this.switchesElemItems = this.switchesElem.firstElementChild;\n  this.arrowLeft = elem.querySelector('[data-code-tabs-left]');\n  this.arrowRight = elem.querySelector('[data-code-tabs-right]');\n\n\n  this.arrowLeft.onclick = function(e) {\n    e.preventDefault();\n\n    this.translateX = Math.max(0, this.translateX - this.switchesElem.offsetWidth);\n    this.renderTranslate();\n  }.bind(this);\n\n\n  this.arrowRight.onclick = function(e) {\n    e.preventDefault();\n\n    this.translateX = Math.min(this.translateX +this.switchesElem.offsetWidth, this.switchesElemItems.offsetWidth - this.switchesElem.offsetWidth);\n    this.renderTranslate();\n  }.bind(this);\n\n  this.delegate('.code-tabs__switch', 'click', this.onSwitchClick);\n}\n\nCodeTabsBox.prototype.onSwitchClick = function(e) {\n  e.preventDefault();\n\n  var siblings = e.delegateTarget.parentNode.children;\n  var tabs = this.elem.querySelector('[data-code-tabs-content]').children;\n\n\n  var selectedIndex;\n  for(var i=0; i<siblings.length; i++) {\n    var switchElem = siblings[i];\n    var tabElem = tabs[i];\n    if (switchElem == e.delegateTarget) {\n      selectedIndex = i;\n      tabElem.classList.add('code-tabs__section_current');\n      switchElem.classList.add('code-tabs__switch_current');\n    } else {\n      tabElem.classList.remove('code-tabs__section_current');\n      switchElem.classList.remove('code-tabs__switch_current');\n    }\n  }\n\n  if (selectedIndex === 0) {\n    this.elem.classList.add('code-tabs_result_on');\n  } else {\n    this.elem.classList.remove('code-tabs_result_on');\n\n    this.highlightTab(tabs[selectedIndex]);\n  }\n\n};\n\n\nCodeTabsBox.prototype.highlightTab = function(tab) {\n  if (tab.highlighted) return;\n  var preElem = tab.querySelector('pre');\n  var codeElem = preElem.querySelector('code');\n  Prism.highlightElement(codeElem);\n  addLineNumbers(preElem);\n  tab.highlighted = true;\n};\n\nCodeTabsBox.prototype.renderTranslate = function() {\n  this.switchesElemItems.style.transform = 'translateX(-' + this.translateX + 'px)';\n  if (this.translateX === 0) {\n    this.arrowLeft.setAttribute('disabled', '');\n  } else {\n    this.arrowLeft.removeAttribute('disabled');\n  }\n\n  if (this.translateX === this.switchesElemItems.offsetWidth - this.switchesElem.offsetWidth) {\n    this.arrowRight.setAttribute('disabled', '');\n  } else {\n    this.arrowRight.removeAttribute('disabled');\n  }\n\n};\n\n\ndelegate.delegateMixin(CodeTabsBox.prototype);\n\n\nmodule.exports = CodeTabsBox;\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/prism/codeTabsBox.js\n **/","'use strict';\n\n\nconst LANG = require('config').lang;\n\nconst MarkdownIt = require('markdown-it');\n\nconst charTypographyPlugin = require('./plugins/charTypography');\nconst extendedCodePlugin = require('./plugins/extendedCode');\nconst outlinedBlocksPlugin = require('./plugins/outlinedBlocks');\nconst sourceBlocksPlugin = require('./plugins/sourceBlocks');\n\nconst imgDescToAttrsPlugin = require('./plugins/imgDescToAttrs');\n\nconst markdownErrorPlugin = require('./plugins/markdownError');\nconst blockTagsPlugin = require('./plugins/blockTags/plugin');\nconst deflistPlugin = require('markdown-it-deflist');\nconst getPrismLanguage = require('./getPrismLanguage');\n\nmodule.exports = class BasicParser {\n\n  constructor(options) {\n    options = options || {};\n    this.options = options;\n\n    this.env = options.env || {};\n    this.md = MarkdownIt(Object.assign({\n      typographer:   true,\n      blockTags:     getPrismLanguage.allSupported,\n      linkHeaderTag: false,\n      html:          false,\n      quotes:        LANG == 'ru' ? '' : ''\n    }, options));\n\n    extendedCodePlugin(this.md);\n    outlinedBlocksPlugin(this.md);\n    sourceBlocksPlugin(this.md);\n    imgDescToAttrsPlugin(this.md);\n    markdownErrorPlugin(this.md);\n    blockTagsPlugin(this.md);\n    charTypographyPlugin(this.md);\n    deflistPlugin(this.md);\n  }\n\n  parse(text) {\n    return this.md.parse(text, this.env);\n  }\n  parseInline(text) {\n    return this.md.parseInline(text, this.env);\n  }\n\n  render(text) {\n    return this.md.renderer.render(this.parse(text), this.md.options, this.env);\n  }\n\n  renderInline(text) {\n    let tokens = this.parseInline(text);\n    let result = this.md.renderer.render(tokens, this.md.options, this.env);\n    return result;\n  }\n\n  renderTokens(tokens) {\n    return this.md.renderer.render(tokens, this.md.options, this.env);\n  }\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/basicParser.js\n **/","module.exports = {\n  lang: LANG\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./client/config.js\n **/","'use strict';\n\n\nmodule.exports = require('./lib/');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/index.js\n **/","// Main perser class\n\n'use strict';\n\n\nvar utils        = require('./common/utils');\nvar helpers      = require('./helpers');\nvar Renderer     = require('./renderer');\nvar ParserCore   = require('./parser_core');\nvar ParserBlock  = require('./parser_block');\nvar ParserInline = require('./parser_inline');\nvar LinkifyIt    = require('linkify-it');\nvar mdurl        = require('mdurl');\nvar punycode     = require('punycode');\n\n\nvar config = {\n  'default': require('./presets/default'),\n  zero: require('./presets/zero'),\n  commonmark: require('./presets/commonmark')\n};\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// This validator can prohibit more than really needed to prevent XSS. It's a\n// tradeoff to keep code simple and to be secure by default.\n//\n// If you need different setup - override validator method as you wish. Or\n// replace it with dummy function and use external sanitizer.\n//\n\nvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\nvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n\nfunction validateLink(url) {\n  // url should be normalized at this point, and existing entities are decoded\n  var str = url.trim().toLowerCase();\n\n  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];\n\nfunction normalizeLink(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.encode(mdurl.format(parsed));\n}\n\nfunction normalizeLinkText(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toUnicode(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.decode(mdurl.format(parsed));\n}\n\n\n/**\n * class MarkdownIt\n *\n * Main parser/renderer class.\n *\n * ##### Usage\n *\n * ```javascript\n * // node.js, \"classic\" way:\n * var MarkdownIt = require('markdown-it'),\n *     md = new MarkdownIt();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // node.js, the same, but with sugar:\n * var md = require('markdown-it')();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // browser without AMD, added to \"window\" on script load\n * // Note, there are no dash.\n * var md = window.markdownit();\n * var result = md.render('# markdown-it rulezz!');\n * ```\n *\n * Single line rendering, without paragraph wrap:\n *\n * ```javascript\n * var md = require('markdown-it')();\n * var result = md.renderInline('__markdown-it__ rulezz!');\n * ```\n **/\n\n/**\n * new MarkdownIt([presetName, options])\n * - presetName (String): optional, `commonmark` / `zero`\n * - options (Object)\n *\n * Creates parser instanse with given config. Can be called without `new`.\n *\n * ##### presetName\n *\n * MarkdownIt provides named presets as a convenience to quickly\n * enable/disable active syntax rules and options for common use cases.\n *\n * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -\n *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -\n *   similar to GFM, used when no preset name given. Enables all available rules,\n *   but still without html, typographer & autolinker.\n * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -\n *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n *   For example, when you need only `bold` and `italic` markup and nothing else.\n *\n * ##### options:\n *\n * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n *   That's not safe! You may need external sanitizer to protect output from XSS.\n *   It's better to extend features via plugins, instead of enabling HTML.\n * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n *   (`<br />`). This is needed only for full CommonMark compatibility. In real\n *   world you will need HTML output.\n * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\n * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n *   Can be useful for external highlighters.\n * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +\n *   quotes beautification (smartquotes).\n * - __quotes__ - ``, String or Array. Double + single quotes replacement\n *   pairs, when typographer enabled and smartquotes on. For example, you can\n *   use `''` for Russian, `''` for German, and\n *   `['\\xA0', '\\xA0', '\\xA0', '\\xA0']` for French (including nbsp).\n * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n *   return empty string if the source was not changed and should be escaped\n *   externaly. If result starts with <pre... internal wrapper is skipped.\n *\n * ##### Example\n *\n * ```javascript\n * // commonmark mode\n * var md = require('markdown-it')('commonmark');\n *\n * // default mode\n * var md = require('markdown-it')();\n *\n * // enable everything\n * var md = require('markdown-it')({\n *   html: true,\n *   linkify: true,\n *   typographer: true\n * });\n * ```\n *\n * ##### Syntax highlighting\n *\n * ```js\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return hljs.highlight(lang, str, true).value;\n *       } catch (__) {}\n *     }\n *\n *     return ''; // use external default escaping\n *   }\n * });\n * ```\n *\n * Or with full wrapper override (if you need assign class to `<pre>`):\n *\n * ```javascript\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * // Actual default values\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return '<pre class=\"hljs\"><code>' +\n *                hljs.highlight(lang, str, true).value +\n *                '</code></pre>';\n *       } catch (__) {}\n *     }\n *\n *     return '<pre class=\"hljs\"><code>' + md.utils.escapeHtml(str) + '</code></pre>';\n *   }\n * });\n * ```\n *\n **/\nfunction MarkdownIt(presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options);\n  }\n\n  if (!options) {\n    if (!utils.isString(presetName)) {\n      options = presetName || {};\n      presetName = 'default';\n    }\n  }\n\n  /**\n   * MarkdownIt#inline -> ParserInline\n   *\n   * Instance of [[ParserInline]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.inline = new ParserInline();\n\n  /**\n   * MarkdownIt#block -> ParserBlock\n   *\n   * Instance of [[ParserBlock]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.block = new ParserBlock();\n\n  /**\n   * MarkdownIt#core -> Core\n   *\n   * Instance of [[Core]] chain executor. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.core = new ParserCore();\n\n  /**\n   * MarkdownIt#renderer -> Renderer\n   *\n   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n   * rules for new token types, generated by plugins.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * function myToken(tokens, idx, options, env, self) {\n   *   //...\n   *   return result;\n   * };\n   *\n   * md.renderer.rules['my_token'] = myToken\n   * ```\n   *\n   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).\n   **/\n  this.renderer = new Renderer();\n\n  /**\n   * MarkdownIt#linkify -> LinkifyIt\n   *\n   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)\n   * rule.\n   **/\n  this.linkify = new LinkifyIt();\n\n  /**\n   * MarkdownIt#validateLink(url) -> Boolean\n   *\n   * Link validation function. CommonMark allows too much in links. By default\n   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n   * except some embedded image types.\n   *\n   * You can change this behaviour:\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   * // enable everything\n   * md.validateLink = function () { return true; }\n   * ```\n   **/\n  this.validateLink = validateLink;\n\n  /**\n   * MarkdownIt#normalizeLink(url) -> String\n   *\n   * Function used to encode link url to a machine-readable format,\n   * which includes url-encoding, punycode, etc.\n   **/\n  this.normalizeLink = normalizeLink;\n\n  /**\n   * MarkdownIt#normalizeLinkText(url) -> String\n   *\n   * Function used to decode link url to a human-readable format`\n   **/\n  this.normalizeLinkText = normalizeLinkText;\n\n\n  // Expose utils & helpers for easy acces from plugins\n\n  /**\n   * MarkdownIt#utils -> utils\n   *\n   * Assorted utility functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).\n   **/\n  this.utils = utils;\n\n  /**\n   * MarkdownIt#helpers -> helpers\n   *\n   * Link components parser functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n   **/\n  this.helpers = helpers;\n\n\n  this.options = {};\n  this.configure(presetName);\n\n  if (options) { this.set(options); }\n}\n\n\n/** chainable\n * MarkdownIt.set(options)\n *\n * Set parser options (in the same format as in constructor). Probably, you\n * will never need it, but you can change options after constructor call.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .set({ html: true, breaks: true })\n *             .set({ typographer, true });\n * ```\n *\n * __Note:__ To achieve the best possible performance, don't modify a\n * `markdown-it` instance options on the fly. If you need multiple configurations\n * it's best to create multiple instances and initialize each with separate\n * config.\n **/\nMarkdownIt.prototype.set = function (options) {\n  utils.assign(this.options, options);\n  return this;\n};\n\n\n/** chainable, internal\n * MarkdownIt.configure(presets)\n *\n * Batch load of all options and compenent settings. This is internal method,\n * and you probably will not need it. But if you with - see available presets\n * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n *\n * We strongly recommend to use presets instead of direct config loads. That\n * will give better compatibility with next versions.\n **/\nMarkdownIt.prototype.configure = function (presets) {\n  var self = this, presetName;\n\n  if (utils.isString(presets)) {\n    presetName = presets;\n    presets = config[presetName];\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name'); }\n  }\n\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty'); }\n\n  if (presets.options) { self.set(presets.options); }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enableOnly(presets.components[name].rules);\n      }\n      if (presets.components[name].rules2) {\n        self[name].ruler2.enableOnly(presets.components[name].rules2);\n      }\n    });\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.enable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to enable\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable list or rules. It will automatically find appropriate components,\n * containing rules with given names. If rule not found, and `ignoreInvalid`\n * not set - throws exception.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .enable(['sub', 'sup'])\n *             .disable('smartquotes');\n * ```\n **/\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.enable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.enable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);\n  }\n\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.disable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * The same as [[MarkdownIt.enable]], but turn specified rules off.\n **/\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.disable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.disable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.use(plugin, params)\n *\n * Load specified plugin with given params into current parser instance.\n * It's just a sugar to call `plugin(md, params)` with curring.\n *\n * ##### Example\n *\n * ```javascript\n * var iterator = require('markdown-it-for-inline');\n * var md = require('markdown-it')()\n *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n *             });\n * ```\n **/\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));\n  plugin.apply(plugin, args);\n  return this;\n};\n\n\n/** internal\n * MarkdownIt.parse(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Parse input string and returns list of block tokens (special token type\n * \"inline\" will contain list of inline tokens). You should not call this\n * method directly, until you write custom renderer (for example, to produce\n * AST).\n *\n * `env` is used to pass data between \"distributed\" rules and return additional\n * metadata like reference info, needed for the renderer. It also can be used to\n * inject data in specific cases. Usually, you will be ok to pass `{}`,\n * and then pass updated object to renderer.\n **/\nMarkdownIt.prototype.parse = function (src, env) {\n  var state = new this.core.State(src, this, env);\n\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.render(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Render markdown string into html. It does all magic for you :).\n *\n * `env` can be used to inject additional metadata (`{}` by default).\n * But you will not need it with high probability. See also comment\n * in [[MarkdownIt.parse]].\n **/\nMarkdownIt.prototype.render = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parse(src, env), this.options, env);\n};\n\n\n/** internal\n * MarkdownIt.parseInline(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n * block tokens list with the single `inline` element, containing parsed inline\n * tokens in `children` property. Also updates `env` object.\n **/\nMarkdownIt.prototype.parseInline = function (src, env) {\n  var state = new this.core.State(src, this, env);\n\n  state.inlineMode = true;\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.renderInline(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n * will NOT be wrapped into `<p>` tags.\n **/\nMarkdownIt.prototype.renderInline = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parseInline(src, env), this.options, env);\n};\n\n\nmodule.exports = MarkdownIt;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/index.js\n **/","// Utilities\n//\n'use strict';\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction isString(obj) { return _class(obj) === '[object String]'; }\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return _hasOwnProperty.call(object, key);\n}\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt(src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\n\nvar UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\nvar ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;\nvar UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');\n\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nvar entities = require('./entities');\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n\n  if (has(entities, name)) {\n    return entities[name];\n  }\n\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16)\n    :\n      parseInt(name.slice(1), 10);\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n\n  return match;\n}\n\n/*function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n}*/\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\nfunction unescapeAll(str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str; }\n\n  return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {\n    if (escaped) { return escaped; }\n    return replaceEntityPattern(match, entity);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n\nfunction escapeRE (str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isSpace(code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true;\n  }\n  return false;\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace(code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true; }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/*eslint-disable max-len*/\nvar UNICODE_PUNCT_RE = require('uc.micro/categories/P/regex');\n\n// Currently without astral characters support.\nfunction isPunctChar(ch) {\n  return UNICODE_PUNCT_RE.test(ch);\n}\n\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct(ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nexports.lib                 = {};\nexports.lib.mdurl           = require('mdurl');\nexports.lib.ucmicro         = require('uc.micro');\n\nexports.assign              = assign;\nexports.isString            = isString;\nexports.has                 = has;\nexports.unescapeMd          = unescapeMd;\nexports.unescapeAll         = unescapeAll;\nexports.isValidEntityCode   = isValidEntityCode;\nexports.fromCodePoint       = fromCodePoint;\n// exports.replaceEntities     = replaceEntities;\nexports.escapeHtml          = escapeHtml;\nexports.arrayReplaceAt      = arrayReplaceAt;\nexports.isSpace             = isSpace;\nexports.isWhiteSpace        = isWhiteSpace;\nexports.isMdAsciiPunct      = isMdAsciiPunct;\nexports.isPunctChar         = isPunctChar;\nexports.escapeRE            = escapeRE;\nexports.normalizeReference  = normalizeReference;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/common/utils.js\n **/","// HTML5 entities map: { name -> utf16string }\n//\n'use strict';\n\n/*eslint quotes:0*/\nmodule.exports = require('entities/maps/entities.json');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/common/entities.js\n **/","module.exports = {\n\t\"Aacute\": \"\",\n\t\"aacute\": \"\",\n\t\"Abreve\": \"\",\n\t\"abreve\": \"\",\n\t\"ac\": \"\",\n\t\"acd\": \"\",\n\t\"acE\": \"\",\n\t\"Acirc\": \"\",\n\t\"acirc\": \"\",\n\t\"acute\": \"\",\n\t\"Acy\": \"\",\n\t\"acy\": \"\",\n\t\"AElig\": \"\",\n\t\"aelig\": \"\",\n\t\"af\": \"\",\n\t\"Afr\": \"\",\n\t\"afr\": \"\",\n\t\"Agrave\": \"\",\n\t\"agrave\": \"\",\n\t\"alefsym\": \"\",\n\t\"aleph\": \"\",\n\t\"Alpha\": \"\",\n\t\"alpha\": \"\",\n\t\"Amacr\": \"\",\n\t\"amacr\": \"\",\n\t\"amalg\": \"\",\n\t\"amp\": \"&\",\n\t\"AMP\": \"&\",\n\t\"andand\": \"\",\n\t\"And\": \"\",\n\t\"and\": \"\",\n\t\"andd\": \"\",\n\t\"andslope\": \"\",\n\t\"andv\": \"\",\n\t\"ang\": \"\",\n\t\"ange\": \"\",\n\t\"angle\": \"\",\n\t\"angmsdaa\": \"\",\n\t\"angmsdab\": \"\",\n\t\"angmsdac\": \"\",\n\t\"angmsdad\": \"\",\n\t\"angmsdae\": \"\",\n\t\"angmsdaf\": \"\",\n\t\"angmsdag\": \"\",\n\t\"angmsdah\": \"\",\n\t\"angmsd\": \"\",\n\t\"angrt\": \"\",\n\t\"angrtvb\": \"\",\n\t\"angrtvbd\": \"\",\n\t\"angsph\": \"\",\n\t\"angst\": \"\",\n\t\"angzarr\": \"\",\n\t\"Aogon\": \"\",\n\t\"aogon\": \"\",\n\t\"Aopf\": \"\",\n\t\"aopf\": \"\",\n\t\"apacir\": \"\",\n\t\"ap\": \"\",\n\t\"apE\": \"\",\n\t\"ape\": \"\",\n\t\"apid\": \"\",\n\t\"apos\": \"'\",\n\t\"ApplyFunction\": \"\",\n\t\"approx\": \"\",\n\t\"approxeq\": \"\",\n\t\"Aring\": \"\",\n\t\"aring\": \"\",\n\t\"Ascr\": \"\",\n\t\"ascr\": \"\",\n\t\"Assign\": \"\",\n\t\"ast\": \"*\",\n\t\"asymp\": \"\",\n\t\"asympeq\": \"\",\n\t\"Atilde\": \"\",\n\t\"atilde\": \"\",\n\t\"Auml\": \"\",\n\t\"auml\": \"\",\n\t\"awconint\": \"\",\n\t\"awint\": \"\",\n\t\"backcong\": \"\",\n\t\"backepsilon\": \"\",\n\t\"backprime\": \"\",\n\t\"backsim\": \"\",\n\t\"backsimeq\": \"\",\n\t\"Backslash\": \"\",\n\t\"Barv\": \"\",\n\t\"barvee\": \"\",\n\t\"barwed\": \"\",\n\t\"Barwed\": \"\",\n\t\"barwedge\": \"\",\n\t\"bbrk\": \"\",\n\t\"bbrktbrk\": \"\",\n\t\"bcong\": \"\",\n\t\"Bcy\": \"\",\n\t\"bcy\": \"\",\n\t\"bdquo\": \"\",\n\t\"becaus\": \"\",\n\t\"because\": \"\",\n\t\"Because\": \"\",\n\t\"bemptyv\": \"\",\n\t\"bepsi\": \"\",\n\t\"bernou\": \"\",\n\t\"Bernoullis\": \"\",\n\t\"Beta\": \"\",\n\t\"beta\": \"\",\n\t\"beth\": \"\",\n\t\"between\": \"\",\n\t\"Bfr\": \"\",\n\t\"bfr\": \"\",\n\t\"bigcap\": \"\",\n\t\"bigcirc\": \"\",\n\t\"bigcup\": \"\",\n\t\"bigodot\": \"\",\n\t\"bigoplus\": \"\",\n\t\"bigotimes\": \"\",\n\t\"bigsqcup\": \"\",\n\t\"bigstar\": \"\",\n\t\"bigtriangledown\": \"\",\n\t\"bigtriangleup\": \"\",\n\t\"biguplus\": \"\",\n\t\"bigvee\": \"\",\n\t\"bigwedge\": \"\",\n\t\"bkarow\": \"\",\n\t\"blacklozenge\": \"\",\n\t\"blacksquare\": \"\",\n\t\"blacktriangle\": \"\",\n\t\"blacktriangledown\": \"\",\n\t\"blacktriangleleft\": \"\",\n\t\"blacktriangleright\": \"\",\n\t\"blank\": \"\",\n\t\"blk12\": \"\",\n\t\"blk14\": \"\",\n\t\"blk34\": \"\",\n\t\"block\": \"\",\n\t\"bne\": \"=\",\n\t\"bnequiv\": \"\",\n\t\"bNot\": \"\",\n\t\"bnot\": \"\",\n\t\"Bopf\": \"\",\n\t\"bopf\": \"\",\n\t\"bot\": \"\",\n\t\"bottom\": \"\",\n\t\"bowtie\": \"\",\n\t\"boxbox\": \"\",\n\t\"boxdl\": \"\",\n\t\"boxdL\": \"\",\n\t\"boxDl\": \"\",\n\t\"boxDL\": \"\",\n\t\"boxdr\": \"\",\n\t\"boxdR\": \"\",\n\t\"boxDr\": \"\",\n\t\"boxDR\": \"\",\n\t\"boxh\": \"\",\n\t\"boxH\": \"\",\n\t\"boxhd\": \"\",\n\t\"boxHd\": \"\",\n\t\"boxhD\": \"\",\n\t\"boxHD\": \"\",\n\t\"boxhu\": \"\",\n\t\"boxHu\": \"\",\n\t\"boxhU\": \"\",\n\t\"boxHU\": \"\",\n\t\"boxminus\": \"\",\n\t\"boxplus\": \"\",\n\t\"boxtimes\": \"\",\n\t\"boxul\": \"\",\n\t\"boxuL\": \"\",\n\t\"boxUl\": \"\",\n\t\"boxUL\": \"\",\n\t\"boxur\": \"\",\n\t\"boxuR\": \"\",\n\t\"boxUr\": \"\",\n\t\"boxUR\": \"\",\n\t\"boxv\": \"\",\n\t\"boxV\": \"\",\n\t\"boxvh\": \"\",\n\t\"boxvH\": \"\",\n\t\"boxVh\": \"\",\n\t\"boxVH\": \"\",\n\t\"boxvl\": \"\",\n\t\"boxvL\": \"\",\n\t\"boxVl\": \"\",\n\t\"boxVL\": \"\",\n\t\"boxvr\": \"\",\n\t\"boxvR\": \"\",\n\t\"boxVr\": \"\",\n\t\"boxVR\": \"\",\n\t\"bprime\": \"\",\n\t\"breve\": \"\",\n\t\"Breve\": \"\",\n\t\"brvbar\": \"\",\n\t\"bscr\": \"\",\n\t\"Bscr\": \"\",\n\t\"bsemi\": \"\",\n\t\"bsim\": \"\",\n\t\"bsime\": \"\",\n\t\"bsolb\": \"\",\n\t\"bsol\": \"\\\\\",\n\t\"bsolhsub\": \"\",\n\t\"bull\": \"\",\n\t\"bullet\": \"\",\n\t\"bump\": \"\",\n\t\"bumpE\": \"\",\n\t\"bumpe\": \"\",\n\t\"Bumpeq\": \"\",\n\t\"bumpeq\": \"\",\n\t\"Cacute\": \"\",\n\t\"cacute\": \"\",\n\t\"capand\": \"\",\n\t\"capbrcup\": \"\",\n\t\"capcap\": \"\",\n\t\"cap\": \"\",\n\t\"Cap\": \"\",\n\t\"capcup\": \"\",\n\t\"capdot\": \"\",\n\t\"CapitalDifferentialD\": \"\",\n\t\"caps\": \"\",\n\t\"caret\": \"\",\n\t\"caron\": \"\",\n\t\"Cayleys\": \"\",\n\t\"ccaps\": \"\",\n\t\"Ccaron\": \"\",\n\t\"ccaron\": \"\",\n\t\"Ccedil\": \"\",\n\t\"ccedil\": \"\",\n\t\"Ccirc\": \"\",\n\t\"ccirc\": \"\",\n\t\"Cconint\": \"\",\n\t\"ccups\": \"\",\n\t\"ccupssm\": \"\",\n\t\"Cdot\": \"\",\n\t\"cdot\": \"\",\n\t\"cedil\": \"\",\n\t\"Cedilla\": \"\",\n\t\"cemptyv\": \"\",\n\t\"cent\": \"\",\n\t\"centerdot\": \"\",\n\t\"CenterDot\": \"\",\n\t\"cfr\": \"\",\n\t\"Cfr\": \"\",\n\t\"CHcy\": \"\",\n\t\"chcy\": \"\",\n\t\"check\": \"\",\n\t\"checkmark\": \"\",\n\t\"Chi\": \"\",\n\t\"chi\": \"\",\n\t\"circ\": \"\",\n\t\"circeq\": \"\",\n\t\"circlearrowleft\": \"\",\n\t\"circlearrowright\": \"\",\n\t\"circledast\": \"\",\n\t\"circledcirc\": \"\",\n\t\"circleddash\": \"\",\n\t\"CircleDot\": \"\",\n\t\"circledR\": \"\",\n\t\"circledS\": \"\",\n\t\"CircleMinus\": \"\",\n\t\"CirclePlus\": \"\",\n\t\"CircleTimes\": \"\",\n\t\"cir\": \"\",\n\t\"cirE\": \"\",\n\t\"cire\": \"\",\n\t\"cirfnint\": \"\",\n\t\"cirmid\": \"\",\n\t\"cirscir\": \"\",\n\t\"ClockwiseContourIntegral\": \"\",\n\t\"CloseCurlyDoubleQuote\": \"\",\n\t\"CloseCurlyQuote\": \"\",\n\t\"clubs\": \"\",\n\t\"clubsuit\": \"\",\n\t\"colon\": \":\",\n\t\"Colon\": \"\",\n\t\"Colone\": \"\",\n\t\"colone\": \"\",\n\t\"coloneq\": \"\",\n\t\"comma\": \",\",\n\t\"commat\": \"@\",\n\t\"comp\": \"\",\n\t\"compfn\": \"\",\n\t\"complement\": \"\",\n\t\"complexes\": \"\",\n\t\"cong\": \"\",\n\t\"congdot\": \"\",\n\t\"Congruent\": \"\",\n\t\"conint\": \"\",\n\t\"Conint\": \"\",\n\t\"ContourIntegral\": \"\",\n\t\"copf\": \"\",\n\t\"Copf\": \"\",\n\t\"coprod\": \"\",\n\t\"Coproduct\": \"\",\n\t\"copy\": \"\",\n\t\"COPY\": \"\",\n\t\"copysr\": \"\",\n\t\"CounterClockwiseContourIntegral\": \"\",\n\t\"crarr\": \"\",\n\t\"cross\": \"\",\n\t\"Cross\": \"\",\n\t\"Cscr\": \"\",\n\t\"cscr\": \"\",\n\t\"csub\": \"\",\n\t\"csube\": \"\",\n\t\"csup\": \"\",\n\t\"csupe\": \"\",\n\t\"ctdot\": \"\",\n\t\"cudarrl\": \"\",\n\t\"cudarrr\": \"\",\n\t\"cuepr\": \"\",\n\t\"cuesc\": \"\",\n\t\"cularr\": \"\",\n\t\"cularrp\": \"\",\n\t\"cupbrcap\": \"\",\n\t\"cupcap\": \"\",\n\t\"CupCap\": \"\",\n\t\"cup\": \"\",\n\t\"Cup\": \"\",\n\t\"cupcup\": \"\",\n\t\"cupdot\": \"\",\n\t\"cupor\": \"\",\n\t\"cups\": \"\",\n\t\"curarr\": \"\",\n\t\"curarrm\": \"\",\n\t\"curlyeqprec\": \"\",\n\t\"curlyeqsucc\": \"\",\n\t\"curlyvee\": \"\",\n\t\"curlywedge\": \"\",\n\t\"curren\": \"\",\n\t\"curvearrowleft\": \"\",\n\t\"curvearrowright\": \"\",\n\t\"cuvee\": \"\",\n\t\"cuwed\": \"\",\n\t\"cwconint\": \"\",\n\t\"cwint\": \"\",\n\t\"cylcty\": \"\",\n\t\"dagger\": \"\",\n\t\"Dagger\": \"\",\n\t\"daleth\": \"\",\n\t\"darr\": \"\",\n\t\"Darr\": \"\",\n\t\"dArr\": \"\",\n\t\"dash\": \"\",\n\t\"Dashv\": \"\",\n\t\"dashv\": \"\",\n\t\"dbkarow\": \"\",\n\t\"dblac\": \"\",\n\t\"Dcaron\": \"\",\n\t\"dcaron\": \"\",\n\t\"Dcy\": \"\",\n\t\"dcy\": \"\",\n\t\"ddagger\": \"\",\n\t\"ddarr\": \"\",\n\t\"DD\": \"\",\n\t\"dd\": \"\",\n\t\"DDotrahd\": \"\",\n\t\"ddotseq\": \"\",\n\t\"deg\": \"\",\n\t\"Del\": \"\",\n\t\"Delta\": \"\",\n\t\"delta\": \"\",\n\t\"demptyv\": \"\",\n\t\"dfisht\": \"\",\n\t\"Dfr\": \"\",\n\t\"dfr\": \"\",\n\t\"dHar\": \"\",\n\t\"dharl\": \"\",\n\t\"dharr\": \"\",\n\t\"DiacriticalAcute\": \"\",\n\t\"DiacriticalDot\": \"\",\n\t\"DiacriticalDoubleAcute\": \"\",\n\t\"DiacriticalGrave\": \"`\",\n\t\"DiacriticalTilde\": \"\",\n\t\"diam\": \"\",\n\t\"diamond\": \"\",\n\t\"Diamond\": \"\",\n\t\"diamondsuit\": \"\",\n\t\"diams\": \"\",\n\t\"die\": \"\",\n\t\"DifferentialD\": \"\",\n\t\"digamma\": \"\",\n\t\"disin\": \"\",\n\t\"div\": \"\",\n\t\"divide\": \"\",\n\t\"divideontimes\": \"\",\n\t\"divonx\": \"\",\n\t\"DJcy\": \"\",\n\t\"djcy\": \"\",\n\t\"dlcorn\": \"\",\n\t\"dlcrop\": \"\",\n\t\"dollar\": \"$\",\n\t\"Dopf\": \"\",\n\t\"dopf\": \"\",\n\t\"Dot\": \"\",\n\t\"dot\": \"\",\n\t\"DotDot\": \"\",\n\t\"doteq\": \"\",\n\t\"doteqdot\": \"\",\n\t\"DotEqual\": \"\",\n\t\"dotminus\": \"\",\n\t\"dotplus\": \"\",\n\t\"dotsquare\": \"\",\n\t\"doublebarwedge\": \"\",\n\t\"DoubleContourIntegral\": \"\",\n\t\"DoubleDot\": \"\",\n\t\"DoubleDownArrow\": \"\",\n\t\"DoubleLeftArrow\": \"\",\n\t\"DoubleLeftRightArrow\": \"\",\n\t\"DoubleLeftTee\": \"\",\n\t\"DoubleLongLeftArrow\": \"\",\n\t\"DoubleLongLeftRightArrow\": \"\",\n\t\"DoubleLongRightArrow\": \"\",\n\t\"DoubleRightArrow\": \"\",\n\t\"DoubleRightTee\": \"\",\n\t\"DoubleUpArrow\": \"\",\n\t\"DoubleUpDownArrow\": \"\",\n\t\"DoubleVerticalBar\": \"\",\n\t\"DownArrowBar\": \"\",\n\t\"downarrow\": \"\",\n\t\"DownArrow\": \"\",\n\t\"Downarrow\": \"\",\n\t\"DownArrowUpArrow\": \"\",\n\t\"DownBreve\": \"\",\n\t\"downdownarrows\": \"\",\n\t\"downharpoonleft\": \"\",\n\t\"downharpoonright\": \"\",\n\t\"DownLeftRightVector\": \"\",\n\t\"DownLeftTeeVector\": \"\",\n\t\"DownLeftVectorBar\": \"\",\n\t\"DownLeftVector\": \"\",\n\t\"DownRightTeeVector\": \"\",\n\t\"DownRightVectorBar\": \"\",\n\t\"DownRightVector\": \"\",\n\t\"DownTeeArrow\": \"\",\n\t\"DownTee\": \"\",\n\t\"drbkarow\": \"\",\n\t\"drcorn\": \"\",\n\t\"drcrop\": \"\",\n\t\"Dscr\": \"\",\n\t\"dscr\": \"\",\n\t\"DScy\": \"\",\n\t\"dscy\": \"\",\n\t\"dsol\": \"\",\n\t\"Dstrok\": \"\",\n\t\"dstrok\": \"\",\n\t\"dtdot\": \"\",\n\t\"dtri\": \"\",\n\t\"dtrif\": \"\",\n\t\"duarr\": \"\",\n\t\"duhar\": \"\",\n\t\"dwangle\": \"\",\n\t\"DZcy\": \"\",\n\t\"dzcy\": \"\",\n\t\"dzigrarr\": \"\",\n\t\"Eacute\": \"\",\n\t\"eacute\": \"\",\n\t\"easter\": \"\",\n\t\"Ecaron\": \"\",\n\t\"ecaron\": \"\",\n\t\"Ecirc\": \"\",\n\t\"ecirc\": \"\",\n\t\"ecir\": \"\",\n\t\"ecolon\": \"\",\n\t\"Ecy\": \"\",\n\t\"ecy\": \"\",\n\t\"eDDot\": \"\",\n\t\"Edot\": \"\",\n\t\"edot\": \"\",\n\t\"eDot\": \"\",\n\t\"ee\": \"\",\n\t\"efDot\": \"\",\n\t\"Efr\": \"\",\n\t\"efr\": \"\",\n\t\"eg\": \"\",\n\t\"Egrave\": \"\",\n\t\"egrave\": \"\",\n\t\"egs\": \"\",\n\t\"egsdot\": \"\",\n\t\"el\": \"\",\n\t\"Element\": \"\",\n\t\"elinters\": \"\",\n\t\"ell\": \"\",\n\t\"els\": \"\",\n\t\"elsdot\": \"\",\n\t\"Emacr\": \"\",\n\t\"emacr\": \"\",\n\t\"empty\": \"\",\n\t\"emptyset\": \"\",\n\t\"EmptySmallSquare\": \"\",\n\t\"emptyv\": \"\",\n\t\"EmptyVerySmallSquare\": \"\",\n\t\"emsp13\": \"\",\n\t\"emsp14\": \"\",\n\t\"emsp\": \"\",\n\t\"ENG\": \"\",\n\t\"eng\": \"\",\n\t\"ensp\": \"\",\n\t\"Eogon\": \"\",\n\t\"eogon\": \"\",\n\t\"Eopf\": \"\",\n\t\"eopf\": \"\",\n\t\"epar\": \"\",\n\t\"eparsl\": \"\",\n\t\"eplus\": \"\",\n\t\"epsi\": \"\",\n\t\"Epsilon\": \"\",\n\t\"epsilon\": \"\",\n\t\"epsiv\": \"\",\n\t\"eqcirc\": \"\",\n\t\"eqcolon\": \"\",\n\t\"eqsim\": \"\",\n\t\"eqslantgtr\": \"\",\n\t\"eqslantless\": \"\",\n\t\"Equal\": \"\",\n\t\"equals\": \"=\",\n\t\"EqualTilde\": \"\",\n\t\"equest\": \"\",\n\t\"Equilibrium\": \"\",\n\t\"equiv\": \"\",\n\t\"equivDD\": \"\",\n\t\"eqvparsl\": \"\",\n\t\"erarr\": \"\",\n\t\"erDot\": \"\",\n\t\"escr\": \"\",\n\t\"Escr\": \"\",\n\t\"esdot\": \"\",\n\t\"Esim\": \"\",\n\t\"esim\": \"\",\n\t\"Eta\": \"\",\n\t\"eta\": \"\",\n\t\"ETH\": \"\",\n\t\"eth\": \"\",\n\t\"Euml\": \"\",\n\t\"euml\": \"\",\n\t\"euro\": \"\",\n\t\"excl\": \"!\",\n\t\"exist\": \"\",\n\t\"Exists\": \"\",\n\t\"expectation\": \"\",\n\t\"exponentiale\": \"\",\n\t\"ExponentialE\": \"\",\n\t\"fallingdotseq\": \"\",\n\t\"Fcy\": \"\",\n\t\"fcy\": \"\",\n\t\"female\": \"\",\n\t\"ffilig\": \"\",\n\t\"fflig\": \"\",\n\t\"ffllig\": \"\",\n\t\"Ffr\": \"\",\n\t\"ffr\": \"\",\n\t\"filig\": \"\",\n\t\"FilledSmallSquare\": \"\",\n\t\"FilledVerySmallSquare\": \"\",\n\t\"fjlig\": \"fj\",\n\t\"flat\": \"\",\n\t\"fllig\": \"\",\n\t\"fltns\": \"\",\n\t\"fnof\": \"\",\n\t\"Fopf\": \"\",\n\t\"fopf\": \"\",\n\t\"forall\": \"\",\n\t\"ForAll\": \"\",\n\t\"fork\": \"\",\n\t\"forkv\": \"\",\n\t\"Fouriertrf\": \"\",\n\t\"fpartint\": \"\",\n\t\"frac12\": \"\",\n\t\"frac13\": \"\",\n\t\"frac14\": \"\",\n\t\"frac15\": \"\",\n\t\"frac16\": \"\",\n\t\"frac18\": \"\",\n\t\"frac23\": \"\",\n\t\"frac25\": \"\",\n\t\"frac34\": \"\",\n\t\"frac35\": \"\",\n\t\"frac38\": \"\",\n\t\"frac45\": \"\",\n\t\"frac56\": \"\",\n\t\"frac58\": \"\",\n\t\"frac78\": \"\",\n\t\"frasl\": \"\",\n\t\"frown\": \"\",\n\t\"fscr\": \"\",\n\t\"Fscr\": \"\",\n\t\"gacute\": \"\",\n\t\"Gamma\": \"\",\n\t\"gamma\": \"\",\n\t\"Gammad\": \"\",\n\t\"gammad\": \"\",\n\t\"gap\": \"\",\n\t\"Gbreve\": \"\",\n\t\"gbreve\": \"\",\n\t\"Gcedil\": \"\",\n\t\"Gcirc\": \"\",\n\t\"gcirc\": \"\",\n\t\"Gcy\": \"\",\n\t\"gcy\": \"\",\n\t\"Gdot\": \"\",\n\t\"gdot\": \"\",\n\t\"ge\": \"\",\n\t\"gE\": \"\",\n\t\"gEl\": \"\",\n\t\"gel\": \"\",\n\t\"geq\": \"\",\n\t\"geqq\": \"\",\n\t\"geqslant\": \"\",\n\t\"gescc\": \"\",\n\t\"ges\": \"\",\n\t\"gesdot\": \"\",\n\t\"gesdoto\": \"\",\n\t\"gesdotol\": \"\",\n\t\"gesl\": \"\",\n\t\"gesles\": \"\",\n\t\"Gfr\": \"\",\n\t\"gfr\": \"\",\n\t\"gg\": \"\",\n\t\"Gg\": \"\",\n\t\"ggg\": \"\",\n\t\"gimel\": \"\",\n\t\"GJcy\": \"\",\n\t\"gjcy\": \"\",\n\t\"gla\": \"\",\n\t\"gl\": \"\",\n\t\"glE\": \"\",\n\t\"glj\": \"\",\n\t\"gnap\": \"\",\n\t\"gnapprox\": \"\",\n\t\"gne\": \"\",\n\t\"gnE\": \"\",\n\t\"gneq\": \"\",\n\t\"gneqq\": \"\",\n\t\"gnsim\": \"\",\n\t\"Gopf\": \"\",\n\t\"gopf\": \"\",\n\t\"grave\": \"`\",\n\t\"GreaterEqual\": \"\",\n\t\"GreaterEqualLess\": \"\",\n\t\"GreaterFullEqual\": \"\",\n\t\"GreaterGreater\": \"\",\n\t\"GreaterLess\": \"\",\n\t\"GreaterSlantEqual\": \"\",\n\t\"GreaterTilde\": \"\",\n\t\"Gscr\": \"\",\n\t\"gscr\": \"\",\n\t\"gsim\": \"\",\n\t\"gsime\": \"\",\n\t\"gsiml\": \"\",\n\t\"gtcc\": \"\",\n\t\"gtcir\": \"\",\n\t\"gt\": \">\",\n\t\"GT\": \">\",\n\t\"Gt\": \"\",\n\t\"gtdot\": \"\",\n\t\"gtlPar\": \"\",\n\t\"gtquest\": \"\",\n\t\"gtrapprox\": \"\",\n\t\"gtrarr\": \"\",\n\t\"gtrdot\": \"\",\n\t\"gtreqless\": \"\",\n\t\"gtreqqless\": \"\",\n\t\"gtrless\": \"\",\n\t\"gtrsim\": \"\",\n\t\"gvertneqq\": \"\",\n\t\"gvnE\": \"\",\n\t\"Hacek\": \"\",\n\t\"hairsp\": \"\",\n\t\"half\": \"\",\n\t\"hamilt\": \"\",\n\t\"HARDcy\": \"\",\n\t\"hardcy\": \"\",\n\t\"harrcir\": \"\",\n\t\"harr\": \"\",\n\t\"hArr\": \"\",\n\t\"harrw\": \"\",\n\t\"Hat\": \"^\",\n\t\"hbar\": \"\",\n\t\"Hcirc\": \"\",\n\t\"hcirc\": \"\",\n\t\"hearts\": \"\",\n\t\"heartsuit\": \"\",\n\t\"hellip\": \"\",\n\t\"hercon\": \"\",\n\t\"hfr\": \"\",\n\t\"Hfr\": \"\",\n\t\"HilbertSpace\": \"\",\n\t\"hksearow\": \"\",\n\t\"hkswarow\": \"\",\n\t\"hoarr\": \"\",\n\t\"homtht\": \"\",\n\t\"hookleftarrow\": \"\",\n\t\"hookrightarrow\": \"\",\n\t\"hopf\": \"\",\n\t\"Hopf\": \"\",\n\t\"horbar\": \"\",\n\t\"HorizontalLine\": \"\",\n\t\"hscr\": \"\",\n\t\"Hscr\": \"\",\n\t\"hslash\": \"\",\n\t\"Hstrok\": \"\",\n\t\"hstrok\": \"\",\n\t\"HumpDownHump\": \"\",\n\t\"HumpEqual\": \"\",\n\t\"hybull\": \"\",\n\t\"hyphen\": \"\",\n\t\"Iacute\": \"\",\n\t\"iacute\": \"\",\n\t\"ic\": \"\",\n\t\"Icirc\": \"\",\n\t\"icirc\": \"\",\n\t\"Icy\": \"\",\n\t\"icy\": \"\",\n\t\"Idot\": \"\",\n\t\"IEcy\": \"\",\n\t\"iecy\": \"\",\n\t\"iexcl\": \"\",\n\t\"iff\": \"\",\n\t\"ifr\": \"\",\n\t\"Ifr\": \"\",\n\t\"Igrave\": \"\",\n\t\"igrave\": \"\",\n\t\"ii\": \"\",\n\t\"iiiint\": \"\",\n\t\"iiint\": \"\",\n\t\"iinfin\": \"\",\n\t\"iiota\": \"\",\n\t\"IJlig\": \"\",\n\t\"ijlig\": \"\",\n\t\"Imacr\": \"\",\n\t\"imacr\": \"\",\n\t\"image\": \"\",\n\t\"ImaginaryI\": \"\",\n\t\"imagline\": \"\",\n\t\"imagpart\": \"\",\n\t\"imath\": \"\",\n\t\"Im\": \"\",\n\t\"imof\": \"\",\n\t\"imped\": \"\",\n\t\"Implies\": \"\",\n\t\"incare\": \"\",\n\t\"in\": \"\",\n\t\"infin\": \"\",\n\t\"infintie\": \"\",\n\t\"inodot\": \"\",\n\t\"intcal\": \"\",\n\t\"int\": \"\",\n\t\"Int\": \"\",\n\t\"integers\": \"\",\n\t\"Integral\": \"\",\n\t\"intercal\": \"\",\n\t\"Intersection\": \"\",\n\t\"intlarhk\": \"\",\n\t\"intprod\": \"\",\n\t\"InvisibleComma\": \"\",\n\t\"InvisibleTimes\": \"\",\n\t\"IOcy\": \"\",\n\t\"iocy\": \"\",\n\t\"Iogon\": \"\",\n\t\"iogon\": \"\",\n\t\"Iopf\": \"\",\n\t\"iopf\": \"\",\n\t\"Iota\": \"\",\n\t\"iota\": \"\",\n\t\"iprod\": \"\",\n\t\"iquest\": \"\",\n\t\"iscr\": \"\",\n\t\"Iscr\": \"\",\n\t\"isin\": \"\",\n\t\"isindot\": \"\",\n\t\"isinE\": \"\",\n\t\"isins\": \"\",\n\t\"isinsv\": \"\",\n\t\"isinv\": \"\",\n\t\"it\": \"\",\n\t\"Itilde\": \"\",\n\t\"itilde\": \"\",\n\t\"Iukcy\": \"\",\n\t\"iukcy\": \"\",\n\t\"Iuml\": \"\",\n\t\"iuml\": \"\",\n\t\"Jcirc\": \"\",\n\t\"jcirc\": \"\",\n\t\"Jcy\": \"\",\n\t\"jcy\": \"\",\n\t\"Jfr\": \"\",\n\t\"jfr\": \"\",\n\t\"jmath\": \"\",\n\t\"Jopf\": \"\",\n\t\"jopf\": \"\",\n\t\"Jscr\": \"\",\n\t\"jscr\": \"\",\n\t\"Jsercy\": \"\",\n\t\"jsercy\": \"\",\n\t\"Jukcy\": \"\",\n\t\"jukcy\": \"\",\n\t\"Kappa\": \"\",\n\t\"kappa\": \"\",\n\t\"kappav\": \"\",\n\t\"Kcedil\": \"\",\n\t\"kcedil\": \"\",\n\t\"Kcy\": \"\",\n\t\"kcy\": \"\",\n\t\"Kfr\": \"\",\n\t\"kfr\": \"\",\n\t\"kgreen\": \"\",\n\t\"KHcy\": \"\",\n\t\"khcy\": \"\",\n\t\"KJcy\": \"\",\n\t\"kjcy\": \"\",\n\t\"Kopf\": \"\",\n\t\"kopf\": \"\",\n\t\"Kscr\": \"\",\n\t\"kscr\": \"\",\n\t\"lAarr\": \"\",\n\t\"Lacute\": \"\",\n\t\"lacute\": \"\",\n\t\"laemptyv\": \"\",\n\t\"lagran\": \"\",\n\t\"Lambda\": \"\",\n\t\"lambda\": \"\",\n\t\"lang\": \"\",\n\t\"Lang\": \"\",\n\t\"langd\": \"\",\n\t\"langle\": \"\",\n\t\"lap\": \"\",\n\t\"Laplacetrf\": \"\",\n\t\"laquo\": \"\",\n\t\"larrb\": \"\",\n\t\"larrbfs\": \"\",\n\t\"larr\": \"\",\n\t\"Larr\": \"\",\n\t\"lArr\": \"\",\n\t\"larrfs\": \"\",\n\t\"larrhk\": \"\",\n\t\"larrlp\": \"\",\n\t\"larrpl\": \"\",\n\t\"larrsim\": \"\",\n\t\"larrtl\": \"\",\n\t\"latail\": \"\",\n\t\"lAtail\": \"\",\n\t\"lat\": \"\",\n\t\"late\": \"\",\n\t\"lates\": \"\",\n\t\"lbarr\": \"\",\n\t\"lBarr\": \"\",\n\t\"lbbrk\": \"\",\n\t\"lbrace\": \"{\",\n\t\"lbrack\": \"[\",\n\t\"lbrke\": \"\",\n\t\"lbrksld\": \"\",\n\t\"lbrkslu\": \"\",\n\t\"Lcaron\": \"\",\n\t\"lcaron\": \"\",\n\t\"Lcedil\": \"\",\n\t\"lcedil\": \"\",\n\t\"lceil\": \"\",\n\t\"lcub\": \"{\",\n\t\"Lcy\": \"\",\n\t\"lcy\": \"\",\n\t\"ldca\": \"\",\n\t\"ldquo\": \"\",\n\t\"ldquor\": \"\",\n\t\"ldrdhar\": \"\",\n\t\"ldrushar\": \"\",\n\t\"ldsh\": \"\",\n\t\"le\": \"\",\n\t\"lE\": \"\",\n\t\"LeftAngleBracket\": \"\",\n\t\"LeftArrowBar\": \"\",\n\t\"leftarrow\": \"\",\n\t\"LeftArrow\": \"\",\n\t\"Leftarrow\": \"\",\n\t\"LeftArrowRightArrow\": \"\",\n\t\"leftarrowtail\": \"\",\n\t\"LeftCeiling\": \"\",\n\t\"LeftDoubleBracket\": \"\",\n\t\"LeftDownTeeVector\": \"\",\n\t\"LeftDownVectorBar\": \"\",\n\t\"LeftDownVector\": \"\",\n\t\"LeftFloor\": \"\",\n\t\"leftharpoondown\": \"\",\n\t\"leftharpoonup\": \"\",\n\t\"leftleftarrows\": \"\",\n\t\"leftrightarrow\": \"\",\n\t\"LeftRightArrow\": \"\",\n\t\"Leftrightarrow\": \"\",\n\t\"leftrightarrows\": \"\",\n\t\"leftrightharpoons\": \"\",\n\t\"leftrightsquigarrow\": \"\",\n\t\"LeftRightVector\": \"\",\n\t\"LeftTeeArrow\": \"\",\n\t\"LeftTee\": \"\",\n\t\"LeftTeeVector\": \"\",\n\t\"leftthreetimes\": \"\",\n\t\"LeftTriangleBar\": \"\",\n\t\"LeftTriangle\": \"\",\n\t\"LeftTriangleEqual\": \"\",\n\t\"LeftUpDownVector\": \"\",\n\t\"LeftUpTeeVector\": \"\",\n\t\"LeftUpVectorBar\": \"\",\n\t\"LeftUpVector\": \"\",\n\t\"LeftVectorBar\": \"\",\n\t\"LeftVector\": \"\",\n\t\"lEg\": \"\",\n\t\"leg\": \"\",\n\t\"leq\": \"\",\n\t\"leqq\": \"\",\n\t\"leqslant\": \"\",\n\t\"lescc\": \"\",\n\t\"les\": \"\",\n\t\"lesdot\": \"\",\n\t\"lesdoto\": \"\",\n\t\"lesdotor\": \"\",\n\t\"lesg\": \"\",\n\t\"lesges\": \"\",\n\t\"lessapprox\": \"\",\n\t\"lessdot\": \"\",\n\t\"lesseqgtr\": \"\",\n\t\"lesseqqgtr\": \"\",\n\t\"LessEqualGreater\": \"\",\n\t\"LessFullEqual\": \"\",\n\t\"LessGreater\": \"\",\n\t\"lessgtr\": \"\",\n\t\"LessLess\": \"\",\n\t\"lesssim\": \"\",\n\t\"LessSlantEqual\": \"\",\n\t\"LessTilde\": \"\",\n\t\"lfisht\": \"\",\n\t\"lfloor\": \"\",\n\t\"Lfr\": \"\",\n\t\"lfr\": \"\",\n\t\"lg\": \"\",\n\t\"lgE\": \"\",\n\t\"lHar\": \"\",\n\t\"lhard\": \"\",\n\t\"lharu\": \"\",\n\t\"lharul\": \"\",\n\t\"lhblk\": \"\",\n\t\"LJcy\": \"\",\n\t\"ljcy\": \"\",\n\t\"llarr\": \"\",\n\t\"ll\": \"\",\n\t\"Ll\": \"\",\n\t\"llcorner\": \"\",\n\t\"Lleftarrow\": \"\",\n\t\"llhard\": \"\",\n\t\"lltri\": \"\",\n\t\"Lmidot\": \"\",\n\t\"lmidot\": \"\",\n\t\"lmoustache\": \"\",\n\t\"lmoust\": \"\",\n\t\"lnap\": \"\",\n\t\"lnapprox\": \"\",\n\t\"lne\": \"\",\n\t\"lnE\": \"\",\n\t\"lneq\": \"\",\n\t\"lneqq\": \"\",\n\t\"lnsim\": \"\",\n\t\"loang\": \"\",\n\t\"loarr\": \"\",\n\t\"lobrk\": \"\",\n\t\"longleftarrow\": \"\",\n\t\"LongLeftArrow\": \"\",\n\t\"Longleftarrow\": \"\",\n\t\"longleftrightarrow\": \"\",\n\t\"LongLeftRightArrow\": \"\",\n\t\"Longleftrightarrow\": \"\",\n\t\"longmapsto\": \"\",\n\t\"longrightarrow\": \"\",\n\t\"LongRightArrow\": \"\",\n\t\"Longrightarrow\": \"\",\n\t\"looparrowleft\": \"\",\n\t\"looparrowright\": \"\",\n\t\"lopar\": \"\",\n\t\"Lopf\": \"\",\n\t\"lopf\": \"\",\n\t\"loplus\": \"\",\n\t\"lotimes\": \"\",\n\t\"lowast\": \"\",\n\t\"lowbar\": \"_\",\n\t\"LowerLeftArrow\": \"\",\n\t\"LowerRightArrow\": \"\",\n\t\"loz\": \"\",\n\t\"lozenge\": \"\",\n\t\"lozf\": \"\",\n\t\"lpar\": \"(\",\n\t\"lparlt\": \"\",\n\t\"lrarr\": \"\",\n\t\"lrcorner\": \"\",\n\t\"lrhar\": \"\",\n\t\"lrhard\": \"\",\n\t\"lrm\": \"\",\n\t\"lrtri\": \"\",\n\t\"lsaquo\": \"\",\n\t\"lscr\": \"\",\n\t\"Lscr\": \"\",\n\t\"lsh\": \"\",\n\t\"Lsh\": \"\",\n\t\"lsim\": \"\",\n\t\"lsime\": \"\",\n\t\"lsimg\": \"\",\n\t\"lsqb\": \"[\",\n\t\"lsquo\": \"\",\n\t\"lsquor\": \"\",\n\t\"Lstrok\": \"\",\n\t\"lstrok\": \"\",\n\t\"ltcc\": \"\",\n\t\"ltcir\": \"\",\n\t\"lt\": \"<\",\n\t\"LT\": \"<\",\n\t\"Lt\": \"\",\n\t\"ltdot\": \"\",\n\t\"lthree\": \"\",\n\t\"ltimes\": \"\",\n\t\"ltlarr\": \"\",\n\t\"ltquest\": \"\",\n\t\"ltri\": \"\",\n\t\"ltrie\": \"\",\n\t\"ltrif\": \"\",\n\t\"ltrPar\": \"\",\n\t\"lurdshar\": \"\",\n\t\"luruhar\": \"\",\n\t\"lvertneqq\": \"\",\n\t\"lvnE\": \"\",\n\t\"macr\": \"\",\n\t\"male\": \"\",\n\t\"malt\": \"\",\n\t\"maltese\": \"\",\n\t\"Map\": \"\",\n\t\"map\": \"\",\n\t\"mapsto\": \"\",\n\t\"mapstodown\": \"\",\n\t\"mapstoleft\": \"\",\n\t\"mapstoup\": \"\",\n\t\"marker\": \"\",\n\t\"mcomma\": \"\",\n\t\"Mcy\": \"\",\n\t\"mcy\": \"\",\n\t\"mdash\": \"\",\n\t\"mDDot\": \"\",\n\t\"measuredangle\": \"\",\n\t\"MediumSpace\": \"\",\n\t\"Mellintrf\": \"\",\n\t\"Mfr\": \"\",\n\t\"mfr\": \"\",\n\t\"mho\": \"\",\n\t\"micro\": \"\",\n\t\"midast\": \"*\",\n\t\"midcir\": \"\",\n\t\"mid\": \"\",\n\t\"middot\": \"\",\n\t\"minusb\": \"\",\n\t\"minus\": \"\",\n\t\"minusd\": \"\",\n\t\"minusdu\": \"\",\n\t\"MinusPlus\": \"\",\n\t\"mlcp\": \"\",\n\t\"mldr\": \"\",\n\t\"mnplus\": \"\",\n\t\"models\": \"\",\n\t\"Mopf\": \"\",\n\t\"mopf\": \"\",\n\t\"mp\": \"\",\n\t\"mscr\": \"\",\n\t\"Mscr\": \"\",\n\t\"mstpos\": \"\",\n\t\"Mu\": \"\",\n\t\"mu\": \"\",\n\t\"multimap\": \"\",\n\t\"mumap\": \"\",\n\t\"nabla\": \"\",\n\t\"Nacute\": \"\",\n\t\"nacute\": \"\",\n\t\"nang\": \"\",\n\t\"nap\": \"\",\n\t\"napE\": \"\",\n\t\"napid\": \"\",\n\t\"napos\": \"\",\n\t\"napprox\": \"\",\n\t\"natural\": \"\",\n\t\"naturals\": \"\",\n\t\"natur\": \"\",\n\t\"nbsp\": \"\",\n\t\"nbump\": \"\",\n\t\"nbumpe\": \"\",\n\t\"ncap\": \"\",\n\t\"Ncaron\": \"\",\n\t\"ncaron\": \"\",\n\t\"Ncedil\": \"\",\n\t\"ncedil\": \"\",\n\t\"ncong\": \"\",\n\t\"ncongdot\": \"\",\n\t\"ncup\": \"\",\n\t\"Ncy\": \"\",\n\t\"ncy\": \"\",\n\t\"ndash\": \"\",\n\t\"nearhk\": \"\",\n\t\"nearr\": \"\",\n\t\"neArr\": \"\",\n\t\"nearrow\": \"\",\n\t\"ne\": \"\",\n\t\"nedot\": \"\",\n\t\"NegativeMediumSpace\": \"\",\n\t\"NegativeThickSpace\": \"\",\n\t\"NegativeThinSpace\": \"\",\n\t\"NegativeVeryThinSpace\": \"\",\n\t\"nequiv\": \"\",\n\t\"nesear\": \"\",\n\t\"nesim\": \"\",\n\t\"NestedGreaterGreater\": \"\",\n\t\"NestedLessLess\": \"\",\n\t\"NewLine\": \"\\n\",\n\t\"nexist\": \"\",\n\t\"nexists\": \"\",\n\t\"Nfr\": \"\",\n\t\"nfr\": \"\",\n\t\"ngE\": \"\",\n\t\"nge\": \"\",\n\t\"ngeq\": \"\",\n\t\"ngeqq\": \"\",\n\t\"ngeqslant\": \"\",\n\t\"nges\": \"\",\n\t\"nGg\": \"\",\n\t\"ngsim\": \"\",\n\t\"nGt\": \"\",\n\t\"ngt\": \"\",\n\t\"ngtr\": \"\",\n\t\"nGtv\": \"\",\n\t\"nharr\": \"\",\n\t\"nhArr\": \"\",\n\t\"nhpar\": \"\",\n\t\"ni\": \"\",\n\t\"nis\": \"\",\n\t\"nisd\": \"\",\n\t\"niv\": \"\",\n\t\"NJcy\": \"\",\n\t\"njcy\": \"\",\n\t\"nlarr\": \"\",\n\t\"nlArr\": \"\",\n\t\"nldr\": \"\",\n\t\"nlE\": \"\",\n\t\"nle\": \"\",\n\t\"nleftarrow\": \"\",\n\t\"nLeftarrow\": \"\",\n\t\"nleftrightarrow\": \"\",\n\t\"nLeftrightarrow\": \"\",\n\t\"nleq\": \"\",\n\t\"nleqq\": \"\",\n\t\"nleqslant\": \"\",\n\t\"nles\": \"\",\n\t\"nless\": \"\",\n\t\"nLl\": \"\",\n\t\"nlsim\": \"\",\n\t\"nLt\": \"\",\n\t\"nlt\": \"\",\n\t\"nltri\": \"\",\n\t\"nltrie\": \"\",\n\t\"nLtv\": \"\",\n\t\"nmid\": \"\",\n\t\"NoBreak\": \"\",\n\t\"NonBreakingSpace\": \"\",\n\t\"nopf\": \"\",\n\t\"Nopf\": \"\",\n\t\"Not\": \"\",\n\t\"not\": \"\",\n\t\"NotCongruent\": \"\",\n\t\"NotCupCap\": \"\",\n\t\"NotDoubleVerticalBar\": \"\",\n\t\"NotElement\": \"\",\n\t\"NotEqual\": \"\",\n\t\"NotEqualTilde\": \"\",\n\t\"NotExists\": \"\",\n\t\"NotGreater\": \"\",\n\t\"NotGreaterEqual\": \"\",\n\t\"NotGreaterFullEqual\": \"\",\n\t\"NotGreaterGreater\": \"\",\n\t\"NotGreaterLess\": \"\",\n\t\"NotGreaterSlantEqual\": \"\",\n\t\"NotGreaterTilde\": \"\",\n\t\"NotHumpDownHump\": \"\",\n\t\"NotHumpEqual\": \"\",\n\t\"notin\": \"\",\n\t\"notindot\": \"\",\n\t\"notinE\": \"\",\n\t\"notinva\": \"\",\n\t\"notinvb\": \"\",\n\t\"notinvc\": \"\",\n\t\"NotLeftTriangleBar\": \"\",\n\t\"NotLeftTriangle\": \"\",\n\t\"NotLeftTriangleEqual\": \"\",\n\t\"NotLess\": \"\",\n\t\"NotLessEqual\": \"\",\n\t\"NotLessGreater\": \"\",\n\t\"NotLessLess\": \"\",\n\t\"NotLessSlantEqual\": \"\",\n\t\"NotLessTilde\": \"\",\n\t\"NotNestedGreaterGreater\": \"\",\n\t\"NotNestedLessLess\": \"\",\n\t\"notni\": \"\",\n\t\"notniva\": \"\",\n\t\"notnivb\": \"\",\n\t\"notnivc\": \"\",\n\t\"NotPrecedes\": \"\",\n\t\"NotPrecedesEqual\": \"\",\n\t\"NotPrecedesSlantEqual\": \"\",\n\t\"NotReverseElement\": \"\",\n\t\"NotRightTriangleBar\": \"\",\n\t\"NotRightTriangle\": \"\",\n\t\"NotRightTriangleEqual\": \"\",\n\t\"NotSquareSubset\": \"\",\n\t\"NotSquareSubsetEqual\": \"\",\n\t\"NotSquareSuperset\": \"\",\n\t\"NotSquareSupersetEqual\": \"\",\n\t\"NotSubset\": \"\",\n\t\"NotSubsetEqual\": \"\",\n\t\"NotSucceeds\": \"\",\n\t\"NotSucceedsEqual\": \"\",\n\t\"NotSucceedsSlantEqual\": \"\",\n\t\"NotSucceedsTilde\": \"\",\n\t\"NotSuperset\": \"\",\n\t\"NotSupersetEqual\": \"\",\n\t\"NotTilde\": \"\",\n\t\"NotTildeEqual\": \"\",\n\t\"NotTildeFullEqual\": \"\",\n\t\"NotTildeTilde\": \"\",\n\t\"NotVerticalBar\": \"\",\n\t\"nparallel\": \"\",\n\t\"npar\": \"\",\n\t\"nparsl\": \"\",\n\t\"npart\": \"\",\n\t\"npolint\": \"\",\n\t\"npr\": \"\",\n\t\"nprcue\": \"\",\n\t\"nprec\": \"\",\n\t\"npreceq\": \"\",\n\t\"npre\": \"\",\n\t\"nrarrc\": \"\",\n\t\"nrarr\": \"\",\n\t\"nrArr\": \"\",\n\t\"nrarrw\": \"\",\n\t\"nrightarrow\": \"\",\n\t\"nRightarrow\": \"\",\n\t\"nrtri\": \"\",\n\t\"nrtrie\": \"\",\n\t\"nsc\": \"\",\n\t\"nsccue\": \"\",\n\t\"nsce\": \"\",\n\t\"Nscr\": \"\",\n\t\"nscr\": \"\",\n\t\"nshortmid\": \"\",\n\t\"nshortparallel\": \"\",\n\t\"nsim\": \"\",\n\t\"nsime\": \"\",\n\t\"nsimeq\": \"\",\n\t\"nsmid\": \"\",\n\t\"nspar\": \"\",\n\t\"nsqsube\": \"\",\n\t\"nsqsupe\": \"\",\n\t\"nsub\": \"\",\n\t\"nsubE\": \"\",\n\t\"nsube\": \"\",\n\t\"nsubset\": \"\",\n\t\"nsubseteq\": \"\",\n\t\"nsubseteqq\": \"\",\n\t\"nsucc\": \"\",\n\t\"nsucceq\": \"\",\n\t\"nsup\": \"\",\n\t\"nsupE\": \"\",\n\t\"nsupe\": \"\",\n\t\"nsupset\": \"\",\n\t\"nsupseteq\": \"\",\n\t\"nsupseteqq\": \"\",\n\t\"ntgl\": \"\",\n\t\"Ntilde\": \"\",\n\t\"ntilde\": \"\",\n\t\"ntlg\": \"\",\n\t\"ntriangleleft\": \"\",\n\t\"ntrianglelefteq\": \"\",\n\t\"ntriangleright\": \"\",\n\t\"ntrianglerighteq\": \"\",\n\t\"Nu\": \"\",\n\t\"nu\": \"\",\n\t\"num\": \"#\",\n\t\"numero\": \"\",\n\t\"numsp\": \"\",\n\t\"nvap\": \"\",\n\t\"nvdash\": \"\",\n\t\"nvDash\": \"\",\n\t\"nVdash\": \"\",\n\t\"nVDash\": \"\",\n\t\"nvge\": \"\",\n\t\"nvgt\": \">\",\n\t\"nvHarr\": \"\",\n\t\"nvinfin\": \"\",\n\t\"nvlArr\": \"\",\n\t\"nvle\": \"\",\n\t\"nvlt\": \"<\",\n\t\"nvltrie\": \"\",\n\t\"nvrArr\": \"\",\n\t\"nvrtrie\": \"\",\n\t\"nvsim\": \"\",\n\t\"nwarhk\": \"\",\n\t\"nwarr\": \"\",\n\t\"nwArr\": \"\",\n\t\"nwarrow\": \"\",\n\t\"nwnear\": \"\",\n\t\"Oacute\": \"\",\n\t\"oacute\": \"\",\n\t\"oast\": \"\",\n\t\"Ocirc\": \"\",\n\t\"ocirc\": \"\",\n\t\"ocir\": \"\",\n\t\"Ocy\": \"\",\n\t\"ocy\": \"\",\n\t\"odash\": \"\",\n\t\"Odblac\": \"\",\n\t\"odblac\": \"\",\n\t\"odiv\": \"\",\n\t\"odot\": \"\",\n\t\"odsold\": \"\",\n\t\"OElig\": \"\",\n\t\"oelig\": \"\",\n\t\"ofcir\": \"\",\n\t\"Ofr\": \"\",\n\t\"ofr\": \"\",\n\t\"ogon\": \"\",\n\t\"Ograve\": \"\",\n\t\"ograve\": \"\",\n\t\"ogt\": \"\",\n\t\"ohbar\": \"\",\n\t\"ohm\": \"\",\n\t\"oint\": \"\",\n\t\"olarr\": \"\",\n\t\"olcir\": \"\",\n\t\"olcross\": \"\",\n\t\"oline\": \"\",\n\t\"olt\": \"\",\n\t\"Omacr\": \"\",\n\t\"omacr\": \"\",\n\t\"Omega\": \"\",\n\t\"omega\": \"\",\n\t\"Omicron\": \"\",\n\t\"omicron\": \"\",\n\t\"omid\": \"\",\n\t\"ominus\": \"\",\n\t\"Oopf\": \"\",\n\t\"oopf\": \"\",\n\t\"opar\": \"\",\n\t\"OpenCurlyDoubleQuote\": \"\",\n\t\"OpenCurlyQuote\": \"\",\n\t\"operp\": \"\",\n\t\"oplus\": \"\",\n\t\"orarr\": \"\",\n\t\"Or\": \"\",\n\t\"or\": \"\",\n\t\"ord\": \"\",\n\t\"order\": \"\",\n\t\"orderof\": \"\",\n\t\"ordf\": \"\",\n\t\"ordm\": \"\",\n\t\"origof\": \"\",\n\t\"oror\": \"\",\n\t\"orslope\": \"\",\n\t\"orv\": \"\",\n\t\"oS\": \"\",\n\t\"Oscr\": \"\",\n\t\"oscr\": \"\",\n\t\"Oslash\": \"\",\n\t\"oslash\": \"\",\n\t\"osol\": \"\",\n\t\"Otilde\": \"\",\n\t\"otilde\": \"\",\n\t\"otimesas\": \"\",\n\t\"Otimes\": \"\",\n\t\"otimes\": \"\",\n\t\"Ouml\": \"\",\n\t\"ouml\": \"\",\n\t\"ovbar\": \"\",\n\t\"OverBar\": \"\",\n\t\"OverBrace\": \"\",\n\t\"OverBracket\": \"\",\n\t\"OverParenthesis\": \"\",\n\t\"para\": \"\",\n\t\"parallel\": \"\",\n\t\"par\": \"\",\n\t\"parsim\": \"\",\n\t\"parsl\": \"\",\n\t\"part\": \"\",\n\t\"PartialD\": \"\",\n\t\"Pcy\": \"\",\n\t\"pcy\": \"\",\n\t\"percnt\": \"%\",\n\t\"period\": \".\",\n\t\"permil\": \"\",\n\t\"perp\": \"\",\n\t\"pertenk\": \"\",\n\t\"Pfr\": \"\",\n\t\"pfr\": \"\",\n\t\"Phi\": \"\",\n\t\"phi\": \"\",\n\t\"phiv\": \"\",\n\t\"phmmat\": \"\",\n\t\"phone\": \"\",\n\t\"Pi\": \"\",\n\t\"pi\": \"\",\n\t\"pitchfork\": \"\",\n\t\"piv\": \"\",\n\t\"planck\": \"\",\n\t\"planckh\": \"\",\n\t\"plankv\": \"\",\n\t\"plusacir\": \"\",\n\t\"plusb\": \"\",\n\t\"pluscir\": \"\",\n\t\"plus\": \"+\",\n\t\"plusdo\": \"\",\n\t\"plusdu\": \"\",\n\t\"pluse\": \"\",\n\t\"PlusMinus\": \"\",\n\t\"plusmn\": \"\",\n\t\"plussim\": \"\",\n\t\"plustwo\": \"\",\n\t\"pm\": \"\",\n\t\"Poincareplane\": \"\",\n\t\"pointint\": \"\",\n\t\"popf\": \"\",\n\t\"Popf\": \"\",\n\t\"pound\": \"\",\n\t\"prap\": \"\",\n\t\"Pr\": \"\",\n\t\"pr\": \"\",\n\t\"prcue\": \"\",\n\t\"precapprox\": \"\",\n\t\"prec\": \"\",\n\t\"preccurlyeq\": \"\",\n\t\"Precedes\": \"\",\n\t\"PrecedesEqual\": \"\",\n\t\"PrecedesSlantEqual\": \"\",\n\t\"PrecedesTilde\": \"\",\n\t\"preceq\": \"\",\n\t\"precnapprox\": \"\",\n\t\"precneqq\": \"\",\n\t\"precnsim\": \"\",\n\t\"pre\": \"\",\n\t\"prE\": \"\",\n\t\"precsim\": \"\",\n\t\"prime\": \"\",\n\t\"Prime\": \"\",\n\t\"primes\": \"\",\n\t\"prnap\": \"\",\n\t\"prnE\": \"\",\n\t\"prnsim\": \"\",\n\t\"prod\": \"\",\n\t\"Product\": \"\",\n\t\"profalar\": \"\",\n\t\"profline\": \"\",\n\t\"profsurf\": \"\",\n\t\"prop\": \"\",\n\t\"Proportional\": \"\",\n\t\"Proportion\": \"\",\n\t\"propto\": \"\",\n\t\"prsim\": \"\",\n\t\"prurel\": \"\",\n\t\"Pscr\": \"\",\n\t\"pscr\": \"\",\n\t\"Psi\": \"\",\n\t\"psi\": \"\",\n\t\"puncsp\": \"\",\n\t\"Qfr\": \"\",\n\t\"qfr\": \"\",\n\t\"qint\": \"\",\n\t\"qopf\": \"\",\n\t\"Qopf\": \"\",\n\t\"qprime\": \"\",\n\t\"Qscr\": \"\",\n\t\"qscr\": \"\",\n\t\"quaternions\": \"\",\n\t\"quatint\": \"\",\n\t\"quest\": \"?\",\n\t\"questeq\": \"\",\n\t\"quot\": \"\\\"\",\n\t\"QUOT\": \"\\\"\",\n\t\"rAarr\": \"\",\n\t\"race\": \"\",\n\t\"Racute\": \"\",\n\t\"racute\": \"\",\n\t\"radic\": \"\",\n\t\"raemptyv\": \"\",\n\t\"rang\": \"\",\n\t\"Rang\": \"\",\n\t\"rangd\": \"\",\n\t\"range\": \"\",\n\t\"rangle\": \"\",\n\t\"raquo\": \"\",\n\t\"rarrap\": \"\",\n\t\"rarrb\": \"\",\n\t\"rarrbfs\": \"\",\n\t\"rarrc\": \"\",\n\t\"rarr\": \"\",\n\t\"Rarr\": \"\",\n\t\"rArr\": \"\",\n\t\"rarrfs\": \"\",\n\t\"rarrhk\": \"\",\n\t\"rarrlp\": \"\",\n\t\"rarrpl\": \"\",\n\t\"rarrsim\": \"\",\n\t\"Rarrtl\": \"\",\n\t\"rarrtl\": \"\",\n\t\"rarrw\": \"\",\n\t\"ratail\": \"\",\n\t\"rAtail\": \"\",\n\t\"ratio\": \"\",\n\t\"rationals\": \"\",\n\t\"rbarr\": \"\",\n\t\"rBarr\": \"\",\n\t\"RBarr\": \"\",\n\t\"rbbrk\": \"\",\n\t\"rbrace\": \"}\",\n\t\"rbrack\": \"]\",\n\t\"rbrke\": \"\",\n\t\"rbrksld\": \"\",\n\t\"rbrkslu\": \"\",\n\t\"Rcaron\": \"\",\n\t\"rcaron\": \"\",\n\t\"Rcedil\": \"\",\n\t\"rcedil\": \"\",\n\t\"rceil\": \"\",\n\t\"rcub\": \"}\",\n\t\"Rcy\": \"\",\n\t\"rcy\": \"\",\n\t\"rdca\": \"\",\n\t\"rdldhar\": \"\",\n\t\"rdquo\": \"\",\n\t\"rdquor\": \"\",\n\t\"rdsh\": \"\",\n\t\"real\": \"\",\n\t\"realine\": \"\",\n\t\"realpart\": \"\",\n\t\"reals\": \"\",\n\t\"Re\": \"\",\n\t\"rect\": \"\",\n\t\"reg\": \"\",\n\t\"REG\": \"\",\n\t\"ReverseElement\": \"\",\n\t\"ReverseEquilibrium\": \"\",\n\t\"ReverseUpEquilibrium\": \"\",\n\t\"rfisht\": \"\",\n\t\"rfloor\": \"\",\n\t\"rfr\": \"\",\n\t\"Rfr\": \"\",\n\t\"rHar\": \"\",\n\t\"rhard\": \"\",\n\t\"rharu\": \"\",\n\t\"rharul\": \"\",\n\t\"Rho\": \"\",\n\t\"rho\": \"\",\n\t\"rhov\": \"\",\n\t\"RightAngleBracket\": \"\",\n\t\"RightArrowBar\": \"\",\n\t\"rightarrow\": \"\",\n\t\"RightArrow\": \"\",\n\t\"Rightarrow\": \"\",\n\t\"RightArrowLeftArrow\": \"\",\n\t\"rightarrowtail\": \"\",\n\t\"RightCeiling\": \"\",\n\t\"RightDoubleBracket\": \"\",\n\t\"RightDownTeeVector\": \"\",\n\t\"RightDownVectorBar\": \"\",\n\t\"RightDownVector\": \"\",\n\t\"RightFloor\": \"\",\n\t\"rightharpoondown\": \"\",\n\t\"rightharpoonup\": \"\",\n\t\"rightleftarrows\": \"\",\n\t\"rightleftharpoons\": \"\",\n\t\"rightrightarrows\": \"\",\n\t\"rightsquigarrow\": \"\",\n\t\"RightTeeArrow\": \"\",\n\t\"RightTee\": \"\",\n\t\"RightTeeVector\": \"\",\n\t\"rightthreetimes\": \"\",\n\t\"RightTriangleBar\": \"\",\n\t\"RightTriangle\": \"\",\n\t\"RightTriangleEqual\": \"\",\n\t\"RightUpDownVector\": \"\",\n\t\"RightUpTeeVector\": \"\",\n\t\"RightUpVectorBar\": \"\",\n\t\"RightUpVector\": \"\",\n\t\"RightVectorBar\": \"\",\n\t\"RightVector\": \"\",\n\t\"ring\": \"\",\n\t\"risingdotseq\": \"\",\n\t\"rlarr\": \"\",\n\t\"rlhar\": \"\",\n\t\"rlm\": \"\",\n\t\"rmoustache\": \"\",\n\t\"rmoust\": \"\",\n\t\"rnmid\": \"\",\n\t\"roang\": \"\",\n\t\"roarr\": \"\",\n\t\"robrk\": \"\",\n\t\"ropar\": \"\",\n\t\"ropf\": \"\",\n\t\"Ropf\": \"\",\n\t\"roplus\": \"\",\n\t\"rotimes\": \"\",\n\t\"RoundImplies\": \"\",\n\t\"rpar\": \")\",\n\t\"rpargt\": \"\",\n\t\"rppolint\": \"\",\n\t\"rrarr\": \"\",\n\t\"Rrightarrow\": \"\",\n\t\"rsaquo\": \"\",\n\t\"rscr\": \"\",\n\t\"Rscr\": \"\",\n\t\"rsh\": \"\",\n\t\"Rsh\": \"\",\n\t\"rsqb\": \"]\",\n\t\"rsquo\": \"\",\n\t\"rsquor\": \"\",\n\t\"rthree\": \"\",\n\t\"rtimes\": \"\",\n\t\"rtri\": \"\",\n\t\"rtrie\": \"\",\n\t\"rtrif\": \"\",\n\t\"rtriltri\": \"\",\n\t\"RuleDelayed\": \"\",\n\t\"ruluhar\": \"\",\n\t\"rx\": \"\",\n\t\"Sacute\": \"\",\n\t\"sacute\": \"\",\n\t\"sbquo\": \"\",\n\t\"scap\": \"\",\n\t\"Scaron\": \"\",\n\t\"scaron\": \"\",\n\t\"Sc\": \"\",\n\t\"sc\": \"\",\n\t\"sccue\": \"\",\n\t\"sce\": \"\",\n\t\"scE\": \"\",\n\t\"Scedil\": \"\",\n\t\"scedil\": \"\",\n\t\"Scirc\": \"\",\n\t\"scirc\": \"\",\n\t\"scnap\": \"\",\n\t\"scnE\": \"\",\n\t\"scnsim\": \"\",\n\t\"scpolint\": \"\",\n\t\"scsim\": \"\",\n\t\"Scy\": \"\",\n\t\"scy\": \"\",\n\t\"sdotb\": \"\",\n\t\"sdot\": \"\",\n\t\"sdote\": \"\",\n\t\"searhk\": \"\",\n\t\"searr\": \"\",\n\t\"seArr\": \"\",\n\t\"searrow\": \"\",\n\t\"sect\": \"\",\n\t\"semi\": \";\",\n\t\"seswar\": \"\",\n\t\"setminus\": \"\",\n\t\"setmn\": \"\",\n\t\"sext\": \"\",\n\t\"Sfr\": \"\",\n\t\"sfr\": \"\",\n\t\"sfrown\": \"\",\n\t\"sharp\": \"\",\n\t\"SHCHcy\": \"\",\n\t\"shchcy\": \"\",\n\t\"SHcy\": \"\",\n\t\"shcy\": \"\",\n\t\"ShortDownArrow\": \"\",\n\t\"ShortLeftArrow\": \"\",\n\t\"shortmid\": \"\",\n\t\"shortparallel\": \"\",\n\t\"ShortRightArrow\": \"\",\n\t\"ShortUpArrow\": \"\",\n\t\"shy\": \"\",\n\t\"Sigma\": \"\",\n\t\"sigma\": \"\",\n\t\"sigmaf\": \"\",\n\t\"sigmav\": \"\",\n\t\"sim\": \"\",\n\t\"simdot\": \"\",\n\t\"sime\": \"\",\n\t\"simeq\": \"\",\n\t\"simg\": \"\",\n\t\"simgE\": \"\",\n\t\"siml\": \"\",\n\t\"simlE\": \"\",\n\t\"simne\": \"\",\n\t\"simplus\": \"\",\n\t\"simrarr\": \"\",\n\t\"slarr\": \"\",\n\t\"SmallCircle\": \"\",\n\t\"smallsetminus\": \"\",\n\t\"smashp\": \"\",\n\t\"smeparsl\": \"\",\n\t\"smid\": \"\",\n\t\"smile\": \"\",\n\t\"smt\": \"\",\n\t\"smte\": \"\",\n\t\"smtes\": \"\",\n\t\"SOFTcy\": \"\",\n\t\"softcy\": \"\",\n\t\"solbar\": \"\",\n\t\"solb\": \"\",\n\t\"sol\": \"/\",\n\t\"Sopf\": \"\",\n\t\"sopf\": \"\",\n\t\"spades\": \"\",\n\t\"spadesuit\": \"\",\n\t\"spar\": \"\",\n\t\"sqcap\": \"\",\n\t\"sqcaps\": \"\",\n\t\"sqcup\": \"\",\n\t\"sqcups\": \"\",\n\t\"Sqrt\": \"\",\n\t\"sqsub\": \"\",\n\t\"sqsube\": \"\",\n\t\"sqsubset\": \"\",\n\t\"sqsubseteq\": \"\",\n\t\"sqsup\": \"\",\n\t\"sqsupe\": \"\",\n\t\"sqsupset\": \"\",\n\t\"sqsupseteq\": \"\",\n\t\"square\": \"\",\n\t\"Square\": \"\",\n\t\"SquareIntersection\": \"\",\n\t\"SquareSubset\": \"\",\n\t\"SquareSubsetEqual\": \"\",\n\t\"SquareSuperset\": \"\",\n\t\"SquareSupersetEqual\": \"\",\n\t\"SquareUnion\": \"\",\n\t\"squarf\": \"\",\n\t\"squ\": \"\",\n\t\"squf\": \"\",\n\t\"srarr\": \"\",\n\t\"Sscr\": \"\",\n\t\"sscr\": \"\",\n\t\"ssetmn\": \"\",\n\t\"ssmile\": \"\",\n\t\"sstarf\": \"\",\n\t\"Star\": \"\",\n\t\"star\": \"\",\n\t\"starf\": \"\",\n\t\"straightepsilon\": \"\",\n\t\"straightphi\": \"\",\n\t\"strns\": \"\",\n\t\"sub\": \"\",\n\t\"Sub\": \"\",\n\t\"subdot\": \"\",\n\t\"subE\": \"\",\n\t\"sube\": \"\",\n\t\"subedot\": \"\",\n\t\"submult\": \"\",\n\t\"subnE\": \"\",\n\t\"subne\": \"\",\n\t\"subplus\": \"\",\n\t\"subrarr\": \"\",\n\t\"subset\": \"\",\n\t\"Subset\": \"\",\n\t\"subseteq\": \"\",\n\t\"subseteqq\": \"\",\n\t\"SubsetEqual\": \"\",\n\t\"subsetneq\": \"\",\n\t\"subsetneqq\": \"\",\n\t\"subsim\": \"\",\n\t\"subsub\": \"\",\n\t\"subsup\": \"\",\n\t\"succapprox\": \"\",\n\t\"succ\": \"\",\n\t\"succcurlyeq\": \"\",\n\t\"Succeeds\": \"\",\n\t\"SucceedsEqual\": \"\",\n\t\"SucceedsSlantEqual\": \"\",\n\t\"SucceedsTilde\": \"\",\n\t\"succeq\": \"\",\n\t\"succnapprox\": \"\",\n\t\"succneqq\": \"\",\n\t\"succnsim\": \"\",\n\t\"succsim\": \"\",\n\t\"SuchThat\": \"\",\n\t\"sum\": \"\",\n\t\"Sum\": \"\",\n\t\"sung\": \"\",\n\t\"sup1\": \"\",\n\t\"sup2\": \"\",\n\t\"sup3\": \"\",\n\t\"sup\": \"\",\n\t\"Sup\": \"\",\n\t\"supdot\": \"\",\n\t\"supdsub\": \"\",\n\t\"supE\": \"\",\n\t\"supe\": \"\",\n\t\"supedot\": \"\",\n\t\"Superset\": \"\",\n\t\"SupersetEqual\": \"\",\n\t\"suphsol\": \"\",\n\t\"suphsub\": \"\",\n\t\"suplarr\": \"\",\n\t\"supmult\": \"\",\n\t\"supnE\": \"\",\n\t\"supne\": \"\",\n\t\"supplus\": \"\",\n\t\"supset\": \"\",\n\t\"Supset\": \"\",\n\t\"supseteq\": \"\",\n\t\"supseteqq\": \"\",\n\t\"supsetneq\": \"\",\n\t\"supsetneqq\": \"\",\n\t\"supsim\": \"\",\n\t\"supsub\": \"\",\n\t\"supsup\": \"\",\n\t\"swarhk\": \"\",\n\t\"swarr\": \"\",\n\t\"swArr\": \"\",\n\t\"swarrow\": \"\",\n\t\"swnwar\": \"\",\n\t\"szlig\": \"\",\n\t\"Tab\": \"\\t\",\n\t\"target\": \"\",\n\t\"Tau\": \"\",\n\t\"tau\": \"\",\n\t\"tbrk\": \"\",\n\t\"Tcaron\": \"\",\n\t\"tcaron\": \"\",\n\t\"Tcedil\": \"\",\n\t\"tcedil\": \"\",\n\t\"Tcy\": \"\",\n\t\"tcy\": \"\",\n\t\"tdot\": \"\",\n\t\"telrec\": \"\",\n\t\"Tfr\": \"\",\n\t\"tfr\": \"\",\n\t\"there4\": \"\",\n\t\"therefore\": \"\",\n\t\"Therefore\": \"\",\n\t\"Theta\": \"\",\n\t\"theta\": \"\",\n\t\"thetasym\": \"\",\n\t\"thetav\": \"\",\n\t\"thickapprox\": \"\",\n\t\"thicksim\": \"\",\n\t\"ThickSpace\": \"\",\n\t\"ThinSpace\": \"\",\n\t\"thinsp\": \"\",\n\t\"thkap\": \"\",\n\t\"thksim\": \"\",\n\t\"THORN\": \"\",\n\t\"thorn\": \"\",\n\t\"tilde\": \"\",\n\t\"Tilde\": \"\",\n\t\"TildeEqual\": \"\",\n\t\"TildeFullEqual\": \"\",\n\t\"TildeTilde\": \"\",\n\t\"timesbar\": \"\",\n\t\"timesb\": \"\",\n\t\"times\": \"\",\n\t\"timesd\": \"\",\n\t\"tint\": \"\",\n\t\"toea\": \"\",\n\t\"topbot\": \"\",\n\t\"topcir\": \"\",\n\t\"top\": \"\",\n\t\"Topf\": \"\",\n\t\"topf\": \"\",\n\t\"topfork\": \"\",\n\t\"tosa\": \"\",\n\t\"tprime\": \"\",\n\t\"trade\": \"\",\n\t\"TRADE\": \"\",\n\t\"triangle\": \"\",\n\t\"triangledown\": \"\",\n\t\"triangleleft\": \"\",\n\t\"trianglelefteq\": \"\",\n\t\"triangleq\": \"\",\n\t\"triangleright\": \"\",\n\t\"trianglerighteq\": \"\",\n\t\"tridot\": \"\",\n\t\"trie\": \"\",\n\t\"triminus\": \"\",\n\t\"TripleDot\": \"\",\n\t\"triplus\": \"\",\n\t\"trisb\": \"\",\n\t\"tritime\": \"\",\n\t\"trpezium\": \"\",\n\t\"Tscr\": \"\",\n\t\"tscr\": \"\",\n\t\"TScy\": \"\",\n\t\"tscy\": \"\",\n\t\"TSHcy\": \"\",\n\t\"tshcy\": \"\",\n\t\"Tstrok\": \"\",\n\t\"tstrok\": \"\",\n\t\"twixt\": \"\",\n\t\"twoheadleftarrow\": \"\",\n\t\"twoheadrightarrow\": \"\",\n\t\"Uacute\": \"\",\n\t\"uacute\": \"\",\n\t\"uarr\": \"\",\n\t\"Uarr\": \"\",\n\t\"uArr\": \"\",\n\t\"Uarrocir\": \"\",\n\t\"Ubrcy\": \"\",\n\t\"ubrcy\": \"\",\n\t\"Ubreve\": \"\",\n\t\"ubreve\": \"\",\n\t\"Ucirc\": \"\",\n\t\"ucirc\": \"\",\n\t\"Ucy\": \"\",\n\t\"ucy\": \"\",\n\t\"udarr\": \"\",\n\t\"Udblac\": \"\",\n\t\"udblac\": \"\",\n\t\"udhar\": \"\",\n\t\"ufisht\": \"\",\n\t\"Ufr\": \"\",\n\t\"ufr\": \"\",\n\t\"Ugrave\": \"\",\n\t\"ugrave\": \"\",\n\t\"uHar\": \"\",\n\t\"uharl\": \"\",\n\t\"uharr\": \"\",\n\t\"uhblk\": \"\",\n\t\"ulcorn\": \"\",\n\t\"ulcorner\": \"\",\n\t\"ulcrop\": \"\",\n\t\"ultri\": \"\",\n\t\"Umacr\": \"\",\n\t\"umacr\": \"\",\n\t\"uml\": \"\",\n\t\"UnderBar\": \"_\",\n\t\"UnderBrace\": \"\",\n\t\"UnderBracket\": \"\",\n\t\"UnderParenthesis\": \"\",\n\t\"Union\": \"\",\n\t\"UnionPlus\": \"\",\n\t\"Uogon\": \"\",\n\t\"uogon\": \"\",\n\t\"Uopf\": \"\",\n\t\"uopf\": \"\",\n\t\"UpArrowBar\": \"\",\n\t\"uparrow\": \"\",\n\t\"UpArrow\": \"\",\n\t\"Uparrow\": \"\",\n\t\"UpArrowDownArrow\": \"\",\n\t\"updownarrow\": \"\",\n\t\"UpDownArrow\": \"\",\n\t\"Updownarrow\": \"\",\n\t\"UpEquilibrium\": \"\",\n\t\"upharpoonleft\": \"\",\n\t\"upharpoonright\": \"\",\n\t\"uplus\": \"\",\n\t\"UpperLeftArrow\": \"\",\n\t\"UpperRightArrow\": \"\",\n\t\"upsi\": \"\",\n\t\"Upsi\": \"\",\n\t\"upsih\": \"\",\n\t\"Upsilon\": \"\",\n\t\"upsilon\": \"\",\n\t\"UpTeeArrow\": \"\",\n\t\"UpTee\": \"\",\n\t\"upuparrows\": \"\",\n\t\"urcorn\": \"\",\n\t\"urcorner\": \"\",\n\t\"urcrop\": \"\",\n\t\"Uring\": \"\",\n\t\"uring\": \"\",\n\t\"urtri\": \"\",\n\t\"Uscr\": \"\",\n\t\"uscr\": \"\",\n\t\"utdot\": \"\",\n\t\"Utilde\": \"\",\n\t\"utilde\": \"\",\n\t\"utri\": \"\",\n\t\"utrif\": \"\",\n\t\"uuarr\": \"\",\n\t\"Uuml\": \"\",\n\t\"uuml\": \"\",\n\t\"uwangle\": \"\",\n\t\"vangrt\": \"\",\n\t\"varepsilon\": \"\",\n\t\"varkappa\": \"\",\n\t\"varnothing\": \"\",\n\t\"varphi\": \"\",\n\t\"varpi\": \"\",\n\t\"varpropto\": \"\",\n\t\"varr\": \"\",\n\t\"vArr\": \"\",\n\t\"varrho\": \"\",\n\t\"varsigma\": \"\",\n\t\"varsubsetneq\": \"\",\n\t\"varsubsetneqq\": \"\",\n\t\"varsupsetneq\": \"\",\n\t\"varsupsetneqq\": \"\",\n\t\"vartheta\": \"\",\n\t\"vartriangleleft\": \"\",\n\t\"vartriangleright\": \"\",\n\t\"vBar\": \"\",\n\t\"Vbar\": \"\",\n\t\"vBarv\": \"\",\n\t\"Vcy\": \"\",\n\t\"vcy\": \"\",\n\t\"vdash\": \"\",\n\t\"vDash\": \"\",\n\t\"Vdash\": \"\",\n\t\"VDash\": \"\",\n\t\"Vdashl\": \"\",\n\t\"veebar\": \"\",\n\t\"vee\": \"\",\n\t\"Vee\": \"\",\n\t\"veeeq\": \"\",\n\t\"vellip\": \"\",\n\t\"verbar\": \"|\",\n\t\"Verbar\": \"\",\n\t\"vert\": \"|\",\n\t\"Vert\": \"\",\n\t\"VerticalBar\": \"\",\n\t\"VerticalLine\": \"|\",\n\t\"VerticalSeparator\": \"\",\n\t\"VerticalTilde\": \"\",\n\t\"VeryThinSpace\": \"\",\n\t\"Vfr\": \"\",\n\t\"vfr\": \"\",\n\t\"vltri\": \"\",\n\t\"vnsub\": \"\",\n\t\"vnsup\": \"\",\n\t\"Vopf\": \"\",\n\t\"vopf\": \"\",\n\t\"vprop\": \"\",\n\t\"vrtri\": \"\",\n\t\"Vscr\": \"\",\n\t\"vscr\": \"\",\n\t\"vsubnE\": \"\",\n\t\"vsubne\": \"\",\n\t\"vsupnE\": \"\",\n\t\"vsupne\": \"\",\n\t\"Vvdash\": \"\",\n\t\"vzigzag\": \"\",\n\t\"Wcirc\": \"\",\n\t\"wcirc\": \"\",\n\t\"wedbar\": \"\",\n\t\"wedge\": \"\",\n\t\"Wedge\": \"\",\n\t\"wedgeq\": \"\",\n\t\"weierp\": \"\",\n\t\"Wfr\": \"\",\n\t\"wfr\": \"\",\n\t\"Wopf\": \"\",\n\t\"wopf\": \"\",\n\t\"wp\": \"\",\n\t\"wr\": \"\",\n\t\"wreath\": \"\",\n\t\"Wscr\": \"\",\n\t\"wscr\": \"\",\n\t\"xcap\": \"\",\n\t\"xcirc\": \"\",\n\t\"xcup\": \"\",\n\t\"xdtri\": \"\",\n\t\"Xfr\": \"\",\n\t\"xfr\": \"\",\n\t\"xharr\": \"\",\n\t\"xhArr\": \"\",\n\t\"Xi\": \"\",\n\t\"xi\": \"\",\n\t\"xlarr\": \"\",\n\t\"xlArr\": \"\",\n\t\"xmap\": \"\",\n\t\"xnis\": \"\",\n\t\"xodot\": \"\",\n\t\"Xopf\": \"\",\n\t\"xopf\": \"\",\n\t\"xoplus\": \"\",\n\t\"xotime\": \"\",\n\t\"xrarr\": \"\",\n\t\"xrArr\": \"\",\n\t\"Xscr\": \"\",\n\t\"xscr\": \"\",\n\t\"xsqcup\": \"\",\n\t\"xuplus\": \"\",\n\t\"xutri\": \"\",\n\t\"xvee\": \"\",\n\t\"xwedge\": \"\",\n\t\"Yacute\": \"\",\n\t\"yacute\": \"\",\n\t\"YAcy\": \"\",\n\t\"yacy\": \"\",\n\t\"Ycirc\": \"\",\n\t\"ycirc\": \"\",\n\t\"Ycy\": \"\",\n\t\"ycy\": \"\",\n\t\"yen\": \"\",\n\t\"Yfr\": \"\",\n\t\"yfr\": \"\",\n\t\"YIcy\": \"\",\n\t\"yicy\": \"\",\n\t\"Yopf\": \"\",\n\t\"yopf\": \"\",\n\t\"Yscr\": \"\",\n\t\"yscr\": \"\",\n\t\"YUcy\": \"\",\n\t\"yucy\": \"\",\n\t\"yuml\": \"\",\n\t\"Yuml\": \"\",\n\t\"Zacute\": \"\",\n\t\"zacute\": \"\",\n\t\"Zcaron\": \"\",\n\t\"zcaron\": \"\",\n\t\"Zcy\": \"\",\n\t\"zcy\": \"\",\n\t\"Zdot\": \"\",\n\t\"zdot\": \"\",\n\t\"zeetrf\": \"\",\n\t\"ZeroWidthSpace\": \"\",\n\t\"Zeta\": \"\",\n\t\"zeta\": \"\",\n\t\"zfr\": \"\",\n\t\"Zfr\": \"\",\n\t\"ZHcy\": \"\",\n\t\"zhcy\": \"\",\n\t\"zigrarr\": \"\",\n\t\"zopf\": \"\",\n\t\"Zopf\": \"\",\n\t\"Zscr\": \"\",\n\t\"zscr\": \"\",\n\t\"zwj\": \"\",\n\t\"zwnj\": \"\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/entities/maps/entities.json\n ** module id = 257\n ** module chunks = 29\n **/","module.exports=/[!-#%-\\*,-/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDE38-\\uDE3D]|\\uD805[\\uDCC6\\uDDC1-\\uDDC9\\uDE41-\\uDE43]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F/\n\n\n/** WEBPACK FOOTER **\n ** ./~/uc.micro/categories/P/regex.js\n **/","'use strict';\n\n\nmodule.exports.encode = require('./encode');\nmodule.exports.decode = require('./decode');\nmodule.exports.format = require('./format');\nmodule.exports.parse  = require('./parse');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/mdurl/index.js\n **/","\n'use strict';\n\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\n\nmodule.exports = encode;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/mdurl/encode.js\n **/","\n'use strict';\n\n\n/* eslint-disable no-bitwise */\n\nvar decodeCache = {};\n\nfunction getDecodeCache(exclude) {\n  var i, ch, cache = decodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = decodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache;\n}\n\n\n// Decode percent-encoded string.\n//\nfunction decode(string, exclude) {\n  var cache;\n\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  cache = getDecodeCache(exclude);\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n    var i, l, b1, b2, b3, b4, chr,\n        result = '';\n\n    for (i = 0, l = seq.length; i < l; i += 3) {\n      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue;\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 3;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\n\n          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 6;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n\n          i += 9;\n          continue;\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result;\n  });\n}\n\n\ndecode.defaultChars   = ';/?:@&=+$,#';\ndecode.componentChars = '';\n\n\nmodule.exports = decode;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/mdurl/decode.js\n **/","\n'use strict';\n\n\nmodule.exports = function format(url) {\n  var result = '';\n\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n\n  return result;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/mdurl/format.js\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = [ '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t' ],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = [ '{', '}', '|', '\\\\', '^', '`' ].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = [ '\\'' ].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\n    hostEndingChars = [ '/', '?', '#' ],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    /* eslint-disable no-script-url */\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    };\n    /* eslint-enable no-script-url */\n\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, slashesDenoteHost) {\n  var i, l, lowerProto, hec, slashes,\n      rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    var host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this;\n};\n\nUrl.prototype.parseHost = function(host) {\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nmodule.exports = urlParse;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/mdurl/parse.js\n **/","\nmodule.exports.Any = require('./properties/Any/regex');\nmodule.exports.Cc  = require('./categories/Cc/regex');\nmodule.exports.Cf  = require('./categories/Cf/regex');\nmodule.exports.P   = require('./categories/P/regex');\nmodule.exports.Z   = require('./categories/Z/regex');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/uc.micro/index.js\n **/","module.exports=/[\\0-\\uD7FF\\uDC00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]/\n\n\n/** WEBPACK FOOTER **\n ** ./~/uc.micro/properties/Any/regex.js\n **/","module.exports=/[\\0-\\x1F\\x7F-\\x9F]/\n\n\n/** WEBPACK FOOTER **\n ** ./~/uc.micro/categories/Cc/regex.js\n **/","module.exports=/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/\n\n\n/** WEBPACK FOOTER **\n ** ./~/uc.micro/categories/Cf/regex.js\n **/","module.exports=/[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/\n\n\n/** WEBPACK FOOTER **\n ** ./~/uc.micro/categories/Z/regex.js\n **/","// Just a shortcut for bulk export\n'use strict';\n\n\nexports.parseLinkLabel       = require('./parse_link_label');\nexports.parseLinkDestination = require('./parse_link_destination');\nexports.parseLinkTitle       = require('./parse_link_title');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/helpers/index.js\n **/","// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n'use strict';\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level, found, marker, prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n\n  return labelEnd;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/helpers/parse_link_label.js\n **/","// Parse link destination\n//\n'use strict';\n\n\nvar isSpace     = require('../common/utils').isSpace;\nvar unescapeAll = require('../common/utils').unescapeAll;\n\n\nmodule.exports = function parseLinkDestination(str, pos, max) {\n  var code, level,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (str.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = str.charCodeAt(pos);\n      if (code === 0x0A /* \\n */ || isSpace(code)) { return result; }\n      if (code === 0x3E /* > */) {\n        result.pos = pos + 1;\n        result.str = unescapeAll(str.slice(start + 1, pos));\n        result.ok = true;\n        return result;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n\n      pos++;\n    }\n\n    // no closing '>'\n    return result;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n\n    if (code === 0x20) { break; }\n\n    // ascii control characters\n    if (code < 0x20 || code === 0x7F) { break; }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++;\n      if (level > 1) { break; }\n    }\n\n    if (code === 0x29 /* ) */) {\n      level--;\n      if (level < 0) { break; }\n    }\n\n    pos++;\n  }\n\n  if (start === pos) { return result; }\n\n  result.str = unescapeAll(str.slice(start, pos));\n  result.lines = lines;\n  result.pos = pos;\n  result.ok = true;\n  return result;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/helpers/parse_link_destination.js\n **/","// Parse link title\n//\n'use strict';\n\n\nvar unescapeAll = require('../common/utils').unescapeAll;\n\n\nmodule.exports = function parseLinkTitle(str, pos, max) {\n  var code,\n      marker,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (pos >= max) { return result; }\n\n  marker = str.charCodeAt(pos);\n\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }\n\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) { marker = 0x29; }\n\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n    if (code === marker) {\n      result.pos = pos + 1;\n      result.lines = lines;\n      result.str = unescapeAll(str.slice(start + 1, pos));\n      result.ok = true;\n      return result;\n    } else if (code === 0x0A) {\n      lines++;\n    } else if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos++;\n      if (str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n\n    pos++;\n  }\n\n  return result;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/helpers/parse_link_title.js\n **/","/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\n\nvar assign          = require('./common/utils').assign;\nvar unescapeAll     = require('./common/utils').unescapeAll;\nvar escapeHtml      = require('./common/utils').escapeHtml;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx /*, options, env */) {\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx /*, options, env */) {\n  return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      highlighted;\n\n  if (info) {\n    langName = info.split(/\\s+/g)[0];\n    token.attrJoin('class', options.langPrefix + langName);\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  return  '<pre><code' + slf.renderAttrs(token) + '>'\n        + highlighted\n        + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env);\n\n  return slf.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independed static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) { return ''; }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n\n  return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += rules.text(tokens, i, options, env, this);\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i, len, type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/renderer.js\n **/","/** internal\n * class Core\n *\n * Top-level rules executor. Glues block/inline parsers and does intermediate\n * transformations.\n **/\n'use strict';\n\n\nvar Ruler  = require('./ruler');\n\n\nvar _rules = [\n  [ 'normalize',      require('./rules_core/normalize')      ],\n  [ 'block',          require('./rules_core/block')          ],\n  [ 'inline',         require('./rules_core/inline')         ],\n  [ 'linkify',        require('./rules_core/linkify')        ],\n  [ 'replacements',   require('./rules_core/replacements')   ],\n  [ 'smartquotes',    require('./rules_core/smartquotes')    ]\n];\n\n\n/**\n * new Core()\n **/\nfunction Core() {\n  /**\n   * Core#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of core rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n\n/**\n * Core.process(state)\n *\n * Executes core chain rules.\n **/\nCore.prototype.process = function (state) {\n  var i, l, rules;\n\n  rules = this.ruler.getRules('');\n\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\nCore.prototype.State = require('./rules_core/state_core');\n\n\nmodule.exports = Core;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/parser_core.js\n **/","/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n'use strict';\n\n\n/**\n * new Ruler()\n **/\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typorgapher replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\n\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\n\n  this.enable(list, ignoreInvalid);\n};\n\n\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || [];\n};\n\nmodule.exports = Ruler;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/ruler.js\n **/","// Normalize input string\n\n'use strict';\n\n\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar NULL_RE      = /\\u0000/g;\n\n\nmodule.exports = function inline(state) {\n  var str;\n\n  // Normalize newlines\n  str = state.src.replace(NEWLINES_RE, '\\n');\n\n  // Replace NULL characters\n  str = str.replace(NULL_RE, '\\uFFFD');\n\n  state.src = str;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_core/normalize.js\n **/","'use strict';\n\n\nmodule.exports = function block(state) {\n  var token;\n\n  if (state.inlineMode) {\n    token          = new state.Token('inline', '', 0);\n    token.content  = state.src;\n    token.map      = [ 0, 1 ];\n    token.children = [];\n    state.tokens.push(token);\n  } else {\n    state.md.block.parse(state.src, state.md, state.env, state.tokens);\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_core/block.js\n **/","'use strict';\n\nmodule.exports = function inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n    }\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_core/inline.js\n **/","// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n'use strict';\n\n\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\n      level, htmlLinkLevel, url, fullUrl, urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\n        text = currentToken.content;\n        links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) { continue; }\n\n          urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token         = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level   = level;\n            nodes.push(token);\n          }\n\n          token         = new state.Token('link_open', 'a', 1);\n          token.attrs   = [ [ 'href', fullUrl ] ];\n          token.level   = level++;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          token         = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level   = level;\n          nodes.push(token);\n\n          token         = new state.Token('link_close', 'a', -1);\n          token.level   = --level;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          token         = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level   = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_core/linkify.js\n **/","// Simple typographyc replacements\n//\n// (c) (C)  \n// (tm) (TM)  \n// (r) (R)  \n// +-  \n// (p) (P) -> \n// ...   (also ?....  ?.., !....  !..)\n// ????????  ???, !!!!!  !!!, `,,`  `,`\n// --  &ndash;, ---  &mdash;\n//\n'use strict';\n\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> , , \n// - miltiplication 2 x 4 -> 2  4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\n// Workaround for phantomjs - need regex without /g flag,\n// or root check will fail every second time\nvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  'c': '',\n  'r': '',\n  'p': '',\n  'tm': ''\n};\n\nfunction replaceFn(match, name) {\n  return SCOPED_ABBR[name.toLowerCase()];\n}\n\nfunction replace_scoped(inlineTokens) {\n  var i, token;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n    if (token.type === 'text') {\n      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n    }\n  }\n}\n\nfunction replace_rare(inlineTokens) {\n  var i, token;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n    if (token.type === 'text') {\n      if (RARE_RE.test(token.content)) {\n        token.content = token.content\n                    .replace(/\\+-/g, '')\n                    // .., ..., ....... -> \n                    // but ?..... & !..... -> ?.. & !..\n                    .replace(/\\.{2,}/g, '').replace(/([?!])/g, '$1..')\n                    .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n                    // em-dash\n                    .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n                    // en-dash\n                    .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\n                    .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n      }\n    }\n  }\n}\n\n\nmodule.exports = function replace(state) {\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n      replace_scoped(state.tokens[blkIdx].children);\n    }\n\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n      replace_rare(state.tokens[blkIdx].children);\n    }\n\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_core/replacements.js\n **/","// Convert straight quotation marks to typographic ones\n//\n'use strict';\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /*  */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type !== 'text') { continue; }\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type !== 'text') { continue; }\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // treat this as the middle of the word\n        canOpen = false;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_core/smartquotes.js\n **/","// Core state object\n//\n'use strict';\n\nvar Token = require('../token');\n\n\nfunction StateCore(src, md, env) {\n  this.src = src;\n  this.env = env;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.md = md; // link to parser instance\n}\n\n// re-export Token class to use in core rules\nStateCore.prototype.Token = Token;\n\n\nmodule.exports = StateCore;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_core/state_core.js\n **/","// Token class\n\n'use strict';\n\n\n/**\n * class Token\n **/\n\n/**\n * new Token(type, tag, nesting)\n *\n * Create new token and fill passed properties.\n **/\nfunction Token(type, tag, nesting) {\n  /**\n   * Token#type -> String\n   *\n   * Type of the token (string, e.g. \"paragraph_open\")\n   **/\n  this.type     = type;\n\n  /**\n   * Token#tag -> String\n   *\n   * html tag name, e.g. \"p\"\n   **/\n  this.tag      = tag;\n\n  /**\n   * Token#attrs -> Array\n   *\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n   **/\n  this.attrs    = null;\n\n  /**\n   * Token#map -> Array\n   *\n   * Source map info. Format: `[ line_begin, line_end ]`\n   **/\n  this.map      = null;\n\n  /**\n   * Token#nesting -> Number\n   *\n   * Level change (number in {-1, 0, 1} set), where:\n   *\n   * -  `1` means the tag is opening\n   * -  `0` means the tag is self-closing\n   * - `-1` means the tag is closing\n   **/\n  this.nesting  = nesting;\n\n  /**\n   * Token#level -> Number\n   *\n   * nesting level, the same as `state.level`\n   **/\n  this.level    = 0;\n\n  /**\n   * Token#children -> Array\n   *\n   * An array of child nodes (inline and img tokens)\n   **/\n  this.children = null;\n\n  /**\n   * Token#content -> String\n   *\n   * In a case of self-closing tag (code, html, fence, etc.),\n   * it has contents of this tag.\n   **/\n  this.content  = '';\n\n  /**\n   * Token#markup -> String\n   *\n   * '*' or '_' for emphasis, fence string for fence, etc.\n   **/\n  this.markup   = '';\n\n  /**\n   * Token#info -> String\n   *\n   * fence infostring\n   **/\n  this.info     = '';\n\n  /**\n   * Token#meta -> Object\n   *\n   * A place for plugins to store an arbitrary data\n   **/\n  this.meta     = null;\n\n  /**\n   * Token#block -> Boolean\n   *\n   * True for block-level tokens, false for inline tokens.\n   * Used in renderer to calculate line breaks\n   **/\n  this.block    = false;\n\n  /**\n   * Token#hidden -> Boolean\n   *\n   * If it's true, ignore this element when rendering. Used for tight lists\n   * to hide paragraphs.\n   **/\n  this.hidden   = false;\n}\n\n\n/**\n * Token.attrIndex(name) -> Number\n *\n * Search attribute index by name.\n **/\nToken.prototype.attrIndex = function attrIndex(name) {\n  var attrs, i, len;\n\n  if (!this.attrs) { return -1; }\n\n  attrs = this.attrs;\n\n  for (i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name) { return i; }\n  }\n  return -1;\n};\n\n\n/**\n * Token.attrPush(attrData)\n *\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\n **/\nToken.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [ attrData ];\n  }\n};\n\n\n/**\n * Token.attrSet(name, value)\n *\n * Set `name` attribute to `value`. Override old value if exists.\n **/\nToken.prototype.attrSet = function attrSet(name, value) {\n  var idx = this.attrIndex(name),\n      attrData = [ name, value ];\n\n  if (idx < 0) {\n    this.attrPush(attrData);\n  } else {\n    this.attrs[idx] = attrData;\n  }\n};\n\n\n/**\n * Token.attrJoin(name, value)\n *\n * Join value to existing attribute via space. Or create new attribute if not\n * exists. Useful to operate with token classes.\n **/\nToken.prototype.attrJoin = function attrJoin(name, value) {\n  var idx = this.attrIndex(name);\n\n  if (idx < 0) {\n    this.attrPush([ name, value ]);\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\n  }\n};\n\n\nmodule.exports = Token;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/token.js\n **/","/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  require('./rules_block/reference') ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return []; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = require('./rules_block/state_block');\n\n\nmodule.exports = ParserBlock;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/parser_block.js\n **/","// GFM table, non-standard\n\n'use strict';\n\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n\n  return state.src.substr(pos, max - pos);\n}\n\nfunction escapedSplit(str) {\n  var result = [],\n      pos = 0,\n      max = str.length,\n      ch,\n      escapes = 0,\n      lastPos = 0,\n      backTicked = false,\n      lastBackTick = 0;\n\n  ch  = str.charCodeAt(pos);\n\n  while (pos < max) {\n    if (ch === 0x60/* ` */ && (escapes % 2 === 0)) {\n      backTicked = !backTicked;\n      lastBackTick = pos;\n    } else if (ch === 0x7c/* | */ && (escapes % 2 === 0) && !backTicked) {\n      result.push(str.substring(lastPos, pos));\n      lastPos = pos + 1;\n    } else if (ch === 0x5c/* \\ */) {\n      escapes++;\n    } else {\n      escapes = 0;\n    }\n\n    pos++;\n\n    // If there was an un-closed backtick, go back to just after\n    // the last backtick, but as if it was a normal character\n    if (pos === max && backTicked) {\n      backTicked = false;\n      pos = lastBackTick + 1;\n    }\n\n    ch = str.charCodeAt(pos);\n  }\n\n  result.push(str.substring(lastPos));\n\n  return result;\n}\n\n\nmodule.exports = function table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, columns, columnCount, token,\n      aligns, t, tableLines, tbodyLines;\n\n  // should have at least three lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false; }\n\n  // first character of the second line should be '|' or '-'\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  ch = state.src.charCodeAt(pos);\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n  lineText = getLine(state, startLine + 1);\n  if (!/^[-:| ]+$/.test(lineText)) { return false; }\n\n  columns = lineText.split('|');\n  aligns = [];\n  for (i = 0; i < columns.length; i++) {\n    t = columns[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\n  // header row will define an amount of columns in the entire table,\n  // and align row shouldn't be smaller than that (the rest of the rows can)\n  columnCount = columns.length;\n  if (columnCount > aligns.length) { return false; }\n\n  if (silent) { return true; }\n\n  token     = state.push('table_open', 'table', 1);\n  token.map = tableLines = [ startLine, 0 ];\n\n  token     = state.push('thead_open', 'thead', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  token     = state.push('tr_open', 'tr', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  for (i = 0; i < columns.length; i++) {\n    token          = state.push('th_open', 'th', 1);\n    token.map      = [ startLine, startLine + 1 ];\n    if (aligns[i]) {\n      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n    }\n\n    token          = state.push('inline', '', 0);\n    token.content  = columns[i].trim();\n    token.map      = [ startLine, startLine + 1 ];\n    token.children = [];\n\n    token          = state.push('th_close', 'th', -1);\n  }\n\n  token     = state.push('tr_close', 'tr', -1);\n  token     = state.push('thead_close', 'thead', -1);\n\n  token     = state.push('tbody_open', 'tbody', 1);\n  token.map = tbodyLines = [ startLine + 2, 0 ];\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    lineText = getLine(state, nextLine).trim();\n    if (lineText.indexOf('|') === -1) { break; }\n    columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\n    token = state.push('tr_open', 'tr', 1);\n    for (i = 0; i < columnCount; i++) {\n      token          = state.push('td_open', 'td', 1);\n      if (aligns[i]) {\n        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n      }\n\n      token          = state.push('inline', '', 0);\n      token.content  = columns[i] ? columns[i].trim() : '';\n      token.children = [];\n\n      token          = state.push('td_close', 'td', -1);\n    }\n    token = state.push('tr_close', 'tr', -1);\n  }\n  token = state.push('tbody_close', 'tbody', -1);\n  token = state.push('table_close', 'table', -1);\n\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/table.js\n **/","// Code block (4 spaces padded)\n\n'use strict';\n\n\nmodule.exports = function code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last, token, emptyLines = 0;\n\n  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      emptyLines++;\n\n      // workaround for lists: 2 blank lines should terminate indented\n      // code block, but not fenced code block\n      if (emptyLines >= 2 && state.parentType === 'list') {\n        break;\n      }\n\n      nextLine++;\n      continue;\n    }\n\n    emptyLines = 0;\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = last;\n\n  token         = state.push('code_block', 'code', 0);\n  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/code.js\n **/","// fences (``` lang, ~~~ lang)\n\n'use strict';\n\n\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem, token, markup,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n\n  if (params.indexOf('`') >= 0) { return false; }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n\n  token         = state.push('fence', 'code', 0);\n  token.info    = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup  = markup;\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/fence.js\n **/","// Block quotes\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var nextLine, lastLineEmpty, oldTShift, oldSCount, oldBMarks, oldIndent, oldParentType, lines, initial, offset, ch,\n      terminatorRules, token,\n      i, l, terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip one optional space (but not tab, check cmark impl) after '>'\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  // skip spaces after \">\" and re-calculate offset\n  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - offset % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < oldIndent) { break; }\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space (but not tab, check cmark impl) after '>'\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      // skip spaces after \">\" and re-calculate offset\n      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - offset % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/blockquote.js\n **/","// Horizontal rule\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && !isSpace(ch)) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n\n  token        = state.push('hr', 'hr', 0);\n  token.map    = [ startLine, state.line ];\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/hr.js\n **/","// Lists\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var nextLine,\n      initial,\n      offset,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldLIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      ch,\n      pos,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      token,\n      i, l, terminate;\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldLIndent = state.sCount[startLine];\n    oldParentType = state.parentType;\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldLIndent;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finilize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/list.js\n **/","'use strict';\n\n\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/reference.js\n **/","// heading (#, ##, ...)\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function heading(state, startLine, endLine, silent) {\n  var ch, level, tmp, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipSpacesBack(max, pos);\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  token        = state.push('heading_open', 'h' + String(level), 1);\n  token.markup = '########'.slice(0, level);\n  token.map    = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = state.src.slice(pos, max).trim();\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token        = state.push('heading_close', 'h' + String(level), -1);\n  token.markup = '########'.slice(0, level);\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/heading.js\n **/","// lheading (---, ===)\n\n'use strict';\n\n\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\n  var content, terminate, i, l, token, pos, max, level, marker,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker);\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2);\n            break;\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine + 1;\n\n  token          = state.push('heading_open', 'h' + String(level), 1);\n  token.markup   = String.fromCharCode(marker);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line - 1 ];\n  token.children = [];\n\n  token          = state.push('heading_close', 'h' + String(level), -1);\n  token.markup   = String.fromCharCode(marker);\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/lheading.js\n **/","// HTML block\n\n'use strict';\n\n\nvar block_names = require('../common/html_blocks');\nvar HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nvar HTML_SEQUENCES = [\n  [ /^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true ],\n  [ /^<!--/,        /-->/,   true ],\n  [ /^<\\?/,         /\\?>/,   true ],\n  [ /^<![A-Z]/,     />/,     true ],\n  [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ],\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true ],\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false ]\n];\n\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i, nextLine, token, lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (!state.md.options.html) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\n  }\n\n  if (i === HTML_SEQUENCES.length) { return false; }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++; }\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n\n  token         = state.push('html_block', '', 0);\n  token.map     = [ startLine, nextLine ];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/html_block.js\n **/","// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n'use strict';\n\n\nmodule.exports = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'meta',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'pre',\n  'section',\n  'source',\n  'title',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n];\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/common/html_blocks.js\n **/","// Regexps to match html elements\n\n'use strict';\n\nvar attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\n\nvar unquoted      = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar single_quoted = \"'[^']*'\";\nvar double_quoted = '\"[^\"]*\"';\n\nvar attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';\n\nvar attribute   = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)';\n\nvar open_tag    = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\n\nvar close_tag   = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\nvar comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar processing  = '<[?].*?[?]>';\nvar declaration = '<![A-Z]+\\\\s+[^>]*>';\nvar cdata       = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\n\nvar HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +\n                        '|' + processing + '|' + declaration + '|' + cdata + ')');\nvar HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');\n\nmodule.exports.HTML_TAG_RE = HTML_TAG_RE;\nmodule.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/common/html_re.js\n **/","// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/paragraph.js\n **/","// Parser state class\n\n'use strict';\n\nvar Token = require('../token');\nvar isSpace = require('../common/utils').isSpace;\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = [];  // indents for each line (tabs expanded)\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, lineIndent, ch, first, last, queue, lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - lineIndent % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_block/state_block.js\n **/","/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Parser rules\n\nvar _rules = [\n  [ 'text',            require('./rules_inline/text') ],\n  [ 'newline',         require('./rules_inline/newline') ],\n  [ 'escape',          require('./rules_inline/escape') ],\n  [ 'backticks',       require('./rules_inline/backticks') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],\n  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],\n  [ 'link',            require('./rules_inline/link') ],\n  [ 'image',           require('./rules_inline/image') ],\n  [ 'autolink',        require('./rules_inline/autolink') ],\n  [ 'html_inline',     require('./rules_inline/html_inline') ],\n  [ 'entity',          require('./rules_inline/entity') ]\n];\n\nvar _rules2 = [\n  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],\n  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],\n  [ 'text_collapse',   require('./rules_inline/text_collapse') ]\n];\n\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline() {\n  var i;\n\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new Ruler();\n\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\n\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  var ok, i, pos = state.pos,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      maxNesting = state.md.options.maxNesting,\n      cache = state.cache;\n\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n\n      if (ok) { break; }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n\n  if (!ok) { state.pos++; }\n  cache[pos] = state.pos;\n};\n\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      end = state.posMax,\n      maxNesting = state.md.options.maxNesting;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n        if (ok) { break; }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md, env, outTokens);\n\n  this.tokenize(state);\n\n  rules = this.ruler2.getRules('');\n  len = rules.length;\n\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\n\n\nParserInline.prototype.State = require('./rules_inline/state_inline');\n\n\nmodule.exports = ParserInline;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/parser_inline.js\n **/","// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n'use strict';\n\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n};\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParcerInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n};*/\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/text.js\n **/","// Proceess '\\n'\n\n'use strict';\n\nmodule.exports = function newline(state, silent) {\n  var pmax, max, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        state.pending = state.pending.replace(/ +$/, '');\n        state.push('hardbreak', 'br', 0);\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push('softbreak', 'br', 0);\n      }\n\n    } else {\n      state.push('softbreak', 'br', 0);\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  state.pos = pos;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/newline.js\n **/","// Proceess escaped chars and hardbreaks\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nmodule.exports = function escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push('hardbreak', 'br', 0);\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/escape.js\n **/","// Parse backticks\n\n'use strict';\n\nmodule.exports = function backtick(state, silent) {\n  var start, max, marker, matchStart, matchEnd, token,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        token         = state.push('code_inline', 'code', 0);\n        token.markup  = marker;\n        token.content = state.src.slice(pos, matchStart)\n                                 .replace(/[ \\n]+/g, ' ')\n                                 .trim();\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/backticks.js\n **/","// ~~strike through~~\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function strikethrough(state, silent) {\n  var i, scanned, token, len, ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x7E/* ~ */) { return false; }\n\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch = String.fromCharCode(marker);\n\n  if (len < 2) { return false; }\n\n  if (len % 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch;\n    len--;\n  }\n\n  for (i = 0; i < len; i += 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch + ch;\n\n    state.delimiters.push({\n      marker: marker,\n      jump:   i,\n      token:  state.tokens.length - 1,\n      level:  state.level,\n      end:    -1,\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function strikethrough(state) {\n  var i, j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x7E/* ~ */) {\n      continue;\n    }\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    token         = state.tokens[startDelim.token];\n    token.type    = 's_open';\n    token.tag     = 's';\n    token.nesting = 1;\n    token.markup  = '~~';\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = 's_close';\n    token.tag     = 's';\n    token.nesting = -1;\n    token.markup  = '~~';\n    token.content = '';\n\n    if (state.tokens[endDelim.token - 1].type === 'text' &&\n        state.tokens[endDelim.token - 1].content === '~') {\n\n      loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++;\n    }\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/strikethrough.js\n **/","// Process *this* and _that_\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump:   i,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // Token level.\n      //\n      level:  state.level,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the next delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i + 1 < max &&\n               delimiters[i + 1].end === startDelim.end - 1 &&\n               delimiters[i + 1].token === startDelim.token + 1 &&\n               delimiters[startDelim.end - 1].token === endDelim.token - 1 &&\n               delimiters[i + 1].marker === startDelim.marker;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i + 1].token].content = '';\n      state.tokens[delimiters[startDelim.end - 1].token].content = '';\n      i++;\n    }\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/emphasis.js\n **/","// Process [link](<to> \"stuff\")\n\n'use strict';\n\nvar parseLinkLabel       = require('../helpers/parse_link_label');\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function link(state, silent) {\n  var attrs,\n      code,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      res,\n      ref,\n      title,\n      token,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 1;\n  labelEnd = parseLinkLabel(state, state.pos, true);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    token        = state.push('link_open', 'a', 1);\n    token.attrs  = attrs = [ [ 'href', href ] ];\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n\n    state.md.inline.tokenize(state);\n\n    token        = state.push('link_close', 'a', -1);\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/link.js\n **/","// Process ![image](<src> \"title\")\n\n'use strict';\n\nvar parseLinkLabel       = require('../helpers/parse_link_label');\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function image(state, silent) {\n  var attrs,\n      code,\n      content,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      ref,\n      res,\n      title,\n      token,\n      tokens,\n      start,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 2;\n  labelEnd = parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens = []\n    );\n\n    token          = state.push('image', 'img', 0);\n    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];\n    token.children = tokens;\n    token.content  = content;\n\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/image.js\n **/","// Process autolinks '<protocol:...>'\n\n'use strict';\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)>/;\n\n\nmodule.exports = function autolink(state, silent) {\n  var tail, linkMatch, emailMatch, url, fullUrl, token,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) { return false; }\n\n  if (AUTOLINK_RE.test(tail)) {\n    linkMatch = tail.match(AUTOLINK_RE);\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink(url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  if (EMAIL_RE.test(tail)) {\n    emailMatch = tail.match(EMAIL_RE);\n\n    url = emailMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink('mailto:' + url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/autolink.js\n **/","// Process html tags\n\n'use strict';\n\n\nvar HTML_TAG_RE = require('../common/html_re').HTML_TAG_RE;\n\n\nfunction isLetter(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nmodule.exports = function html_inline(state, silent) {\n  var ch, match, max, token,\n      pos = state.pos;\n\n  if (!state.md.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    token         = state.push('html_inline', '', 0);\n    token.content = state.src.slice(pos, pos + match[0].length);\n  }\n  state.pos += match[0].length;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/html_inline.js\n **/","// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n'use strict';\n\nvar entities          = require('../common/entities');\nvar has               = require('../common/utils').has;\nvar isValidEntityCode = require('../common/utils').isValidEntityCode;\nvar fromCodePoint     = require('../common/utils').fromCodePoint;\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nmodule.exports = function entity(state, silent) {\n  var ch, code, match, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        if (has(entities, match[1])) {\n          if (!silent) { state.pending += entities[match[1]]; }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) { state.pending += '&'; }\n  state.pos++;\n  return true;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/entity.js\n **/","// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nmodule.exports = function link_pairs(state) {\n  var i, j, lastDelim, currDelim,\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    lastDelim = delimiters[i];\n\n    if (!lastDelim.close) { continue; }\n\n    j = i - lastDelim.jump - 1;\n\n    while (j >= 0) {\n      currDelim = delimiters[j];\n\n      if (currDelim.open &&\n          currDelim.marker === lastDelim.marker &&\n          currDelim.end < 0 &&\n          currDelim.level === lastDelim.level) {\n\n        lastDelim.jump = i - j;\n        lastDelim.open = false;\n        currDelim.end  = i;\n        currDelim.jump = 0;\n        break;\n      }\n\n      j -= currDelim.jump + 1;\n    }\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/balance_pairs.js\n **/","// Merge adjacent text nodes into one, and re-calculate all token levels\n//\n'use strict';\n\n\nmodule.exports = function text_collapse(state) {\n  var curr, last,\n      level = 0,\n      tokens = state.tokens,\n      max = state.tokens.length;\n\n  for (curr = last = 0; curr < max; curr++) {\n    // re-calculate levels\n    level += tokens[curr].nesting;\n    tokens[curr].level = level;\n\n    if (tokens[curr].type === 'text' &&\n        curr + 1 < max &&\n        tokens[curr + 1].type === 'text') {\n\n      // collapse two adjacent text nodes\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n    } else {\n      if (curr !== last) { tokens[last] = tokens[curr]; }\n\n      last++;\n    }\n  }\n\n  if (curr !== last) {\n    tokens.length = last;\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/text_collapse.js\n **/","// Inline parser state\n\n'use strict';\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  this.delimiters = [];   // Emphasis-like delimiters\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/rules_inline/state_inline.js\n **/","'use strict';\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Helpers\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\nfunction isString(obj) { return _class(obj) === '[object String]'; }\nfunction isObject(obj) { return _class(obj) === '[object Object]'; }\nfunction isRegExp(obj) { return _class(obj) === '[object RegExp]'; }\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\n\n\nfunction escapeRE (str) { return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&'); }\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar defaultOptions = {\n  fuzzyLink: true,\n  fuzzyEmail: true,\n  fuzzyIP: false\n};\n\n\nfunction isOptionsObj(obj) {\n  return Object.keys(obj || {}).reduce(function (acc, k) {\n    return acc || defaultOptions.hasOwnProperty(k);\n  }, false);\n}\n\n\nvar defaultSchemas = {\n  'http:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.http) {\n        // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.http =  new RegExp(\n          '^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\n        );\n      }\n      if (self.re.http.test(tail)) {\n        return tail.match(self.re.http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'https:':  'http:',\n  'ftp:':    'http:',\n  '//':      {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.no_http) {\n      // compile lazily, becayse \"host\"-containing variables can change on tlds update.\n        self.re.no_http =  new RegExp(\n          '^' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\n        );\n      }\n\n      if (self.re.no_http.test(tail)) {\n        // should not be `://`, that protects from errors in protocol name\n        if (pos >= 3 && text[pos - 3] === ':') { return 0; }\n        return tail.match(self.re.no_http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'mailto:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.mailto) {\n        self.re.mailto =  new RegExp(\n          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'\n        );\n      }\n      if (self.re.mailto.test(tail)) {\n        return tail.match(self.re.mailto)[0].length;\n      }\n      return 0;\n    }\n  }\n};\n\n/*eslint-disable max-len*/\n\n// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\nvar tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';\n\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\nvar tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|'.split('|');\n\n/*eslint-enable max-len*/\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction resetScanCache(self) {\n  self.__index__ = -1;\n  self.__text_cache__   = '';\n}\n\nfunction createValidator(re) {\n  return function (text, pos) {\n    var tail = text.slice(pos);\n\n    if (re.test(tail)) {\n      return tail.match(re)[0].length;\n    }\n    return 0;\n  };\n}\n\nfunction createNormalizer() {\n  return function (match, self) {\n    self.normalize(match);\n  };\n}\n\n// Schemas compiler. Build regexps.\n//\nfunction compile(self) {\n\n  // Load & clone RE patterns.\n  var re = self.re = assign({}, require('./lib/re'));\n\n  // Define dynamic patterns\n  var tlds = self.__tlds__.slice();\n\n  if (!self.__tlds_replaced__) {\n    tlds.push(tlds_2ch_src_re);\n  }\n  tlds.push(re.src_xn);\n\n  re.src_tlds = tlds.join('|');\n\n  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }\n\n  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');\n  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');\n  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');\n  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');\n\n  //\n  // Compile each schema\n  //\n\n  var aliases = [];\n\n  self.__compiled__ = {}; // Reset compiled data\n\n  function schemaError(name, val) {\n    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n  }\n\n  Object.keys(self.__schemas__).forEach(function (name) {\n    var val = self.__schemas__[name];\n\n    // skip disabled methods\n    if (val === null) { return; }\n\n    var compiled = { validate: null, link: null };\n\n    self.__compiled__[name] = compiled;\n\n    if (isObject(val)) {\n      if (isRegExp(val.validate)) {\n        compiled.validate = createValidator(val.validate);\n      } else if (isFunction(val.validate)) {\n        compiled.validate = val.validate;\n      } else {\n        schemaError(name, val);\n      }\n\n      if (isFunction(val.normalize)) {\n        compiled.normalize = val.normalize;\n      } else if (!val.normalize) {\n        compiled.normalize = createNormalizer();\n      } else {\n        schemaError(name, val);\n      }\n\n      return;\n    }\n\n    if (isString(val)) {\n      aliases.push(name);\n      return;\n    }\n\n    schemaError(name, val);\n  });\n\n  //\n  // Compile postponed aliases\n  //\n\n  aliases.forEach(function (alias) {\n    if (!self.__compiled__[self.__schemas__[alias]]) {\n      // Silently fail on missed schemas to avoid errons on disable.\n      // schemaError(alias, self.__schemas__[alias]);\n      return;\n    }\n\n    self.__compiled__[alias].validate =\n      self.__compiled__[self.__schemas__[alias]].validate;\n    self.__compiled__[alias].normalize =\n      self.__compiled__[self.__schemas__[alias]].normalize;\n  });\n\n  //\n  // Fake record for guessed links\n  //\n  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };\n\n  //\n  // Build schema condition\n  //\n  var slist = Object.keys(self.__compiled__)\n                      .filter(function(name) {\n                        // Filter disabled & fake schemas\n                        return name.length > 0 && self.__compiled__[name];\n                      })\n                      .map(escapeRE)\n                      .join('|');\n  // (?!_) cause 1.5x slowdown\n  self.re.schema_test   = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'i');\n  self.re.schema_search = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'ig');\n\n  self.re.pretest       = RegExp(\n                            '(' + self.re.schema_test.source + ')|' +\n                            '(' + self.re.host_fuzzy_test.source + ')|' +\n                            '@',\n                            'i');\n\n  //\n  // Cleanup\n  //\n\n  resetScanCache(self);\n}\n\n/**\n * class Match\n *\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\n **/\nfunction Match(self, shift) {\n  var start = self.__index__,\n      end   = self.__last_index__,\n      text  = self.__text_cache__.slice(start, end);\n\n  /**\n   * Match#schema -> String\n   *\n   * Prefix (protocol) for matched string.\n   **/\n  this.schema    = self.__schema__.toLowerCase();\n  /**\n   * Match#index -> Number\n   *\n   * First position of matched string.\n   **/\n  this.index     = start + shift;\n  /**\n   * Match#lastIndex -> Number\n   *\n   * Next position after matched string.\n   **/\n  this.lastIndex = end + shift;\n  /**\n   * Match#raw -> String\n   *\n   * Matched string.\n   **/\n  this.raw       = text;\n  /**\n   * Match#text -> String\n   *\n   * Notmalized text of matched string.\n   **/\n  this.text      = text;\n  /**\n   * Match#url -> String\n   *\n   * Normalized url of matched string.\n   **/\n  this.url       = text;\n}\n\nfunction createMatch(self, shift) {\n  var match = new Match(self, shift);\n\n  self.__compiled__[match.schema].normalize(match, self);\n\n  return match;\n}\n\n\n/**\n * class LinkifyIt\n **/\n\n/**\n * new LinkifyIt(schemas, options)\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Creates new linkifier instance with optional additional schemas.\n * Can be called without `new` keyword for convenience.\n *\n * By default understands:\n *\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n *\n * `schemas` is an object, where each key/value describes protocol/rule:\n *\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n * - __value__ - rule to check tail after link prefix\n *   - _String_ - just alias to existing rule\n *   - _Object_\n *     - _validate_ - validator function (should return matched length on success),\n *       or `RegExp`.\n *     - _normalize_ - optional function to normalize text & url of matched result\n *       (for example, for @twitter mentions).\n *\n * `options`:\n *\n * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n *   like version numbers. Default `false`.\n * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n *\n **/\nfunction LinkifyIt(schemas, options) {\n  if (!(this instanceof LinkifyIt)) {\n    return new LinkifyIt(schemas, options);\n  }\n\n  if (!options) {\n    if (isOptionsObj(schemas)) {\n      options = schemas;\n      schemas = {};\n    }\n  }\n\n  this.__opts__           = assign({}, defaultOptions, options);\n\n  // Cache last tested result. Used to skip repeating steps on next `match` call.\n  this.__index__          = -1;\n  this.__last_index__     = -1; // Next scan position\n  this.__schema__         = '';\n  this.__text_cache__     = '';\n\n  this.__schemas__        = assign({}, defaultSchemas, schemas);\n  this.__compiled__       = {};\n\n  this.__tlds__           = tlds_default;\n  this.__tlds_replaced__  = false;\n\n  this.re = {};\n\n  compile(this);\n}\n\n\n/** chainable\n * LinkifyIt#add(schema, definition)\n * - schema (String): rule name (fixed pattern prefix)\n * - definition (String|RegExp|Object): schema definition\n *\n * Add new rule definition. See constructor description for details.\n **/\nLinkifyIt.prototype.add = function add(schema, definition) {\n  this.__schemas__[schema] = definition;\n  compile(this);\n  return this;\n};\n\n\n/** chainable\n * LinkifyIt#set(options)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Set recognition options for links without schema.\n **/\nLinkifyIt.prototype.set = function set(options) {\n  this.__opts__ = assign(this.__opts__, options);\n  return this;\n};\n\n\n/**\n * LinkifyIt#test(text) -> Boolean\n *\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n **/\nLinkifyIt.prototype.test = function test(text) {\n  // Reset scan cache\n  this.__text_cache__ = text;\n  this.__index__      = -1;\n\n  if (!text.length) { return false; }\n\n  var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n\n  // try to scan for link with schema - that's the most simple rule\n  if (this.re.schema_test.test(text)) {\n    re = this.re.schema_search;\n    re.lastIndex = 0;\n    while ((m = re.exec(text)) !== null) {\n      len = this.testSchemaAt(text, m[2], re.lastIndex);\n      if (len) {\n        this.__schema__     = m[2];\n        this.__index__      = m.index + m[1].length;\n        this.__last_index__ = m.index + m[0].length + len;\n        break;\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {\n    // guess schemaless links\n    tld_pos = text.search(this.re.host_fuzzy_test);\n    if (tld_pos >= 0) {\n      // if tld is located after found link - no need to check fuzzy pattern\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\n        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n\n          shift = ml.index + ml[1].length;\n\n          if (this.__index__ < 0 || shift < this.__index__) {\n            this.__schema__     = '';\n            this.__index__      = shift;\n            this.__last_index__ = ml.index + ml[0].length;\n          }\n        }\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {\n    // guess schemaless emails\n    at_pos = text.indexOf('@');\n    if (at_pos >= 0) {\n      // We can't skip this check, because this cases are possible:\n      // 192.168.1.1@gmail.com, my.in@example.com\n      if ((me = text.match(this.re.email_fuzzy)) !== null) {\n\n        shift = me.index + me[1].length;\n        next  = me.index + me[0].length;\n\n        if (this.__index__ < 0 || shift < this.__index__ ||\n            (shift === this.__index__ && next > this.__last_index__)) {\n          this.__schema__     = 'mailto:';\n          this.__index__      = shift;\n          this.__last_index__ = next;\n        }\n      }\n    }\n  }\n\n  return this.__index__ >= 0;\n};\n\n\n/**\n * LinkifyIt#pretest(text) -> Boolean\n *\n * Very quick check, that can give false positives. Returns true if link MAY BE\n * can exists. Can be used for speed optimization, when you need to check that\n * link NOT exists.\n **/\nLinkifyIt.prototype.pretest = function pretest(text) {\n  return this.re.pretest.test(text);\n};\n\n\n/**\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\n * - text (String): text to scan\n * - name (String): rule (schema) name\n * - position (Number): text offset to check from\n *\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n * at given position. Returns length of found pattern (0 on fail).\n **/\nLinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n  // If not supported schema check requested - terminate\n  if (!this.__compiled__[schema.toLowerCase()]) {\n    return 0;\n  }\n  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n};\n\n\n/**\n * LinkifyIt#match(text) -> Array|null\n *\n * Returns array of found link descriptions or `null` on fail. We strongly\n * to use [[LinkifyIt#test]] first, for best speed.\n *\n * ##### Result match description\n *\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n *   protocol-neutral  links.\n * - __index__ - offset of matched text\n * - __lastIndex__ - index of next char after mathch end\n * - __raw__ - matched text\n * - __text__ - normalized text\n * - __url__ - link, generated from matched text\n **/\nLinkifyIt.prototype.match = function match(text) {\n  var shift = 0, result = [];\n\n  // Try to take previous element from cache, if .test() called before\n  if (this.__index__ >= 0 && this.__text_cache__ === text) {\n    result.push(createMatch(this, shift));\n    shift = this.__last_index__;\n  }\n\n  // Cut head if cache was used\n  var tail = shift ? text.slice(shift) : text;\n\n  // Scan string until end reached\n  while (this.test(tail)) {\n    result.push(createMatch(this, shift));\n\n    tail = tail.slice(this.__last_index__);\n    shift += this.__last_index__;\n  }\n\n  if (result.length) {\n    return result;\n  }\n\n  return null;\n};\n\n\n/** chainable\n * LinkifyIt#tlds(list [, keepOld]) -> this\n * - list (Array): list of tlds\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n *\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n * to avoid false positives. By default this algorythm used:\n *\n * - hostname with any 2-letter root zones are ok.\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\n *   are ok.\n * - encoded (`xn--...`) root zones are ok.\n *\n * If list is replaced, then exact match for 2-chars root zones will be checked.\n **/\nLinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n  list = Array.isArray(list) ? list : [ list ];\n\n  if (!keepOld) {\n    this.__tlds__ = list.slice();\n    this.__tlds_replaced__ = true;\n    compile(this);\n    return this;\n  }\n\n  this.__tlds__ = this.__tlds__.concat(list)\n                                  .sort()\n                                  .filter(function(el, idx, arr) {\n                                    return el !== arr[idx - 1];\n                                  })\n                                  .reverse();\n\n  compile(this);\n  return this;\n};\n\n/**\n * LinkifyIt#normalize(match)\n *\n * Default normalizer (if schema does not define it's own).\n **/\nLinkifyIt.prototype.normalize = function normalize(match) {\n\n  // Do minimal possible changes by default. Need to collect feedback prior\n  // to move forward https://github.com/markdown-it/linkify-it/issues/1\n\n  if (!match.schema) { match.url = 'http://' + match.url; }\n\n  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\n    match.url = 'mailto:' + match.url;\n  }\n};\n\n\nmodule.exports = LinkifyIt;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/linkify-it/index.js\n **/","'use strict';\n\n// Use direct extract instead of `regenerate` to reduse browserified size\nvar src_Any = exports.src_Any = require('uc.micro/properties/Any/regex').source;\nvar src_Cc  = exports.src_Cc = require('uc.micro/categories/Cc/regex').source;\nvar src_Z   = exports.src_Z  = require('uc.micro/categories/Z/regex').source;\nvar src_P   = exports.src_P  = require('uc.micro/categories/P/regex').source;\n\n// \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\nvar src_ZPCc = exports.src_ZPCc = [ src_Z, src_P, src_Cc ].join('|');\n\n// \\p{\\Z\\Cc} (white spaces + control)\nvar src_ZCc = exports.src_ZCc = [ src_Z, src_Cc ].join('|');\n\n// All possible word characters (everything without punctuation, spaces & controls)\n// Defined via punctuation & spaces to save space\n// Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\nvar src_pseudo_letter       = '(?:(?!' + src_ZPCc + ')' + src_Any + ')';\n// The same as abothe but without [0-9]\nvar src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar src_ip4 = exports.src_ip4 =\n\n  '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';\n\nexports.src_auth    = '(?:(?:(?!' + src_ZCc + ').)+@)?';\n\nvar src_port = exports.src_port =\n\n  '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?';\n\nvar src_host_terminator = exports.src_host_terminator =\n\n  '(?=$|' + src_ZPCc + ')(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|' + src_ZPCc + '))';\n\nvar src_path = exports.src_path =\n\n  '(?:' +\n    '[/?#]' +\n      '(?:' +\n        '(?!' + src_ZCc + '|[()[\\\\]{}.,\"\\'?!\\\\-]).|' +\n        '\\\\[(?:(?!' + src_ZCc + '|\\\\]).)*\\\\]|' +\n        '\\\\((?:(?!' + src_ZCc + '|[)]).)*\\\\)|' +\n        '\\\\{(?:(?!' + src_ZCc + '|[}]).)*\\\\}|' +\n        '\\\\\"(?:(?!' + src_ZCc + '|[\"]).)+\\\\\"|' +\n        \"\\\\'(?:(?!\" + src_ZCc + \"|[']).)+\\\\'|\" +\n        \"\\\\'(?=\" + src_pseudo_letter + ').|' +  // allow `I'm_king` if no pair found\n        '\\\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to\n                                   // - english\n                                   // - percent-encoded\n                                   // - parts of file path\n                                   // until more examples found.\n        '\\\\.(?!' + src_ZCc + '|[.]).|' +\n        '\\\\-(?!--(?:[^-]|$))(?:-*)|' +  // `---` => long dash, terminate\n        '\\\\,(?!' + src_ZCc + ').|' +      // allow `,,,` in paths\n        '\\\\!(?!' + src_ZCc + '|[!]).|' +\n        '\\\\?(?!' + src_ZCc + '|[?]).' +\n      ')+' +\n    '|\\\\/' +\n  ')?';\n\nvar src_email_name = exports.src_email_name =\n\n  '[\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]+';\n\nvar src_xn = exports.src_xn =\n\n  'xn--[a-z0-9\\\\-]{1,59}';\n\n// More to read about domain names\n// http://serverfault.com/questions/638260/\n\nvar src_domain_root = exports.src_domain_root =\n\n  // Can't have digits and dashes\n  '(?:' +\n    src_xn +\n    '|' +\n    src_pseudo_letter_non_d + '{1,63}' +\n  ')';\n\nvar src_domain = exports.src_domain =\n\n  '(?:' +\n    src_xn +\n    '|' +\n    '(?:' + src_pseudo_letter + ')' +\n    '|' +\n    // don't allow `--` in domain names, because:\n    // - that can conflict with markdown &mdash; / &ndash;\n    // - nobody use those anyway\n    '(?:' + src_pseudo_letter + '(?:-(?!-)|' + src_pseudo_letter + '){0,61}' + src_pseudo_letter + ')' +\n  ')';\n\nvar src_host = exports.src_host =\n\n  '(?:' +\n    src_ip4 +\n  '|' +\n    '(?:(?:(?:' + src_domain + ')\\\\.)*' + src_domain_root + ')' +\n  ')';\n\nvar tpl_host_fuzzy = exports.tpl_host_fuzzy =\n\n  '(?:' +\n    src_ip4 +\n  '|' +\n    '(?:(?:(?:' + src_domain + ')\\\\.)+(?:%TLDS%))' +\n  ')';\n\nvar tpl_host_no_ip_fuzzy = exports.tpl_host_no_ip_fuzzy =\n\n  '(?:(?:(?:' + src_domain + ')\\\\.)+(?:%TLDS%))';\n\nexports.src_host_strict =\n\n  src_host + src_host_terminator;\n\nvar tpl_host_fuzzy_strict = exports.tpl_host_fuzzy_strict =\n\n  tpl_host_fuzzy + src_host_terminator;\n\nexports.src_host_port_strict =\n\n  src_host + src_port + src_host_terminator;\n\nvar tpl_host_port_fuzzy_strict = exports.tpl_host_port_fuzzy_strict =\n\n  tpl_host_fuzzy + src_port + src_host_terminator;\n\nvar tpl_host_port_no_ip_fuzzy_strict = exports.tpl_host_port_no_ip_fuzzy_strict =\n\n  tpl_host_no_ip_fuzzy + src_port + src_host_terminator;\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Main rules\n\n// Rude test fuzzy links by host, for quick deny\nexports.tpl_host_fuzzy_test =\n\n  'localhost|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + src_ZPCc + '|$))';\n\nexports.tpl_email_fuzzy =\n\n    '(^|>|' + src_ZCc + ')(' + src_email_name + '@' + tpl_host_fuzzy_strict + ')';\n\nexports.tpl_link_fuzzy =\n    // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n    // but can start with > (markdown blockquote)\n    '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' +\n    '((?![$+<=>^`|])' + tpl_host_port_fuzzy_strict + src_path + ')';\n\nexports.tpl_link_no_ip_fuzzy =\n    // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n    // but can start with > (markdown blockquote)\n    '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' +\n    '((?![$+<=>^`|])' + tpl_host_port_no_ip_fuzzy_strict + src_path + ')';\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/linkify-it/lib/re.js\n **/","/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/punycode/punycode.js\n **/","// markdown-it default options\n\n'use strict';\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '' for Russian, '' for German,\n    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /*  */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   100            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/presets/default.js\n **/","// \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\n// modes. For example, to parse bold/italic only.\n\n'use strict';\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '' for Russian, '' for German,\n    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /*  */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'text_collapse'\n      ]\n    }\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/presets/zero.js\n **/","// Commonmark default options\n\n'use strict';\n\n\nmodule.exports = {\n  options: {\n    html:         true,         // Enable HTML tags in source\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '' for Russian, '' for German,\n    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /*  */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fence',\n        'heading',\n        'hr',\n        'html_block',\n        'lheading',\n        'list',\n        'reference',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'html_inline',\n        'image',\n        'link',\n        'newline',\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'emphasis',\n        'text_collapse'\n      ]\n    }\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it/lib/presets/commonmark.js\n **/","'use strict';\n\n/**\n * Adds `key:Ctrl+B` support to code_inline\n * @param md\n */\n\nmodule.exports = function(md) {\n\n  md.renderer.rules.code_inline = function(tokens, idx, options, env, slf) {\n\n    let token = tokens[idx];\n    let content = token.content.trim();\n\n    if (content.indexOf('key:') == 0) {\n      return renderKey(content.slice(4));\n    } else {\n      let codePrefixes = ['pattern', 'match', 'subject'];\n      for (var i = 0; i < codePrefixes.length; i++) {\n        var prefix = codePrefixes[i];\n        if (content.startsWith(prefix + ':')) {\n          return `<code class=\"${prefix}\">${md.utils.escapeHtml(content.slice(prefix.length + 1))}</code>`;\n        }\n      }\n    }\n\n    return '<code>' + md.utils.escapeHtml(content) + '</code>';\n  };\n\n  function renderKey(keys) {\n\n    var results = [];\n\n    if (keys === '+') {\n      return `<kbd class=\"shortcut\">+</kbd>`;\n    }\n\n    var plusLabel = Math.random();\n    keys = keys.replace(/\\+\\+/g, '+' + plusLabel);\n    keys = keys.split('+');\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      results.push((key == plusLabel) ? '+' : md.utils.escapeHtml(key));\n      if (i < keys.length - 1) {\n        results.push('<span class=\"shortcut__plus\">+</span>');\n      }\n    }\n\n    return `<kbd class=\"shortcut\">${results.join('')}</kbd>`;\n  }\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/plugins/extendedCode.js\n **/","'use strict';\n\n/**\n * Client/server plugin\n */\n\nconst markdownItContainer = require('markdown-it-container');\nconst parseAttrs = require('../utils/parseAttrs');\nconst t = require('i18n');\n\nconst LANG = require('config').lang;\n\nt.requirePhrase('markit.outlined', require('../locales/outlined/' + LANG + '.yml'));\n\nmodule.exports = function(md) {\n\n  ['warn', 'smart', 'ponder'].forEach(name => {\n    md.use(markdownItContainer, name, {\n      marker: '`',\n      render(tokens, idx, options, env, slf) {\n\n        if (tokens[idx].nesting === 1) {\n          let attrs = parseAttrs(tokens[idx].info, true);\n          let header = attrs.header;\n          if (header) {\n            //header = header.replace(/`(.*?)`/g, '<code>$1</code>');\n            header = md.renderInline(header);\n          } else {\n            header = t(`markit.outlined.${name}`);\n          }\n          return `<div class=\"important important_${name}\">\n            <div class=\"important__header\"><span class=\"important__type\">${header}</span></div>\n            <div class=\"important__content\">`;\n\n        } else {\n          // closing tag\n          return '</div></div>\\n';\n        }\n      }\n    });\n  });\n\n\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/plugins/outlinedBlocks.js\n **/","// Process block-level custom containers\n//\n'use strict';\n\n\nmodule.exports = function container_plugin(md, name, options) {\n\n  function validateDefault(params) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, self) {\n\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrPush([ 'class', name ]);\n    }\n\n    return self.renderToken(tokens, idx, _options, env, self);\n  }\n\n  options = options || {};\n\n  var min_markers = 3,\n      marker_str  = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length,\n      validate    = options.validate || validateDefault,\n      render      = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos, nextLine, marker_count, markup, params, token,\n        old_parent, old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false; }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n    if (marker_count < min_markers) { return false; }\n    pos -= (pos - start) % marker_len;\n\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n    if (!validate(params)) { return false; }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true; }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue; }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue; }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) { continue; }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block  = true;\n    token.info   = params;\n    token.map    = [ startLine, nextLine ];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    token        = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block  = true;\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it-container/index.js\n **/","'use strict';\n\n// 'my=5 test=3 bla=\"my \"test\"'  -> my=5 test=3 bla=\"my \"  (test is not matched)\nconst attrsReg = /([\\w-]+)(?:=(?:'((?:\\\\'|[^'])*)'|\"((?:\\\\\"|[^\"])*)\"|(\\S+))|(?:\\s|$))/g;\n\nmodule.exports = function(attrs, withBlockName) {\n  const attrsObject = {};\n\n  if (!attrs) {\n    return attrsObject;\n  }\n\n  let blockName;\n  if (withBlockName) {\n    blockName = attrs.match(/^\\w+/);\n    blockName = blockName && blockName[0];\n    attrs = attrs.replace(/^\\w+\\s+/, '');\n  }\n\n  let match, name, value;\n  while ((match = attrsReg.exec(attrs)) !== null) {\n    name = match[1];\n    value = match[2] !== undefined ? match[2].replace(/\\\\'/g, \"'\") :\n      match[3] !== undefined ? match[3].replace(/\\\\\"/g, '\"') : match[4];\n\n    attrsObject[name.toLowerCase()] = (value === undefined) ? true : value;\n  }\n\n  if (blockName) {\n    attrsObject.blockName = blockName;\n  }\n\n  return attrsObject;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/utils/parseAttrs.js\n **/","'use strict';\n\nconst BabelFish = require('babelfish');\n\nconst i18n = new BabelFish('en');\n\nconst LANG = require('config').lang;\n\nfunction t() {\n  let args = [LANG];\n  for (let i = 0; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n  return i18n.t.apply(i18n, args);\n}\n\nlet docs = {};\n\nt.i18n = i18n;\n\nt.requirePhrase = function(packageName, doc) {\n  // if same phrase with same doc was processed - don't redo it\n  if (docs[packageName] && docs[packageName].indexOf(doc) != -1) return;\n\n  if (!docs[packageName]) docs[packageName] = [];\n  docs[packageName].push(doc);\n\n  i18n.addPhrase(LANG, packageName, doc);\n};\n\n\nmodule.exports = t;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/i18n/index.js\n **/","module.exports = require('./lib/babelfish');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/babelfish/index.js\n **/","/**\n *  class BabelFish\n *\n *  Internalization and localization library that makes i18n and l10n fun again.\n *\n *  ##### Example\n *\n *  ```javascript\n *  var BabelFish = require('babelfish'),\n *      i18n = new BabelFish();\n *  ```\n *\n *  or\n *\n *  ```javascript\n *  var babelfish = require('babelfish'),\n *      i18n = babelfish();\n *  ```\n **/\n\n\n'use strict';\n\n\nvar parser = require('./parser');\nvar plural = require('plurals-cldr');\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction isString(obj)   { return _class(obj) === '[object String]'; }\nfunction isNumber(obj)   { return !isNaN(obj) && isFinite(obj); }\nfunction isBoolean(obj)  { return obj === true || obj === false; }\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\nfunction isObject(obj)   { return _class(obj) === '[object Object]'; }\n\n/*istanbul ignore next*/\nvar isArray = Array.isArray || function _isArray(obj) {\n  return _class(obj) === '[object Array]';\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n// The following two utilities (forEach and extend) are modified from Underscore\n//\n// http://underscorejs.org\n//\n// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//\n// Underscore may be freely distributed under the MIT license\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar nativeForEach = Array.prototype.forEach;\n\n\n// The cornerstone, an `each` implementation, aka `forEach`.\n// Handles objects with the built-in `forEach`, arrays, and raw objects.\n// Delegates to **ECMAScript 5**'s native `forEach` if available.\n/*istanbul ignore next*/\nfunction forEach(obj, iterator, context) {\n  if (obj === null) {\n    return;\n  }\n  if (nativeForEach && obj.forEach === nativeForEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, l = obj.length; i < l; i += 1) {\n      iterator.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        iterator.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n\nvar formatRegExp = /%[sdj%]/g;\n\n/*istanbul ignore next*/\nfunction format(f) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') { return '%'; }\n    if (i >= len) { return x; }\n    switch (x) {\n      case '%s':\n        return String(args[i++]);\n      case '%d':\n        return Number(args[i++]);\n      case '%j':\n        return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  return str;\n}\n\n\n// helpers\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Last resort locale, that exists for sure\nvar GENERIC_LOCALE = 'en';\n\n\n// flatten(obj) -> Object\n//\n// Flattens object into one-level dictionary.\n//\n// ##### Example\n//\n//     var obj = {\n//       abc: { def: 'foo' },\n//       hij: 'bar'\n//     };\n//\n//     flatten(obj);\n//     // -> { 'abc.def': 'foo', 'hij': 'bar' };\n//\nfunction flatten(obj) {\n  var params = {};\n\n  forEach(obj || {}, function (val, key) {\n    if (val && typeof val === 'object') {\n      forEach(flatten(val), function (sub_val, sub_key) {\n        params[key + '.' + sub_key] = sub_val;\n      });\n      return;\n    }\n\n    params[key] = val;\n  });\n\n  return params;\n}\n\n\nvar keySeparator = '#@$';\n\nfunction makePhraseKey(locale, phrase) {\n  return locale + keySeparator + phrase;\n}\n\n\nfunction searchPhraseKey(self, locale, phrase) {\n  var key = makePhraseKey(locale, phrase);\n  var storage = self._storage;\n\n  // direct search first\n  if (storage.hasOwnProperty(key)) { return key; }\n\n  // don't try follbacks for default locale\n  if (locale === self._defaultLocale) { return null; }\n\n  // search via fallback map cache\n  var fb_cache = self._fallbacks_cache;\n  if (fb_cache.hasOwnProperty(key)) { return fb_cache[key]; }\n\n  // scan fallbacks & cache result\n  var fb = self._fallbacks[locale] || [ self._defaultLocale ];\n  var fb_key;\n\n  for (var i = 0, l = fb.length; i < l; i++) {\n    fb_key = makePhraseKey(fb[i], phrase);\n    if (storage.hasOwnProperty(fb_key)) {\n      // found - update cache and return result\n      fb_cache[key] = fb_key;\n      return fb_cache[key];\n    }\n  }\n\n  // mark fb_cache entry empty for fast lookup on next request\n  fb_cache[key] = null;\n  return null;\n}\n\n\nfunction pluralizer(lang, val, forms) {\n  var idx = plural.indexOf(lang, val);\n\n  if (idx === -1) {\n    return format('[pluralizer for \"%s\" locale not found]', lang);\n  }\n\n  if (typeof forms[idx] === 'undefined') {\n    return format('[plural form %d (\"%s\") not found in translation]',\n                      idx, plural.forms(lang)[idx]);\n  }\n\n  return forms[idx];\n}\n\n// public api (module)\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new BabelFish([defaultLocale = 'en'])\n *\n *  Initiates new instance of BabelFish.\n *\n *  __Note!__ you can omit `new` for convenience, direct call will return\n * new instance too.\n **/\nfunction BabelFish(defaultLocale) {\n  if (!(this instanceof BabelFish)) { return new BabelFish(defaultLocale); }\n\n  this._defaultLocale = defaultLocale ? String(defaultLocale) : GENERIC_LOCALE;\n\n  // hash of locale => [ fallback1, fallback2, ... ] pairs\n  this._fallbacks = {};\n\n  // fallback cache for each phrase\n  //\n  // {\n  //   locale_key: fallback_key\n  // }\n  //\n  // fallback_key can be null if search failed\n  //\n  this._fallbacks_cache = {};\n\n  // storage of compiled translations\n  //\n  // {\n  //   locale + @#$ + phrase_key: {\n  //     locale:      locale name - can be different for fallbacks\n  //     translation: original translation phrase or data variable/object\n  //     raw:         true/false - does translation contain plain data or\n  //                  string to compile\n  //     compiled:    copiled translation fn or plain string\n  //   }\n  //   ...\n  // }\n  //\n  this._storage = {};\n\n  // cache for complex plural parts (with params)\n  //\n  // {\n  //   language: new BabelFish(language)\n  // }\n  //\n  this._plurals_cache = {};\n}\n\n\n// public api (instance)\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  BabelFish#addPhrase(locale, phrase, translation [, flattenLevel]) -> BabelFish\n *  - locale (String): Locale of translation\n *  - phrase (String|Null): Phrase ID, e.g. `apps.forum`\n *  - translation (String|Object|Array|Number|Boolean): Translation or an object\n *    with nested phrases, or a pure object.\n *  - flattenLevel (Number|Boolean): Optional, 0..infinity. `Infinity` by default.\n *    Define \"flatten\" deepness for loaded object.  You can also use\n *    `true` as `0` or `false` as `Infinity`.\n *\n *\n *  ##### Flatten & using JS objects\n *\n *  By default all nested properties are normalized to strings like \"foo.bar.baz\",\n *  and if value is string, it will be compiled with babelfish notation.\n *  If deepness is above `flattenLevel` OR value is not object and not string,\n *  it will be used \"as is\". Note, only JSON stringifiable data should be used.\n *\n *  In short: you can safely pass `Array`, `Number` or `Boolean`. For objects you\n *  should define flatten level or disable it compleetely, to work with pure data.\n *\n *  Pure objects can be useful to prepare bulk data for external libraries, like\n *  calendars, time/date generators and so on.\n *\n *  ##### Example\n *\n *  ```javascript\n *  i18n.addPhrase('ru-RU',\n *    'apps.forums.replies_count',\n *    '#{count} %{||}:count  ');\n *\n *  // equals to:\n *  i18n.addPhrase('ru-RU',\n *    'apps.forums',\n *    { replies_count: '#{count} %{||}:count  ' });\n *  ```\n **/\nBabelFish.prototype.addPhrase = function _addPhrase(locale, phrase, translation, flattenLevel) {\n  var self = this, fl;\n\n  // Calculate flatten level. Infinity by default\n  if (isBoolean(flattenLevel)) {\n    fl = flattenLevel ? Infinity : 0;\n  } else if (isNumber(flattenLevel)) {\n    fl = Math.floor(flattenLevel);\n    if (fl < 0) {\n      throw new TypeError('Invalid flatten level (should be >= 0).');\n    }\n  } else {\n    fl = Infinity;\n  }\n\n  if (isObject(translation) && (fl > 0)) {\n    // recursive object walk, until flattenLevel allows\n    forEach(translation, function (val, key) {\n      self.addPhrase(locale, (phrase ? phrase + '.' : '') + key, val, fl - 1);\n    });\n    return this;\n  }\n\n  if (isString(translation)) {\n    this._storage[makePhraseKey(locale, phrase)] = {\n      translation: translation,\n      locale: locale,\n      raw: false\n    };\n  } else if (isArray(translation) ||\n             isNumber(translation) ||\n             isBoolean(translation) ||\n             (fl === 0 && isObject(translation))) {\n    // Pure objects are stored without compilation\n    // Limit allowed types.\n    this._storage[makePhraseKey(locale, phrase)] = {\n      translation: translation,\n      locale: locale,\n      raw: true\n    };\n  } else {\n    // `Regex`, `Date`, `Uint8Array` and others types will\n    //  fuckup `stringify()`. Don't allow here.\n    // `undefined` also means wrong param in real life.\n    // `null` can be allowed when examples from real life available.\n    throw new TypeError('Invalid translation - [String|Object|Array|Number|Boolean] expected.');\n  }\n\n  self._fallbacks_cache = {};\n\n  return this;\n};\n\n\n/**\n *  BabelFish#setFallback(locale, fallbacks) -> BabelFish\n *  - locale (String): Target locale\n *  - fallbacks (Array): List of fallback locales\n *\n *  Set fallbacks for given locale.\n *\n *  When `locale` has no translation for the phrase, `fallbacks[0]` will be\n *  tried, if translation still not found, then `fallbacks[1]` will be tried\n *  and so on. If none of fallbacks have translation,\n *  default locale will be tried as last resort.\n *\n *  ##### Errors\n *\n *  - throws `Error`, when `locale` equals default locale\n *\n *  ##### Example\n *\n *  ```javascript\n *  i18n.setFallback('ua-UK', ['ua', 'ru']);\n *  ```\n **/\nBabelFish.prototype.setFallback = function _setFallback(locale, fallbacks) {\n  var def = this._defaultLocale;\n\n  if (def === locale) {\n    throw new Error(\"Default locale can't have fallbacks\");\n  }\n\n  var fb = isArray(fallbacks) ? fallbacks.slice() : [ fallbacks ];\n  if (fb[fb.length - 1] !== def) { fb.push(def); }\n\n  this._fallbacks[locale] = fb;\n  this._fallbacks_cache = {};\n\n  return this;\n};\n\n\nvar CAN_HAVE_DIRECTIVES_RE = /#\\{|\\(\\(|\\\\\\\\/;\n\n// Compiles given string into function. Used to compile phrases,\n// which contains `plurals`, `variables`, etc.\nfunction compile(self, str, locale) {\n  var nodes, buf, key, strict_exec, forms_exec, plurals_cache;\n\n  // Quick check to avoid parse in most cases :)\n  if (!CAN_HAVE_DIRECTIVES_RE.test(str)) { return str; }\n\n  nodes = parser.parse(str);\n\n  if (nodes.length === 1 && nodes[0].type === 'literal') {\n    return nodes[0].text;\n  }\n\n  // init cache instance for plural parts, if not exists yet.\n  if (!self._plurals_cache[locale]) {\n    self._plurals_cache[locale] = new BabelFish(locale);\n  }\n  plurals_cache = self._plurals_cache[locale];\n\n  buf = [];\n  buf.push([ 'var str = \"\", strict, strict_exec, forms, forms_exec, plrl, cache, loc, loc_plzr, anchor;' ]);\n  buf.push('params = flatten(params);');\n\n  forEach(nodes, function (node) {\n    if (node.type === 'literal') {\n      buf.push(format('str += %j;', node.text));\n      return;\n    }\n\n    if (node.type === 'variable') {\n      key = node.anchor;\n      buf.push(format(\n        'str += (\"undefined\" === typeof (params[%j])) ? \"[missed variable: %s]\" : params[%j];',\n        key, key, key\n      ));\n      return;\n    }\n\n    // should never happen\n    /*istanbul ignore next*/\n    if (node.type !== 'plural') { throw new Error('Unknown node type'); }\n\n    //\n    // Compile plural\n    //\n\n    key = node.anchor;\n    // check if plural parts are plain strings or executable,\n    // and add executable to \"cache\" instance of babelfish\n    // plural part text will be used as translation key\n    strict_exec = {};\n    forEach(node.strict, function (text, k) {\n      var parsed = parser.parse(text);\n      if (parsed.length === 1 && parsed[0].type === 'literal') {\n        strict_exec[k] = false;\n        // patch with unescaped value for direct extract\n        node.strict[k] = parsed[0].text;\n        return;\n      }\n\n      strict_exec[k] = true;\n      if (!plurals_cache.hasPhrase(locale, text, true)) {\n        plurals_cache.addPhrase(locale, text, text);\n      }\n    });\n\n    forms_exec = {};\n    forEach(node.forms, function (text, idx) {\n      var parsed = parser.parse(text), unescaped;\n      if (parsed.length === 1 && parsed[0].type === 'literal') {\n        // patch with unescaped value for direct extract\n        unescaped = parsed[0].text;\n        node.forms[idx] = unescaped;\n        forms_exec[unescaped] = false;\n        return;\n      }\n\n      forms_exec[text] = true;\n      if (!plurals_cache.hasPhrase(locale, text, true)) {\n        plurals_cache.addPhrase(locale, text, text);\n      }\n    });\n    /*eslint-disable space-in-parens*/\n    buf.push(format('loc = %j;', locale));\n    buf.push(format('loc_plzr = %j;', locale.split(/[-_]/)[0]));\n    buf.push(format('anchor = params[%j];', key));\n    buf.push(format('cache = this._plurals_cache[loc];'));\n    buf.push(format('strict = %j;', node.strict));\n    buf.push(format('strict_exec = %j;', strict_exec));\n    buf.push(format('forms = %j;', node.forms));\n    buf.push(format('forms_exec = %j;', forms_exec));\n    buf.push(       'if (+(anchor) != anchor) {');\n    buf.push(format('  str += \"[invalid plurals amount: %s(\" + anchor + \")]\";', key));\n    buf.push(       '} else {');\n    buf.push(       '  if (strict[anchor] !== undefined) {');\n    buf.push(       '    plrl = strict[anchor];');\n    buf.push(       '    str += strict_exec[anchor] ? cache.t(loc, plrl, params) : plrl;');\n    buf.push(       '  } else {');\n    buf.push(       '    plrl = pluralizer(loc_plzr, +anchor, forms);');\n    buf.push(       '    str += forms_exec[plrl] ? cache.t(loc, plrl, params) : plrl;');\n    buf.push(       '  }');\n    buf.push(       '}');\n    return;\n  });\n\n  buf.push('return str;');\n\n  /*eslint-disable no-new-func*/\n  return new Function('params', 'flatten', 'pluralizer', buf.join('\\n'));\n}\n\n\n/**\n *  BabelFish#translate(locale, phrase[, params]) -> String\n *  - locale (String): Locale of translation\n *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n *  - params (Object|Number|String): Params for translation. `Number` & `String`\n *    will be  coerced to `{ count: X, value: X }`\n *\n *  ##### Example\n *\n *  ```javascript\n *  i18n.addPhrase('ru-RU',\n *     'apps.forums.replies_count',\n *     '#{count} ((||))  ');\n *\n *  // ...\n *\n *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 1 });\n *  i18n.translate('ru-RU', 'app.forums.replies_count', 1});\n *  // -> '1 '\n *\n *  i18n.translate('ru-RU', 'app.forums.replies_count', { count: 2 });\n *  i18n.translate('ru-RU', 'app.forums.replies_count', 2);\n *  // -> '2 a'\n *  ```\n **/\nBabelFish.prototype.translate = function _translate(locale, phrase, params) {\n  var key = searchPhraseKey(this, locale, phrase);\n  var data;\n\n  if (!key) {\n    return locale + ': No translation for [' + phrase + ']';\n  }\n\n  data = this._storage[key];\n\n  // simple string or other pure object\n  if (data.raw) { return data.translation; }\n\n  // compile data if not done yet\n  if (!data.hasOwnProperty('compiled')) {\n    // We should use locale from phrase, because of possible fallback,\n    // to keep plural locales in sync.\n    data.compiled = compile(this, data.translation, data.locale);\n  }\n\n  // return simple string immediately\n  if (!isFunction(data.compiled)) {\n    return data.compiled;\n  }\n\n  //\n  // Generate \"complex\" phrase\n  //\n\n  // Sugar: coerce numbers & strings to { count: X, value: X }\n  if (isNumber(params) || isString(params)) {\n    params = { count: params, value: params };\n  }\n\n  return data.compiled.call(this, params, flatten, pluralizer);\n};\n\n\n/**\n *  BabelFish#hasPhrase(locale, phrase) -> Boolean\n *  - locale (String): Locale of translation\n *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n *  - noFallback (Boolean): Disable search in fallbacks\n *\n *  Returns whenever or not there's a translation of a `phrase`.\n **/\nBabelFish.prototype.hasPhrase = function _hasPhrase(locale, phrase, noFallback) {\n  return noFallback ?\n    this._storage.hasOwnProperty(makePhraseKey(locale, phrase))\n  :\n    searchPhraseKey(this, locale, phrase) ? true : false;\n};\n\n\n/**\n *  BabelFish#getLocale(locale, phrase) -> String|null\n *  - locale (String): Locale of translation\n *  - phrase (String): Phrase ID, e.g. `app.forums.replies_count`\n *  - noFallback (Boolean): Disable search in fallbacks\n *\n *  Similar to [[BabelFish#hasPhrase]], but returns real locale of requested\n *  phrase, or `null` if nothing found. Can be useful for dynamic dependencies\n *  init. For example, when you fetch i10n config as single object and create\n *  phrases from it's content.\n **/\nBabelFish.prototype.getLocale = function _getLocale(locale, phrase, noFallback) {\n  if (noFallback) {\n    return this._storage.hasOwnProperty(makePhraseKey(locale, phrase)) ? locale : null;\n  }\n\n  var key = searchPhraseKey(this, locale, phrase);\n\n  return key ? key.split(keySeparator, 2)[0] : null;\n};\n\n\n/** alias of: BabelFish#translate\n *  BabelFish#t(locale, phrase[, params]) -> String\n **/\nBabelFish.prototype.t = BabelFish.prototype.translate;\n\n\n/**\n *  BabelFish#stringify(locale) -> String\n *  - locale (String): Locale of translation\n *\n *  Returns serialized locale data, uncluding fallbacks.\n *  It can be loaded back via `load()` method.\n **/\nBabelFish.prototype.stringify = function _stringify(locale) {\n  var self = this;\n\n  // Collect unique keys\n  var unique = {};\n\n  forEach(this._storage, function (val, key) {\n    unique[key.split(keySeparator)[1]] = true;\n  });\n\n  // Collect phrases (with fallbacks)\n  var result = {};\n\n  forEach(unique, function(val, key) {\n    var k = searchPhraseKey(self, locale, key);\n    // if key was just a garbage from another\n    // and doesn't fit into fallback chain for current locale - skip it\n    if (!k) { return; }\n    // create namespace if not exists\n    var l = self._storage[k].locale;\n    if (!result[l]) { result[l] = {}; }\n    result[l][key] = self._storage[k].translation;\n  });\n\n  var out = {\n    fallback: {},\n    locales: result\n  };\n\n  // Get fallback rule. Cut auto-added fallback to default locale\n  var fallback = (self._fallbacks[locale] || []).slice(0, -1);\n  if (fallback.length) {\n    out.fallback[locale] = fallback;\n  }\n\n  return JSON.stringify(out);\n};\n\n\n/**\n *  BabelFish#load(data) -> BabelFish\n *  - data (Object|String): data from `stringify()` method, as object or string.\n *\n *  Batch load phrases data, prepared with `stringify()` method.\n *  Useful at browser side.\n **/\nBabelFish.prototype.load = function _load(data) {\n  var self = this;\n\n  if (isString(data)) { data = JSON.parse(data); }\n\n  forEach(data.locales, function (phrases, locale) {\n    forEach(phrases, function(translation, key) {\n      self.addPhrase(locale, key, translation, 0);\n    });\n  });\n\n  forEach(data.fallback, function (rule, locale) {\n    self.setFallback(locale, rule);\n  });\n\n  return this;\n};\n\n// export module\nmodule.exports = BabelFish;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/babelfish/lib/babelfish.js\n **/","module.exports = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = [],\n        peg$c1 = peg$FAILED,\n        peg$c2 = \"((\",\n        peg$c3 = { type: \"literal\", value: \"((\", description: \"\\\"((\\\"\" },\n        peg$c4 = \"))\",\n        peg$c5 = { type: \"literal\", value: \"))\", description: \"\\\"))\\\"\" },\n        peg$c6 = null,\n        peg$c7 = function(forms, anchor) {\n              return {\n                type:   'plural',\n                forms:  regularForms(forms),\n                strict: strictForms(forms),\n                anchor: anchor || 'count'\n              };\n            },\n        peg$c8 = \"|\",\n        peg$c9 = { type: \"literal\", value: \"|\", description: \"\\\"|\\\"\" },\n        peg$c10 = function(part, more) {\n              return [part].concat(more);\n            },\n        peg$c11 = function(part) {\n              return [part];\n            },\n        peg$c12 = \"=\",\n        peg$c13 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c14 = /^[0-9]/,\n        peg$c15 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c16 = \" \",\n        peg$c17 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n        peg$c18 = function(strict, form) {\n              return {\n                strict: strict.join(''),\n                text: form.join('')\n              }\n            },\n        peg$c19 = function() {\n              return {\n                text: text()\n              };\n            },\n        peg$c20 = \"\\\\\",\n        peg$c21 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n        peg$c22 = /^[\\\\|)(]/,\n        peg$c23 = { type: \"class\", value: \"[\\\\\\\\|)(]\", description: \"[\\\\\\\\|)(]\" },\n        peg$c24 = function(char) {\n              return char;\n            },\n        peg$c25 = void 0,\n        peg$c26 = { type: \"any\", description: \"any character\" },\n        peg$c27 = function() {\n              return text();\n            },\n        peg$c28 = \":\",\n        peg$c29 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c30 = function(name) {\n              return name;\n            },\n        peg$c31 = \"#{\",\n        peg$c32 = { type: \"literal\", value: \"#{\", description: \"\\\"#{\\\"\" },\n        peg$c33 = \"}\",\n        peg$c34 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c35 = function(anchor) {\n              return {\n                type:   'variable',\n                anchor: anchor\n              };\n            },\n        peg$c36 = \".\",\n        peg$c37 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c38 = function() {\n              return text()\n            },\n        peg$c39 = /^[a-zA-Z_$]/,\n        peg$c40 = { type: \"class\", value: \"[a-zA-Z_$]\", description: \"[a-zA-Z_$]\" },\n        peg$c41 = /^[a-zA-Z0-9_$]/,\n        peg$c42 = { type: \"class\", value: \"[a-zA-Z0-9_$]\", description: \"[a-zA-Z0-9_$]\" },\n        peg$c43 = function(lc) { return lc; },\n        peg$c44 = function(literal_chars) {\n              return {\n                type: 'literal',\n                text: literal_chars.join('')\n              };\n            },\n        peg$c45 = /^[\\\\#()|]/,\n        peg$c46 = { type: \"class\", value: \"[\\\\\\\\#()|]\", description: \"[\\\\\\\\#()|]\" },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1;\n\n      s0 = [];\n      s1 = peg$parseliteral();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseplural();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsevariable();\n        }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parseliteral();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseplural();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsevariable();\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c2) {\n        s1 = peg$c2;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseplural_forms();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c4) {\n            s3 = peg$c4;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseplural_anchor();\n            if (s4 === peg$FAILED) {\n              s4 = peg$c6;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c1;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_forms() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseplural_part();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s2 = peg$c8;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c9); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseplural_forms();\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c10(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseplural_part();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c11(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_part() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s1 = peg$c12;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c13); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c14.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c14.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c15); }\n            }\n          }\n        } else {\n          s2 = peg$c1;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s3 = peg$c16;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c6;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseplural_char();\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parseplural_char();\n              }\n            } else {\n              s4 = peg$c1;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c18(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c1;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseplural_char();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parseplural_char();\n          }\n        } else {\n          s1 = peg$c1;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c19();\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_char() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c22.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c23); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c24(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s2 = peg$c8;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c9); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c4) {\n            s2 = peg$c4;\n            peg$currPos += 2;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = peg$c25;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c1;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c26); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c27();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseplural_anchor() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifier();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c30(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsevariable() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c31) {\n        s1 = peg$c31;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifier();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s3 = peg$c33;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c35(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifier_part();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c36;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseidentifier();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseidentifier();\n            }\n          } else {\n            s3 = peg$c1;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c38();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier_part();\n      }\n\n      return s0;\n    }\n\n    function peg$parseidentifier_part() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (peg$c39.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c41.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c41.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c42); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c27();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseliteral() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parseplural();\n      if (s4 === peg$FAILED) {\n        s4 = peg$parsevariable();\n      }\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c25;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c1;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseliteral_char();\n        if (s4 !== peg$FAILED) {\n          peg$reportedPos = s2;\n          s3 = peg$c43(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c1;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseplural();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsevariable();\n          }\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c25;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c1;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseliteral_char();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s2;\n              s3 = peg$c43(s4);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c1;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c1;\n          }\n        }\n      } else {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseliteral_char() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c45.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c24(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c26); }\n        }\n      }\n\n      return s0;\n    }\n\n\n      function regularForms(forms) {\n        var result = [];\n        for (var i=0; i<forms.length; i++) {\n          if (forms[i].strict === undefined) { result.push(forms[i].text); }\n        }\n        return result;\n      }\n      function strictForms(forms) {\n        var result = {};\n        for (var i=0; i<forms.length; i++) {\n          if (forms[i].strict !== undefined) { result[forms[i].strict] = forms[i].text; }\n        }\n        return result;\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/babelfish/lib/parser.js\n **/","/*\n * Plural functions support (cardinal & ordinal forms)\n *\n * Autogenerated from CLDR:\n *\n *   Version:   28\n *   $Revision: 12002 $\n */\n\n'use strict';\n\n\n// pluralizers cache\nvar s = {};\n\nfunction normalize(loc) {\n  var l;\n  if (s[loc]) { return loc; }\n  l = loc.toLowerCase().replace('_', '-');\n  if (s[l]) { return l; }\n  l = l.split('-')[0];\n  if (s[l]) { return l; }\n  return null;\n}\n\nfunction forms(loc) {\n  var l = normalize(loc);\n  return s[l] ? s[l].c : null;\n}\n\nfunction indexOf(loc, value) {\n  var l = normalize(loc);\n  if (!l) {\n    return -1;\n  }\n\n  if (!s[l].cFn) {\n    return 0;\n  }\n\n  var sval  = String(value),\n      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n      v = f.length,\n      n = +value,\n      i = +(sval.split('.')[0]),\n      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\n  return s[l].cFn(n, i, v, +f, t);\n}\n\nfunction plural(loc, value) {\n  var l = normalize(loc);\n  if (!l) {\n    return null;\n  }\n  return s[l].c[indexOf(l, value)];\n}\n\n\nfunction o_forms(loc) {\n  var l = normalize(loc);\n  return s[l] ? s[l].o : null;\n}\n\nfunction o_indexOf(loc, value) {\n  var l = normalize(loc);\n  if (!l) {\n    return -1;\n  }\n\n  if (!s[l].oFn) {\n    return 0;\n  }\n\n  var sval  = String(value),\n      f = sval.indexOf('.') < 0 ? '' : sval.split('.')[1],\n      v = f.length,\n      n = +value,\n      i = +(sval.split('.')[0]),\n      t = f.length === 0 ? 0 : +f.replace(/0+$/, '');\n\n  return s[l].oFn(n, i, v, +f, t);\n}\n\nfunction ordinal(loc, value) {\n  var l = normalize(loc);\n  if (!s[l]) {\n    return null;\n  }\n  return s[l].o[o_indexOf(l, value)];\n}\n\nmodule.exports                  = plural;\nmodule.exports.indexOf          = indexOf;\nmodule.exports.forms            = forms;\nmodule.exports.ordinal          = ordinal;\nmodule.exports.ordinal.indexOf  = o_indexOf;\nmodule.exports.ordinal.forms    = o_forms;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar FORMS = [ 'zero', 'one', 'two', 'few', 'many', 'other' ];\n\nfunction unpack(i) { return FORMS[i]; }\n\n// adds given `rule` pluralizer for given `locales` into `storage`\nfunction add(locales, rule) {\n  var i;\n\n  rule.c = rule.c ? rule.c.map(unpack) : [ 'other' ];\n  rule.o = rule.o ? rule.o.map(unpack) : [ 'other' ];\n\n  for (i = 0; i < locales.length; i++) {\n    s[locales[i]] = rule;\n  }\n}\n\nfunction B(x, y, val) { return x <= val && val <= y && val % 1 === 0; }\nfunction IN(set, val) { return set.indexOf(val) >= 0; }\n\n\nadd([ 'af', 'asa', 'bem', 'bez', 'bg', 'brx', 'ce', 'cgg', 'chr', 'ckb', 'dv', 'ee', 'el', 'eo', 'es', 'eu', 'fo', 'fur', 'gsw', 'ha', 'haw', 'jgo', 'jmc', 'kaj', 'kcg', 'kkj', 'kl', 'ks', 'ksb', 'ku', 'ky', 'lb', 'lg', 'mas', 'mgo', 'ml', 'mn', 'nah', 'nb', 'nd', 'nn', 'nnh', 'no', 'nr', 'ny', 'nyn', 'om', 'or', 'os', 'pap', 'ps', 'rm', 'rof', 'rwk', 'saq', 'sdh', 'seh', 'sn', 'so', 'ss', 'ssy', 'st', 'syr', 'ta', 'te', 'teo', 'tig', 'tk', 'tn', 'tr', 'ts', 'ug', 'uz', 've', 'vo', 'vun', 'wae', 'xh', 'xog' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'ak', 'bh', 'guw', 'ln', 'mg', 'nso', 'pa', 'ti', 'wa' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return B(0, 1, n) ? 0 : 1;\n  }\n});\n\nadd([ 'am', 'fa', 'kn', 'zu' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'ar' ], {\n  c: [ 0, 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    var n100 = n % 100;\n    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : B(3, 10, n100) ? 3 : B(11, 99, n100) ? 4 : 5;\n  }\n});\n\nadd([ 'as', 'bn' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 4, 5 ],\n  oFn: function (n) {\n    return IN([ 1, 5, 7, 8, 9, 10 ], n) ? 0 : IN([ 2, 3 ], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n  }\n});\n\nadd([ 'ast', 'de', 'et', 'fi', 'fy', 'gl', 'ji', 'nl', 'sw', 'ur', 'yi' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  }\n});\n\nadd([ 'az' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 3, 4, 5 ],\n  oFn: function (n, i) {\n    var i10 = i % 10, i100 = i % 100, i1000 = i % 1000;\n    return IN([ 1, 2, 5, 7, 8 ], i10) || IN([ 20, 50, 70, 80 ], i100) ? 0 : IN([ 3, 4 ], i10) || IN([ 100, 200, 300, 400, 500, 600, 700, 800, 900 ], i1000) ? 1 : i === 0 || i10 === 6 || IN([ 40, 60, 90 ], i100) ? 2 : 3;\n  }\n});\n\nadd([ 'be' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 1 && n100 !== 11 ? 0 : B(2, 4, n10) && !B(12, 14, n100) ? 1 : n10 === 0 || B(5, 9, n10) || B(11, 14, n100) ? 2 : 3;\n  },\n  o: [ 3, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return IN([ 2, 3 ], n10) && !IN([ 12, 13 ], n100) ? 0 : 1;\n  }\n});\n\nadd([ 'bm', 'bo', 'dz', 'id', 'ig', 'ii', 'in', 'ja', 'jbo', 'jv', 'jw', 'kde', 'kea', 'km', 'ko', 'lkt', 'my', 'nqo', 'root', 'sah', 'ses', 'sg', 'th', 'to', 'wo', 'yo', 'zh' ], {\n});\n\nadd([ 'br' ], {\n  c: [ 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    var n10 = n % 10, n100 = n % 100, n1000000 = n % 1000000;\n    return n10 === 1 && !IN([ 11, 71, 91 ], n100) ? 0 : n10 === 2 && !IN([ 12, 72, 92 ], n100) ? 1 : (B(3, 4, n10) || n10 === 9) && (!B(10, 19, n100) && !B(70, 79, n100) && !B(90, 99, n100)) ? 2 : n !== 0 && n1000000 === 0 ? 3 : 4;\n  }\n});\n\nadd([ 'bs', 'hr', 'sh', 'sr' ], {\n  c: [ 1, 3, 5 ],\n  cFn: function (n, i, v, f) {\n    var i10 = i % 10, i100 = i % 100, f10 = f % 10, f100 = f % 100;\n    return v === 0 && i10 === 1 && i100 !== 11 || f10 === 1 && f100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) || B(2, 4, f10) && !B(12, 14, f100) ? 1 : 2;\n  }\n});\n\nadd([ 'ca' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 5 ],\n  oFn: function (n) {\n    return IN([ 1, 3 ], n) ? 0 : n === 2 ? 1 : n === 4 ? 2 : 3;\n  }\n});\n\nadd([ 'cs', 'sk' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : B(2, 4, i) && v === 0 ? 1 : v !== 0 ? 2 : 3;\n  }\n});\n\nadd([ 'cy' ], {\n  c: [ 0, 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n === 3 ? 3 : n === 6 ? 4 : 5;\n  },\n  o: [ 0, 1, 2, 3, 4, 5 ],\n  oFn: function (n) {\n    return IN([ 0, 7, 8, 9 ], n) ? 0 : n === 1 ? 1 : n === 2 ? 2 : IN([ 3, 4 ], n) ? 3 : IN([ 5, 6 ], n) ? 4 : 5;\n  }\n});\n\nadd([ 'da' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f, t) {\n    return n === 1 || t !== 0 && IN([ 0, 1 ], i) ? 0 : 1;\n  }\n});\n\nadd([ 'dsb', 'hsb' ], {\n  c: [ 1, 2, 3, 5 ],\n  cFn: function (n, i, v, f) {\n    var i100 = i % 100, f100 = f % 100;\n    return v === 0 && i100 === 1 || f100 === 1 ? 0 : v === 0 && i100 === 2 || f100 === 2 ? 1 : v === 0 && B(3, 4, i100) || B(3, 4, f100) ? 2 : 3;\n  }\n});\n\nadd([ 'en' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 1 && n100 !== 11 ? 0 : n10 === 2 && n100 !== 12 ? 1 : n10 === 3 && n100 !== 13 ? 2 : 3;\n  }\n});\n\nadd([ 'ff', 'kab' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return IN([ 0, 1 ], i) ? 0 : 1;\n  }\n});\n\nadd([ 'fil', 'tl' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f) {\n    var i10 = i % 10, f10 = f % 10;\n    return v === 0 && IN([ 1, 2, 3 ], i) || v === 0 && !IN([ 4, 6, 9 ], i10) || v !== 0 && !IN([ 4, 6, 9 ], f10) ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'fr', 'hy' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return IN([ 0, 1 ], i) ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'ga' ], {\n  c: [ 1, 2, 3, 4, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : n === 2 ? 1 : B(3, 6, n) ? 2 : B(7, 10, n) ? 3 : 4;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'gd' ], {\n  c: [ 1, 2, 3, 5 ],\n  cFn: function (n) {\n    return IN([ 1, 11 ], n) ? 0 : IN([ 2, 12 ], n) ? 1 : (B(3, 10, n) || B(13, 19, n)) ? 2 : 3;\n  }\n});\n\nadd([ 'gu', 'hi' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 4, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : IN([ 2, 3 ], n) ? 1 : n === 4 ? 2 : n === 6 ? 3 : 4;\n  }\n});\n\nadd([ 'gv' ], {\n  c: [ 1, 2, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return v === 0 && i10 === 1 ? 0 : v === 0 && i10 === 2 ? 1 : v === 0 && IN([ 0, 20, 40, 60, 80 ], i100) ? 2 : v !== 0 ? 3 : 4;\n  }\n});\n\nadd([ 'he', 'iw' ], {\n  c: [ 1, 2, 4, 5 ],\n  cFn: function (n, i, v) {\n    var n10 = n % 10;\n    return i === 1 && v === 0 ? 0 : i === 2 && v === 0 ? 1 : v === 0 && !B(0, 10, n) && n10 === 0 ? 2 : 3;\n  }\n});\n\nadd([ 'hu' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return IN([ 1, 5 ], n) ? 0 : 1;\n  }\n});\n\nadd([ 'is' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f, t) {\n    var i10 = i % 10, i100 = i % 100;\n    return t === 0 && i10 === 1 && i100 !== 11 || t !== 0 ? 0 : 1;\n  }\n});\n\nadd([ 'it' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 4, 5 ],\n  oFn: function (n) {\n    return IN([ 11, 8, 80, 800 ], n) ? 0 : 1;\n  }\n});\n\nadd([ 'iu', 'kw', 'naq', 'se', 'sma', 'smi', 'smj', 'smn', 'sms' ], {\n  c: [ 1, 2, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : n === 2 ? 1 : 2;\n  }\n});\n\nadd([ 'ka' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 4, 5 ],\n  oFn: function (n, i) {\n    var i100 = i % 100;\n    return i === 1 ? 0 : i === 0 || (B(2, 20, i100) || i100 === 40 || i100 === 60 || i100 === 80) ? 1 : 2;\n  }\n});\n\nadd([ 'kk' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 4, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10;\n    return n10 === 6 || n10 === 9 || n10 === 0 && n !== 0 ? 0 : 1;\n  }\n});\n\nadd([ 'ksh' ], {\n  c: [ 0, 1, 5 ],\n  cFn: function (n) {\n    return n === 0 ? 0 : n === 1 ? 1 : 2;\n  }\n});\n\nadd([ 'lag' ], {\n  c: [ 0, 1, 5 ],\n  cFn: function (n, i) {\n    return n === 0 ? 0 : IN([ 0, 1 ], i) && n !== 0 ? 1 : 2;\n  }\n});\n\nadd([ 'lo', 'ms', 'vi' ], {\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'lt' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v, f) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 1 && !B(11, 19, n100) ? 0 : B(2, 9, n10) && !B(11, 19, n100) ? 1 : f !== 0 ? 2 : 3;\n  }\n});\n\nadd([ 'lv', 'prg' ], {\n  c: [ 0, 1, 5 ],\n  cFn: function (n, i, v, f) {\n    var n10 = n % 10, n100 = n % 100, f100 = f % 100, f10 = f % 10;\n    return n10 === 0 || B(11, 19, n100) || v === 2 && B(11, 19, f100) ? 0 : n10 === 1 && n100 !== 11 || v === 2 && f10 === 1 && f100 !== 11 || v !== 2 && f10 === 1 ? 1 : 2;\n  }\n});\n\nadd([ 'mk' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f) {\n    var i10 = i % 10, f10 = f % 10;\n    return v === 0 && i10 === 1 || f10 === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 4, 5 ],\n  oFn: function (n, i) {\n    var i10 = i % 10, i100 = i % 100;\n    return i10 === 1 && i100 !== 11 ? 0 : i10 === 2 && i100 !== 12 ? 1 : IN([ 7, 8 ], i10) && !IN([ 17, 18 ], i100) ? 2 : 3;\n  }\n});\n\nadd([ 'mo', 'ro' ], {\n  c: [ 1, 3, 5 ],\n  cFn: function (n, i, v) {\n    var n100 = n % 100;\n    return i === 1 && v === 0 ? 0 : v !== 0 || n === 0 || n !== 1 && B(1, 19, n100) ? 1 : 2;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'mr' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : 1;\n  },\n  o: [ 1, 2, 3, 5 ],\n  oFn: function (n) {\n    return n === 1 ? 0 : IN([ 2, 3 ], n) ? 1 : n === 4 ? 2 : 3;\n  }\n});\n\nadd([ 'mt' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n) {\n    var n100 = n % 100;\n    return n === 1 ? 0 : n === 0 || B(2, 10, n100) ? 1 : B(11, 19, n100) ? 2 : 3;\n  }\n});\n\nadd([ 'ne' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    return B(1, 4, n) ? 0 : 1;\n  }\n});\n\nadd([ 'pl' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return i === 1 && v === 0 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i !== 1 && B(0, 1, i10) || v === 0 && B(5, 9, i10) || v === 0 && B(12, 14, i100) ? 2 : 3;\n  }\n});\n\nadd([ 'pt' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return B(0, 2, n) && n !== 2 ? 0 : 1;\n  }\n});\n\nadd([ 'pt-pt' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return n === 1 && v === 0 ? 0 : 1;\n  }\n});\n\nadd([ 'ru' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n  }\n});\n\nadd([ 'shi' ], {\n  c: [ 1, 3, 5 ],\n  cFn: function (n, i) {\n    return i === 0 || n === 1 ? 0 : B(2, 10, n) ? 1 : 2;\n  }\n});\n\nadd([ 'si' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v, f) {\n    return IN([ 0, 1 ], n) || i === 0 && f === 1 ? 0 : 1;\n  }\n});\n\nadd([ 'sl' ], {\n  c: [ 1, 2, 3, 5 ],\n  cFn: function (n, i, v) {\n    var i100 = i % 100;\n    return v === 0 && i100 === 1 ? 0 : v === 0 && i100 === 2 ? 1 : v === 0 && B(3, 4, i100) || v !== 0 ? 2 : 3;\n  }\n});\n\nadd([ 'sq' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return n === 1 ? 0 : 1;\n  },\n  o: [ 1, 4, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n === 1 ? 0 : n10 === 4 && n100 !== 14 ? 1 : 2;\n  }\n});\n\nadd([ 'sv' ], {\n  c: [ 1, 5 ],\n  cFn: function (n, i, v) {\n    return i === 1 && v === 0 ? 0 : 1;\n  },\n  o: [ 1, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return IN([ 1, 2 ], n10) && !IN([ 11, 12 ], n100) ? 0 : 1;\n  }\n});\n\nadd([ 'tzm' ], {\n  c: [ 1, 5 ],\n  cFn: function (n) {\n    return B(0, 1, n) || B(11, 99, n) ? 0 : 1;\n  }\n});\n\nadd([ 'uk' ], {\n  c: [ 1, 3, 4, 5 ],\n  cFn: function (n, i, v) {\n    var i10 = i % 10, i100 = i % 100;\n    return v === 0 && i10 === 1 && i100 !== 11 ? 0 : v === 0 && B(2, 4, i10) && !B(12, 14, i100) ? 1 : v === 0 && i10 === 0 || v === 0 && B(5, 9, i10) || v === 0 && B(11, 14, i100) ? 2 : 3;\n  },\n  o: [ 3, 5 ],\n  oFn: function (n) {\n    var n10 = n % 10, n100 = n % 100;\n    return n10 === 3 && n100 !== 13 ? 0 : 1;\n  }\n});\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/plurals-cldr/index.js\n **/","var map = {\n\t\"./en.yml\": 332,\n\t\"./ru.yml\": 333\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 331;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/markit/locales/outlined ^\\.\\/.*\\.yml$\n ** module id = 331\n ** module chunks = 29\n **/","module.exports = {\n\t\"smart\": \"Please note:\",\n\t\"warn\": \"Important:\",\n\t\"ponder\": \"How do you think?\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/markit/locales/outlined/en.yml\n ** module id = 332\n ** module chunks = 29\n **/","module.exports = {\n\t\"smart\": \" :\",\n\t\"warn\": \":\",\n\t\"ponder\": \"  ?\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/markit/locales/outlined/ru.yml\n ** module id = 333\n ** module chunks = 29\n **/","'use strict';\n\n/**\n * Client/server plugin\n * Rewrites fenced blocks to blocktag_source\n * adds the renderer for it\n */\n\nconst parseAttrs = require('../utils/parseAttrs');\nconst stripIndents = require('textUtil/stripIndents');\nconst extractHighlight = require('../utils/source/extractHighlight');\nconst t = require('i18n');\nconst getPrismLanguage = require('../getPrismLanguage');\n\nconst LANG = require('config').lang;\n\nt.requirePhrase('markit.code', require('../locales/code/' + LANG + '.yml'));\n\n\nfunction rewriteFenceToSource(state) {\n\n  for (var idx = 0; idx < state.tokens.length; idx++) {\n\n    if (state.tokens[idx].type == 'fence') {\n      let attrs = parseAttrs(state.tokens[idx].info, true);\n\n      let langOrExt = attrs.blockName || '';\n\n      if (getPrismLanguage.allSupported.indexOf(langOrExt) == -1) continue;\n\n      state.tokens[idx].type = 'blocktag_source';\n      state.tokens[idx].blockTagAttrs = attrs;\n    }\n  }\n\n}\n\n\nmodule.exports = function(md) {\n\n  md.core.ruler.push('rewrite_fence_to_source', rewriteFenceToSource);\n\n  md.renderer.rules.blocktag_source = function(tokens, idx, options, env, slf) {\n    let token = tokens[idx];\n\n    let attrs = token.blockTagAttrs;\n\n    var lang = attrs.blockName;\n    let prismLanguage = getPrismLanguage(lang);\n\n    token.attrPush([ 'data-trusted', (options.html && !attrs.untrusted) ? 1 : 0]);\n\n    token.attrPush([ 'class', 'code-example' ]);\n\n    if (attrs['no-strict']) {\n      token.attrPush(['data-no-strict', 1]);\n    }\n\n    let height;\n    // demo height of\n    if (+attrs.height) {\n      height = +attrs.height;\n      if (!options.html) height = Math.max(height, 800);\n      token.attrPush(['data-demo-height', height]);\n    }\n\n    if (options.html && attrs.autorun) {\n      // autorun may have \"no-epub\" value meaning that it shouldn't run on epub (code not supported)\n      token.attrPush(['data-autorun', attrs.autorun]);\n    }\n\n    if (attrs.refresh) {\n      token.attrPush(['data-refresh', '1']);\n    }\n\n    if (options.html && attrs.demo) {\n      token.attrPush(['data-demo', '1']);\n    }\n\n    // strip first empty lines\n    let content = stripIndents(token.content);\n\n    let highlight = extractHighlight(content);\n\n    if (highlight.block) {\n      token.attrPush(['data-highlight-block', highlight.block]);\n    }\n    if (highlight.inline) {\n      token.attrPush(['data-highlight-inline', highlight.inline]);\n    }\n\n    content = highlight.text;\n\n    let toolbarHtml = '';\n    if (attrs.run) {\n      toolbarHtml = `\n        <div class=\"toolbar codebox__toolbar\">\n          <div class=\"toolbar__tool\">\n            <a href=\"#\" title=\"${t(lang == 'js' ? 'markit.code.run' : 'markit.code.show')}\" data-action=\"run\" class=\"toolbar__button toolbar__button_run\"></a>\n          </div>\n          <div class=\"toolbar__tool\">\n            <a href=\"#\" title=\"${t('markit.code.open.sandbox')}\" target=\"_blank\" data-action=\"edit\" class=\"toolbar__button toolbar__button_edit\"></a>\n          </div>\n        </div>`;\n    }\n\n    let codeResultHtml = '';\n\n    //- iframe must be in HTML with the right height\n    //- otherwise page sizes will be wrong and autorun leads to resizes/jumps\n    if (attrs.autorun && options.html && lang == 'html') {\n      //- iframes with about:html are saved to disk incorrectly by FF (1 iframe content for all)\n      //- @see https://bugzilla.mozilla.org/show_bug.cgi?id=1154167\n      codeResultHtml = `<div class=\"code-result code-example__result\">\n        <iframe\n          class=\"code-result__iframe\"\n          name=\"code-result-${(Math.random()*1e9^0).toString(36)}\"\n          style=\"height:${height || 200}px\"\n          src=\"${options.ebookType == 'epub' ? (\"/bookify/blank.html?\" + Math.random()) : 'about:blank'}\"></iframe>\n      </div>`;\n    }\n\n    return `<div${slf.renderAttrs(token)}>\n      <div class=\"codebox code-example__codebox\">\n        ${toolbarHtml}\n        <div class=\"codebox__code\" data-code=\"1\">\n          <pre class=\"line-numbers language-${prismLanguage}\"><code class=\"language-${prismLanguage}\">${md.utils.escapeHtml(content)}</code></pre>\n        </div>\n      </div>\n      ${codeResultHtml}\n      </div>`;\n\n  };\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/plugins/sourceBlocks.js\n **/","\nfunction stripFirstEmptyLines(text) {\n  return text.replace(/^\\n+/, ''); // no 'm' flag!\n}\n// strip first empty lines\nfunction rtrim(text) {\n  return text.replace(/\\s+$/, '');  // no 'm' flag!\n}\n\nfunction rtrimLines(text) {\n  return text.replace(/[ \\t]+$/gim, '');\n}\n\nfunction stripSpaceIndent(text) {\n\n  if (!text) return text;\n\n  var stripPattern = /^ *(?=\\S+)/gm;\n\n  var indentLen = text.match(stripPattern)\n    .reduce(function (min, line) {\n      return Math.min(min, line.length);\n    }, Infinity);\n\n  var indent = new RegExp('^ {' + indentLen + '}', 'gm');\n  return indentLen > 0 ? text.replace(indent, '') : text;\n}\n\nfunction stripTabIndent(text) {\n  if (!text) return text;\n\n  var stripPattern = /^\\t*(?=\\S+)/gm;\n\n  var indentLen = text.match(stripPattern)\n    .reduce(function (min, line) {\n      return Math.min(min, line.length);\n    }, Infinity);\n\n  var indent = new RegExp('^\\t{' + indentLen + '}', 'gm');\n  return indentLen > 0 ? text.replace(indent, '') : text;\n}\n\n// same as Ruby strip_heredoc + rtrim every line + strip first lines and rtrim\nmodule.exports = function(text) {\n  text = rtrim(text);\n  text = rtrimLines(text);\n  text = stripFirstEmptyLines(text);\n\n  text = stripSpaceIndent(text);\n  text = stripTabIndent(text);\n\n  return text;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/textUtil/stripIndents.js\n **/","\nfunction deTab(text) {\n  // attacklab: Detab's completely rewritten for speed.\n  // In perl we could fix it by anchoring the regexp with \\G.\n  // In javascript we're less fortunate.\n\n  // expand first n-1 tabs\n  text = text.replace(/\\t(?=\\t)/g, \"  \"); // attacklab: g_tab_width\n\n  // replace the nth with two sentinels\n  text = text.replace(/\\t/g, \"~A~B\");\n\n  // use the sentinel to anchor our regex so it doesn't explode\n  text = text.replace(/~B(.+?)~A/g,\n    function(wholeMatch, m1) {\n      var leadingText = m1;\n      var numSpaces = 2 - leadingText.length % 2;  // attacklab: g_tab_width\n\n      // there *must* be a better way to do this:\n      for (var i = 0; i < numSpaces; i++) leadingText += \" \";\n\n      return leadingText;\n    }\n  );\n\n  // clean up sentinels\n  text = text.replace(/~A/g, \"  \");  // attacklab: g_tab_width\n  text = text.replace(/~B/g, \"\");\n\n  return text;\n}\n\nmodule.exports = function(text) {\n  text = deTab(text);\n  text += \"\\n\";\n\n  var r = {block: [], inline: []};\n  var last = null;\n  var newText = [];\n\n  text.split(\"\\n\").forEach(function(line) {\n    if (/^\\s*\\*!\\*\\s*$/.test(line)) { // only *!*\n      if (last) {\n        newText.push(line);\n      } else {\n        last = newText.length;\n      }\n    } else if (/^\\s*\\*\\/!\\*\\s*$/.test(line)) { // only */!*\n      if (last !== null) {\n        r.block.push(last + '-' + (newText.length-1));\n        last = null;\n      } else {\n        newText.push(line);\n      }\n    } else if (/\\s*\\*!\\*\\s*$/.test(line)) { // ends with *!*\n      r.block.push(newText.length + '-' + newText.length);\n      line = line.replace(/\\s*\\*!\\*\\s*$/g, '');\n      newText.push(line);\n    } else {\n      newText.push(\"\");\n      var offset = 0;\n      while(true) {\n        var fromPos = line.indexOf('*!*');\n        var toPos = line.indexOf('*/!*');\n        if (fromPos != -1 && toPos != -1) {\n          r.inline.push( (newText.length-1) + ':' + (offset+fromPos) + '-' + (offset+toPos-3) );\n          newText[newText.length-1] += line.slice(0, toPos+4).replace(/\\*\\/?!\\*/g, '');\n          offset += toPos - 3;\n          line = line.slice(toPos+4);\n        } else {\n          newText[newText.length-1] += line;\n          break;\n        }\n      }\n    }\n  });\n\n  if (last) {\n    r.block.push( last + '-' + (newText.length-1) );\n  }\n\n  return {\n    block: r.block.join(','),\n    inline: r.inline.join(','),\n    text: newText.join(\"\\n\").replace(/\\s+$/, '')\n  };\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/utils/source/extractHighlight.js\n **/","'use strict';\n\nlet ext2language = {\n  html:   'markup',\n  js:     'javascript',\n  coffee: 'coffeescript',\n  '':     'none'\n};\n\nlet languages = 'none markup javascript css coffeescript php http java ruby scss sql'.split(' ');\n\nlet allSupported = Object.keys(ext2language).concat(languages);\n\nfunction getPrismLanguage(language) {\n  language = ext2language[language] || language;\n  if (languages.indexOf(language) == -1) language = 'none';\n\n  return language;\n}\n\n// all supported programming languages\ngetPrismLanguage.languages = languages;\n\n// all supported programming languages and extensions\ngetPrismLanguage.allSupported = allSupported;\n\nmodule.exports = getPrismLanguage;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/getPrismLanguage.js\n **/","'use strict';\n\n/**\n * Reads attrs from ![alt|height=100 width=200](...) into image token\n *\n * P.S. Plugins that work like ![...](/url =100x150) require special parser, not markdown-compatible markup\n */\n\nconst parseAttrs = require('../utils/parseAttrs');\nconst tokenUtils = require('../utils/token');\n\nfunction readImgAttrs(state) {\n\n  for (let idx = 0; idx < state.tokens.length; idx++) {\n    let token = state.tokens[idx];\n\n    if (token.type !== 'inline') continue;\n\n    for (let i = 0; i < token.children.length; i++) {\n      let inlineToken = token.children[i];\n\n      if (inlineToken.type == 'image') {\n        processImg(inlineToken);\n      }\n    }\n  }\n\n\n  // doesn't work for ![desc *me*|height=\"*hi*\"](fig.png)\n  // works for ![desc *me*|height=\"hi\"](fig.png)\n  function processImg(imgToken) {\n    if (!imgToken.children.length) return; // ![](..) empty image\n\n    // last always textToken\n    let lastTextToken = imgToken.children[imgToken.children.length - 1];\n\n    let parts = lastTextToken.content.split('|');\n    if (parts.length != 2) { // no | or many || (invalid)\n      // try ', ' for tables\n      parts = lastTextToken.content.split(', ');\n      if (parts.length != 2) {\n        // still invalid\n        return;\n      }\n    }\n\n    lastTextToken.content = parts[0];\n\n    let attrs = parseAttrs(parts[1]);\n\n    for (let name in attrs) {\n      if (!state.md.options.html && ['height', 'width'].indexOf(name) == -1) continue;\n      tokenUtils.attrReplace(imgToken, name, attrs[name]);\n    }\n  }\n\n\n}\n\nmodule.exports = function(md) {\n\n  md.core.ruler.push('read_img_attrs', readImgAttrs);\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/plugins/imgDescToAttrs.js\n **/","'use strict';\n\n/**\n * tokenAttrReplace(name, value)\n *\n * Replace all attributes with name `name` with one with the value `attrData`\n **/\nfunction attrReplace(token, name, value) {\n  var found;\n\n  var attrs = token.attrs;\n\n  if (attrs) {\n    // modify the existing attr is possible\n    for (var i = 0; i < attrs.length; i++) {\n      if (attrs[i][0] === name) {\n        if (!found) {\n          attrs[i][1] = value;\n          found = true;\n        } else {\n          // remove extra attrs with same name\n          attrs.splice(i, 1);\n          i--;\n        }\n      }\n    }\n\n    // add a new attribute with such name if none was found\n    if (!found) {\n      attrs.push([name, value]);\n    }\n  } else {\n    token.attrs = [ [name, value] ];\n  }\n}\n\nfunction addClass(token, value) {\n  let classAttr = attrGet(token, 'class');\n  if (classAttr.match(new RegExp(`\\b${value}\\b`))) return;\n\n  if (classAttr) {\n    classAttr += ' ' + value;\n  } else {\n    classAttr = value;\n  }\n  attrReplace(token, 'class', classAttr);\n}\n\nfunction attrGet(token, name) {\n  let idx = token.attrIndex(name);\n  if (idx == -1) return null;\n  return token.attrs[idx][1];\n}\n\nfunction attrDel(token, name) {\n  let idx = token.attrIndex(name);\n  if (idx == -1) return null;\n  token.attrs.splice(idx, 1);\n}\n\nexports.attrReplace = attrReplace;\n\nexports.attrGet = attrGet;\nexports.attrDel = attrDel;\nexports.addClass = addClass;\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/utils/token.js\n **/","'use strict';\n\nmodule.exports = function(md) {\n\n  md.renderer.rules.markdown_error_block = function(tokens, idx, options, env, slf) {\n    return '<div class=\"markdown-error\">' + md.utils.escapeHtml(tokens[idx].content) + '</div>';\n  };\n\n  md.renderer.rules.markdown_error_inline = function(tokens, idx, options, env, slf) {\n    return '<span class=\"markdown-error\">' + md.utils.escapeHtml(tokens[idx].content) + '</span>';\n  };\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/plugins/markdownError.js\n **/","'use strict';\n\nconst parseAttrs = require('../../utils/parseAttrs');\nconst getPrismLanguage = require('../../getPrismLanguage');\n\nfunction rewriteInlineToBlockTags(state) {\n  for (var idx = 1; idx < state.tokens.length - 1; idx++) {\n    if (state.tokens[idx - 1].type == 'paragraph_open' &&\n      state.tokens[idx + 1].type == 'paragraph_close' &&\n      state.tokens[idx].type == 'inline') {\n\n      let blockTagMatch = state.tokens[idx].content.trim().match(/^\\[(\\w+\\s*[^\\]]*)\\]$/);\n      if (!blockTagMatch) continue;\n\n      let blockTagAttrs = parseAttrs(blockTagMatch[1], true);\n\n      let blockName = blockTagAttrs.blockName;\n\n      // if not supported\n      if (!state.md.options.blockTags || state.md.options.blockTags.indexOf(blockName) == -1) continue;\n\n      let tokenType = getPrismLanguage.allSupported.indexOf(blockName) == -1 ? 'blocktag_' + blockName : 'blocktag_source';\n\n      let blockTagToken = new state.Token(tokenType, blockName, state.tokens[idx].nesting);\n\n      blockTagToken.blockTagAttrs = blockTagAttrs;\n      blockTagToken.map = state.tokens[idx].map.slice();\n      blockTagToken.block = true;\n      blockTagToken.level = state.tokens[idx].level;\n\n      state.tokens.splice(idx - 1, 3, blockTagToken);\n      // no need to move idx back, because\n      // p ! p p ! p\n      // 0 1 2\n      //   ^ if match here, we have this after move\n      // B p ! p\n      //   ^ idx position ok\n\n    }\n  }\n}\n\n\nmodule.exports = function(md) {\n\n  md.core.ruler.push('rewrite_inline_to_block_tags', rewriteInlineToBlockTags);\n\n};\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/plugins/blockTags/plugin.js\n **/","// Process definition lists\n//\n'use strict';\n\n\nmodule.exports = function deflist_plugin(md) {\n  var isSpace = md.utils.isSpace;\n\n  // Search `[:~][\\n ]`, returns next pos after marker on success\n  // or -1 on fail.\n  function skipMarker(state, line) {\n    var pos, marker,\n        start = state.bMarks[line] + state.tShift[line],\n        max = state.eMarks[line];\n\n    if (start >= max) { return -1; }\n\n    // Check bullet\n    marker = state.src.charCodeAt(start++);\n    if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n    pos = state.skipSpaces(start);\n\n    // require space after \":\"\n    if (start === pos) { return -1; }\n\n    // no empty definitions, e.g. \"  : \"\n    if (pos >= max) { return -1; }\n\n    return start;\n  }\n\n  function markTightParagraphs(state, idx) {\n    var i, l,\n        level = state.level + 2;\n\n    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n      if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n        state.tokens[i + 2].hidden = true;\n        state.tokens[i].hidden = true;\n        i += 2;\n      }\n    }\n  }\n\n  function deflist(state, startLine, endLine, silent) {\n    var ch,\n        contentStart,\n        ddLine,\n        dtLine,\n        itemLines,\n        listLines,\n        listTokIdx,\n        max,\n        nextLine,\n        offset,\n        oldDDIndent,\n        oldIndent,\n        oldParentType,\n        oldSCount,\n        oldTShift,\n        oldTight,\n        pos,\n        prevEmptyEnd,\n        tight,\n        token;\n\n    if (silent) {\n      // quirk: validation mode validates a dd block only, not a whole deflist\n      if (state.ddIndent < 0) { return false; }\n      return skipMarker(state, startLine) >= 0;\n    }\n\n    nextLine = startLine + 1;\n    if (state.isEmpty(nextLine)) {\n      if (++nextLine > endLine) { return false; }\n    }\n\n    if (state.sCount[nextLine] < state.blkIndent) { return false; }\n    contentStart = skipMarker(state, nextLine);\n    if (contentStart < 0) { return false; }\n\n    // Start list\n    listTokIdx = state.tokens.length;\n\n    token     = state.push('dl_open', 'dl', 1);\n    token.map = listLines = [ startLine, 0 ];\n\n    //\n    // Iterate list items\n    //\n\n    dtLine = startLine;\n    ddLine = nextLine;\n\n    // One definition list can contain multiple DTs,\n    // and one DT can be followed by multiple DDs.\n    //\n    // Thus, there is two loops here, and label is\n    // needed to break out of the second one\n    //\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    for (;;) {\n      tight = true;\n      prevEmptyEnd = false;\n\n      token          = state.push('dt_open', 'dt', 1);\n      token.map      = [ dtLine, dtLine ];\n\n      token          = state.push('inline', '', 0);\n      token.map      = [ dtLine, dtLine ];\n      token.content  = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim();\n      token.children = [];\n\n      token          = state.push('dt_close', 'dt', -1);\n\n      for (;;) {\n        token     = state.push('dd_open', 'dd', 1);\n        token.map = itemLines = [ nextLine, 0 ];\n\n        pos = contentStart;\n        max = state.eMarks[ddLine];\n        offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine]);\n\n        while (pos < max) {\n          ch = state.src.charCodeAt(pos);\n\n          if (isSpace(ch)) {\n            if (ch === 0x09) {\n              offset += 4 - offset % 4;\n            } else {\n              offset++;\n            }\n          } else {\n            break;\n          }\n\n          pos++;\n        }\n\n        contentStart = pos;\n\n        oldTight = state.tight;\n        oldDDIndent = state.ddIndent;\n        oldIndent = state.blkIndent;\n        oldTShift = state.tShift[ddLine];\n        oldSCount = state.sCount[ddLine];\n        oldParentType = state.parentType;\n        state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;\n        state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n        state.sCount[ddLine] = offset;\n        state.tight = true;\n        state.parentType = 'deflist';\n\n        state.md.block.tokenize(state, ddLine, endLine, true);\n\n        // If any of list item is tight, mark list as tight\n        if (!state.tight || prevEmptyEnd) {\n          tight = false;\n        }\n        // Item become loose if finish with empty line,\n        // but we should filter last element, because it means list finish\n        prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n        state.tShift[ddLine] = oldTShift;\n        state.sCount[ddLine] = oldSCount;\n        state.tight = oldTight;\n        state.parentType = oldParentType;\n        state.blkIndent = oldIndent;\n        state.ddIndent = oldDDIndent;\n\n        token = state.push('dd_close', 'dd', -1);\n\n        itemLines[1] = nextLine = state.line;\n\n        if (nextLine >= endLine) { break OUTER; }\n\n        if (state.sCount[nextLine] < state.blkIndent) { break OUTER; }\n        contentStart = skipMarker(state, nextLine);\n        if (contentStart < 0) { break; }\n\n        ddLine = nextLine;\n\n        // go to the next loop iteration:\n        // insert DD tag and repeat checking\n      }\n\n      if (nextLine >= endLine) { break; }\n      dtLine = nextLine;\n\n      if (state.isEmpty(dtLine)) { break; }\n      if (state.sCount[dtLine] < state.blkIndent) { break; }\n\n      ddLine = dtLine + 1;\n      if (ddLine >= endLine) { break; }\n      if (state.isEmpty(ddLine)) { ddLine++; }\n      if (ddLine >= endLine) { break; }\n\n      if (state.sCount[ddLine] < state.blkIndent) { break; }\n      contentStart = skipMarker(state, ddLine);\n      if (contentStart < 0) { break; }\n\n      // go to the next loop iteration:\n      // insert DT and DD tags and repeat checking\n    }\n\n    // Finilize list\n    token = state.push('dl_close', 'dl', -1);\n\n    listLines[1] = nextLine;\n\n    state.line = nextLine;\n\n    // mark paragraphs tight if needed\n    if (tight) {\n      markTightParagraphs(state, listTokIdx);\n    }\n\n    return true;\n  }\n\n\n  md.block.ruler.before('paragraph', 'deflist', deflist, { alt: [ 'paragraph', 'reference' ] });\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/markdown-it-deflist/index.js\n **/","'use strict';\n\nfunction charTypography(state) {\n  for (var idx = state.tokens.length - 1; idx >= 0; idx--) {\n\n    if (state.tokens[idx].type !== 'inline') continue;\n\n    doReplacementsInToken(state.tokens[idx].children);\n  }\n}\n\nfunction doReplacementsInToken(inlineTokens) {\n  var i, token;\n\n  for (i = 0; i < inlineTokens.length; i++) {\n    token = inlineTokens[i];\n    if (token.type === 'text') {\n      token.content = token.content\n        .replace(/([^+])\\+\\-/gi, '$1')\n        .replace(/\\.\\.\\./mg, '')\n        .replace(/\\([cC]\\)(?=[^\\.\\,\\;\\:])/ig, '')\n        .replace(/\\(r\\)/ig, '<sup></sup>')\n        .replace(/\\(tm\\)/ig, '')\n        .replace(/(\\s|;)\\-(\\s)/gi, '$1$2')\n        .replace(/<->/gi, '').replace(/<-/gi, '').replace(/(\\s)->/gi, '$1')\n        .replace(/\\s-(\\w)/gim, '&#8209;$1'); // non-breaking hyphen: -Infinity won't get line-broken\n    }\n  }\n}\n\nmodule.exports = function smartArrows_plugin(md, scheme) {\n  // must come before the built-in m-dash and n-dash support\n  md.core.ruler.before('replacements', 'char_typography', charTypography);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/markit/plugins/charTypography.js\n **/","var map = {\n\t\"./en.yml\": 346,\n\t\"./ru.yml\": 347\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 345;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/markit/locales/code ^\\.\\/.*\\.yml$\n ** module id = 345\n ** module chunks = 29\n **/","module.exports = {\n\t\"run\": \"run\",\n\t\"show\": \"show\",\n\t\"open\": {\n\t\t\"sandbox\": \"open in sandbox\"\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/markit/locales/code/en.yml\n ** module id = 346\n ** module chunks = 29\n **/","module.exports = {\n\t\"run\": \"\",\n\t\"show\": \"\",\n\t\"open\": {\n\t\t\"sandbox\": \"  \"\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/markit/locales/code/ru.yml\n ** module id = 347\n ** module chunks = 29\n **/","'use strict';\n\nconst BasicParser = require('markit/basicParser');\nconst CodeMirror = require('codemirror');\nconst prism = require('client/prism');\nrequire('codemirror/mode/gfm/gfm');\n\nconst template = require('../templates/editor.jade');\nconst throttle = require('lodash/throttle');\nconst clientRender = require('client/clientRender');\n\n\nconst delegate = require('client/delegate');\n\nconst t = require('i18n');\n\nconst LANG = require('config').lang;\n\nt.requirePhrase('mdeditor', require('../locales/' + LANG + '.yml'));\n\nconst buttonSets = {\n  standard: 'bold italic | link ul ol | code fencedCode | undo redo'.split(' ')\n};\n\nclass MdEditor {\n\n  actionBold() {\n    this.replaceSelection(\"**\", \"**\", t(\"mdeditor.text.bold\"));\n  }\n\n\n  actionItalic() {\n    this.replaceSelection(\"*\", \"*\", t(\"mdeditor.text.italic\"));\n  }\n\n  actionCode() {\n    this.replaceSelection(\"`\", \"`\", t(\"mdeditor.text.code\"));\n  }\n\n  actionRedo() {\n    this.codemirror.redo();\n  }\n\n  actionUndo() {\n    this.codemirror.undo();\n  }\n\n  actionFencedCode() {\n    let hadSelection = this.codemirror.getSelection();\n    this.replaceSelection(\"\\n```js\\n\", \"\\n```\\n\", t(\"mdeditor.text.fencedCode\"));\n\n    let cursorPos = this.codemirror.getCursor();\n    let line = cursorPos.line - 2;\n    this.codemirror.setCursor(line, 9999);\n    if (!hadSelection) {\n      // select default\n      this.codemirror.setSelection(\n        {line, ch: 0},\n        {line, ch: 9999}\n      );\n    }\n  }\n\n  actionLink() {\n    let text;\n    let link;\n\n    let selection = this.codemirror.getSelection();\n\n    if (selection) {\n      if (selection.match(/^https?:\\/\\//)) {\n        link = selection;\n      } else {\n        text = selection;\n      }\n    }\n    let substitution = '[' + (text || t('mdeditor.text.link')) + '](' + (link || 'http://') + ')';\n\n    this.codemirror.replaceSelection(substitution);\n\n    let cursorPos = this.codemirror.getCursor();\n\n    if (!text) {\n      this.codemirror.setCursor(cursorPos.line, cursorPos.ch - substitution.length + 1 + t('mdeditor.text.link').length);\n      this.codemirror.setSelection(\n        {line: cursorPos.line, ch: cursorPos.ch - substitution.length + 1},\n        {line: cursorPos.line, ch: cursorPos.ch -  substitution.length + 1 + t('mdeditor.text.link').length}\n      );\n    } else if (!link) {\n      this.codemirror.setCursor(cursorPos.line, cursorPos.ch - 1);\n    }\n\n  }\n\n  actionOl() {\n    let cursorPos = this.codemirror.getCursor();\n    this.codemirror.setSelection(\n      {line: cursorPos.line, ch: 0},\n      {line: cursorPos.line, ch: 99999}\n    );\n\n    this.replaceSelection(\"1. \", \"\\n\", t('mdeditor.text.ol'));\n  }\n\n  actionUl() {\n    let cursorPos = this.codemirror.getCursor();\n    this.codemirror.setSelection(\n      {line: cursorPos.line, ch: 0},\n      {line: cursorPos.line, ch: 99999}\n    );\n\n    this.replaceSelection(\"- \", \"\\n\", t('mdeditor.text.ol'));\n  }\n\n  actionHeading() {\n    let cursorPos = this.codemirror.getCursor();\n    this.codemirror.setSelection(\n      {line: cursorPos.line, ch: 0},\n      {line: cursorPos.line, ch: 99999}\n    );\n\n    this.replaceSelection(\"# \", \"\\n\", t('mdeditor.text.heading'));\n  }\n\n  actionImage() {\n    // todo\n    let selection = this.codemirror.getSelection();\n    let text = t(\"mdeditor.text.alt\");\n\n    if (!selection) {\n      selection = \"http://my.jpg\";\n    }\n    this.codemirror.replaceSelection('![' + text + '](' + selection + ')');\n    let cursorPos = this.codemirror.getCursor();\n    this.codemirror.setCursor(cursorPos.line, cursorPos.ch - (1 + selection.length));\n  }\n\n  replaceSelection(before, after, defaultText) {\n\n    let selection = this.codemirror.getSelection();\n\n    let defaultTextUsed = !selection;\n\n    let substitution = defaultTextUsed ? (before + defaultText + after) : (before + selection + after);\n    this.codemirror.replaceSelection(substitution);\n\n    let cursorPos = this.codemirror.getCursor();\n\n    if (defaultTextUsed) {\n      this.codemirror.setCursor(cursorPos.line, cursorPos.ch - after.length);\n      this.codemirror.setSelection(\n        {line: cursorPos.line, ch: cursorPos.ch - defaultText.length - after.length},\n        {line: cursorPos.line, ch: cursorPos.ch - after.length}\n      );\n    }\n  }\n\n  render(textArea) {\n\n    let buttonSet = buttonSets[this.options.buttonSet || 'standard'];\n\n    textArea.insertAdjacentHTML(\"afterEnd\", clientRender(template, {\n      buttons: buttonSet\n    }));\n\n    this.elem = textArea.nextElementSibling;\n\n    let templateArea = this.elem.querySelector('textarea');\n    templateArea.replace(textArea);\n\n    textArea.classList.remove('mdeditor');\n    // move all classes from template textarea to the existing one\n    for (var i = 0; i < templateArea.classList.length; i++) {\n      var cls = templateArea.classList[i];\n      textArea.classList.add(cls);\n    }\n  }\n\n  onResizeMouseDown(e) {\n    this.elem.classList.add('mdeditor_resizing');\n    document.addEventListener('mousemove', this.onResizeMouseMove);\n    document.addEventListener('mouseup', this.onResizeMouseUp);\n    e.preventDefault();\n  }\n\n  onResizeMouseMove(e) {\n    let editorElem = this.codemirror.getWrapperElement();\n    let height = e.clientY - editorElem.getBoundingClientRect().top;\n    console.log(height);\n    if (height < 30) height = 30;\n    this.codemirror.setSize('100%', height);\n  }\n\n  onResizeMouseUp(e) {\n    this.elem.classList.remove('mdeditor_resizing');\n    document.removeEventListener('mousemove', this.onResizeMouseMove);\n    document.removeEventListener('mouseup', this.onResizeMouseUp);\n  }\n\n  constructor(options) {\n    this.options = Object.create(options);\n    if (!options.buttonSet) this.options.buttonSet = 'standard';\n\n    this.render(options.elem);\n    this.value = this.elem.value;\n\n    this.delegate('[data-action]', 'click', function(e) {\n      let actionName = 'action' +\n        e.delegateTarget.getAttribute('data-action')[0].toUpperCase() +\n        e.delegateTarget.getAttribute('data-action').slice(1);\n\n      if (!this[actionName]) return;\n\n      e.preventDefault();\n      this[actionName]();\n      this.codemirror.focus();\n    });\n\n\n    this.onResizeMouseDown = this.onResizeMouseDown.bind(this);\n    this.onResizeMouseMove = this.onResizeMouseMove.bind(this);\n    this.onResizeMouseUp = this.onResizeMouseUp.bind(this);\n\n    this.renderPreviewThrottled = throttle(this.renderPreview.bind(this), 100);\n    this.highlightInPreviewThrottled = throttle(this.highlightInPreview.bind(this), 500);\n\n    this.delegate('[data-mdeditor-resize]', 'mousedown', this.onResizeMouseDown);\n\n    this.codemirror = CodeMirror.fromTextArea(this.elem.querySelector('textarea'), {\n      tabSize: 2,\n      //lineNumbers: false,\n      mode:    'gfm'\n    });\n\n    this.codemirror.setOption(\"extraKeys\", {\n      'Ctrl-B': () => this.actionBold(),\n      'Ctrl-I': () => this.actionItalic(),\n      'Cmd-B': () => this.actionBold(),\n      'Cmd-I': () => this.actionItalic()\n    });\n\n\n    this.codemirror.on(\"change\", this.renderPreviewThrottled);\n\n  }\n\n  highlightInPreview() {\n    prism.highlight(this.elem.querySelector('[data-editor-preview]'));\n  }\n\n  renderPreview() {\n    let value = this.codemirror.getValue();\n    let rendered = new BasicParser().render(value);\n    this.elem.querySelector('[data-editor-preview]').innerHTML = rendered;\n    this.highlightInPreviewThrottled();\n  }\n\n}\n\ndelegate.delegateMixin(MdEditor.prototype);\n\nmodule.exports = MdEditor;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/mdeditor/client/mdeditor.js\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    (this || window).CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) display.input.focus();\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    var cm = this;\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || cm.hasFocus())\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) options.finishInit(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      display.lineDiv.style.textRendering = \"auto\";\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\n    if (place) {\n      if (place.appendChild) place.appendChild(d.wrapper);\n      else place(d.wrapper);\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function() {\n      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n    });\n    on(horiz, \"scroll\", function() {\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n  }\n\n  NativeScrollbars.prototype = copyObj({\n    update: function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n\n      if (needsV) {\n        this.vert.style.display = \"block\";\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        // A bug in IE8 can cause this value to be negative, so guard it.\n        this.vert.firstChild.style.height =\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n      } else {\n        this.vert.style.display = \"\";\n        this.vert.firstChild.style.height = \"0\";\n      }\n\n      if (needsH) {\n        this.horiz.style.display = \"block\";\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n        this.horiz.style.left = measure.barLeft + \"px\";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width =\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n      } else {\n        this.horiz.style.display = \"\";\n        this.horiz.firstChild.style.width = \"0\";\n      }\n\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n        if (sWidth == 0) this.zeroWidthHack();\n        this.checkedZeroWidth = true;\n      }\n\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n    },\n    setScrollLeft: function(pos) {\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n    },\n    setScrollTop: function(pos) {\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n    },\n    zeroWidthHack: function() {\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n      this.horiz.style.height = this.vert.style.width = w;\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n      this.disableHoriz = new Delayed;\n      this.disableVert = new Delayed;\n    },\n    enableZeroWidthBar: function(bar, delay) {\n      bar.style.pointerEvents = \"auto\";\n      function maybeDisable() {\n        // To find out whether the scrollbar is still visible, we\n        // check whether the element under the pixel in the bottom\n        // left corner of the scrollbar box is the scrollbar box\n        // itself (when the bar is still visible) or its filler child\n        // (when the bar is hidden). If it is still visible, we keep\n        // it enabled, if it's hidden, we disable pointer events.\n        var box = bar.getBoundingClientRect();\n        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n        if (elt != bar) bar.style.pointerEvents = \"none\";\n        else delay.set(1000, maybeDisable);\n      }\n      delay.set(1000, maybeDisable);\n    },\n    clear: function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    }\n  }, NativeScrollbars.prototype);\n\n  function NullScrollbars() {}\n\n  NullScrollbars.prototype = copyObj({\n    update: function() { return {bottom: 0, right: 0}; },\n    setScrollLeft: function() {},\n    setScrollTop: function() {},\n    clear: function() {}\n  }, NullScrollbars.prototype);\n\n  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function() {\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function(pos, axis) {\n      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n      else setScrollTop(cm, pos);\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n  }\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        updateHeightsInViewport(cm);\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter && view[i].gutter)\n        view[i].gutter.style.left = left;\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  }\n\n  DisplayUpdate.prototype.signal = function(emitter, type) {\n    if (hasHandler(emitter, type))\n      this.events.push(arguments);\n  };\n  DisplayUpdate.prototype.finish = function() {\n    for (var i = 0; i < this.events.length; i++)\n      signal.apply(null, this.events[i]);\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    var total = measure.docHeight + cm.display.barHeight;\n    cm.display.heightForcer.style.top = total + \"px\";\n    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // INPUT HANDLING\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  // This will be set to an array of strings when copying, so that,\n  // when pasting, we know what kind of selections the copied text\n  // was made out of.\n  var lastCopied = null;\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) sel = doc.sel;\n\n    var paste = cm.state.pasteIncoming || origin == \"paste\";\n    var textLines = doc.splitLines(inserted), multiPaste = null;\n    // When pasing N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.length; i++)\n            multiPaste.push(doc.splitLines(lastCopied[i]));\n        }\n      } else if (textLines.length == sel.ranges.length) {\n        multiPaste = map(textLines, function(l) { return [l]; });\n      }\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          from = Pos(from.line, from.ch - deleted);\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n      }\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      triggerElectric(cm, inserted);\n\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          indented = indentLine(cm, range.head.line, \"smart\");\n      }\n      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges};\n  }\n\n  function disableBrowserMagic(field) {\n    field.setAttribute(\"autocorrect\", \"off\");\n    field.setAttribute(\"autocapitalize\", \"off\");\n    field.setAttribute(\"spellcheck\", \"false\");\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  function TextareaInput(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Tracks when input.reset has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    this.inaccurateSelection = false;\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) te.style.width = \"1000px\";\n    else te.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) te.style.border = \"1px solid black\";\n    disableBrowserMagic(te);\n    return div;\n  }\n\n  TextareaInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = this.cm;\n\n      // Wraps and hides input textarea\n      var div = this.wrapper = hiddenTextarea();\n      // The semihidden textarea that is focused when the editor is\n      // focused, and receives input.\n      var te = this.textarea = div.firstChild;\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n      if (ios) te.style.width = \"0px\";\n\n      on(te, \"input\", function() {\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n        input.poll();\n      });\n\n      on(te, \"paste\", function(e) {\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\n        cm.state.pasteIncoming = true;\n        input.fastPoll();\n      });\n\n      function prepareCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (input.inaccurateSelection) {\n            input.prevInput = \"\";\n            input.inaccurateSelection = false;\n            te.value = lastCopied.join(\"\\n\");\n            selectInput(te);\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = \"\";\n            te.value = ranges.text.join(\"\\n\");\n            selectInput(te);\n          }\n        }\n        if (e.type == \"cut\") cm.state.cutIncoming = true;\n      }\n      on(te, \"cut\", prepareCopyCut);\n      on(te, \"copy\", prepareCopyCut);\n\n      on(display.scroller, \"paste\", function(e) {\n        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n        cm.state.pasteIncoming = true;\n        input.focus();\n      });\n\n      // Prevent normal selection in the editor (we handle our own)\n      on(display.lineSpace, \"selectstart\", function(e) {\n        if (!eventInWidget(display, e)) e_preventDefault(e);\n      });\n\n      on(te, \"compositionstart\", function() {\n        var start = cm.getCursor(\"from\");\n        if (input.composing) input.composing.range.clear()\n        input.composing = {\n          start: start,\n          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n        };\n      });\n      on(te, \"compositionend\", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    },\n\n    prepareSelection: function() {\n      // Redraw the selection and/or cursor\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result = prepareSelection(cm);\n\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                            headPos.top + lineOff.top - wrapOff.top));\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                             headPos.left + lineOff.left - wrapOff.left));\n      }\n\n      return result;\n    },\n\n    showSelection: function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + \"px\";\n        this.wrapper.style.left = drawn.teLeft + \"px\";\n      }\n    },\n\n    // Reset the input to correspond to the selection (or to be empty,\n    // when not typing and nothing is selected)\n    reset: function(typing) {\n      if (this.contextMenuPending) return;\n      var minimal, selected, cm = this.cm, doc = cm.doc;\n      if (cm.somethingSelected()) {\n        this.prevInput = \"\";\n        var range = doc.sel.primary();\n        minimal = hasCopyEvent &&\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n        var content = minimal ? \"-\" : selected || cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) selectInput(this.textarea);\n        if (ie && ie_version >= 9) this.hasSelection = content;\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = \"\";\n        if (ie && ie_version >= 9) this.hasSelection = null;\n      }\n      this.inaccurateSelection = minimal;\n    },\n\n    getField: function() { return this.textarea; },\n\n    supportsTouch: function() { return false; },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n        try { this.textarea.focus(); }\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n      }\n    },\n\n    blur: function() { this.textarea.blur(); },\n\n    resetPosition: function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    },\n\n    receivedFocus: function() { this.slowPoll(); },\n\n    // Poll for input changes, using the normal rate of polling. This\n    // runs as long as the editor is focused.\n    slowPoll: function() {\n      var input = this;\n      if (input.pollingFast) return;\n      input.polling.set(this.cm.options.pollInterval, function() {\n        input.poll();\n        if (input.cm.state.focused) input.slowPoll();\n      });\n    },\n\n    // When an event has just come in that is likely to add or change\n    // something in the input textarea, we poll faster, to ensure that\n    // the change appears on the screen quickly.\n    fastPoll: function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p() {\n        var changed = input.poll();\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n        else {input.pollingFast = false; input.slowPoll();}\n      }\n      input.polling.set(20, p);\n    },\n\n    // Read input from the textarea, and update the document to match.\n    // When something is selected, it is present in the textarea, and\n    // selected (unless it is huge, in which case a placeholder is\n    // used). When nothing is selected, the cursor sits after previously\n    // seen text (can be empty), which is stored in prevInput (we must\n    // not reset the textarea when typing, because that breaks IME).\n    poll: function() {\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      // Since this is called a *lot*, try to bail out as cheaply as\n      // possible when it is clear that nothing happened. hasSelection\n      // will be the case when there is a lot of text in the textarea,\n      // in which case reading its value would be expensive.\n      if (this.contextMenuPending || !cm.state.focused ||\n          (hasSelection(input) && !prevInput && !this.composing) ||\n          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n        return false;\n\n      var text = input.value;\n      // If nothing changed, bail.\n      if (text == prevInput && !cm.somethingSelected()) return false;\n      // Work around nonsensical selection resetting in IE9/10, and\n      // inexplicable appearance of private area unicode characters on\n      // some key combos in Mac (#2689).\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\n          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n        cm.display.input.reset();\n        return false;\n      }\n\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text.charCodeAt(0);\n        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n      }\n      // Find the part of the input that is actually new\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\n      var self = this;\n      runInOp(cm, function() {\n        applyTextInput(cm, text.slice(same), prevInput.length - same,\n                       null, self.composing ? \"*compose\" : null);\n\n        // Don't leave long text in the textarea, since it makes further polling slow\n        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n        else self.prevInput = text;\n\n        if (self.composing) {\n          self.composing.range.clear();\n          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n                                             {className: \"CodeMirror-composing\"});\n        }\n      });\n      return true;\n    },\n\n    ensurePolled: function() {\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\n    },\n\n    onKeyPress: function() {\n      if (ie && ie_version >= 9) this.hasSelection = null;\n      this.fastPoll();\n    },\n\n    onContextMenu: function(e) {\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) return; // Opera is difficult.\n\n      // Reset the current text selection only if the click is done outside of the selection\n      // and 'resetSelectionOnContextMenu' option is true.\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1)\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n      var oldCSS = te.style.cssText;\n      input.wrapper.style.position = \"absolute\";\n      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n      display.input.focus();\n      if (webkit) window.scrollTo(null, oldScrollY);\n      display.input.reset();\n      // Adds \"Select all\" to context menu in FF\n      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n      input.contextMenuPending = true;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n\n      // Select-all will be greyed out if there's nothing to select, so\n      // this adds a zero-width space so that we can later check whether\n      // it got selected.\n      function prepareSelectAllHack() {\n        if (te.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n          te.value = \"\\u21da\"; // Used to catch context-menu undo\n          te.value = extval;\n          input.prevInput = selected ? \"\" : \"\\u200b\";\n          te.selectionStart = 1; te.selectionEnd = extval.length;\n          // Re-set this, in case some other handler touched the\n          // selection in the meantime.\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      function rehide() {\n        input.contextMenuPending = false;\n        input.wrapper.style.position = \"relative\";\n        te.style.cssText = oldCSS;\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\n        // Try to detect the user choosing select-all\n        if (te.selectionStart != null) {\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n          var i = 0, poll = function() {\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n              operation(cm, commands.selectAll)(cm);\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n            else display.input.reset();\n          };\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n\n      if (ie && ie_version >= 9) prepareSelectAllHack();\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = function() {\n          off(window, \"mouseup\", mouseup);\n          setTimeout(rehide, 20);\n        };\n        on(window, \"mouseup\", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    },\n\n    readOnlyChanged: function(val) {\n      if (!val) this.reset();\n    },\n\n    setUneditable: nothing,\n\n    needsContentAttribute: false\n  }, TextareaInput.prototype);\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.gracePeriod = false;\n  }\n\n  ContentEditableInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = input.cm;\n      var div = input.div = display.lineDiv;\n      disableBrowserMagic(div);\n\n      on(div, \"paste\", function(e) {\n        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);\n      })\n\n      on(div, \"compositionstart\", function(e) {\n        var data = e.data;\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n        if (!data) return;\n        var prim = cm.doc.sel.primary();\n        var line = cm.getLine(prim.head.line);\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n        if (found > -1 && found <= prim.head.ch)\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n                                                Pos(prim.head.line, found + data.length));\n      });\n      on(div, \"compositionupdate\", function(e) {\n        input.composing.data = e.data;\n      });\n      on(div, \"compositionend\", function(e) {\n        var ours = input.composing;\n        if (!ours) return;\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n          ours.data = e.data;\n        // Need a small delay to prevent other code (input event,\n        // selection polling) from doing damage when fired right after\n        // compositionend.\n        setTimeout(function() {\n          if (!ours.handled)\n            input.applyComposition(ours);\n          if (input.composing == ours)\n            input.composing = null;\n        }, 50);\n      });\n\n      on(div, \"touchstart\", function() {\n        input.forceCompositionEnd();\n      });\n\n      on(div, \"input\", function() {\n        if (input.composing) return;\n        if (cm.isReadOnly() || !input.pollContent())\n          runInOp(input.cm, function() {regChange(cm);});\n      });\n\n      function onCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection(\"\", null, \"cut\");\n            });\n          }\n        }\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        if (e.clipboardData && !ios) {\n          e.preventDefault();\n          e.clipboardData.clearData();\n          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n        } else {\n          // Old-fashioned briefly-focus-a-textarea hack\n          var kludge = hiddenTextarea(), te = kludge.firstChild;\n          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n          te.value = lastCopied.join(\"\\n\");\n          var hadFocus = document.activeElement;\n          selectInput(te);\n          setTimeout(function() {\n            cm.display.lineSpace.removeChild(kludge);\n            hadFocus.focus();\n          }, 50);\n        }\n      }\n      on(div, \"copy\", onCopyCut);\n      on(div, \"cut\", onCopyCut);\n    },\n\n    prepareSelection: function() {\n      var result = prepareSelection(this.cm, false);\n      result.focus = this.cm.state.focused;\n      return result;\n    },\n\n    showSelection: function(info) {\n      if (!info || !this.cm.display.view.length) return;\n      if (info.focus) this.showPrimarySelection();\n      this.showMultipleSelections(info);\n    },\n\n    showPrimarySelection: function() {\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n        return;\n\n      var start = posToDOM(this.cm, prim.from());\n      var end = posToDOM(this.cm, prim.to());\n      if (!start && !end) return;\n\n      var view = this.cm.display.view;\n      var old = sel.rangeCount && sel.getRangeAt(0);\n      if (!start) {\n        start = {node: view[0].measure.map[2], offset: 0};\n      } else if (!end) { // FIXME dangerously hacky\n        var measure = view[view.length - 1].measure;\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n      }\n\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n      if (rng) {\n        if (!gecko && this.cm.state.focused) {\n          sel.collapse(start.node, start.offset);\n          if (!rng.collapsed) sel.addRange(rng);\n        } else {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n        if (old && sel.anchorNode == null) sel.addRange(old);\n        else if (gecko) this.startGracePeriod();\n      }\n      this.rememberSelection();\n    },\n\n    startGracePeriod: function() {\n      var input = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        input.gracePeriod = false;\n        if (input.selectionChanged())\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n      }, 20);\n    },\n\n    showMultipleSelections: function(info) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    },\n\n    rememberSelection: function() {\n      var sel = window.getSelection();\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n    },\n\n    selectionInEditor: function() {\n      var sel = window.getSelection();\n      if (!sel.rangeCount) return false;\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n    },\n    blur: function() { this.div.blur(); },\n    getField: function() { return this.div; },\n\n    supportsTouch: function() { return true; },\n\n    receivedFocus: function() {\n      var input = this;\n      if (this.selectionInEditor())\n        this.pollSelection();\n      else\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      this.polling.set(this.cm.options.pollInterval, poll);\n    },\n\n    selectionChanged: function() {\n      var sel = window.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    },\n\n    pollSelection: function() {\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n        var sel = window.getSelection(), cm = this.cm;\n        this.rememberSelection();\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (anchor && head) runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n        });\n      }\n    },\n\n    pollContent: function() {\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\n      var fromIndex;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        var fromLine = lineNo(display.view[0].line);\n        var fromNode = display.view[0].node;\n      } else {\n        var fromLine = lineNo(display.view[fromIndex].line);\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      if (toIndex == display.view.length - 1) {\n        var toLine = display.viewTo - 1;\n        var toNode = display.lineDiv.lastChild;\n      } else {\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        var toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n        else break;\n      }\n\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n        ++cutFront;\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n        ++cutEnd;\n\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n      newText[0] = newText[0].slice(cutFront);\n\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n        return true;\n      }\n    },\n\n    ensurePolled: function() {\n      this.forceCompositionEnd();\n    },\n    reset: function() {\n      this.forceCompositionEnd();\n    },\n    forceCompositionEnd: function() {\n      if (!this.composing || this.composing.handled) return;\n      this.applyComposition(this.composing);\n      this.composing.handled = true;\n      this.div.blur();\n      this.div.focus();\n    },\n    applyComposition: function(composing) {\n      if (this.cm.isReadOnly())\n        operation(this.cm, regChange)(this.cm)\n      else if (composing.data && composing.data != composing.startData)\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n    },\n\n    setUneditable: function(node) {\n      node.contentEditable = \"false\"\n    },\n\n    onKeyPress: function(e) {\n      e.preventDefault();\n      if (!this.cm.isReadOnly())\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    },\n\n    readOnlyChanged: function(val) {\n      this.div.contentEditable = String(val != \"nocursor\")\n    },\n\n    onContextMenu: nothing,\n    resetPosition: nothing,\n\n    needsContentAttribute: true\n  }, ContentEditableInput.prototype);\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) return null;\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        return locateNodeInLineView(lineView, node, offset);\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) offset = textNode.nodeValue.length;\n    }\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) return badPos(found, bad);\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        return badPos(Pos(found.line, found.ch + dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText != null) {\n          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n          text += cmText;\n          return;\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find()))\n            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n          return;\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n        for (var i = 0; i < node.childNodes.length; i++)\n          walk(node.childNodes[i]);\n        if (/^(pre|div|p)$/i.test(node.nodeName))\n          closing = true;\n      } else if (node.nodeType == 3) {\n        var val = node.nodeValue;\n        if (!val) return;\n        if (closing) {\n          text += lineSep;\n          closing = false;\n        }\n        text += val;\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) break;\n      from = from.nextSibling;\n    }\n    return text;\n  }\n\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel, options);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) break;\n            else {--i; continue;}\n          }\n        }\n        if (!m.atomic) continue;\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff;\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) near = movePos(doc, near, -dir, line);\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            return skipAtomicInner(doc, near, pos, dir, mayClear);\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) far = movePos(doc, far, dir, line);\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n      }\n    }\n    return pos;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0);\n    }\n    return found;\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n      else return null;\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n      else return null;\n    } else {\n      return new Pos(pos.line, pos.ch + dir);\n    }\n  }\n\n  // SELECTION DRAWING\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (primary === false && i == doc.sel.primIndex) continue;\n      var range = doc.sel.ranges[i];\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range.head, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n    return result;\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else if (ie && cm.options.lineWrapping) {\n          var rects = range(node, start, end).getClientRects();\n          if (rects.length)\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n          else\n            rect = nullRect;\n        } else {\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n        }\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i].call(null);\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.preparedSelection = display.input.prepareSelection();\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    if (op.preparedSelection)\n      cm.display.input.showSelection(op.preparedSelection);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      cm.display.input.reset(op.typing);\n    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))\n      ensureFocus(op.cm);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scrollbars.setScrollTop(doc.scrollTop);\n      display.scroller.scrollTop = doc.scrollTop;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\n      display.scroller.scrollLeft = doc.scrollLeft;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n    if (op.update)\n      op.update.finish();\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    };\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) return false;\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n    function farAway(touch, other) {\n      if (other.left == null) return true;\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n    on(d.scroller, \"touchstart\", function(e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function() {\n      if (d.activeTouch) d.activeTouch.moved = true;\n    });\n    on(d.scroller, \"touchend\", function(e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          range = new Range(pos, pos);\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          range = cm.findWordAt(pos);\n        else // Triple tap\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function(e){onDragStart(cm, e);},\n      drop: operation(cm, onDrop),\n      leave: function() {clearDragCursor(cm);}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", bind(onFocus, cm));\n    on(inp, \"blur\", bind(onBlur, cm));\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != CodeMirror.Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n      return;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      // #3261: make sure, that we're not starting a second selection\n      if (cm.state.selectingText)\n        cm.state.selectingText(e);\n      else if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(function() {display.input.focus();}, 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      else delayBlurEvent(cm);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n    else cm.curOp.focus = activeElt();\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display, startTime = +new Date;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier && +new Date - 200 < startTime)\n          extendSelection(cm.doc, start);\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n        else\n          display.input.focus();\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          return;\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function() {cm.display.input.focus();}, 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) return;\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  var wheelEventDelta = function(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n    return {x: dx, y: dy};\n  };\n  CodeMirror.wheelEventPixels = function(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  };\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) return result;\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm);\n  }\n\n  var stopSeq = new Delayed;\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) return \"handled\";\n      stopSeq.set(50, function() {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      });\n      name = seq + \" \" + name;\n    }\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      cm.state.keySeq = name;\n    if (result == \"handled\")\n      signalLater(cm, \"keyHandled\", cm, name, e);\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    if (seq && !result && /\\'$/.test(name)) {\n      e_preventDefault(e);\n      return true;\n    }\n    return !!result;\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) return false;\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n          || dispatchKey(cm, name, e, function(b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 return doHandleBinding(cm, b);\n             });\n    } else {\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n                       function(b) { return doHandleBinding(cm, b, true); });\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    cm.display.input.onKeyPress(e);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function() {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n        onBlur(cm);\n      }\n    }, 100);\n  }\n\n  function onFocus(cm) {\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.delayingBlurEvent) return;\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    cm.display.input.onContextMenu(e);\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      regChange(cm);\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = doc.splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) break;\n    }\n    return coords;\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return false\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return false\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") {\n      moveOnce()\n    } else if (unit == \"column\") {\n      moveOnce(true)\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n    if (!cmp(pos, result)) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || maps[i].name == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise);\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true);\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return found;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) line = this.doc.first;\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd].call(null, this);\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input.getField();},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function(cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) return;\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function(line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) break;\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n  });\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != CodeMirror.Init) cm.refresh();\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n  }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function(cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != CodeMirror.Init && getKeyMap(old);\n    if (prev && prev.detach) prev.detach(cm, next);\n    if (next.attach) next.attach(cm, prev || null);\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n  option(\"scrollbarStyle\", \"native\", function(cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val)\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.input.resetPosition();\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.getField().tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                                prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n        }\n        ensureCursorVisible(cm);\n      });\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n      else if (/^s(hift)$/i.test(mod)) shift = true;\n      else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) name = \"Alt-\" + name;\n    if (ctrl) name = \"Ctrl-\" + name;\n    if (cmd) name = \"Cmd-\" + name;\n    if (shift) name = \"Shift-\" + name;\n    return name;\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  CodeMirror.normalizeKeyMap = function(keymap) {\n    var copy = {};\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n      if (value == \"...\") { delete keymap[keyname]; continue; }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val, name;\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) copy[name] = val;\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n      }\n      delete keymap[keyname];\n    }\n    for (var prop in copy) keymap[prop] = copy[prop];\n    return keymap;\n  };\n\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        return lookupKey(key, map.fallthrough, handle, context);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) return result;\n      }\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var base = keyNames[event.keyCode], name = base;\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n    return name;\n  };\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  }\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      options.tabindex = textarea.tabIndex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function(cm) {\n      cm.save = save;\n      cm.getTextArea = function() { return textarea; };\n      cm.toTextArea = function() {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            textarea.form.submit = realSubmit;\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var nextMarkerId = 0;\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) return null;\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.doc = doc;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(line, line.height + diff);\n    if (cm) runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    var cm = widget.doc.cm;\n    if (!cm) return 0;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      if (widget.noHScroll)\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight;\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    function getObj(copy) {\n      return {start: stream.start, end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: copy ? copyState(doc.mode, state) : state};\n    }\n\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n    if (asArray) tokens = [];\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, state);\n      if (asArray) tokens.push(getObj(true));\n    }\n    return asArray ? tokens : getObj();\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 50000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var state = getStateBefore(cm, lineNo(line));\n      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n      line.stateAfter = state;\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol()) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n      builder.content.className = \"cm-tab-wrap-hack\";\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n    if (!text) return;\n    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt.setAttribute(\"role\", \"presentation\");\n          txt.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function splitSpaces(old) {\n    var out = \" \";\n    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n    out += \" \";\n    return out;\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title, css) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\n        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n          if (collapsed.to == pos) collapsed = false;\n        }\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      for (var i = start, result = []; i < end; ++i)\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      return result;\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added = linesFor(1, text.length - 1);\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added = linesFor(1, text.length - 1);\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.extend = false;\n\n    if (typeof text == \"string\") text = this.splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || this.lineSeparator());\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (classTest(cls).test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(lineNo == from.line && from.ch > span.to ||\n                span.from == null && lineNo != from.line||\n                lineNo == to.line && span.from > to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;},\n\n    splitLines: function(str) {\n      if (this.lineSep) return str.split(this.lineSep);\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, ore are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var noHandlers = []\n  function getHandlers(emitter, type, copy) {\n    var arr = emitter._handlers && emitter._handlers[type]\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n    else return arr || noHandlers\n  }\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var handlers = getHandlers(emitter, type, false)\n      for (var i = 0; i < handlers.length; ++i)\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type, true)\n    if (!handlers.length) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type, false)\n    if (!arr.length) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r; }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  var contains = CodeMirror.contains = function(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      child = child.parentNode;\n    if (parent.contains)\n      return parent.contains(child);\n    do {\n      if (child.nodeType == 11) child = child.host;\n      if (child == parent) return true;\n    } while (child = child.parentNode);\n  };\n\n  function activeElt() {\n    var activeElement = document.activeElement;\n    while (activeElement && activeElement.root && activeElement.root.activeElement)\n      activeElement = activeElement.root.activeElement;\n    return activeElement;\n  }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n  var addClass = CodeMirror.addClass = function(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n  };\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = CodeMirror.keyNames = {\n    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level == 2)\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"5.11.0\";\n\n  return CodeMirror;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/lib/codemirror.js\n ** module id = 360\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../markdown/markdown\"), require(\"../../addon/mode/overlay\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../markdown/markdown\", \"../../addon/mode/overlay\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\\.beep|\\.lwz|\\.xpc|\\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\\.beeps?|xmpp|xri|ymsgr|z39\\.50[rs]?):(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]|\\([^\\s()<>]*\\))+(?:\\([^\\s()<>]*\\)|[^\\s`*!()\\[\\]{};:'\".,<>?]))/i\n\nCodeMirror.defineMode(\"gfm\", function(config, modeConfig) {\n  var codeDepth = 0;\n  function blankLine(state) {\n    state.code = false;\n    return null;\n  }\n  var gfmOverlay = {\n    startState: function() {\n      return {\n        code: false,\n        codeBlock: false,\n        ateSpace: false\n      };\n    },\n    copyState: function(s) {\n      return {\n        code: s.code,\n        codeBlock: s.codeBlock,\n        ateSpace: s.ateSpace\n      };\n    },\n    token: function(stream, state) {\n      state.combineTokens = null;\n\n      // Hack to prevent formatting override inside code blocks (block and inline)\n      if (state.codeBlock) {\n        if (stream.match(/^```+/)) {\n          state.codeBlock = false;\n          return null;\n        }\n        stream.skipToEnd();\n        return null;\n      }\n      if (stream.sol()) {\n        state.code = false;\n      }\n      if (stream.sol() && stream.match(/^```+/)) {\n        stream.skipToEnd();\n        state.codeBlock = true;\n        return null;\n      }\n      // If this block is changed, it may need to be updated in Markdown mode\n      if (stream.peek() === '`') {\n        stream.next();\n        var before = stream.pos;\n        stream.eatWhile('`');\n        var difference = 1 + stream.pos - before;\n        if (!state.code) {\n          codeDepth = difference;\n          state.code = true;\n        } else {\n          if (difference === codeDepth) { // Must be exact\n            state.code = false;\n          }\n        }\n        return null;\n      } else if (state.code) {\n        stream.next();\n        return null;\n      }\n      // Check if space. If so, links can be formatted later on\n      if (stream.eatSpace()) {\n        state.ateSpace = true;\n        return null;\n      }\n      if (stream.sol() || state.ateSpace) {\n        state.ateSpace = false;\n        if (modeConfig.gitHubSpice !== false) {\n          if(stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+@)?(?:[a-f0-9]{7,40}\\b)/)) {\n            // User/Project@SHA\n            // User@SHA\n            // SHA\n            state.combineTokens = true;\n            return \"link\";\n          } else if (stream.match(/^(?:[a-zA-Z0-9\\-_]+\\/)?(?:[a-zA-Z0-9\\-_]+)?#[0-9]+\\b/)) {\n            // User/Project#Num\n            // User#Num\n            // #Num\n            state.combineTokens = true;\n            return \"link\";\n          }\n        }\n      }\n      if (stream.match(urlRE) &&\n          stream.string.slice(stream.start - 2, stream.start) != \"](\" &&\n          (stream.start == 0 || /\\W/.test(stream.string.charAt(stream.start - 1)))) {\n        // URLs\n        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine\n        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL\n        state.combineTokens = true;\n        return \"link\";\n      }\n      stream.next();\n      return null;\n    },\n    blankLine: blankLine\n  };\n\n  var markdownConfig = {\n    underscoresBreakWords: false,\n    taskLists: true,\n    fencedCodeBlocks: '```',\n    strikethrough: true\n  };\n  for (var attr in modeConfig) {\n    markdownConfig[attr] = modeConfig[attr];\n  }\n  markdownConfig.name = \"markdown\";\n  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);\n\n}, \"markdown\");\n\n  CodeMirror.defineMIME(\"text/x-gfm\", \"gfm\");\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/gfm/gfm.js\n ** module id = 361\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../meta\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\n\n  var htmlFound = CodeMirror.modes.hasOwnProperty(\"xml\");\n  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: \"xml\", htmlMode: true} : \"text/plain\");\n\n  function getMode(name) {\n    if (CodeMirror.findModeByName) {\n      var found = CodeMirror.findModeByName(name);\n      if (found) name = found.mime || found.mimes[0];\n    }\n    var mode = CodeMirror.getMode(cmCfg, name);\n    return mode.name == \"null\" ? null : mode;\n  }\n\n  // Should characters that affect highlighting be highlighted separate?\n  // Does not include characters that will be output (such as `1.` and `-` for lists)\n  if (modeCfg.highlightFormatting === undefined)\n    modeCfg.highlightFormatting = false;\n\n  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\n  // Excess `>` will emit `error` token.\n  if (modeCfg.maxBlockquoteDepth === undefined)\n    modeCfg.maxBlockquoteDepth = 0;\n\n  // Should underscores in words open/close em/strong?\n  if (modeCfg.underscoresBreakWords === undefined)\n    modeCfg.underscoresBreakWords = true;\n\n  // Use `fencedCodeBlocks` to configure fenced code blocks. false to\n  // disable, string to specify a precise regexp that the fence should\n  // match, and true to allow three or more backticks or tildes (as\n  // per CommonMark).\n\n  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\n  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\n\n  // Turn on strikethrough syntax\n  if (modeCfg.strikethrough === undefined)\n    modeCfg.strikethrough = false;\n\n  // Allow token types to be overridden by user-provided token types.\n  if (modeCfg.tokenTypeOverrides === undefined)\n    modeCfg.tokenTypeOverrides = {};\n\n  var codeDepth = 0;\n\n  var tokenTypes = {\n    header: \"header\",\n    code: \"comment\",\n    quote: \"quote\",\n    list1: \"variable-2\",\n    list2: \"variable-3\",\n    list3: \"keyword\",\n    hr: \"hr\",\n    image: \"tag\",\n    formatting: \"formatting\",\n    linkInline: \"link\",\n    linkEmail: \"link\",\n    linkText: \"link\",\n    linkHref: \"string\",\n    em: \"em\",\n    strong: \"strong\",\n    strikethrough: \"strikethrough\"\n  };\n\n  for (var tokenType in tokenTypes) {\n    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\n      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\n    }\n  }\n\n  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\n  ,   ulRE = /^[*\\-+]\\s+/\n  ,   olRE = /^[0-9]+([.)])\\s+/\n  ,   taskListRE = /^\\[(x| )\\](?=\\s)/ // Must follow ulRE or olRE\n  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\n  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\n  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~]+/\n  ,   fencedCodeRE = new RegExp(\"^(\" + (modeCfg.fencedCodeBlocks === true ? \"~~~+|```+\" : modeCfg.fencedCodeBlocks) +\n                                \")[ \\\\t]*([\\\\w+#]*)\");\n\n  function switchInline(stream, state, f) {\n    state.f = state.inline = f;\n    return f(stream, state);\n  }\n\n  function switchBlock(stream, state, f) {\n    state.f = state.block = f;\n    return f(stream, state);\n  }\n\n  function lineIsEmpty(line) {\n    return !line || !/\\S/.test(line.string)\n  }\n\n  // Blocks\n\n  function blankLine(state) {\n    // Reset linkTitle state\n    state.linkTitle = false;\n    // Reset EM state\n    state.em = false;\n    // Reset STRONG state\n    state.strong = false;\n    // Reset strikethrough state\n    state.strikethrough = false;\n    // Reset state.quote\n    state.quote = 0;\n    // Reset state.indentedCode\n    state.indentedCode = false;\n    if (!htmlFound && state.f == htmlBlock) {\n      state.f = inlineNormal;\n      state.block = blockNormal;\n    }\n    // Reset state.trailingSpace\n    state.trailingSpace = 0;\n    state.trailingSpaceNewLine = false;\n    // Mark this line as blank\n    state.prevLine = state.thisLine\n    state.thisLine = null\n    return null;\n  }\n\n  function blockNormal(stream, state) {\n\n    var sol = stream.sol();\n\n    var prevLineIsList = state.list !== false,\n        prevLineIsIndentedCode = state.indentedCode;\n\n    state.indentedCode = false;\n\n    if (prevLineIsList) {\n      if (state.indentationDiff >= 0) { // Continued list\n        if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block\n          state.indentation -= state.indentationDiff;\n        }\n        state.list = null;\n      } else if (state.indentation > 0) {\n        state.list = null;\n        state.listDepth = Math.floor(state.indentation / 4);\n      } else { // No longer a list\n        state.list = false;\n        state.listDepth = 0;\n      }\n    }\n\n    var match = null;\n    if (state.indentationDiff >= 4) {\n      stream.skipToEnd();\n      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {\n        state.indentation -= 4;\n        state.indentedCode = true;\n        return tokenTypes.code;\n      } else {\n        return null;\n      }\n    } else if (stream.eatSpace()) {\n      return null;\n    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\n      state.header = match[1].length;\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      state.f = state.inline;\n      return getType(state);\n    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&\n               !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {\n      state.header = match[0].charAt(0) == '=' ? 1 : 2;\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      state.f = state.inline;\n      return getType(state);\n    } else if (stream.eat('>')) {\n      state.quote = sol ? 1 : state.quote + 1;\n      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\n      stream.eatSpace();\n      return getType(state);\n    } else if (stream.peek() === '[') {\n      return switchInline(stream, state, footnoteLink);\n    } else if (stream.match(hrRE, true)) {\n      state.hr = true;\n      return tokenTypes.hr;\n    } else if ((lineIsEmpty(state.prevLine) || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {\n      var listType = null;\n      if (stream.match(ulRE, true)) {\n        listType = 'ul';\n      } else {\n        stream.match(olRE, true);\n        listType = 'ol';\n      }\n      state.indentation = stream.column() + stream.current().length;\n      state.list = true;\n      state.listDepth++;\n      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\n        state.taskList = true;\n      }\n      state.f = state.inline;\n      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\n      return getType(state);\n    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {\n      state.fencedChars = match[1]\n      // try switching mode\n      state.localMode = getMode(match[2]);\n      if (state.localMode) state.localState = state.localMode.startState();\n      state.f = state.block = local;\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n      state.code = true;\n      return getType(state);\n    }\n\n    return switchInline(stream, state, state.inline);\n  }\n\n  function htmlBlock(stream, state) {\n    var style = htmlMode.token(stream, state.htmlState);\n    if ((htmlFound && state.htmlState.tagStart === null &&\n         (!state.htmlState.context && state.htmlState.tokenize.isInText)) ||\n        (state.md_inside && stream.current().indexOf(\">\") > -1)) {\n      state.f = inlineNormal;\n      state.block = blockNormal;\n      state.htmlState = null;\n    }\n    return style;\n  }\n\n  function local(stream, state) {\n    if (state.fencedChars && stream.match(state.fencedChars, false)) {\n      state.localMode = state.localState = null;\n      state.f = state.block = leavingLocal;\n      return null;\n    } else if (state.localMode) {\n      return state.localMode.token(stream, state.localState);\n    } else {\n      stream.skipToEnd();\n      return tokenTypes.code;\n    }\n  }\n\n  function leavingLocal(stream, state) {\n    stream.match(state.fencedChars);\n    state.block = blockNormal;\n    state.f = inlineNormal;\n    state.fencedChars = null;\n    if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n    state.code = true;\n    var returnType = getType(state);\n    state.code = false;\n    return returnType;\n  }\n\n  // Inline\n  function getType(state) {\n    var styles = [];\n\n    if (state.formatting) {\n      styles.push(tokenTypes.formatting);\n\n      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\n\n      for (var i = 0; i < state.formatting.length; i++) {\n        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\n\n        if (state.formatting[i] === \"header\") {\n          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\n        }\n\n        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\n        // Add `error` instead if the maximum blockquote nesting depth is passed\n        if (state.formatting[i] === \"quote\") {\n          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\n          } else {\n            styles.push(\"error\");\n          }\n        }\n      }\n    }\n\n    if (state.taskOpen) {\n      styles.push(\"meta\");\n      return styles.length ? styles.join(' ') : null;\n    }\n    if (state.taskClosed) {\n      styles.push(\"property\");\n      return styles.length ? styles.join(' ') : null;\n    }\n\n    if (state.linkHref) {\n      styles.push(tokenTypes.linkHref, \"url\");\n    } else { // Only apply inline styles to non-url text\n      if (state.strong) { styles.push(tokenTypes.strong); }\n      if (state.em) { styles.push(tokenTypes.em); }\n      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\n      if (state.linkText) { styles.push(tokenTypes.linkText); }\n      if (state.code) { styles.push(tokenTypes.code); }\n    }\n\n    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\n\n    if (state.quote) {\n      styles.push(tokenTypes.quote);\n\n      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\n      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n        styles.push(tokenTypes.quote + \"-\" + state.quote);\n      } else {\n        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\n      }\n    }\n\n    if (state.list !== false) {\n      var listMod = (state.listDepth - 1) % 3;\n      if (!listMod) {\n        styles.push(tokenTypes.list1);\n      } else if (listMod === 1) {\n        styles.push(tokenTypes.list2);\n      } else {\n        styles.push(tokenTypes.list3);\n      }\n    }\n\n    if (state.trailingSpaceNewLine) {\n      styles.push(\"trailing-space-new-line\");\n    } else if (state.trailingSpace) {\n      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\n    }\n\n    return styles.length ? styles.join(' ') : null;\n  }\n\n  function handleText(stream, state) {\n    if (stream.match(textRE, true)) {\n      return getType(state);\n    }\n    return undefined;\n  }\n\n  function inlineNormal(stream, state) {\n    var style = state.text(stream, state);\n    if (typeof style !== 'undefined')\n      return style;\n\n    if (state.list) { // List marker (*, +, -, 1., etc)\n      state.list = null;\n      return getType(state);\n    }\n\n    if (state.taskList) {\n      var taskOpen = stream.match(taskListRE, true)[1] !== \"x\";\n      if (taskOpen) state.taskOpen = true;\n      else state.taskClosed = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"task\";\n      state.taskList = false;\n      return getType(state);\n    }\n\n    state.taskOpen = false;\n    state.taskClosed = false;\n\n    if (state.header && stream.match(/^#+$/, true)) {\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      return getType(state);\n    }\n\n    // Get sol() value now, before character is consumed\n    var sol = stream.sol();\n\n    var ch = stream.next();\n\n    if (ch === '\\\\') {\n      stream.next();\n      if (modeCfg.highlightFormatting) {\n        var type = getType(state);\n        var formattingEscape = tokenTypes.formatting + \"-escape\";\n        return type ? type + \" \" + formattingEscape : formattingEscape;\n      }\n    }\n\n    // Matches link titles present on next line\n    if (state.linkTitle) {\n      state.linkTitle = false;\n      var matchCh = ch;\n      if (ch === '(') {\n        matchCh = ')';\n      }\n      matchCh = (matchCh+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\n      if (stream.match(new RegExp(regex), true)) {\n        return tokenTypes.linkHref;\n      }\n    }\n\n    // If this block is changed, it may need to be updated in GFM mode\n    if (ch === '`') {\n      var previousFormatting = state.formatting;\n      if (modeCfg.highlightFormatting) state.formatting = \"code\";\n      var t = getType(state);\n      var before = stream.pos;\n      stream.eatWhile('`');\n      var difference = 1 + stream.pos - before;\n      if (!state.code) {\n        codeDepth = difference;\n        state.code = true;\n        return getType(state);\n      } else {\n        if (difference === codeDepth) { // Must be exact\n          state.code = false;\n          return t;\n        }\n        state.formatting = previousFormatting;\n        return getType(state);\n      }\n    } else if (state.code) {\n      return getType(state);\n    }\n\n    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\n      stream.match(/\\[[^\\]]*\\]/);\n      state.inline = state.f = linkHref;\n      return tokenTypes.image;\n    }\n\n    if (ch === '[' && stream.match(/.*\\](\\(.*\\)| ?\\[.*\\])/, false)) {\n      state.linkText = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      return getType(state);\n    }\n\n    if (ch === ']' && state.linkText && stream.match(/\\(.*\\)| ?\\[.*\\]/, false)) {\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      state.linkText = false;\n      state.inline = state.f = linkHref;\n      return type;\n    }\n\n    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkEmail;\n    }\n\n    if (ch === '<' && stream.match(/^(!--|\\w)/, false)) {\n      var end = stream.string.indexOf(\">\", stream.pos);\n      if (end != -1) {\n        var atts = stream.string.substring(stream.start, end);\n        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\n      }\n      stream.backUp(1);\n      state.htmlState = CodeMirror.startState(htmlMode);\n      return switchBlock(stream, state, htmlBlock);\n    }\n\n    if (ch === '<' && stream.match(/^\\/\\w*?>/)) {\n      state.md_inside = false;\n      return \"tag\";\n    }\n\n    var ignoreUnderscore = false;\n    if (!modeCfg.underscoresBreakWords) {\n      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\\w)/, false)) {\n        var prevPos = stream.pos - 2;\n        if (prevPos >= 0) {\n          var prevCh = stream.string.charAt(prevPos);\n          if (prevCh !== '_' && prevCh.match(/(\\w)/, false)) {\n            ignoreUnderscore = true;\n          }\n        }\n      }\n    }\n    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {\n      if (sol && stream.peek() === ' ') {\n        // Do nothing, surrounded by newline and space\n      } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG\n        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n        var t = getType(state);\n        state.strong = false;\n        return t;\n      } else if (!state.strong && stream.eat(ch)) { // Add STRONG\n        state.strong = ch;\n        if (modeCfg.highlightFormatting) state.formatting = \"strong\";\n        return getType(state);\n      } else if (state.em === ch) { // Remove EM\n        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n        var t = getType(state);\n        state.em = false;\n        return t;\n      } else if (!state.em) { // Add EM\n        state.em = ch;\n        if (modeCfg.highlightFormatting) state.formatting = \"em\";\n        return getType(state);\n      }\n    } else if (ch === ' ') {\n      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\n        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n          return getType(state);\n        } else { // Not surrounded by spaces, back up pointer\n          stream.backUp(1);\n        }\n      }\n    }\n\n    if (modeCfg.strikethrough) {\n      if (ch === '~' && stream.eatWhile(ch)) {\n        if (state.strikethrough) {// Remove strikethrough\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          var t = getType(state);\n          state.strikethrough = false;\n          return t;\n        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\n          state.strikethrough = true;\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          return getType(state);\n        }\n      } else if (ch === ' ') {\n        if (stream.match(/^~~/, true)) { // Probably surrounded by space\n          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n            return getType(state);\n          } else { // Not surrounded by spaces, back up pointer\n            stream.backUp(2);\n          }\n        }\n      }\n    }\n\n    if (ch === ' ') {\n      if (stream.match(/ +$/, false)) {\n        state.trailingSpace++;\n      } else if (state.trailingSpace) {\n        state.trailingSpaceNewLine = true;\n      }\n    }\n\n    return getType(state);\n  }\n\n  function linkInline(stream, state) {\n    var ch = stream.next();\n\n    if (ch === \">\") {\n      state.f = state.inline = inlineNormal;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    stream.match(/^[^>]+/, true);\n\n    return tokenTypes.linkInline;\n  }\n\n  function linkHref(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    var ch = stream.next();\n    if (ch === '(' || ch === '[') {\n      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\n      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n      state.linkHref = true;\n      return getType(state);\n    }\n    return 'error';\n  }\n\n  function getLinkHrefInside(endChar) {\n    return function(stream, state) {\n      var ch = stream.next();\n\n      if (ch === endChar) {\n        state.f = state.inline = inlineNormal;\n        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n        var returnState = getType(state);\n        state.linkHref = false;\n        return returnState;\n      }\n\n      if (stream.match(inlineRE(endChar), true)) {\n        stream.backUp(1);\n      }\n\n      state.linkHref = true;\n      return getType(state);\n    };\n  }\n\n  function footnoteLink(stream, state) {\n    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\n      state.f = footnoteLinkInside;\n      stream.next(); // Consume [\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      state.linkText = true;\n      return getType(state);\n    }\n    return switchInline(stream, state, inlineNormal);\n  }\n\n  function footnoteLinkInside(stream, state) {\n    if (stream.match(/^\\]:/, true)) {\n      state.f = state.inline = footnoteUrl;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var returnType = getType(state);\n      state.linkText = false;\n      return returnType;\n    }\n\n    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\n\n    return tokenTypes.linkText;\n  }\n\n  function footnoteUrl(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    // Match URL\n    stream.match(/^[^\\s]+/, true);\n    // Check for link title\n    if (stream.peek() === undefined) { // End of line, set flag to check next line\n      state.linkTitle = true;\n    } else { // More content on line, check if link title\n      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\n    }\n    state.f = state.inline = inlineNormal;\n    return tokenTypes.linkHref + \" url\";\n  }\n\n  var savedInlineRE = [];\n  function inlineRE(endChar) {\n    if (!savedInlineRE[endChar]) {\n      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)\n      endChar = (endChar+'').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n      // Match any non-endChar, escaped character, as well as the closing\n      // endChar.\n      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\\\\\]|\\\\\\\\.)*?(' + endChar + ')');\n    }\n    return savedInlineRE[endChar];\n  }\n\n  var mode = {\n    startState: function() {\n      return {\n        f: blockNormal,\n\n        prevLine: null,\n        thisLine: null,\n\n        block: blockNormal,\n        htmlState: null,\n        indentation: 0,\n\n        inline: inlineNormal,\n        text: handleText,\n\n        formatting: false,\n        linkText: false,\n        linkHref: false,\n        linkTitle: false,\n        em: false,\n        strong: false,\n        header: 0,\n        hr: false,\n        taskList: false,\n        list: false,\n        listDepth: 0,\n        quote: 0,\n        trailingSpace: 0,\n        trailingSpaceNewLine: false,\n        strikethrough: false,\n        fencedChars: null\n      };\n    },\n\n    copyState: function(s) {\n      return {\n        f: s.f,\n\n        prevLine: s.prevLine,\n        thisLine: s.thisLine,\n\n        block: s.block,\n        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\n        indentation: s.indentation,\n\n        localMode: s.localMode,\n        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\n\n        inline: s.inline,\n        text: s.text,\n        formatting: false,\n        linkTitle: s.linkTitle,\n        code: s.code,\n        em: s.em,\n        strong: s.strong,\n        strikethrough: s.strikethrough,\n        header: s.header,\n        hr: s.hr,\n        taskList: s.taskList,\n        list: s.list,\n        listDepth: s.listDepth,\n        quote: s.quote,\n        indentedCode: s.indentedCode,\n        trailingSpace: s.trailingSpace,\n        trailingSpaceNewLine: s.trailingSpaceNewLine,\n        md_inside: s.md_inside,\n        fencedChars: s.fencedChars\n      };\n    },\n\n    token: function(stream, state) {\n\n      // Reset state.formatting\n      state.formatting = false;\n\n      if (stream != state.thisLine) {\n        var forceBlankLine = state.header || state.hr;\n\n        // Reset state.header and state.hr\n        state.header = 0;\n        state.hr = false;\n\n        if (stream.match(/^\\s*$/, true) || forceBlankLine) {\n          blankLine(state);\n          if (!forceBlankLine) return null\n          state.prevLine = null\n        }\n\n        state.prevLine = state.thisLine\n        state.thisLine = stream\n\n        // Reset state.taskList\n        state.taskList = false;\n\n        // Reset state.trailingSpace\n        state.trailingSpace = 0;\n        state.trailingSpaceNewLine = false;\n\n        state.f = state.block;\n        var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, '    ').length;\n        var difference = Math.floor((indentation - state.indentation) / 4) * 4;\n        if (difference > 4) difference = 4;\n        var adjustedIndentation = state.indentation + difference;\n        state.indentationDiff = adjustedIndentation - state.indentation;\n        state.indentation = adjustedIndentation;\n        if (indentation > 0) return null;\n      }\n      return state.f(stream, state);\n    },\n\n    innerMode: function(state) {\n      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\n      if (state.localState) return {state: state.localState, mode: state.localMode};\n      return {state: state, mode: mode};\n    },\n\n    blankLine: blankLine,\n\n    getType: getType,\n\n    fold: \"markdown\"\n  };\n  return mode;\n}, \"xml\");\n\nCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/markdown/markdown.js\n ** module id = 362\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if (state.context && state.context.tagName == tagName) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/xml/xml.js\n ** module id = 363\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.modeInfo = [\n    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\n    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"pgp\"]},\n    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\n    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\n    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\n    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\"]},\n    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\n    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\n    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\n    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\"]},\n    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\n    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\n    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\n    {name: \"CoffeeScript\", mime: \"text/x-coffeescript\", mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\n    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\n    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\n    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\n    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\n    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\n    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\n    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\n    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\n    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\n    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\n    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\n    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\n    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\n    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\n    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\n    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\n    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\n    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\n    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\n    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\n    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\n    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\n    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\"]},\n    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\n    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\n    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\n    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\n    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\n    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\"]},\n    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\n    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\n    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\n    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\n    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\n    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\n    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\"], alias: [\"xhtml\"]},\n    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\n    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\n    {name: \"Jade\", mime: \"text/x-jade\", mode: \"jade\", ext: [\"jade\"]},\n    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\n    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\n    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\n     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\n    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\n    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\n    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\n    {name: \"Jinja2\", mime: \"null\", mode: \"jinja2\"},\n    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\n    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\n    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\n    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\n    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\n    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\n    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\n    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\n    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\n    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\n    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\"},\n    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\n    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\n    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\n    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\n    {name: \"NTriples\", mime: \"text/n-triples\", mode: \"ntriples\", ext: [\"nt\"]},\n    {name: \"Objective C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"]},\n    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\n    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\n    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\n    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\n    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\n    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\n    {name: \"PHP\", mime: \"application/x-httpd-php\", mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"phtml\"]},\n    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\n    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\n    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\n    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\n    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"py\", \"pyw\"]},\n    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\n    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\n    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\"], alias: [\"rscript\"]},\n    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\n    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\n    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\n    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\n    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\n    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\n    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\n    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\n    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\n    {name: \"Shell\", mime: \"text/x-sh\", mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\n    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\n    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\n    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\n    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\n    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\n    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\n    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\n    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\n    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\n    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\n    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\n    {name: \"MariaDB\", mime: \"text/x-mariadb\", mode: \"sql\"},\n    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\n    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\"], alias: [\"tex\"]},\n    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\"]},\n    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\n    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\n    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\n    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\n    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\n    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\n    {name: \"troff\", mime: \"troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\n    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\n    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\n    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\n    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\n    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\n    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\n    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\n    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\n    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\n    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\n    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\n    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\n    {name: \"YAML\", mime: \"text/x-yaml\", mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\n    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\n    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\n    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\n    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\n  ];\n  // Ensure all modes have a mime property for backwards compatibility\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n    var info = CodeMirror.modeInfo[i];\n    if (info.mimes) info.mime = info.mimes[0];\n  }\n\n  CodeMirror.findModeByMIME = function(mime) {\n    mime = mime.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.mime == mime) return info;\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\n        if (info.mimes[j] == mime) return info;\n    }\n  };\n\n  CodeMirror.findModeByExtension = function(ext) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.ext) for (var j = 0; j < info.ext.length; j++)\n        if (info.ext[j] == ext) return info;\n    }\n  };\n\n  CodeMirror.findModeByFileName = function(filename) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.file && info.file.test(filename)) return info;\n    }\n    var dot = filename.lastIndexOf(\".\");\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n    if (ext) return CodeMirror.findModeByExtension(ext);\n  };\n\n  CodeMirror.findModeByName = function(name) {\n    name = name.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.name.toLowerCase() == name) return info;\n      if (info.alias) for (var j = 0; j < info.alias.length; j++)\n        if (info.alias[j].toLowerCase() == name) return info;\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/meta.js\n ** module id = 364\n ** module chunks = 29\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Utility function that allows modes to be combined. The mode given\n// as the base argument takes care of most of the normal mode\n// functionality, but a second (typically simple) mode is used, which\n// can override the style of text. Both modes get to parse all of the\n// text, but when both assign a non-null style to a piece of code, the\n// overlay wins, unless the combine argument was true and not overridden,\n// or state.overlay.combineTokens was true, in which case the styles are\n// combined.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.overlayMode = function(base, overlay, combine) {\n  return {\n    startState: function() {\n      return {\n        base: CodeMirror.startState(base),\n        overlay: CodeMirror.startState(overlay),\n        basePos: 0, baseCur: null,\n        overlayPos: 0, overlayCur: null,\n        streamSeen: null\n      };\n    },\n    copyState: function(state) {\n      return {\n        base: CodeMirror.copyState(base, state.base),\n        overlay: CodeMirror.copyState(overlay, state.overlay),\n        basePos: state.basePos, baseCur: null,\n        overlayPos: state.overlayPos, overlayCur: null\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream != state.streamSeen ||\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\n        state.streamSeen = stream;\n        state.basePos = state.overlayPos = stream.start;\n      }\n\n      if (stream.start == state.basePos) {\n        state.baseCur = base.token(stream, state.base);\n        state.basePos = stream.pos;\n      }\n      if (stream.start == state.overlayPos) {\n        stream.pos = stream.start;\n        state.overlayCur = overlay.token(stream, state.overlay);\n        state.overlayPos = stream.pos;\n      }\n      stream.pos = Math.min(state.basePos, state.overlayPos);\n\n      // state.overlay.combineTokens always takes precedence over combine,\n      // unless set to null\n      if (state.overlayCur == null) return state.baseCur;\n      else if (state.baseCur != null &&\n               state.overlay.combineTokens ||\n               combine && state.overlay.combineTokens == null)\n        return state.baseCur + \" \" + state.overlayCur;\n      else return state.overlayCur;\n    },\n\n    indent: base.indent && function(state, textAfter) {\n      return base.indent(state.base, textAfter);\n    },\n    electricChars: base.electricChars,\n\n    innerMode: function(state) { return {state: state.base, mode: base}; },\n\n    blankLine: function(state) {\n      if (base.blankLine) base.blankLine(state.base);\n      if (overlay.blankLine) overlay.blankLine(state.overlay);\n    }\n  };\n};\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/mode/overlay.js\n ** module id = 365\n ** module chunks = 29\n **/","var jade = require(\"/js/build/node_modules/jade/lib/runtime.js\");\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n;var locals_for_with = (locals || {});(function (bem, buttons, navigator, t) {\nbuf.push(\"\");\nvar bem_chain = [];\njade_mixins[\"b\"] = jade_interp = function(tag, isElement, noBlockClass){\nvar block = (this && this.block), attributes = (this && this.attributes) || {};\nbem.call(this, buf, bem_chain, tag, isElement, noBlockClass)\n};\n\n\n\n\n\n\n\n\n\njade_mixins[\"e\"] = jade_interp = function(tag){\nvar block = (this && this.block), attributes = (this && this.attributes) || {};\njade_mixins[\"b\"].call({\nblock: function(){\nblock && block();\n},\nattributes: jade.merge([attributes])\n}, tag, true);\n};\njade_mixins[\"b\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nblock: function(){\n// iterate buttons\n;(function(){\n  var $$obj = buttons;\n  if ('number' == typeof $$obj.length) {\n\n    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n      var button = $$obj[$index];\n\nif ( button == '|')\n{\njade_mixins[\"e\"].call({\nattributes: {\"class\": \"button-separator\"}\n});\n}\nelse\n{\nvar tooltip = t('mdeditor.buttons.'+ button);\nif (navigator.userAgent.indexOf('Mac OS X') != -1) tooltip = tooltip.replace('Ctrl', 'Cmd')\njade_mixins[\"e\"].call({\nattributes: {\"data-action\": (typeof (jade_interp = button) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"data-tooltip\": (typeof (jade_interp = tooltip) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"class\": \"button\"}\n}, 'button');\n}\n    }\n\n  } else {\n    var $$l = 0;\n    for (var $index in $$obj) {\n      $$l++;      var button = $$obj[$index];\n\nif ( button == '|')\n{\njade_mixins[\"e\"].call({\nattributes: {\"class\": \"button-separator\"}\n});\n}\nelse\n{\nvar tooltip = t('mdeditor.buttons.'+ button);\nif (navigator.userAgent.indexOf('Mac OS X') != -1) tooltip = tooltip.replace('Ctrl', 'Cmd')\njade_mixins[\"e\"].call({\nattributes: {\"data-action\": (typeof (jade_interp = button) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"data-tooltip\": (typeof (jade_interp = tooltip) == \"string\" ? jade.escape(jade_interp) : jade_interp),\"class\": \"button\"}\n}, 'button');\n}\n    }\n\n  }\n}).call(this);\n\n},\nattributes: {\"class\": \"button-bar\"}\n});\njade_mixins[\"e\"].call({\nattributes: {\"class\": \"input\"}\n}, 'textarea');\njade_mixins[\"e\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nattributes: {\"data-mdeditor-resize\": true,\"class\": \"resize-handle\"}\n});\n},\nattributes: {\"class\": \"footer\"}\n});\n},\nattributes: {\"class\": \"editor\"}\n});\njade_mixins[\"e\"].call({\nblock: function(){\njade_mixins[\"e\"].call({\nblock: function(){\nbuf.push(\"\");\n}\n}, 'h2');\n},\nattributes: {\"class\": \"title-preview\"}\n});\njade_mixins[\"e\"].call({\nattributes: {\"data-editor-preview\": true,\"class\": \"preview\"}\n});\n},\nattributes: {\"class\": \"mdeditor\"}\n});}.call(this,\"bem\" in locals_for_with?locals_for_with.bem:typeof bem!==\"undefined\"?bem:undefined,\"buttons\" in locals_for_with?locals_for_with.buttons:typeof buttons!==\"undefined\"?buttons:undefined,\"navigator\" in locals_for_with?locals_for_with.navigator:typeof navigator!==\"undefined\"?navigator:undefined,\"t\" in locals_for_with?locals_for_with.t:typeof t!==\"undefined\"?t:undefined));;return buf.join(\"\");\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/templates/editor.jade\n ** module id = 366\n ** module chunks = 29\n **/","var map = {\n\t\"./en.yml\": 368,\n\t\"./ru.yml\": 369\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 367;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/locales ^\\.\\/.*\\.yml$\n ** module id = 367\n ** module chunks = 29\n **/","module.exports = {\n\t\"text\": {\n\t\t\"bold\": \"bold text\",\n\t\t\"italic\": \"italic text\",\n\t\t\"code\": \"code\",\n\t\t\"heading\": \"Heading\",\n\t\t\"fencedCode\": \"enter multiline code here\",\n\t\t\"ol\": \"List item\",\n\t\t\"ul\": \"List item\",\n\t\t\"alt\": \"Image desciption\",\n\t\t\"link\": \"link text\"\n\t},\n\t\"buttons\": {\n\t\t\"bold\": \"bold [Ctrl-B]\",\n\t\t\"italic\": \"italic [Ctrl-I]\",\n\t\t\"code\": \"inline code\",\n\t\t\"undo\": \"undo [Ctrl-Z]\",\n\t\t\"redo\": \"redo [Ctrl-Y]\",\n\t\t\"fencedCode\": \"multiline code\",\n\t\t\"link\": \"insert link\",\n\t\t\"ul\": \"itemized list\",\n\t\t\"ol\": \"ordered list\",\n\t\t\"heading\": \"heading\",\n\t\t\"image\": \"insert image\"\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/locales/en.yml\n ** module id = 368\n ** module chunks = 29\n **/","module.exports = {\n\t\"text\": {\n\t\t\"bold\": \" \",\n\t\t\"italic\": \" \",\n\t\t\"code\": \"code\",\n\t\t\"heading\": \"\",\n\t\t\"fencedCode\": \"enter multiline code here\",\n\t\t\"link\": \" \",\n\t\t\"ol\": \" \",\n\t\t\"ul\": \" \",\n\t\t\"alt\": \" \"\n\t},\n\t\"buttons\": {\n\t\t\"bold\": \"  [Ctrl-B]\",\n\t\t\"italic\": \"  [Ctrl-I]\",\n\t\t\"code\": \" \",\n\t\t\"undo\": \" [Ctrl-Z]\",\n\t\t\"redo\": \"  [Ctrl-Y]\",\n\t\t\"fencedCode\": \"  \",\n\t\t\"link\": \"\",\n\t\t\"ul\": \"\",\n\t\t\"ol\": \" \",\n\t\t\"heading\": \"\",\n\t\t\"image\": \" \"\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/mdeditor/locales/ru.yml\n ** module id = 369\n ** module chunks = 29\n **/","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide an options object to indicate whether\n * `func` should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n * on the trailing edge of the timeout only if the throttled function is\n * invoked more than once during the `wait` timeout.\n *\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.leading=true] Specify invoking on the leading\n *  edge of the timeout.\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n *  edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash/throttle.js\n **/","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide an options object to indicate whether `func` should be invoked on\n * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent calls\n * to the debounced function return the result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n * on the trailing edge of the timeout only if the debounced function is\n * invoked more than once during the `wait` timeout.\n *\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.leading=false] Specify invoking on the leading\n *  edge of the timeout.\n * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n *  delayed before it's invoked.\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n *  edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var args,\n      maxTimeoutId,\n      result,\n      stamp,\n      thisArg,\n      timeoutId,\n      trailingCall,\n      lastCalled = 0,\n      leading = false,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && nativeMax(toNumber(options.maxWait) || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    if (maxTimeoutId) {\n      clearTimeout(maxTimeoutId);\n    }\n    lastCalled = 0;\n    args = maxTimeoutId = thisArg = timeoutId = trailingCall = undefined;\n  }\n\n  function complete(isCalled, id) {\n    if (id) {\n      clearTimeout(id);\n    }\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n    if (isCalled) {\n      lastCalled = now();\n      result = func.apply(thisArg, args);\n      if (!timeoutId && !maxTimeoutId) {\n        args = thisArg = undefined;\n      }\n    }\n  }\n\n  function delayed() {\n    var remaining = wait - (now() - stamp);\n    if (remaining <= 0 || remaining > wait) {\n      complete(trailingCall, maxTimeoutId);\n    } else {\n      timeoutId = setTimeout(delayed, remaining);\n    }\n  }\n\n  function flush() {\n    if ((timeoutId && trailingCall) || (maxTimeoutId && trailing)) {\n      result = func.apply(thisArg, args);\n    }\n    cancel();\n    return result;\n  }\n\n  function maxDelayed() {\n    complete(trailing, timeoutId);\n  }\n\n  function debounced() {\n    args = arguments;\n    stamp = now();\n    thisArg = this;\n    trailingCall = trailing && (timeoutId || !leading);\n\n    if (maxWait === false) {\n      var leadingCall = leading && !timeoutId;\n    } else {\n      if (!lastCalled && !maxTimeoutId && !leading) {\n        lastCalled = stamp;\n      }\n      var remaining = maxWait - (stamp - lastCalled);\n\n      var isCalled = (remaining <= 0 || remaining > maxWait) &&\n        (leading || maxTimeoutId);\n\n      if (isCalled) {\n        if (maxTimeoutId) {\n          maxTimeoutId = clearTimeout(maxTimeoutId);\n        }\n        lastCalled = stamp;\n        result = func.apply(thisArg, args);\n      }\n      else if (!maxTimeoutId) {\n        maxTimeoutId = setTimeout(maxDelayed, remaining);\n      }\n    }\n    if (isCalled && timeoutId) {\n      timeoutId = clearTimeout(timeoutId);\n    }\n    else if (!timeoutId && wait !== maxWait) {\n      timeoutId = setTimeout(delayed, wait);\n    }\n    if (leadingCall) {\n      isCalled = true;\n      result = func.apply(thisArg, args);\n    }\n    if (isCalled && !timeoutId && !maxTimeoutId) {\n      args = thisArg = undefined;\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash/debounce.js\n **/","/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash/isObject.js\n **/","/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @type {Function}\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => logs the number of milliseconds it took for the deferred function to be invoked\n */\nvar now = Date.now;\n\nmodule.exports = now;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash/now.js\n **/","var isFunction = require('./isFunction'),\n    isObject = require('./isObject');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3);\n * // => 3\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3');\n * // => 3\n */\nfunction toNumber(value) {\n  if (isObject(value)) {\n    var other = isFunction(value.valueOf) ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash/toNumber.js\n **/","var isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8 which returns 'object' for typed array constructors, and\n  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\nmodule.exports = isFunction;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash/isFunction.js\n **/"],"sourceRoot":""}